//! A64 sve load tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// LDNT1D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rm_0_min_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a581c000() {
    // Encoding: 0xA581C000
    // Test LDNT1D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA581C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a59ec000() {
    // Encoding: 0xA59EC000
    // Test LDNT1D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Rm=30, Pg=0
    let encoding: u32 = 0xA59EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rm_31_max_c000_a59fc000() {
    // Encoding: 0xA59FC000
    // Test LDNT1D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=31, Rn=0
    let encoding: u32 = 0xA59FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_pg_0_min_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a580c400() {
    // Encoding: 0xA580C400
    // Test LDNT1D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA580C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rn_0_min_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a580c020() {
    // Encoding: 0xA580C020
    // Test LDNT1D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, Rm=0
    let encoding: u32 = 0xA580C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a580c3c0() {
    // Encoding: 0xA580C3C0
    // Test LDNT1D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, Rm=0
    let encoding: u32 = 0xA580C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_rn_31_max_c000_a580c3e0() {
    // Encoding: 0xA580C3E0
    // Test LDNT1D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA580C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_zt_0_min_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a580c001() {
    // Encoding: 0xA580C001
    // Test LDNT1D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Rm=0, Pg=0
    let encoding: u32 = 0xA580C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a580c01e() {
    // Encoding: 0xA580C01E
    // Test LDNT1D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, Zt=30, Pg=0
    let encoding: u32 = 0xA580C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1d_z_p_br_contiguous_field_zt_31_max_c000_a580c01f() {
    // Encoding: 0xA580C01F
    // Test LDNT1D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Rm=0
    let encoding: u32 = 0xA580C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldnt1d_z_p_br_contiguous_combo_0_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a580c3e0(
) {
    // Encoding: 0xA580C3E0
    // Test LDNT1D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA580C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_br_contiguous_invalid_0_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_br_contiguous_invalid_1_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_br_contiguous_invalid_2_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_br_contiguous_invalid_3_c000_a580c000() {
    // Encoding: 0xA580C000
    // Test LDNT1D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1d_z_p_br_contiguous_reg_write_0_a580c000() {
    // Test LDNT1D_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA580C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1d_z_p_br_contiguous_sp_rn_a580c3e0() {
    // Test LDNT1D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA580C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1D_Z.P.BZ_D.x32.scaled Tests
// ============================================================================

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_xs_0_min_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_xs_1_max_6000_c5e06000() {
    // Encoding: 0xC5E06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, xs=1, Zt=0
    let encoding: u32 = 0xC5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zm_0_min_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_6000_c5a16000() {
    // Encoding: 0xC5A16000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, xs=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_6000_c5be6000() {
    // Encoding: 0xC5BE6000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Pg=0, Zm=30, Rn=0
    let encoding: u32 = 0xC5BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zm_31_max_6000_c5bf6000() {
    // Encoding: 0xC5BF6000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC5BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_pg_0_min_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_6000_c5a06400() {
    // Encoding: 0xC5A06400
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Zm=0, Rn=0, Pg=1
    let encoding: u32 = 0xC5A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_rn_0_min_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_6000_c5a06020() {
    // Encoding: 0xC5A06020
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=1, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_6000_c5a063c0() {
    // Encoding: 0xC5A063C0
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=30
    let encoding: u32 = 0xC5A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_rn_31_max_6000_c5a063e0() {
    // Encoding: 0xC5A063E0
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0xC5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zt_0_min_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_6000_c5a06001() {
    // Encoding: 0xC5A06001
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC5A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_6000_c5a0601e() {
    // Encoding: 0xC5A0601E
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=0, Zm=0, Zt=30, Pg=0
    let encoding: u32 = 0xC5A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_field_zt_31_max_6000_c5a0601f() {
    // Encoding: 0xC5A0601F
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Zt=31, Zm=0, Rn=0
    let encoding: u32 = 0xC5A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_combo_0_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c5a063e0(
) {
    // Encoding: 0xC5A063E0
    // Test LDFF1D_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_invalid_0_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_invalid_1_6000_c5a06000() {
    // Encoding: 0xC5A06000
    // Test LDFF1D_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xC5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_xs_0_min_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_xs_1_max_6000_c5c06000() {
    // Encoding: 0xC5C06000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zm_0_min_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_6000_c5816000() {
    // Encoding: 0xC5816000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zt=0, Zm=1, Rn=0
    let encoding: u32 = 0xC5816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_6000_c59e6000() {
    // Encoding: 0xC59E6000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=30, Pg=0, Rn=0
    let encoding: u32 = 0xC59E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zm_31_max_6000_c59f6000() {
    // Encoding: 0xC59F6000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=31
    let encoding: u32 = 0xC59F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_pg_0_min_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_6000_c5806400() {
    // Encoding: 0xC5806400
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Pg=1, xs=0, Rn=0
    let encoding: u32 = 0xC5806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_rn_0_min_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_6000_c5806020() {
    // Encoding: 0xC5806020
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Pg=0, xs=0, Rn=1
    let encoding: u32 = 0xC5806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_6000_c58063c0() {
    // Encoding: 0xC58063C0
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xC58063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_rn_31_max_6000_c58063e0() {
    // Encoding: 0xC58063E0
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Pg=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zt_0_min_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_6000_c5806001() {
    // Encoding: 0xC5806001
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=1, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_6000_c580601e() {
    // Encoding: 0xC580601E
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, xs=0, Zt=30, Zm=0, Pg=0
    let encoding: u32 = 0xC580601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_field_zt_31_max_6000_c580601f() {
    // Encoding: 0xC580601F
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Rn=0, Zm=0, Zt=31, Pg=0
    let encoding: u32 = 0xC580601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_combo_0_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c58063e0(
) {
    // Encoding: 0xC58063E0
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xC58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_invalid_0_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_invalid_1_6000_c5806000() {
    // Encoding: 0xC5806000
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zm_0_min_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_e000_c5e1e000() {
    // Encoding: 0xC5E1E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=1
    let encoding: u32 = 0xC5E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_e000_c5fee000() {
    // Encoding: 0xC5FEE000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=30
    let encoding: u32 = 0xC5FEE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zm_31_max_e000_c5ffe000() {
    // Encoding: 0xC5FFE000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_pg_0_min_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_e000_c5e0e400() {
    // Encoding: 0xC5E0E400
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xC5E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_rn_0_min_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_e000_c5e0e020() {
    // Encoding: 0xC5E0E020
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xC5E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_e000_c5e0e3c0() {
    // Encoding: 0xC5E0E3C0
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, Zm=0
    let encoding: u32 = 0xC5E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_rn_31_max_e000_c5e0e3e0() {
    // Encoding: 0xC5E0E3E0
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0xC5E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zt_0_min_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_e000_c5e0e001() {
    // Encoding: 0xC5E0E001
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xC5E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_e000_c5e0e01e() {
    // Encoding: 0xC5E0E01E
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Zm=0
    let encoding: u32 = 0xC5E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_field_zt_31_max_e000_c5e0e01f() {
    // Encoding: 0xC5E0E01F
    // Test LDFF1D_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, Zm=0
    let encoding: u32 = 0xC5E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_combo_0_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c5e0e3e0(
) {
    // Encoding: 0xC5E0E3E0
    // Test LDFF1D_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC5E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_invalid_0_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_invalid_1_e000_c5e0e000() {
    // Encoding: 0xC5E0E000
    // Test LDFF1D_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zm_0_min_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_e000_c5c1e000() {
    // Encoding: 0xC5C1E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=1
    let encoding: u32 = 0xC5C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_e000_c5dee000() {
    // Encoding: 0xC5DEE000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zt=0, Rn=0
    let encoding: u32 = 0xC5DEE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zm_31_max_e000_c5dfe000() {
    // Encoding: 0xC5DFE000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, Zm=31, Rn=0
    let encoding: u32 = 0xC5DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_pg_0_min_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_e000_c5c0e400() {
    // Encoding: 0xC5C0E400
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zm=0, Zt=0
    let encoding: u32 = 0xC5C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_rn_0_min_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_e000_c5c0e020() {
    // Encoding: 0xC5C0E020
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, Zm=0
    let encoding: u32 = 0xC5C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_e000_c5c0e3c0() {
    // Encoding: 0xC5C0E3C0
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Zm=0
    let encoding: u32 = 0xC5C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_rn_31_max_e000_c5c0e3e0() {
    // Encoding: 0xC5C0E3E0
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zt_0_min_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_e000_c5c0e001() {
    // Encoding: 0xC5C0E001
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Zm=0
    let encoding: u32 = 0xC5C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_e000_c5c0e01e() {
    // Encoding: 0xC5C0E01E
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Zm=0
    let encoding: u32 = 0xC5C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_field_zt_31_max_e000_c5c0e01f() {
    // Encoding: 0xC5C0E01F
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xC5C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_combo_0_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c5c0e3e0(
) {
    // Encoding: 0xC5C0E3E0
    // Test LDFF1D_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_invalid_0_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_invalid_1_e000_c5c0e000() {
    // Encoding: 0xC5C0E000
    // Test LDFF1D_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_reg_write_0_c5a06000() {
    // Test LDFF1D_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5A06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1d_z_p_bz_d_x32_scaled_sp_rn_c5a063e0() {
    // Test LDFF1D_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC5A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_reg_write_0_c5806000() {
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1d_z_p_bz_d_x32_unscaled_sp_rn_c58063e0() {
    // Test LDFF1D_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC58063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC58063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_reg_write_0_c5e0e000() {
    // Test LDFF1D_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC5E0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5E0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1d_z_p_bz_d_64_scaled_sp_rn_c5e0e3e0() {
    // Test LDFF1D_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC5E0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5E0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_reg_write_0_c5c0e000() {
    // Test LDFF1D_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5C0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5C0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1d_z_p_bz_d_64_unscaled_sp_rn_c5c0e3e0() {
    // Test LDFF1D_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC5C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rm_0_min_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a4e1c000() {
    // Encoding: 0xA4E1C000
    // Test LD4H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA4E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a4fec000() {
    // Encoding: 0xA4FEC000
    // Test LD4H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=30, Zt=0
    let encoding: u32 = 0xA4FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rm_31_max_c000_a4ffc000() {
    // Encoding: 0xA4FFC000
    // Test LD4H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Zt=0, Rm=31, Pg=0
    let encoding: u32 = 0xA4FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_pg_0_min_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a4e0c400() {
    // Encoding: 0xA4E0C400
    // Test LD4H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Rm=0, Zt=0
    let encoding: u32 = 0xA4E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rn_0_min_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a4e0c020() {
    // Encoding: 0xA4E0C020
    // Test LD4H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA4E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a4e0c3c0() {
    // Encoding: 0xA4E0C3C0
    // Test LD4H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA4E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4h_z_p_br_contiguous_field_rn_31_max_c000_a4e0c3e0() {
    // Encoding: 0xA4E0C3E0
    // Test LD4H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xA4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4h_z_p_br_contiguous_field_zt_0_min_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4h_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a4e0c001() {
    // Encoding: 0xA4E0C001
    // Test LD4H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA4E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4h_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a4e0c01e() {
    // Encoding: 0xA4E0C01E
    // Test LD4H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4h_z_p_br_contiguous_field_zt_31_max_c000_a4e0c01f() {
    // Encoding: 0xA4E0C01F
    // Test LD4H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld4h_z_p_br_contiguous_combo_0_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a4e0c3e0()
{
    // Encoding: 0xA4E0C3E0
    // Test LD4H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_br_contiguous_invalid_0_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_br_contiguous_invalid_1_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_br_contiguous_invalid_2_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_br_contiguous_invalid_3_c000_a4e0c000() {
    // Encoding: 0xA4E0C000
    // Test LD4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4h_z_p_br_contiguous_sp_rn_a4e0c3e0() {
    // Test LD4H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA4E0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_0_zero_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a4c1e000() {
    // Encoding: 0xA4C1E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a4c3e000() {
    // Encoding: 0xA4C3E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=3
    let encoding: u32 = 0xA4C3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a4c4e000() {
    // Encoding: 0xA4C4E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=4
    let encoding: u32 = 0xA4C4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a4c7e000() {
    // Encoding: 0xA4C7E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xA4C7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a4c8e000() {
    // Encoding: 0xA4C8E000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4C8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_imm4_15_max_e000_a4cfe000() {
    // Encoding: 0xA4CFE000
    // Test LD3H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xA4CFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_pg_0_min_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a4c0e400() {
    // Encoding: 0xA4C0E400
    // Test LD3H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_rn_0_min_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a4c0e020() {
    // Encoding: 0xA4C0E020
    // Test LD3H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA4C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a4c0e3c0() {
    // Encoding: 0xA4C0E3C0
    // Test LD3H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA4C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3h_z_p_bi_contiguous_field_rn_31_max_e000_a4c0e3e0() {
    // Encoding: 0xA4C0E3E0
    // Test LD3H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA4C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3h_z_p_bi_contiguous_field_zt_0_min_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a4c0e001() {
    // Encoding: 0xA4C0E001
    // Test LD3H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA4C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a4c0e01e() {
    // Encoding: 0xA4C0E01E
    // Test LD3H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3h_z_p_bi_contiguous_field_zt_31_max_e000_a4c0e01f() {
    // Encoding: 0xA4C0E01F
    // Test LD3H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, imm4=0
    let encoding: u32 = 0xA4C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld3h_z_p_bi_contiguous_combo_0_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a4c0e3e0()
{
    // Encoding: 0xA4C0E3E0
    // Test LD3H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, imm4=0
    let encoding: u32 = 0xA4C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_bi_contiguous_invalid_0_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_bi_contiguous_invalid_1_e000_a4c0e000() {
    // Encoding: 0xA4C0E000
    // Test LD3H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3h_z_p_bi_contiguous_sp_rn_a4c0e3e0() {
    // Test LD3H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA4C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQD_Z.P.BI_U64 Tests
// ============================================================================

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_0_zero_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_1_poweroftwo_2000_a5812000() {
    // Encoding: 0xA5812000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xA5812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_3_poweroftwominusone_2000_a5832000() {
    // Encoding: 0xA5832000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5832000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_4_poweroftwo_2000_a5842000() {
    // Encoding: 0xA5842000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA5842000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_7_poweroftwominusone_2000_a5872000() {
    // Encoding: 0xA5872000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_8_poweroftwo_2000_a5882000() {
    // Encoding: 0xA5882000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5882000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_imm4_15_max_2000_a58f2000() {
    // Encoding: 0xA58F2000
    // Test LD1RQD_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=15
    let encoding: u32 = 0xA58F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_pg_0_min_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_pg_1_poweroftwo_2000_a5802400() {
    // Encoding: 0xA5802400
    // Test LD1RQD_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, imm4=0
    let encoding: u32 = 0xA5802400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_rn_0_min_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_rn_1_poweroftwo_2000_a5802020() {
    // Encoding: 0xA5802020
    // Test LD1RQD_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm4=0, Pg=0
    let encoding: u32 = 0xA5802020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_rn_30_poweroftwominusone_2000_a58023c0() {
    // Encoding: 0xA58023C0
    // Test LD1RQD_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA58023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqd_z_p_bi_u64_field_rn_31_max_2000_a58023e0() {
    // Encoding: 0xA58023E0
    // Test LD1RQD_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA58023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqd_z_p_bi_u64_field_zt_0_min_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqd_z_p_bi_u64_field_zt_1_poweroftwo_2000_a5802001() {
    // Encoding: 0xA5802001
    // Test LD1RQD_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5802001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqd_z_p_bi_u64_field_zt_30_poweroftwominusone_2000_a580201e() {
    // Encoding: 0xA580201E
    // Test LD1RQD_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=30
    let encoding: u32 = 0xA580201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqd_z_p_bi_u64_field_zt_31_max_2000_a580201f() {
    // Encoding: 0xA580201F
    // Test LD1RQD_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA580201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1rqd_z_p_bi_u64_combo_0_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqd_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_8192_a58023e0() {
    // Encoding: 0xA58023E0
    // Test LD1RQD_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA58023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_bi_u64_invalid_0_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_bi_u64_invalid_1_2000_a5802000() {
    // Encoding: 0xA5802000
    // Test LD1RQD_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqd_z_p_bi_u64_reg_write_0_a5802000() {
    // Test LD1RQD_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA5802000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5802000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQD_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqd_z_p_bi_u64_sp_rn_a58023e0() {
    // Test LD1RQD_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA58023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA58023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_0_zero_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a5a1e000() {
    // Encoding: 0xA5A1E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Pg=0, Zt=0
    let encoding: u32 = 0xA5A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a5a3e000() {
    // Encoding: 0xA5A3E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, imm4=3, Pg=0
    let encoding: u32 = 0xA5A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a5a4e000() {
    // Encoding: 0xA5A4E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a5a7e000() {
    // Encoding: 0xA5A7E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Pg=0, Zt=0
    let encoding: u32 = 0xA5A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a5a8e000() {
    // Encoding: 0xA5A8E000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_imm4_15_max_e000_a5afe000() {
    // Encoding: 0xA5AFE000
    // Test LD2D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, imm4=15, Rn=0, Zt=0
    let encoding: u32 = 0xA5AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_pg_0_min_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a5a0e400() {
    // Encoding: 0xA5A0E400
    // Test LD2D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA5A0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_rn_0_min_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a5a0e020() {
    // Encoding: 0xA5A0E020
    // Test LD2D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=1
    let encoding: u32 = 0xA5A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a5a0e3c0() {
    // Encoding: 0xA5A0E3C0
    // Test LD2D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA5A0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2d_z_p_bi_contiguous_field_rn_31_max_e000_a5a0e3e0() {
    // Encoding: 0xA5A0E3E0
    // Test LD2D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2d_z_p_bi_contiguous_field_zt_0_min_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a5a0e001() {
    // Encoding: 0xA5A0E001
    // Test LD2D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA5A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a5a0e01e() {
    // Encoding: 0xA5A0E01E
    // Test LD2D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA5A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2d_z_p_bi_contiguous_field_zt_31_max_e000_a5a0e01f() {
    // Encoding: 0xA5A0E01F
    // Test LD2D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA5A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld2d_z_p_bi_contiguous_combo_0_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a5a0e3e0()
{
    // Encoding: 0xA5A0E3E0
    // Test LD2D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_bi_contiguous_invalid_0_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_bi_contiguous_invalid_1_e000_a5a0e000() {
    // Encoding: 0xA5A0E000
    // Test LD2D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2d_z_p_bi_contiguous_sp_rn_a5a0e3e0() {
    // Test LD2D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA5A0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQW_Z.P.BI_U32 Tests
// ============================================================================

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_0_zero_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_1_poweroftwo_2000_a5012000() {
    // Encoding: 0xA5012000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA5012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_3_poweroftwominusone_2000_a5032000() {
    // Encoding: 0xA5032000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5032000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_4_poweroftwo_2000_a5042000() {
    // Encoding: 0xA5042000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA5042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_7_poweroftwominusone_2000_a5072000() {
    // Encoding: 0xA5072000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Zt=0, Rn=0
    let encoding: u32 = 0xA5072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_8_poweroftwo_2000_a5082000() {
    // Encoding: 0xA5082000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA5082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_imm4_15_max_2000_a50f2000() {
    // Encoding: 0xA50F2000
    // Test LD1RQW_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA50F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_pg_0_min_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_pg_1_poweroftwo_2000_a5002400() {
    // Encoding: 0xA5002400
    // Test LD1RQW_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_rn_0_min_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_rn_1_poweroftwo_2000_a5002020() {
    // Encoding: 0xA5002020
    // Test LD1RQW_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_rn_30_poweroftwominusone_2000_a50023c0() {
    // Encoding: 0xA50023C0
    // Test LD1RQW_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=30, Zt=0
    let encoding: u32 = 0xA50023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqw_z_p_bi_u32_field_rn_31_max_2000_a50023e0() {
    // Encoding: 0xA50023E0
    // Test LD1RQW_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA50023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqw_z_p_bi_u32_field_zt_0_min_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqw_z_p_bi_u32_field_zt_1_poweroftwo_2000_a5002001() {
    // Encoding: 0xA5002001
    // Test LD1RQW_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA5002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqw_z_p_bi_u32_field_zt_30_poweroftwominusone_2000_a500201e() {
    // Encoding: 0xA500201E
    // Test LD1RQW_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA500201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqw_z_p_bi_u32_field_zt_31_max_2000_a500201f() {
    // Encoding: 0xA500201F
    // Test LD1RQW_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA500201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1rqw_z_p_bi_u32_combo_0_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqw_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_8192_a50023e0() {
    // Encoding: 0xA50023E0
    // Test LD1RQW_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA50023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_bi_u32_invalid_0_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_bi_u32_invalid_1_2000_a5002000() {
    // Encoding: 0xA5002000
    // Test LD1RQW_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqw_z_p_bi_u32_reg_write_0_a5002000() {
    // Test LD1RQW_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA5002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQW_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqw_z_p_bi_u32_sp_rn_a50023e0() {
    // Test LD1RQW_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA50023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA50023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1B_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_0_zero_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_1_poweroftwo_e000_8421e000() {
    // Encoding: 0x8421E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=1, Zt=0
    let encoding: u32 = 0x8421E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_3_poweroftwominusone_e000_8423e000() {
    // Encoding: 0x8423E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=3, Zt=0
    let encoding: u32 = 0x8423E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_4_poweroftwo_e000_8424e000() {
    // Encoding: 0x8424E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, imm5=4, Pg=0, Zt=0
    let encoding: u32 = 0x8424E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_7_poweroftwominusone_e000_8427e000() {
    // Encoding: 0x8427E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0x8427E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_8_poweroftwo_e000_8428e000() {
    // Encoding: 0x8428E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x8428E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_15_poweroftwominusone_e000_842fe000() {
    // Encoding: 0x842FE000
    // Test LDFF1B_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=15, Zn=0, Zt=0
    let encoding: u32 = 0x842FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_16_poweroftwo_e000_8430e000() {
    // Encoding: 0x8430E000
    // Test LDFF1B_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=16, Zt=0
    let encoding: u32 = 0x8430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1b_z_p_ai_s_field_imm5_31_max_e000_843fe000() {
    // Encoding: 0x843FE000
    // Test LDFF1B_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Pg=0, Zn=0
    let encoding: u32 = 0x843FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_ai_s_field_pg_0_min_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_ai_s_field_pg_1_poweroftwo_e000_8420e400() {
    // Encoding: 0x8420E400
    // Test LDFF1B_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, Pg=1, imm5=0
    let encoding: u32 = 0x8420E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_ai_s_field_zn_0_min_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_ai_s_field_zn_1_poweroftwo_e000_8420e020() {
    // Encoding: 0x8420E020
    // Test LDFF1B_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=1, imm5=0, Pg=0
    let encoding: u32 = 0x8420E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_ai_s_field_zn_30_poweroftwominusone_e000_8420e3c0() {
    // Encoding: 0x8420E3C0
    // Test LDFF1B_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=30
    let encoding: u32 = 0x8420E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_ai_s_field_zn_31_max_e000_8420e3e0() {
    // Encoding: 0x8420E3E0
    // Test LDFF1B_Z.P.AI_S field Zn = 31 (Max)
    // Fields: imm5=0, Pg=0, Zn=31, Zt=0
    let encoding: u32 = 0x8420E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_ai_s_field_zt_0_min_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S field Zt = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_ai_s_field_zt_1_poweroftwo_e000_8420e001() {
    // Encoding: 0x8420E001
    // Test LDFF1B_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0x8420E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_ai_s_field_zt_30_poweroftwominusone_e000_8420e01e() {
    // Encoding: 0x8420E01E
    // Test LDFF1B_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0x8420E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_ai_s_field_zt_31_max_e000_8420e01f() {
    // Encoding: 0x8420E01F
    // Test LDFF1B_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=31
    let encoding: u32 = 0x8420E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1b_z_p_ai_s_combo_0_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_ai_s_invalid_0_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_ai_s_invalid_1_e000_8420e000() {
    // Encoding: 0x8420E000
    // Test LDFF1B_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x8420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_0_zero_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_1_poweroftwo_e000_c421e000() {
    // Encoding: 0xC421E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm5=1, Zt=0, Zn=0
    let encoding: u32 = 0xC421E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_3_poweroftwominusone_e000_c423e000() {
    // Encoding: 0xC423E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC423E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_4_poweroftwo_e000_c424e000() {
    // Encoding: 0xC424E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC424E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_7_poweroftwominusone_e000_c427e000() {
    // Encoding: 0xC427E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=7
    let encoding: u32 = 0xC427E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_8_poweroftwo_e000_c428e000() {
    // Encoding: 0xC428E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, imm5=8, Pg=0, Zt=0
    let encoding: u32 = 0xC428E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_15_poweroftwominusone_e000_c42fe000() {
    // Encoding: 0xC42FE000
    // Test LDFF1B_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=15
    let encoding: u32 = 0xC42FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_16_poweroftwo_e000_c430e000() {
    // Encoding: 0xC430E000
    // Test LDFF1B_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=16
    let encoding: u32 = 0xC430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1b_z_p_ai_d_field_imm5_31_max_e000_c43fe000() {
    // Encoding: 0xC43FE000
    // Test LDFF1B_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC43FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_ai_d_field_pg_0_min_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_ai_d_field_pg_1_poweroftwo_e000_c420e400() {
    // Encoding: 0xC420E400
    // Test LDFF1B_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=1
    let encoding: u32 = 0xC420E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_ai_d_field_zn_0_min_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_ai_d_field_zn_1_poweroftwo_e000_c420e020() {
    // Encoding: 0xC420E020
    // Test LDFF1B_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC420E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_ai_d_field_zn_30_poweroftwominusone_e000_c420e3c0() {
    // Encoding: 0xC420E3C0
    // Test LDFF1B_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zn=30, imm5=0
    let encoding: u32 = 0xC420E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_ai_d_field_zn_31_max_e000_c420e3e0() {
    // Encoding: 0xC420E3E0
    // Test LDFF1B_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xC420E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_ai_d_field_zt_0_min_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_ai_d_field_zt_1_poweroftwo_e000_c420e001() {
    // Encoding: 0xC420E001
    // Test LDFF1B_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC420E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_ai_d_field_zt_30_poweroftwominusone_e000_c420e01e() {
    // Encoding: 0xC420E01E
    // Test LDFF1B_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=30
    let encoding: u32 = 0xC420E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_ai_d_field_zt_31_max_e000_c420e01f() {
    // Encoding: 0xC420E01F
    // Test LDFF1B_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=31
    let encoding: u32 = 0xC420E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1b_z_p_ai_d_combo_0_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_ai_d_invalid_0_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_ai_d_invalid_1_e000_c420e000() {
    // Encoding: 0xC420E000
    // Test LDFF1B_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_ai_s_reg_write_0_8420e000() {
    // Test LDFF1B_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x8420E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8420E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_ai_d_reg_write_0_c420e000() {
    // Test LDFF1B_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC420E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC420E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1B_Z.P.BR_U8 Tests
// ============================================================================

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u8_field_rm_0_min_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 field Rm = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u8_field_rm_1_poweroftwo_6000_a4016000() {
    // Encoding: 0xA4016000
    // Test LDFF1B_Z.P.BR_U8 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u8_field_rm_30_poweroftwominusone_6000_a41e6000() {
    // Encoding: 0xA41E6000
    // Test LDFF1B_Z.P.BR_U8 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA41E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1b_z_p_br_u8_field_rm_31_max_6000_a41f6000() {
    // Encoding: 0xA41F6000
    // Test LDFF1B_Z.P.BR_U8 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xA41F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u8_field_pg_0_min_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u8_field_pg_1_poweroftwo_6000_a4006400() {
    // Encoding: 0xA4006400
    // Test LDFF1B_Z.P.BR_U8 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA4006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u8_field_rn_0_min_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u8_field_rn_1_poweroftwo_6000_a4006020() {
    // Encoding: 0xA4006020
    // Test LDFF1B_Z.P.BR_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u8_field_rn_30_poweroftwominusone_6000_a40063c0() {
    // Encoding: 0xA40063C0
    // Test LDFF1B_Z.P.BR_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xA40063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_br_u8_field_rn_31_max_6000_a40063e0() {
    // Encoding: 0xA40063E0
    // Test LDFF1B_Z.P.BR_U8 field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_br_u8_field_zt_0_min_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_br_u8_field_zt_1_poweroftwo_6000_a4006001() {
    // Encoding: 0xA4006001
    // Test LDFF1B_Z.P.BR_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA4006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_br_u8_field_zt_30_poweroftwominusone_6000_a400601e() {
    // Encoding: 0xA400601E
    // Test LDFF1B_Z.P.BR_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_br_u8_field_zt_31_max_6000_a400601f() {
    // Encoding: 0xA400601F
    // Test LDFF1B_Z.P.BR_U8 field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=31
    let encoding: u32 = 0xA400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_br_u8_combo_0_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_br_u8_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a40063e0() {
    // Encoding: 0xA40063E0
    // Test LDFF1B_Z.P.BR_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u8_invalid_0_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u8_invalid_1_6000_a4006000() {
    // Encoding: 0xA4006000
    // Test LDFF1B_Z.P.BR_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u16_field_rm_0_min_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u16_field_rm_1_poweroftwo_6000_a4216000() {
    // Encoding: 0xA4216000
    // Test LDFF1B_Z.P.BR_U16 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xA4216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u16_field_rm_30_poweroftwominusone_6000_a43e6000() {
    // Encoding: 0xA43E6000
    // Test LDFF1B_Z.P.BR_U16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA43E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1b_z_p_br_u16_field_rm_31_max_6000_a43f6000() {
    // Encoding: 0xA43F6000
    // Test LDFF1B_Z.P.BR_U16 field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=31, Zt=0
    let encoding: u32 = 0xA43F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u16_field_pg_0_min_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u16_field_pg_1_poweroftwo_6000_a4206400() {
    // Encoding: 0xA4206400
    // Test LDFF1B_Z.P.BR_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u16_field_rn_0_min_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u16_field_rn_1_poweroftwo_6000_a4206020() {
    // Encoding: 0xA4206020
    // Test LDFF1B_Z.P.BR_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=1
    let encoding: u32 = 0xA4206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u16_field_rn_30_poweroftwominusone_6000_a42063c0() {
    // Encoding: 0xA42063C0
    // Test LDFF1B_Z.P.BR_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xA42063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_br_u16_field_rn_31_max_6000_a42063e0() {
    // Encoding: 0xA42063E0
    // Test LDFF1B_Z.P.BR_U16 field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA42063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_br_u16_field_zt_0_min_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_br_u16_field_zt_1_poweroftwo_6000_a4206001() {
    // Encoding: 0xA4206001
    // Test LDFF1B_Z.P.BR_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_br_u16_field_zt_30_poweroftwominusone_6000_a420601e() {
    // Encoding: 0xA420601E
    // Test LDFF1B_Z.P.BR_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, Zt=30, Pg=0
    let encoding: u32 = 0xA420601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_br_u16_field_zt_31_max_6000_a420601f() {
    // Encoding: 0xA420601F
    // Test LDFF1B_Z.P.BR_U16 field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA420601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_br_u16_combo_0_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_br_u16_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a42063e0() {
    // Encoding: 0xA42063E0
    // Test LDFF1B_Z.P.BR_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xA42063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u16_invalid_0_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u16_invalid_1_6000_a4206000() {
    // Encoding: 0xA4206000
    // Test LDFF1B_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u32_field_rm_0_min_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u32_field_rm_1_poweroftwo_6000_a4416000() {
    // Encoding: 0xA4416000
    // Test LDFF1B_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4416000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u32_field_rm_30_poweroftwominusone_6000_a45e6000() {
    // Encoding: 0xA45E6000
    // Test LDFF1B_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Rm=30, Zt=0
    let encoding: u32 = 0xA45E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1b_z_p_br_u32_field_rm_31_max_6000_a45f6000() {
    // Encoding: 0xA45F6000
    // Test LDFF1B_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xA45F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u32_field_pg_0_min_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u32_field_pg_1_poweroftwo_6000_a4406400() {
    // Encoding: 0xA4406400
    // Test LDFF1B_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xA4406400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u32_field_rn_0_min_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u32_field_rn_1_poweroftwo_6000_a4406020() {
    // Encoding: 0xA4406020
    // Test LDFF1B_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, Rm=0
    let encoding: u32 = 0xA4406020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u32_field_rn_30_poweroftwominusone_6000_a44063c0() {
    // Encoding: 0xA44063C0
    // Test LDFF1B_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA44063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_br_u32_field_rn_31_max_6000_a44063e0() {
    // Encoding: 0xA44063E0
    // Test LDFF1B_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA44063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_br_u32_field_zt_0_min_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_br_u32_field_zt_1_poweroftwo_6000_a4406001() {
    // Encoding: 0xA4406001
    // Test LDFF1B_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4406001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_br_u32_field_zt_30_poweroftwominusone_6000_a440601e() {
    // Encoding: 0xA440601E
    // Test LDFF1B_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=30
    let encoding: u32 = 0xA440601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_br_u32_field_zt_31_max_6000_a440601f() {
    // Encoding: 0xA440601F
    // Test LDFF1B_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, Rm=0
    let encoding: u32 = 0xA440601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_br_u32_combo_0_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a44063e0() {
    // Encoding: 0xA44063E0
    // Test LDFF1B_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xA44063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u32_invalid_0_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u32_invalid_1_6000_a4406000() {
    // Encoding: 0xA4406000
    // Test LDFF1B_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u64_field_rm_0_min_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u64_field_rm_1_poweroftwo_6000_a4616000() {
    // Encoding: 0xA4616000
    // Test LDFF1B_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA4616000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u64_field_rm_30_poweroftwominusone_6000_a47e6000() {
    // Encoding: 0xA47E6000
    // Test LDFF1B_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=30, Pg=0, Rn=0
    let encoding: u32 = 0xA47E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1b_z_p_br_u64_field_rm_31_max_6000_a47f6000() {
    // Encoding: 0xA47F6000
    // Test LDFF1B_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xA47F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u64_field_pg_0_min_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u64_field_pg_1_poweroftwo_6000_a4606400() {
    // Encoding: 0xA4606400
    // Test LDFF1B_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA4606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_br_u64_field_rn_0_min_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_br_u64_field_rn_1_poweroftwo_6000_a4606020() {
    // Encoding: 0xA4606020
    // Test LDFF1B_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA4606020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_br_u64_field_rn_30_poweroftwominusone_6000_a46063c0() {
    // Encoding: 0xA46063C0
    // Test LDFF1B_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA46063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_br_u64_field_rn_31_max_6000_a46063e0() {
    // Encoding: 0xA46063E0
    // Test LDFF1B_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA46063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_br_u64_field_zt_0_min_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_br_u64_field_zt_1_poweroftwo_6000_a4606001() {
    // Encoding: 0xA4606001
    // Test LDFF1B_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4606001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_br_u64_field_zt_30_poweroftwominusone_6000_a460601e() {
    // Encoding: 0xA460601E
    // Test LDFF1B_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA460601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_br_u64_field_zt_31_max_6000_a460601f() {
    // Encoding: 0xA460601F
    // Test LDFF1B_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xA460601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_br_u64_combo_0_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a46063e0() {
    // Encoding: 0xA46063E0
    // Test LDFF1B_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA46063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u64_invalid_0_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_br_u64_invalid_1_6000_a4606000() {
    // Encoding: 0xA4606000
    // Test LDFF1B_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_br_u8_reg_write_0_a4006000() {
    // Test LDFF1B_Z.P.BR_U8 register write: SimdFromField("t")
    // Encoding: 0xA4006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_br_u8_sp_rn_a40063e0() {
    // Test LDFF1B_Z.P.BR_U8 with Rn = SP (31)
    // Encoding: 0xA40063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA40063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_br_u16_reg_write_0_a4206000() {
    // Test LDFF1B_Z.P.BR_U16 register write: SimdFromField("t")
    // Encoding: 0xA4206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_br_u16_sp_rn_a42063e0() {
    // Test LDFF1B_Z.P.BR_U16 with Rn = SP (31)
    // Encoding: 0xA42063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA42063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_br_u32_reg_write_0_a4406000() {
    // Test LDFF1B_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA4406000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4406000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_br_u32_sp_rn_a44063e0() {
    // Test LDFF1B_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA44063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA44063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_br_u64_reg_write_0_a4606000() {
    // Test LDFF1B_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA4606000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4606000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_br_u64_sp_rn_a46063e0() {
    // Test LDFF1B_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA46063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA46063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SW_Z.P.BZ_D.x32.scaled Tests
// ============================================================================

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_xs_0_min_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_xs_1_max_2000_c5602000() {
    // Encoding: 0xC5602000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zt=0, Zm=0, xs=1, Pg=0
    let encoding: u32 = 0xC5602000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zm_0_min_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_2000_c5212000() {
    // Encoding: 0xC5212000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5212000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_2000_c53e2000() {
    // Encoding: 0xC53E2000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC53E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zm_31_max_2000_c53f2000() {
    // Encoding: 0xC53F2000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=31
    let encoding: u32 = 0xC53F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_pg_0_min_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_2000_c5202400() {
    // Encoding: 0xC5202400
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=1, xs=0
    let encoding: u32 = 0xC5202400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_rn_0_min_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Rn=0, xs=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_2000_c5202020() {
    // Encoding: 0xC5202020
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0xC5202020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_2000_c52023c0() {
    // Encoding: 0xC52023C0
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xC52023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_rn_31_max_2000_c52023e0() {
    // Encoding: 0xC52023E0
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0xC52023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zt_0_min_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_2000_c5202001() {
    // Encoding: 0xC5202001
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=1
    let encoding: u32 = 0xC5202001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_2000_c520201e() {
    // Encoding: 0xC520201E
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0xC520201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_field_zt_31_max_2000_c520201f() {
    // Encoding: 0xC520201F
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0, xs=0
    let encoding: u32 = 0xC520201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_combo_0_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_c52023e0(
) {
    // Encoding: 0xC52023E0
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC52023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_invalid_0_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_invalid_1_2000_c5202000() {
    // Encoding: 0xC5202000
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_xs_0_min_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_xs_1_max_2000_c5402000() {
    // Encoding: 0xC5402000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Zt=0, xs=1, Rn=0, Zm=0
    let encoding: u32 = 0xC5402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zm_0_min_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_2000_c5012000() {
    // Encoding: 0xC5012000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_2000_c51e2000() {
    // Encoding: 0xC51E2000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC51E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zm_31_max_2000_c51f2000() {
    // Encoding: 0xC51F2000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Zm=31, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC51F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_pg_0_min_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_2000_c5002400() {
    // Encoding: 0xC5002400
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0xC5002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_rn_0_min_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_2000_c5002020() {
    // Encoding: 0xC5002020
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xC5002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_2000_c50023c0() {
    // Encoding: 0xC50023C0
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=0, Rn=30, Pg=0, xs=0
    let encoding: u32 = 0xC50023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_rn_31_max_2000_c50023e0() {
    // Encoding: 0xC50023E0
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC50023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zt_0_min_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_2000_c5002001() {
    // Encoding: 0xC5002001
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=1, Pg=0, xs=0
    let encoding: u32 = 0xC5002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_2000_c500201e() {
    // Encoding: 0xC500201E
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=30
    let encoding: u32 = 0xC500201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_field_zt_31_max_2000_c500201f() {
    // Encoding: 0xC500201F
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=31, xs=0
    let encoding: u32 = 0xC500201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_combo_0_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_c50023e0(
) {
    // Encoding: 0xC50023E0
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=31
    let encoding: u32 = 0xC50023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_invalid_0_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, xs=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_invalid_1_2000_c5002000() {
    // Encoding: 0xC5002000
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zm_0_min_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_a000_c561a000() {
    // Encoding: 0xC561A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=1
    let encoding: u32 = 0xC561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_a000_c57ea000() {
    // Encoding: 0xC57EA000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Rn=0, Zt=0
    let encoding: u32 = 0xC57EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zm_31_max_a000_c57fa000() {
    // Encoding: 0xC57FA000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC57FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_pg_0_min_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_a000_c560a400() {
    // Encoding: 0xC560A400
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zm=0, Zt=0
    let encoding: u32 = 0xC560A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_rn_0_min_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_a000_c560a020() {
    // Encoding: 0xC560A020
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xC560A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_a000_c560a3c0() {
    // Encoding: 0xC560A3C0
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Zm=0
    let encoding: u32 = 0xC560A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_rn_31_max_a000_c560a3e0() {
    // Encoding: 0xC560A3E0
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0xC560A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zt_0_min_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_a000_c560a001() {
    // Encoding: 0xC560A001
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC560A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_a000_c560a01e() {
    // Encoding: 0xC560A01E
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=30, Rn=0, Pg=0
    let encoding: u32 = 0xC560A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_field_zt_31_max_a000_c560a01f() {
    // Encoding: 0xC560A01F
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=31
    let encoding: u32 = 0xC560A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_combo_0_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_c560a3e0(
) {
    // Encoding: 0xC560A3E0
    // Test LDFF1SW_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, Zm=0
    let encoding: u32 = 0xC560A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_invalid_0_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_invalid_1_a000_c560a000() {
    // Encoding: 0xC560A000
    // Test LDFF1SW_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zm_0_min_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_c541a000() {
    // Encoding: 0xC541A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=1
    let encoding: u32 = 0xC541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_c55ea000() {
    // Encoding: 0xC55EA000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC55EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zm_31_max_a000_c55fa000() {
    // Encoding: 0xC55FA000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zt=0, Rn=0
    let encoding: u32 = 0xC55FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_pg_0_min_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_c540a400() {
    // Encoding: 0xC540A400
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xC540A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_rn_0_min_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_c540a020() {
    // Encoding: 0xC540A020
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=1, Zm=0
    let encoding: u32 = 0xC540A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_c540a3c0() {
    // Encoding: 0xC540A3C0
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Zm=0, Pg=0
    let encoding: u32 = 0xC540A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_rn_31_max_a000_c540a3e0() {
    // Encoding: 0xC540A3E0
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=31
    let encoding: u32 = 0xC540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zt_0_min_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_c540a001() {
    // Encoding: 0xC540A001
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, Zm=0
    let encoding: u32 = 0xC540A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_c540a01e() {
    // Encoding: 0xC540A01E
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0xC540A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_field_zt_31_max_a000_c540a01f() {
    // Encoding: 0xC540A01F
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC540A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_combo_0_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_c540a3e0(
) {
    // Encoding: 0xC540A3E0
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_invalid_0_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_invalid_1_a000_c540a000() {
    // Encoding: 0xC540A000
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_reg_write_0_c5202000() {
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5202000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5202000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_scaled_sp_rn_c52023e0() {
    // Test LDFF1SW_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC52023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC52023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_reg_write_0_c5002000() {
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_bz_d_x32_unscaled_sp_rn_c50023e0() {
    // Test LDFF1SW_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC50023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC50023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_reg_write_0_c560a000() {
    // Test LDFF1SW_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC560A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_bz_d_64_scaled_sp_rn_c560a3e0() {
    // Test LDFF1SW_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC560A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_reg_write_0_c540a000() {
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC540A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_bz_d_64_unscaled_sp_rn_c540a3e0() {
    // Test LDFF1SW_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC540A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_0_zero_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a521e000() {
    // Encoding: 0xA521E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=1
    let encoding: u32 = 0xA521E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a523e000() {
    // Encoding: 0xA523E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=3, Zt=0
    let encoding: u32 = 0xA523E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a524e000() {
    // Encoding: 0xA524E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a527e000() {
    // Encoding: 0xA527E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a528e000() {
    // Encoding: 0xA528E000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=8, Rn=0
    let encoding: u32 = 0xA528E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_imm4_15_max_e000_a52fe000() {
    // Encoding: 0xA52FE000
    // Test LD2W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=15
    let encoding: u32 = 0xA52FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_pg_0_min_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a520e400() {
    // Encoding: 0xA520E400
    // Test LD2W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA520E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_rn_0_min_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a520e020() {
    // Encoding: 0xA520E020
    // Test LD2W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA520E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a520e3c0() {
    // Encoding: 0xA520E3C0
    // Test LD2W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA520E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2w_z_p_bi_contiguous_field_rn_31_max_e000_a520e3e0() {
    // Encoding: 0xA520E3E0
    // Test LD2W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA520E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2w_z_p_bi_contiguous_field_zt_0_min_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a520e001() {
    // Encoding: 0xA520E001
    // Test LD2W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=1
    let encoding: u32 = 0xA520E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a520e01e() {
    // Encoding: 0xA520E01E
    // Test LD2W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA520E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2w_z_p_bi_contiguous_field_zt_31_max_e000_a520e01f() {
    // Encoding: 0xA520E01F
    // Test LD2W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xA520E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld2w_z_p_bi_contiguous_combo_0_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a520e3e0()
{
    // Encoding: 0xA520E3E0
    // Test LD2W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA520E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_bi_contiguous_invalid_0_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_bi_contiguous_invalid_1_e000_a520e000() {
    // Encoding: 0xA520E000
    // Test LD2W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2w_z_p_bi_contiguous_sp_rn_a520e3e0() {
    // Test LD2W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA520E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA520E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RSB_Z.P.BI_S16 Tests
// ============================================================================

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_0_zero_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 0 (Zero)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_1_poweroftwo_c000_85c1c000() {
    // Encoding: 0x85C1C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm6=1, Zt=0, Rn=0
    let encoding: u32 = 0x85C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_3_poweroftwominusone_c000_85c3c000() {
    // Encoding: 0x85C3C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm6=3, Zt=0
    let encoding: u32 = 0x85C3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_4_poweroftwo_c000_85c4c000() {
    // Encoding: 0x85C4C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_7_poweroftwominusone_c000_85c7c000() {
    // Encoding: 0x85C7C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm6=7, Pg=0
    let encoding: u32 = 0x85C7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_8_poweroftwo_c000_85c8c000() {
    // Encoding: 0x85C8C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_15_poweroftwominusone_c000_85cfc000() {
    // Encoding: 0x85CFC000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=15, Rn=0, Zt=0
    let encoding: u32 = 0x85CFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_16_poweroftwo_c000_85d0c000() {
    // Encoding: 0x85D0C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 16 (PowerOfTwo)
    // Fields: Pg=0, imm6=16, Rn=0, Zt=0
    let encoding: u32 = 0x85D0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_31_poweroftwominusone_c000_85dfc000() {
    // Encoding: 0x85DFC000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm6=31, Rn=0
    let encoding: u32 = 0x85DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_32_poweroftwo_c000_85e0c000() {
    // Encoding: 0x85E0C000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 32 (PowerOfTwo)
    // Fields: Rn=0, imm6=32, Zt=0, Pg=0
    let encoding: u32 = 0x85E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_imm6_63_max_c000_85ffc000() {
    // Encoding: 0x85FFC000
    // Test LD1RSB_Z.P.BI_S16 field imm6 = 63 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=63
    let encoding: u32 = 0x85FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_pg_0_min_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 field Pg = 0 (Min)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_pg_1_poweroftwo_c000_85c0c400() {
    // Encoding: 0x85C0C400
    // Test LD1RSB_Z.P.BI_S16 field Pg = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0x85C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_rn_0_min_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_rn_1_poweroftwo_c000_85c0c020() {
    // Encoding: 0x85C0C020
    // Test LD1RSB_Z.P.BI_S16 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0x85C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_rn_30_poweroftwominusone_c000_85c0c3c0() {
    // Encoding: 0x85C0C3C0
    // Test LD1RSB_Z.P.BI_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=0, Rn=30, Zt=0
    let encoding: u32 = 0x85C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsb_z_p_bi_s16_field_rn_31_max_c000_85c0c3e0() {
    // Encoding: 0x85C0C3E0
    // Test LD1RSB_Z.P.BI_S16 field Rn = 31 (Max)
    // Fields: imm6=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x85C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsb_z_p_bi_s16_field_zt_0_min_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 field Zt = 0 (Min)
    // Fields: imm6=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsb_z_p_bi_s16_field_zt_1_poweroftwo_c000_85c0c001() {
    // Encoding: 0x85C0C001
    // Test LD1RSB_Z.P.BI_S16 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm6=0, Rn=0
    let encoding: u32 = 0x85C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsb_z_p_bi_s16_field_zt_30_poweroftwominusone_c000_85c0c01e() {
    // Encoding: 0x85C0C01E
    // Test LD1RSB_Z.P.BI_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=30
    let encoding: u32 = 0x85C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsb_z_p_bi_s16_field_zt_31_max_c000_85c0c01f() {
    // Encoding: 0x85C0C01F
    // Test LD1RSB_Z.P.BI_S16 field Zt = 31 (Max)
    // Fields: imm6=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0x85C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsb_z_p_bi_s16_combo_0_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsb_z_p_bi_s16_special_rn_31_stack_pointer_sp_may_require_alignment_49152_85c0c3e0() {
    // Encoding: 0x85C0C3E0
    // Test LD1RSB_Z.P.BI_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, imm6=0, Zt=0
    let encoding: u32 = 0x85C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s16_invalid_0_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm6=0, Zt=0, Pg=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s16_invalid_1_c000_85c0c000() {
    // Encoding: 0x85C0C000
    // Test LD1RSB_Z.P.BI_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_0_zero_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 0 (Zero)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_1_poweroftwo_a000_85c1a000() {
    // Encoding: 0x85C1A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=1
    let encoding: u32 = 0x85C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_3_poweroftwominusone_a000_85c3a000() {
    // Encoding: 0x85C3A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x85C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_4_poweroftwo_a000_85c4a000() {
    // Encoding: 0x85C4A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm6=4, Rn=0, Zt=0
    let encoding: u32 = 0x85C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_7_poweroftwominusone_a000_85c7a000() {
    // Encoding: 0x85C7A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=7, Zt=0, Rn=0
    let encoding: u32 = 0x85C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_8_poweroftwo_a000_85c8a000() {
    // Encoding: 0x85C8A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm6=8, Rn=0, Zt=0
    let encoding: u32 = 0x85C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_15_poweroftwominusone_a000_85cfa000() {
    // Encoding: 0x85CFA000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=15
    let encoding: u32 = 0x85CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_16_poweroftwo_a000_85d0a000() {
    // Encoding: 0x85D0A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 16 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm6=16, Pg=0
    let encoding: u32 = 0x85D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_31_poweroftwominusone_a000_85dfa000() {
    // Encoding: 0x85DFA000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Pg=0, Rn=0
    let encoding: u32 = 0x85DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_32_poweroftwo_a000_85e0a000() {
    // Encoding: 0x85E0A000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Rn=0, Zt=0
    let encoding: u32 = 0x85E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_imm6_63_max_a000_85ffa000() {
    // Encoding: 0x85FFA000
    // Test LD1RSB_Z.P.BI_S32 field imm6 = 63 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=63
    let encoding: u32 = 0x85FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_pg_0_min_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_pg_1_poweroftwo_a000_85c0a400() {
    // Encoding: 0x85C0A400
    // Test LD1RSB_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0x85C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_rn_0_min_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_rn_1_poweroftwo_a000_85c0a020() {
    // Encoding: 0x85C0A020
    // Test LD1RSB_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, imm6=0
    let encoding: u32 = 0x85C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_85c0a3c0() {
    // Encoding: 0x85C0A3C0
    // Test LD1RSB_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0x85C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsb_z_p_bi_s32_field_rn_31_max_a000_85c0a3e0() {
    // Encoding: 0x85C0A3E0
    // Test LD1RSB_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=31
    let encoding: u32 = 0x85C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsb_z_p_bi_s32_field_zt_0_min_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsb_z_p_bi_s32_field_zt_1_poweroftwo_a000_85c0a001() {
    // Encoding: 0x85C0A001
    // Test LD1RSB_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm6=0, Zt=1, Rn=0
    let encoding: u32 = 0x85C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsb_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_85c0a01e() {
    // Encoding: 0x85C0A01E
    // Test LD1RSB_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=30
    let encoding: u32 = 0x85C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsb_z_p_bi_s32_field_zt_31_max_a000_85c0a01f() {
    // Encoding: 0x85C0A01F
    // Test LD1RSB_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: imm6=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0x85C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsb_z_p_bi_s32_combo_0_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: imm6=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsb_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_85c0a3e0() {
    // Encoding: 0x85C0A3E0
    // Test LD1RSB_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0x85C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s32_invalid_0_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s32_invalid_1_a000_85c0a000() {
    // Encoding: 0x85C0A000
    // Test LD1RSB_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm6=0, Rn=0, Zt=0
    let encoding: u32 = 0x85C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_0_zero_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 0 (Zero)
    // Fields: imm6=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_1_poweroftwo_8000_85c18000() {
    // Encoding: 0x85C18000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm6=1, Zt=0, Rn=0
    let encoding: u32 = 0x85C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_3_poweroftwominusone_8000_85c38000() {
    // Encoding: 0x85C38000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_4_poweroftwo_8000_85c48000() {
    // Encoding: 0x85C48000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_7_poweroftwominusone_8000_85c78000() {
    // Encoding: 0x85C78000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0x85C78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_8_poweroftwo_8000_85c88000() {
    // Encoding: 0x85C88000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm6=8, Pg=0, Rn=0
    let encoding: u32 = 0x85C88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_15_poweroftwominusone_8000_85cf8000() {
    // Encoding: 0x85CF8000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=15
    let encoding: u32 = 0x85CF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_16_poweroftwo_8000_85d08000() {
    // Encoding: 0x85D08000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 16 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=16
    let encoding: u32 = 0x85D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_31_poweroftwominusone_8000_85df8000() {
    // Encoding: 0x85DF8000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Pg=0, Rn=0
    let encoding: u32 = 0x85DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_32_poweroftwo_8000_85e08000() {
    // Encoding: 0x85E08000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Rn=0, Zt=0
    let encoding: u32 = 0x85E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_imm6_63_max_8000_85ff8000() {
    // Encoding: 0x85FF8000
    // Test LD1RSB_Z.P.BI_S64 field imm6 = 63 (Max)
    // Fields: Rn=0, imm6=63, Zt=0, Pg=0
    let encoding: u32 = 0x85FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_pg_0_min_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_pg_1_poweroftwo_8000_85c08400() {
    // Encoding: 0x85C08400
    // Test LD1RSB_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=0, Pg=1, Rn=0
    let encoding: u32 = 0x85C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_rn_0_min_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_rn_1_poweroftwo_8000_85c08020() {
    // Encoding: 0x85C08020
    // Test LD1RSB_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=0, Pg=0, Rn=1
    let encoding: u32 = 0x85C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_rn_30_poweroftwominusone_8000_85c083c0() {
    // Encoding: 0x85C083C0
    // Test LD1RSB_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x85C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsb_z_p_bi_s64_field_rn_31_max_8000_85c083e0() {
    // Encoding: 0x85C083E0
    // Test LD1RSB_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x85C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsb_z_p_bi_s64_field_zt_0_min_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Zt=0, imm6=0, Pg=0, Rn=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsb_z_p_bi_s64_field_zt_1_poweroftwo_8000_85c08001() {
    // Encoding: 0x85C08001
    // Test LD1RSB_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm6=0, Zt=1, Rn=0
    let encoding: u32 = 0x85C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsb_z_p_bi_s64_field_zt_30_poweroftwominusone_8000_85c0801e() {
    // Encoding: 0x85C0801E
    // Test LD1RSB_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, imm6=0
    let encoding: u32 = 0x85C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsb_z_p_bi_s64_field_zt_31_max_8000_85c0801f() {
    // Encoding: 0x85C0801F
    // Test LD1RSB_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, imm6=0
    let encoding: u32 = 0x85C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsb_z_p_bi_s64_combo_0_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm6=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsb_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_32768_85c083e0() {
    // Encoding: 0x85C083E0
    // Test LD1RSB_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0x85C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s64_invalid_0_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm6=0, Pg=0, Rn=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsb_z_p_bi_s64_invalid_1_8000_85c08000() {
    // Encoding: 0x85C08000
    // Test LD1RSB_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, imm6=0
    let encoding: u32 = 0x85C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsb_z_p_bi_s16_reg_write_0_85c0c000() {
    // Test LD1RSB_Z.P.BI_S16 register write: SimdFromField("t")
    // Encoding: 0x85C0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSB_Z.P.BI_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsb_z_p_bi_s16_sp_rn_85c0c3e0() {
    // Test LD1RSB_Z.P.BI_S16 with Rn = SP (31)
    // Encoding: 0x85C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsb_z_p_bi_s32_reg_write_0_85c0a000() {
    // Test LD1RSB_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0x85C0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSB_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsb_z_p_bi_s32_sp_rn_85c0a3e0() {
    // Test LD1RSB_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0x85C0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsb_z_p_bi_s64_reg_write_0_85c08000() {
    // Test LD1RSB_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0x85C08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSB_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsb_z_p_bi_s64_sp_rn_85c083e0() {
    // Test LD1RSB_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0x85C083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RB_Z.P.BI_U8 Tests
// ============================================================================

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_0_zero_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 0 (Zero)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_1_poweroftwo_8000_84418000() {
    // Encoding: 0x84418000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=1
    let encoding: u32 = 0x84418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_3_poweroftwominusone_8000_84438000() {
    // Encoding: 0x84438000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=3, Zt=0, Rn=0
    let encoding: u32 = 0x84438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_4_poweroftwo_8000_84448000() {
    // Encoding: 0x84448000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x84448000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_7_poweroftwominusone_8000_84478000() {
    // Encoding: 0x84478000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84478000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_8_poweroftwo_8000_84488000() {
    // Encoding: 0x84488000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm6=8, Zt=0
    let encoding: u32 = 0x84488000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_15_poweroftwominusone_8000_844f8000() {
    // Encoding: 0x844F8000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: imm6=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x844F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_16_poweroftwo_8000_84508000() {
    // Encoding: 0x84508000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=16
    let encoding: u32 = 0x84508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_31_poweroftwominusone_8000_845f8000() {
    // Encoding: 0x845F8000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm6=31, Rn=0
    let encoding: u32 = 0x845F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_32_poweroftwo_8000_84608000() {
    // Encoding: 0x84608000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 32 (PowerOfTwo)
    // Fields: imm6=32, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rb_z_p_bi_u8_field_imm6_63_max_8000_847f8000() {
    // Encoding: 0x847F8000
    // Test LD1RB_Z.P.BI_U8 field imm6 = 63 (Max)
    // Fields: Rn=0, imm6=63, Pg=0, Zt=0
    let encoding: u32 = 0x847F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u8_field_pg_0_min_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u8_field_pg_1_poweroftwo_8000_84408400() {
    // Encoding: 0x84408400
    // Test LD1RB_Z.P.BI_U8 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x84408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u8_field_rn_0_min_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u8_field_rn_1_poweroftwo_8000_84408020() {
    // Encoding: 0x84408020
    // Test LD1RB_Z.P.BI_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=1
    let encoding: u32 = 0x84408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rb_z_p_bi_u8_field_rn_30_poweroftwominusone_8000_844083c0() {
    // Encoding: 0x844083C0
    // Test LD1RB_Z.P.BI_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, imm6=0
    let encoding: u32 = 0x844083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rb_z_p_bi_u8_field_rn_31_max_8000_844083e0() {
    // Encoding: 0x844083E0
    // Test LD1RB_Z.P.BI_U8 field Rn = 31 (Max)
    // Fields: Zt=0, imm6=0, Rn=31, Pg=0
    let encoding: u32 = 0x844083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rb_z_p_bi_u8_field_zt_0_min_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rb_z_p_bi_u8_field_zt_1_poweroftwo_8000_84408001() {
    // Encoding: 0x84408001
    // Test LD1RB_Z.P.BI_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=1
    let encoding: u32 = 0x84408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rb_z_p_bi_u8_field_zt_30_poweroftwominusone_8000_8440801e() {
    // Encoding: 0x8440801E
    // Test LD1RB_Z.P.BI_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0x8440801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rb_z_p_bi_u8_field_zt_31_max_8000_8440801f() {
    // Encoding: 0x8440801F
    // Test LD1RB_Z.P.BI_U8 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, imm6=0, Rn=0
    let encoding: u32 = 0x8440801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rb_z_p_bi_u8_combo_0_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rb_z_p_bi_u8_special_rn_31_stack_pointer_sp_may_require_alignment_32768_844083e0() {
    // Encoding: 0x844083E0
    // Test LD1RB_Z.P.BI_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm6=0, Rn=31, Pg=0
    let encoding: u32 = 0x844083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u8_invalid_0_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u8_invalid_1_8000_84408000() {
    // Encoding: 0x84408000
    // Test LD1RB_Z.P.BI_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, imm6=0, Pg=0
    let encoding: u32 = 0x84408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_0_zero_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 0 (Zero)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_1_poweroftwo_a000_8441a000() {
    // Encoding: 0x8441A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 1 (PowerOfTwo)
    // Fields: imm6=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8441A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_3_poweroftwominusone_a000_8443a000() {
    // Encoding: 0x8443A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x8443A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_4_poweroftwo_a000_8444a000() {
    // Encoding: 0x8444A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 4 (PowerOfTwo)
    // Fields: Rn=0, imm6=4, Pg=0, Zt=0
    let encoding: u32 = 0x8444A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_7_poweroftwominusone_a000_8447a000() {
    // Encoding: 0x8447A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm6=7, Zt=0, Pg=0
    let encoding: u32 = 0x8447A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_8_poweroftwo_a000_8448a000() {
    // Encoding: 0x8448A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x8448A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_15_poweroftwominusone_a000_844fa000() {
    // Encoding: 0x844FA000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, imm6=15, Pg=0
    let encoding: u32 = 0x844FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_16_poweroftwo_a000_8450a000() {
    // Encoding: 0x8450A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm6=16, Zt=0
    let encoding: u32 = 0x8450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_31_poweroftwominusone_a000_845fa000() {
    // Encoding: 0x845FA000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Pg=0, Rn=0
    let encoding: u32 = 0x845FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_32_poweroftwo_a000_8460a000() {
    // Encoding: 0x8460A000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 32 (PowerOfTwo)
    // Fields: Zt=0, imm6=32, Rn=0, Pg=0
    let encoding: u32 = 0x8460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rb_z_p_bi_u16_field_imm6_63_max_a000_847fa000() {
    // Encoding: 0x847FA000
    // Test LD1RB_Z.P.BI_U16 field imm6 = 63 (Max)
    // Fields: imm6=63, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x847FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u16_field_pg_0_min_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u16_field_pg_1_poweroftwo_a000_8440a400() {
    // Encoding: 0x8440A400
    // Test LD1RB_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, imm6=0, Zt=0
    let encoding: u32 = 0x8440A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u16_field_rn_0_min_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u16_field_rn_1_poweroftwo_a000_8440a020() {
    // Encoding: 0x8440A020
    // Test LD1RB_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm6=0, Pg=0
    let encoding: u32 = 0x8440A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rb_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_8440a3c0() {
    // Encoding: 0x8440A3C0
    // Test LD1RB_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0x8440A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rb_z_p_bi_u16_field_rn_31_max_a000_8440a3e0() {
    // Encoding: 0x8440A3E0
    // Test LD1RB_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: imm6=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0x8440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rb_z_p_bi_u16_field_zt_0_min_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rb_z_p_bi_u16_field_zt_1_poweroftwo_a000_8440a001() {
    // Encoding: 0x8440A001
    // Test LD1RB_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm6=0, Zt=1, Pg=0
    let encoding: u32 = 0x8440A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rb_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_8440a01e() {
    // Encoding: 0x8440A01E
    // Test LD1RB_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=30
    let encoding: u32 = 0x8440A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rb_z_p_bi_u16_field_zt_31_max_a000_8440a01f() {
    // Encoding: 0x8440A01F
    // Test LD1RB_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=31
    let encoding: u32 = 0x8440A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rb_z_p_bi_u16_combo_0_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rb_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_8440a3e0() {
    // Encoding: 0x8440A3E0
    // Test LD1RB_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0x8440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u16_invalid_0_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm6=0, Rn=0, Zt=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u16_invalid_1_a000_8440a000() {
    // Encoding: 0x8440A000
    // Test LD1RB_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_0_zero_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 0 (Zero)
    // Fields: Zt=0, Rn=0, imm6=0, Pg=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_1_poweroftwo_c000_8441c000() {
    // Encoding: 0x8441C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=1
    let encoding: u32 = 0x8441C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_3_poweroftwominusone_c000_8443c000() {
    // Encoding: 0x8443C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, imm6=3, Pg=0
    let encoding: u32 = 0x8443C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_4_poweroftwo_c000_8444c000() {
    // Encoding: 0x8444C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm6=4, Zt=0
    let encoding: u32 = 0x8444C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_7_poweroftwominusone_c000_8447c000() {
    // Encoding: 0x8447C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm6=7, Zt=0, Rn=0
    let encoding: u32 = 0x8447C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_8_poweroftwo_c000_8448c000() {
    // Encoding: 0x8448C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8448C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_15_poweroftwominusone_c000_844fc000() {
    // Encoding: 0x844FC000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: imm6=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x844FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_16_poweroftwo_c000_8450c000() {
    // Encoding: 0x8450C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=16
    let encoding: u32 = 0x8450C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_31_poweroftwominusone_c000_845fc000() {
    // Encoding: 0x845FC000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: imm6=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x845FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_32_poweroftwo_c000_8460c000() {
    // Encoding: 0x8460C000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 32 (PowerOfTwo)
    // Fields: imm6=32, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x8460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rb_z_p_bi_u32_field_imm6_63_max_c000_847fc000() {
    // Encoding: 0x847FC000
    // Test LD1RB_Z.P.BI_U32 field imm6 = 63 (Max)
    // Fields: Rn=0, Zt=0, imm6=63, Pg=0
    let encoding: u32 = 0x847FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u32_field_pg_0_min_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u32_field_pg_1_poweroftwo_c000_8440c400() {
    // Encoding: 0x8440C400
    // Test LD1RB_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm6=0, Pg=1, Zt=0
    let encoding: u32 = 0x8440C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u32_field_rn_0_min_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u32_field_rn_1_poweroftwo_c000_8440c020() {
    // Encoding: 0x8440C020
    // Test LD1RB_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0x8440C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rb_z_p_bi_u32_field_rn_30_poweroftwominusone_c000_8440c3c0() {
    // Encoding: 0x8440C3C0
    // Test LD1RB_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, imm6=0
    let encoding: u32 = 0x8440C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rb_z_p_bi_u32_field_rn_31_max_c000_8440c3e0() {
    // Encoding: 0x8440C3E0
    // Test LD1RB_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: imm6=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0x8440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rb_z_p_bi_u32_field_zt_0_min_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, imm6=0, Pg=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rb_z_p_bi_u32_field_zt_1_poweroftwo_c000_8440c001() {
    // Encoding: 0x8440C001
    // Test LD1RB_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0x8440C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rb_z_p_bi_u32_field_zt_30_poweroftwominusone_c000_8440c01e() {
    // Encoding: 0x8440C01E
    // Test LD1RB_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, imm6=0, Rn=0
    let encoding: u32 = 0x8440C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rb_z_p_bi_u32_field_zt_31_max_c000_8440c01f() {
    // Encoding: 0x8440C01F
    // Test LD1RB_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: imm6=0, Zt=31, Rn=0, Pg=0
    let encoding: u32 = 0x8440C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rb_z_p_bi_u32_combo_0_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rb_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_49152_8440c3e0() {
    // Encoding: 0x8440C3E0
    // Test LD1RB_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x8440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u32_invalid_0_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm6=0, Zt=0, Rn=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u32_invalid_1_c000_8440c000() {
    // Encoding: 0x8440C000
    // Test LD1RB_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm6=0, Pg=0, Rn=0
    let encoding: u32 = 0x8440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_0_zero_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 0 (Zero)
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_1_poweroftwo_e000_8441e000() {
    // Encoding: 0x8441E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=1
    let encoding: u32 = 0x8441E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_3_poweroftwominusone_e000_8443e000() {
    // Encoding: 0x8443E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8443E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_4_poweroftwo_e000_8444e000() {
    // Encoding: 0x8444E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm6=4, Pg=0, Rn=0
    let encoding: u32 = 0x8444E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_7_poweroftwominusone_e000_8447e000() {
    // Encoding: 0x8447E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8447E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_8_poweroftwo_e000_8448e000() {
    // Encoding: 0x8448E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm6=8, Zt=0
    let encoding: u32 = 0x8448E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_15_poweroftwominusone_e000_844fe000() {
    // Encoding: 0x844FE000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=15
    let encoding: u32 = 0x844FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_16_poweroftwo_e000_8450e000() {
    // Encoding: 0x8450E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 16 (PowerOfTwo)
    // Fields: imm6=16, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_31_poweroftwominusone_e000_845fe000() {
    // Encoding: 0x845FE000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Pg=0, Rn=0
    let encoding: u32 = 0x845FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_32_poweroftwo_e000_8460e000() {
    // Encoding: 0x8460E000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 32 (PowerOfTwo)
    // Fields: imm6=32, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x8460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rb_z_p_bi_u64_field_imm6_63_max_e000_847fe000() {
    // Encoding: 0x847FE000
    // Test LD1RB_Z.P.BI_U64 field imm6 = 63 (Max)
    // Fields: Pg=0, Zt=0, imm6=63, Rn=0
    let encoding: u32 = 0x847FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u64_field_pg_0_min_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u64_field_pg_1_poweroftwo_e000_8440e400() {
    // Encoding: 0x8440E400
    // Test LD1RB_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, imm6=0, Rn=0
    let encoding: u32 = 0x8440E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rb_z_p_bi_u64_field_rn_0_min_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rb_z_p_bi_u64_field_rn_1_poweroftwo_e000_8440e020() {
    // Encoding: 0x8440E020
    // Test LD1RB_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=1
    let encoding: u32 = 0x8440E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rb_z_p_bi_u64_field_rn_30_poweroftwominusone_e000_8440e3c0() {
    // Encoding: 0x8440E3C0
    // Test LD1RB_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, imm6=0
    let encoding: u32 = 0x8440E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rb_z_p_bi_u64_field_rn_31_max_e000_8440e3e0() {
    // Encoding: 0x8440E3E0
    // Test LD1RB_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x8440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rb_z_p_bi_u64_field_zt_0_min_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rb_z_p_bi_u64_field_zt_1_poweroftwo_e000_8440e001() {
    // Encoding: 0x8440E001
    // Test LD1RB_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0x8440E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rb_z_p_bi_u64_field_zt_30_poweroftwominusone_e000_8440e01e() {
    // Encoding: 0x8440E01E
    // Test LD1RB_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x8440E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rb_z_p_bi_u64_field_zt_31_max_e000_8440e01f() {
    // Encoding: 0x8440E01F
    // Test LD1RB_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm6=0, Rn=0
    let encoding: u32 = 0x8440E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rb_z_p_bi_u64_combo_0_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm6=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rb_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_57344_8440e3e0() {
    // Encoding: 0x8440E3E0
    // Test LD1RB_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u64_invalid_0_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rb_z_p_bi_u64_invalid_1_e000_8440e000() {
    // Encoding: 0x8440E000
    // Test LD1RB_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, imm6=0
    let encoding: u32 = 0x8440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rb_z_p_bi_u8_reg_write_0_84408000() {
    // Test LD1RB_Z.P.BI_U8 register write: SimdFromField("t")
    // Encoding: 0x84408000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84408000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rb_z_p_bi_u8_sp_rn_844083e0() {
    // Test LD1RB_Z.P.BI_U8 with Rn = SP (31)
    // Encoding: 0x844083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x844083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rb_z_p_bi_u16_reg_write_0_8440a000() {
    // Test LD1RB_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0x8440A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rb_z_p_bi_u16_sp_rn_8440a3e0() {
    // Test LD1RB_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0x8440A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rb_z_p_bi_u32_reg_write_0_8440c000() {
    // Test LD1RB_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0x8440C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rb_z_p_bi_u32_sp_rn_8440c3e0() {
    // Test LD1RB_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0x8440C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rb_z_p_bi_u64_reg_write_0_8440e000() {
    // Test LD1RB_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0x8440E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RB_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rb_z_p_bi_u64_sp_rn_8440e3e0() {
    // Test LD1RB_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0x8440E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8440E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SB_Z.P.BR_S16 Tests
// ============================================================================

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rm_0_min_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rm_1_poweroftwo_6000_a5c16000() {
    // Encoding: 0xA5C16000
    // Test LDFF1SB_Z.P.BR_S16 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=1
    let encoding: u32 = 0xA5C16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rm_30_poweroftwominusone_6000_a5de6000() {
    // Encoding: 0xA5DE6000
    // Test LDFF1SB_Z.P.BR_S16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=30, Rn=0, Zt=0
    let encoding: u32 = 0xA5DE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rm_31_max_6000_a5df6000() {
    // Encoding: 0xA5DF6000
    // Test LDFF1SB_Z.P.BR_S16 field Rm = 31 (Max)
    // Fields: Rm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5DF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_pg_0_min_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_pg_1_poweroftwo_6000_a5c06400() {
    // Encoding: 0xA5C06400
    // Test LDFF1SB_Z.P.BR_S16 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5C06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rn_0_min_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rn_1_poweroftwo_6000_a5c06020() {
    // Encoding: 0xA5C06020
    // Test LDFF1SB_Z.P.BR_S16 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5C06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rn_30_poweroftwominusone_6000_a5c063c0() {
    // Encoding: 0xA5C063C0
    // Test LDFF1SB_Z.P.BR_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xA5C063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_br_s16_field_rn_31_max_6000_a5c063e0() {
    // Encoding: 0xA5C063E0
    // Test LDFF1SB_Z.P.BR_S16 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA5C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_br_s16_field_zt_0_min_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_br_s16_field_zt_1_poweroftwo_6000_a5c06001() {
    // Encoding: 0xA5C06001
    // Test LDFF1SB_Z.P.BR_S16 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5C06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_br_s16_field_zt_30_poweroftwominusone_6000_a5c0601e() {
    // Encoding: 0xA5C0601E
    // Test LDFF1SB_Z.P.BR_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5C0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_br_s16_field_zt_31_max_6000_a5c0601f() {
    // Encoding: 0xA5C0601F
    // Test LDFF1SB_Z.P.BR_S16 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, Rm=0
    let encoding: u32 = 0xA5C0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sb_z_p_br_s16_combo_0_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_br_s16_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a5c063e0() {
    // Encoding: 0xA5C063E0
    // Test LDFF1SB_Z.P.BR_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA5C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s16_invalid_0_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s16_invalid_1_6000_a5c06000() {
    // Encoding: 0xA5C06000
    // Test LDFF1SB_Z.P.BR_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rm_0_min_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rm_1_poweroftwo_6000_a5a16000() {
    // Encoding: 0xA5A16000
    // Test LDFF1SB_Z.P.BR_S32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rm_30_poweroftwominusone_6000_a5be6000() {
    // Encoding: 0xA5BE6000
    // Test LDFF1SB_Z.P.BR_S32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rm=30, Rn=0
    let encoding: u32 = 0xA5BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rm_31_max_6000_a5bf6000() {
    // Encoding: 0xA5BF6000
    // Test LDFF1SB_Z.P.BR_S32 field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_pg_0_min_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_pg_1_poweroftwo_6000_a5a06400() {
    // Encoding: 0xA5A06400
    // Test LDFF1SB_Z.P.BR_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, Rm=0
    let encoding: u32 = 0xA5A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rn_0_min_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rn_1_poweroftwo_6000_a5a06020() {
    // Encoding: 0xA5A06020
    // Test LDFF1SB_Z.P.BR_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rn_30_poweroftwominusone_6000_a5a063c0() {
    // Encoding: 0xA5A063C0
    // Test LDFF1SB_Z.P.BR_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Rm=0, Zt=0
    let encoding: u32 = 0xA5A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_br_s32_field_rn_31_max_6000_a5a063e0() {
    // Encoding: 0xA5A063E0
    // Test LDFF1SB_Z.P.BR_S32 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xA5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_br_s32_field_zt_0_min_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_br_s32_field_zt_1_poweroftwo_6000_a5a06001() {
    // Encoding: 0xA5A06001
    // Test LDFF1SB_Z.P.BR_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_br_s32_field_zt_30_poweroftwominusone_6000_a5a0601e() {
    // Encoding: 0xA5A0601E
    // Test LDFF1SB_Z.P.BR_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_br_s32_field_zt_31_max_6000_a5a0601f() {
    // Encoding: 0xA5A0601F
    // Test LDFF1SB_Z.P.BR_S32 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sb_z_p_br_s32_combo_0_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_br_s32_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a5a063e0() {
    // Encoding: 0xA5A063E0
    // Test LDFF1SB_Z.P.BR_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s32_invalid_0_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s32_invalid_1_6000_a5a06000() {
    // Encoding: 0xA5A06000
    // Test LDFF1SB_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rm_0_min_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rm_1_poweroftwo_6000_a5816000() {
    // Encoding: 0xA5816000
    // Test LDFF1SB_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=1
    let encoding: u32 = 0xA5816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rm_30_poweroftwominusone_6000_a59e6000() {
    // Encoding: 0xA59E6000
    // Test LDFF1SB_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=30, Zt=0
    let encoding: u32 = 0xA59E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rm_31_max_6000_a59f6000() {
    // Encoding: 0xA59F6000
    // Test LDFF1SB_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xA59F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_pg_0_min_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_pg_1_poweroftwo_6000_a5806400() {
    // Encoding: 0xA5806400
    // Test LDFF1SB_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rn_0_min_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rn_1_poweroftwo_6000_a5806020() {
    // Encoding: 0xA5806020
    // Test LDFF1SB_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xA5806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rn_30_poweroftwominusone_6000_a58063c0() {
    // Encoding: 0xA58063C0
    // Test LDFF1SB_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xA58063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_br_s64_field_rn_31_max_6000_a58063e0() {
    // Encoding: 0xA58063E0
    // Test LDFF1SB_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=31
    let encoding: u32 = 0xA58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_br_s64_field_zt_0_min_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_br_s64_field_zt_1_poweroftwo_6000_a5806001() {
    // Encoding: 0xA5806001
    // Test LDFF1SB_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Rm=0
    let encoding: u32 = 0xA5806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_br_s64_field_zt_30_poweroftwominusone_6000_a580601e() {
    // Encoding: 0xA580601E
    // Test LDFF1SB_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xA580601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_br_s64_field_zt_31_max_6000_a580601f() {
    // Encoding: 0xA580601F
    // Test LDFF1SB_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xA580601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sb_z_p_br_s64_combo_0_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a58063e0() {
    // Encoding: 0xA58063E0
    // Test LDFF1SB_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xA58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s64_invalid_0_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_br_s64_invalid_1_6000_a5806000() {
    // Encoding: 0xA5806000
    // Test LDFF1SB_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_br_s16_reg_write_0_a5c06000() {
    // Test LDFF1SB_Z.P.BR_S16 register write: SimdFromField("t")
    // Encoding: 0xA5C06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BR_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_br_s16_sp_rn_a5c063e0() {
    // Test LDFF1SB_Z.P.BR_S16 with Rn = SP (31)
    // Encoding: 0xA5C063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_br_s32_reg_write_0_a5a06000() {
    // Test LDFF1SB_Z.P.BR_S32 register write: SimdFromField("t")
    // Encoding: 0xA5A06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BR_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_br_s32_sp_rn_a5a063e0() {
    // Test LDFF1SB_Z.P.BR_S32 with Rn = SP (31)
    // Encoding: 0xA5A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_br_s64_reg_write_0_a5806000() {
    // Test LDFF1SB_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA5806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_br_s64_sp_rn_a58063e0() {
    // Test LDFF1SB_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA58063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA58063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SB_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_0_zero_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_1_poweroftwo_a000_8421a000() {
    // Encoding: 0x8421A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=1
    let encoding: u32 = 0x8421A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_8423a000() {
    // Encoding: 0x8423A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=3, Pg=0, Zn=0
    let encoding: u32 = 0x8423A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_4_poweroftwo_a000_8424a000() {
    // Encoding: 0x8424A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, imm5=4, Pg=0, Zt=0
    let encoding: u32 = 0x8424A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_8427a000() {
    // Encoding: 0x8427A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=7, Pg=0, Zt=0
    let encoding: u32 = 0x8427A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_8_poweroftwo_a000_8428a000() {
    // Encoding: 0x8428A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8428A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_842fa000() {
    // Encoding: 0x842FA000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=15, Pg=0, Zn=0
    let encoding: u32 = 0x842FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_16_poweroftwo_a000_8430a000() {
    // Encoding: 0x8430A000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x8430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sb_z_p_ai_s_field_imm5_31_max_a000_843fa000() {
    // Encoding: 0x843FA000
    // Test LDFF1SB_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: imm5=31, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x843FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_ai_s_field_pg_0_min_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_ai_s_field_pg_1_poweroftwo_a000_8420a400() {
    // Encoding: 0x8420A400
    // Test LDFF1SB_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0x8420A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_ai_s_field_zn_0_min_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_ai_s_field_zn_1_poweroftwo_a000_8420a020() {
    // Encoding: 0x8420A020
    // Test LDFF1SB_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=1, imm5=0, Pg=0
    let encoding: u32 = 0x8420A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_ai_s_field_zn_30_poweroftwominusone_a000_8420a3c0() {
    // Encoding: 0x8420A3C0
    // Test LDFF1SB_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Zn=30, imm5=0
    let encoding: u32 = 0x8420A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_ai_s_field_zn_31_max_a000_8420a3e0() {
    // Encoding: 0x8420A3E0
    // Test LDFF1SB_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=31
    let encoding: u32 = 0x8420A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_ai_s_field_zt_0_min_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S field Zt = 0 (Min)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_ai_s_field_zt_1_poweroftwo_a000_8420a001() {
    // Encoding: 0x8420A001
    // Test LDFF1SB_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=1
    let encoding: u32 = 0x8420A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_ai_s_field_zt_30_poweroftwominusone_a000_8420a01e() {
    // Encoding: 0x8420A01E
    // Test LDFF1SB_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=30, Pg=0, Zn=0
    let encoding: u32 = 0x8420A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_ai_s_field_zt_31_max_a000_8420a01f() {
    // Encoding: 0x8420A01F
    // Test LDFF1SB_Z.P.AI_S field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=31
    let encoding: u32 = 0x8420A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sb_z_p_ai_s_combo_0_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_ai_s_invalid_0_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_ai_s_invalid_1_a000_8420a000() {
    // Encoding: 0x8420A000
    // Test LDFF1SB_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0x8420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_0_zero_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_1_poweroftwo_a000_c421a000() {
    // Encoding: 0xC421A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=1
    let encoding: u32 = 0xC421A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_c423a000() {
    // Encoding: 0xC423A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=3, Zt=0, Zn=0
    let encoding: u32 = 0xC423A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_4_poweroftwo_a000_c424a000() {
    // Encoding: 0xC424A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC424A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_c427a000() {
    // Encoding: 0xC427A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=7, Zt=0
    let encoding: u32 = 0xC427A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_8_poweroftwo_a000_c428a000() {
    // Encoding: 0xC428A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=8
    let encoding: u32 = 0xC428A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_c42fa000() {
    // Encoding: 0xC42FA000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=15, Zn=0
    let encoding: u32 = 0xC42FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_16_poweroftwo_a000_c430a000() {
    // Encoding: 0xC430A000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sb_z_p_ai_d_field_imm5_31_max_a000_c43fa000() {
    // Encoding: 0xC43FA000
    // Test LDFF1SB_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=31
    let encoding: u32 = 0xC43FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_ai_d_field_pg_0_min_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_ai_d_field_pg_1_poweroftwo_a000_c420a400() {
    // Encoding: 0xC420A400
    // Test LDFF1SB_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=1, Zn=0, Zt=0
    let encoding: u32 = 0xC420A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_ai_d_field_zn_0_min_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_ai_d_field_zn_1_poweroftwo_a000_c420a020() {
    // Encoding: 0xC420A020
    // Test LDFF1SB_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0xC420A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_ai_d_field_zn_30_poweroftwominusone_a000_c420a3c0() {
    // Encoding: 0xC420A3C0
    // Test LDFF1SB_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=30
    let encoding: u32 = 0xC420A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_ai_d_field_zn_31_max_a000_c420a3e0() {
    // Encoding: 0xC420A3E0
    // Test LDFF1SB_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, Zt=0, Zn=31, imm5=0
    let encoding: u32 = 0xC420A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_ai_d_field_zt_0_min_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D field Zt = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_ai_d_field_zt_1_poweroftwo_a000_c420a001() {
    // Encoding: 0xC420A001
    // Test LDFF1SB_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Zt=1, Pg=0, Zn=0
    let encoding: u32 = 0xC420A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_ai_d_field_zt_30_poweroftwominusone_a000_c420a01e() {
    // Encoding: 0xC420A01E
    // Test LDFF1SB_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=30, imm5=0, Pg=0
    let encoding: u32 = 0xC420A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_ai_d_field_zt_31_max_a000_c420a01f() {
    // Encoding: 0xC420A01F
    // Test LDFF1SB_Z.P.AI_D field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zt=31, Zn=0
    let encoding: u32 = 0xC420A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sb_z_p_ai_d_combo_0_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_ai_d_invalid_0_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_ai_d_invalid_1_a000_c420a000() {
    // Encoding: 0xC420A000
    // Test LDFF1SB_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_ai_s_reg_write_0_8420a000() {
    // Test LDFF1SB_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x8420A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8420A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_ai_d_reg_write_0_c420a000() {
    // Test LDFF1SB_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC420A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC420A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rm_0_min_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a501c000() {
    // Encoding: 0xA501C000
    // Test LDNT1W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA501C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a51ec000() {
    // Encoding: 0xA51EC000
    // Test LDNT1W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=30, Rn=0, Zt=0
    let encoding: u32 = 0xA51EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rm_31_max_c000_a51fc000() {
    // Encoding: 0xA51FC000
    // Test LDNT1W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=31, Rn=0
    let encoding: u32 = 0xA51FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_pg_0_min_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a500c400() {
    // Encoding: 0xA500C400
    // Test LDNT1W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Rm=0, Zt=0
    let encoding: u32 = 0xA500C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rn_0_min_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a500c020() {
    // Encoding: 0xA500C020
    // Test LDNT1W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA500C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a500c3c0() {
    // Encoding: 0xA500C3C0
    // Test LDNT1W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_rn_31_max_c000_a500c3e0() {
    // Encoding: 0xA500C3E0
    // Test LDNT1W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA500C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_zt_0_min_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a500c001() {
    // Encoding: 0xA500C001
    // Test LDNT1W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=1, Rn=0
    let encoding: u32 = 0xA500C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a500c01e() {
    // Encoding: 0xA500C01E
    // Test LDNT1W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA500C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1w_z_p_br_contiguous_field_zt_31_max_c000_a500c01f() {
    // Encoding: 0xA500C01F
    // Test LDNT1W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, Rm=0
    let encoding: u32 = 0xA500C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldnt1w_z_p_br_contiguous_combo_0_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a500c3e0(
) {
    // Encoding: 0xA500C3E0
    // Test LDNT1W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, Rm=0
    let encoding: u32 = 0xA500C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_br_contiguous_invalid_0_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_br_contiguous_invalid_1_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_br_contiguous_invalid_2_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_br_contiguous_invalid_3_c000_a500c000() {
    // Encoding: 0xA500C000
    // Test LDNT1W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1w_z_p_br_contiguous_reg_write_0_a500c000() {
    // Test LDNT1W_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA500C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1w_z_p_br_contiguous_sp_rn_a500c3e0() {
    // Test LDNT1W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA500C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1W_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_xs_0_min_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_xs_1_max_6000_85606000() {
    // Encoding: 0x85606000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Zm=0, Zt=0, Rn=0, xs=1, Pg=0
    let encoding: u32 = 0x85606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zm_0_min_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_6000_85216000() {
    // Encoding: 0x85216000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x85216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_6000_853e6000() {
    // Encoding: 0x853E6000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=30, Rn=0, Pg=0
    let encoding: u32 = 0x853E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zm_31_max_6000_853f6000() {
    // Encoding: 0x853F6000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x853F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_pg_0_min_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_6000_85206400() {
    // Encoding: 0x85206400
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Pg=1, Zm=0, Zt=0
    let encoding: u32 = 0x85206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_rn_0_min_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_6000_85206020() {
    // Encoding: 0x85206020
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Rn=1, xs=0, Pg=0
    let encoding: u32 = 0x85206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_6000_852063c0() {
    // Encoding: 0x852063C0
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=30
    let encoding: u32 = 0x852063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_rn_31_max_6000_852063e0() {
    // Encoding: 0x852063E0
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0, xs=0
    let encoding: u32 = 0x852063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zt_0_min_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_6000_85206001() {
    // Encoding: 0x85206001
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=1, xs=0
    let encoding: u32 = 0x85206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_6000_8520601e() {
    // Encoding: 0x8520601E
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, xs=0, Zt=30, Zm=0
    let encoding: u32 = 0x8520601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_field_zt_31_max_6000_8520601f() {
    // Encoding: 0x8520601F
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0x8520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_combo_0_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_852063e0(
) {
    // Encoding: 0x852063E0
    // Test LDFF1W_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0x852063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_invalid_0_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_invalid_1_6000_85206000() {
    // Encoding: 0x85206000
    // Test LDFF1W_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0x85206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_xs_0_min_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_xs_1_max_6000_c5606000() {
    // Encoding: 0xC5606000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, xs=1, Zm=0
    let encoding: u32 = 0xC5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zm_0_min_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_6000_c5216000() {
    // Encoding: 0xC5216000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Zm=1, Pg=0, Rn=0
    let encoding: u32 = 0xC5216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_6000_c53e6000() {
    // Encoding: 0xC53E6000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=30
    let encoding: u32 = 0xC53E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zm_31_max_6000_c53f6000() {
    // Encoding: 0xC53F6000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=31
    let encoding: u32 = 0xC53F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_pg_0_min_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_6000_c5206400() {
    // Encoding: 0xC5206400
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xC5206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_rn_0_min_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_6000_c5206020() {
    // Encoding: 0xC5206020
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC5206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_6000_c52063c0() {
    // Encoding: 0xC52063C0
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=30
    let encoding: u32 = 0xC52063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_rn_31_max_6000_c52063e0() {
    // Encoding: 0xC52063E0
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=31
    let encoding: u32 = 0xC52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zt_0_min_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_6000_c5206001() {
    // Encoding: 0xC5206001
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xC5206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_6000_c520601e() {
    // Encoding: 0xC520601E
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, xs=0, Zt=30, Zm=0
    let encoding: u32 = 0xC520601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_field_zt_31_max_6000_c520601f() {
    // Encoding: 0xC520601F
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Rn=0, xs=0, Zm=0, Zt=31, Pg=0
    let encoding: u32 = 0xC520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_combo_0_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c52063e0(
) {
    // Encoding: 0xC52063E0
    // Test LDFF1W_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Rn=31, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_invalid_0_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_invalid_1_6000_c5206000() {
    // Encoding: 0xC5206000
    // Test LDFF1W_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xC5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_xs_0_min_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_xs_1_max_6000_c5406000() {
    // Encoding: 0xC5406000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, xs=1, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zm_0_min_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_6000_c5016000() {
    // Encoding: 0xC5016000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, xs=0, Rn=0, Zm=1
    let encoding: u32 = 0xC5016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_6000_c51e6000() {
    // Encoding: 0xC51E6000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Pg=0, Rn=0, Zm=30
    let encoding: u32 = 0xC51E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zm_31_max_6000_c51f6000() {
    // Encoding: 0xC51F6000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=31, xs=0
    let encoding: u32 = 0xC51F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_pg_0_min_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_6000_c5006400() {
    // Encoding: 0xC5006400
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=1, xs=0
    let encoding: u32 = 0xC5006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_rn_0_min_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_6000_c5006020() {
    // Encoding: 0xC5006020
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=1
    let encoding: u32 = 0xC5006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_6000_c50063c0() {
    // Encoding: 0xC50063C0
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC50063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_rn_31_max_6000_c50063e0() {
    // Encoding: 0xC50063E0
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zt_0_min_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_6000_c5006001() {
    // Encoding: 0xC5006001
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xC5006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_6000_c500601e() {
    // Encoding: 0xC500601E
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC500601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_field_zt_31_max_6000_c500601f() {
    // Encoding: 0xC500601F
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, xs=0, Zt=31
    let encoding: u32 = 0xC500601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_combo_0_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c50063e0(
) {
    // Encoding: 0xC50063E0
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0, xs=0
    let encoding: u32 = 0xC50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_invalid_0_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_invalid_1_6000_c5006000() {
    // Encoding: 0xC5006000
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xC5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_xs_0_min_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_xs_1_max_6000_85406000() {
    // Encoding: 0x85406000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=1
    let encoding: u32 = 0x85406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zm_0_min_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_6000_85016000() {
    // Encoding: 0x85016000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=1
    let encoding: u32 = 0x85016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_6000_851e6000() {
    // Encoding: 0x851E6000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=30, xs=0
    let encoding: u32 = 0x851E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zm_31_max_6000_851f6000() {
    // Encoding: 0x851F6000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zm=31, Zt=0, xs=0
    let encoding: u32 = 0x851F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_pg_0_min_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_6000_85006400() {
    // Encoding: 0x85006400
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x85006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_rn_0_min_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_6000_85006020() {
    // Encoding: 0x85006020
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x85006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_6000_850063c0() {
    // Encoding: 0x850063C0
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=30
    let encoding: u32 = 0x850063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_rn_31_max_6000_850063e0() {
    // Encoding: 0x850063E0
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, xs=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0x850063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zt_0_min_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_6000_85006001() {
    // Encoding: 0x85006001
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=1, xs=0
    let encoding: u32 = 0x85006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_6000_8500601e() {
    // Encoding: 0x8500601E
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zm=0, Zt=30, Rn=0
    let encoding: u32 = 0x8500601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_field_zt_31_max_6000_8500601f() {
    // Encoding: 0x8500601F
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0x8500601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_combo_0_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_850063e0(
) {
    // Encoding: 0x850063E0
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x850063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_invalid_0_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_invalid_1_6000_85006000() {
    // Encoding: 0x85006000
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x85006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zm_0_min_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_e000_c561e000() {
    // Encoding: 0xC561E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC561E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_e000_c57ee000() {
    // Encoding: 0xC57EE000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, Pg=0
    let encoding: u32 = 0xC57EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zm_31_max_e000_c57fe000() {
    // Encoding: 0xC57FE000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=31
    let encoding: u32 = 0xC57FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_pg_0_min_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_e000_c560e400() {
    // Encoding: 0xC560E400
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC560E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_rn_0_min_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_e000_c560e020() {
    // Encoding: 0xC560E020
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC560E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_e000_c560e3c0() {
    // Encoding: 0xC560E3C0
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xC560E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_rn_31_max_e000_c560e3e0() {
    // Encoding: 0xC560E3E0
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xC560E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zt_0_min_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_e000_c560e001() {
    // Encoding: 0xC560E001
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, Zm=0
    let encoding: u32 = 0xC560E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_e000_c560e01e() {
    // Encoding: 0xC560E01E
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Zm=0, Pg=0
    let encoding: u32 = 0xC560E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_field_zt_31_max_e000_c560e01f() {
    // Encoding: 0xC560E01F
    // Test LDFF1W_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xC560E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_combo_0_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c560e3e0(
) {
    // Encoding: 0xC560E3E0
    // Test LDFF1W_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC560E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_invalid_0_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_invalid_1_e000_c560e000() {
    // Encoding: 0xC560E000
    // Test LDFF1W_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zm_0_min_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_e000_c541e000() {
    // Encoding: 0xC541E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC541E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_e000_c55ee000() {
    // Encoding: 0xC55EE000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, Pg=0
    let encoding: u32 = 0xC55EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zm_31_max_e000_c55fe000() {
    // Encoding: 0xC55FE000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Zm=31, Pg=0, Rn=0
    let encoding: u32 = 0xC55FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_pg_0_min_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_e000_c540e400() {
    // Encoding: 0xC540E400
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC540E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_rn_0_min_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_e000_c540e020() {
    // Encoding: 0xC540E020
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xC540E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_e000_c540e3c0() {
    // Encoding: 0xC540E3C0
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=30
    let encoding: u32 = 0xC540E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_rn_31_max_e000_c540e3e0() {
    // Encoding: 0xC540E3E0
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zt_0_min_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_e000_c540e001() {
    // Encoding: 0xC540E001
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=1, Pg=0
    let encoding: u32 = 0xC540E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_e000_c540e01e() {
    // Encoding: 0xC540E01E
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xC540E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_field_zt_31_max_e000_c540e01f() {
    // Encoding: 0xC540E01F
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=31
    let encoding: u32 = 0xC540E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_combo_0_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c540e3e0(
) {
    // Encoding: 0xC540E3E0
    // Test LDFF1W_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xC540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_invalid_0_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_invalid_1_e000_c540e000() {
    // Encoding: 0xC540E000
    // Test LDFF1W_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_reg_write_0_85206000() {
    // Test LDFF1W_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x85206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_s_x32_scaled_sp_rn_852063e0() {
    // Test LDFF1W_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x852063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x852063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_reg_write_0_c5206000() {
    // Test LDFF1W_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_d_x32_scaled_sp_rn_c52063e0() {
    // Test LDFF1W_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC52063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC52063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_reg_write_0_c5006000() {
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_d_x32_unscaled_sp_rn_c50063e0() {
    // Test LDFF1W_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC50063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC50063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_reg_write_0_85006000() {
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x85006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_s_x32_unscaled_sp_rn_850063e0() {
    // Test LDFF1W_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x850063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x850063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_reg_write_0_c560e000() {
    // Test LDFF1W_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC560E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_d_64_scaled_sp_rn_c560e3e0() {
    // Test LDFF1W_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC560E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_reg_write_0_c540e000() {
    // Test LDFF1W_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC540E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_bz_d_64_unscaled_sp_rn_c540e3e0() {
    // Test LDFF1W_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC540E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQB_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rm_0_min_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rm_1_poweroftwo_0_a4010000() {
    // Encoding: 0xA4010000
    // Test LD1RQB_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=1
    let encoding: u32 = 0xA4010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a41e0000() {
    // Encoding: 0xA41E0000
    // Test LD1RQB_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA41E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rm_31_max_0_a41f0000() {
    // Encoding: 0xA41F0000
    // Test LD1RQB_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xA41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_pg_0_min_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_pg_1_poweroftwo_0_a4000400() {
    // Encoding: 0xA4000400
    // Test LD1RQB_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0xA4000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rn_0_min_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rn_1_poweroftwo_0_a4000020() {
    // Encoding: 0xA4000020
    // Test LD1RQB_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xA4000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a40003c0() {
    // Encoding: 0xA40003C0
    // Test LD1RQB_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA40003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_rn_31_max_0_a40003e0() {
    // Encoding: 0xA40003E0
    // Test LD1RQB_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA40003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_zt_0_min_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_zt_1_poweroftwo_0_a4000001() {
    // Encoding: 0xA4000001
    // Test LD1RQB_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=1
    let encoding: u32 = 0xA4000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a400001e() {
    // Encoding: 0xA400001E
    // Test LD1RQB_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA400001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqb_z_p_br_contiguous_field_zt_31_max_0_a400001f() {
    // Encoding: 0xA400001F
    // Test LD1RQB_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xA400001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqb_z_p_br_contiguous_combo_0_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqb_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a40003e0() {
    // Encoding: 0xA40003E0
    // Test LD1RQB_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA40003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_br_contiguous_invalid_0_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_br_contiguous_invalid_1_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_br_contiguous_invalid_2_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_br_contiguous_invalid_3_0_a4000000() {
    // Encoding: 0xA4000000
    // Test LD1RQB_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqb_z_p_br_contiguous_reg_write_0_a4000000() {
    // Test LD1RQB_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA4000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQB_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqb_z_p_br_contiguous_sp_rn_a40003e0() {
    // Test LD1RQB_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA40003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA40003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1SW_Z.P.BI_S64 Tests
// ============================================================================

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_0_zero_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a491a000() {
    // Encoding: 0xA491A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA491A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a493a000() {
    // Encoding: 0xA493A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA493A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a494a000() {
    // Encoding: 0xA494A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=4, Pg=0
    let encoding: u32 = 0xA494A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a497a000() {
    // Encoding: 0xA497A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=7
    let encoding: u32 = 0xA497A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a498a000() {
    // Encoding: 0xA498A000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=8
    let encoding: u32 = 0xA498A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_imm4_15_max_a000_a49fa000() {
    // Encoding: 0xA49FA000
    // Test LDNF1SW_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA49FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_pg_0_min_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_pg_1_poweroftwo_a000_a490a400() {
    // Encoding: 0xA490A400
    // Test LDNF1SW_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA490A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_rn_0_min_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_rn_1_poweroftwo_a000_a490a020() {
    // Encoding: 0xA490A020
    // Test LDNF1SW_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA490A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a490a3c0() {
    // Encoding: 0xA490A3C0
    // Test LDNF1SW_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xA490A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_rn_31_max_a000_a490a3e0() {
    // Encoding: 0xA490A3E0
    // Test LDNF1SW_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA490A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_zt_0_min_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_zt_1_poweroftwo_a000_a490a001() {
    // Encoding: 0xA490A001
    // Test LDNF1SW_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, imm4=0, Pg=0
    let encoding: u32 = 0xA490A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a490a01e() {
    // Encoding: 0xA490A01E
    // Test LDNF1SW_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA490A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sw_z_p_bi_s64_field_zt_31_max_a000_a490a01f() {
    // Encoding: 0xA490A01F
    // Test LDNF1SW_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA490A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sw_z_p_bi_s64_combo_0_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sw_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a490a3e0() {
    // Encoding: 0xA490A3E0
    // Test LDNF1SW_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA490A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sw_z_p_bi_s64_invalid_0_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sw_z_p_bi_s64_invalid_1_a000_a490a000() {
    // Encoding: 0xA490A000
    // Test LDNF1SW_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sw_z_p_bi_s64_reg_write_0_a490a000() {
    // Test LDNF1SW_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA490A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA490A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SW_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sw_z_p_bi_s64_sp_rn_a490a3e0() {
    // Test LDNF1SW_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA490A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA490A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDR_P.BI__ Tests
// ============================================================================

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldr_p_bi_field_imm9h_0_zero_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ field imm9h = 0 (Zero)
    // Fields: imm9l=0, Rn=0, Pt=0, imm9h=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldr_p_bi_field_imm9h_1_poweroftwo_0_85810000() {
    // Encoding: 0x85810000
    // Test LDR_P.BI__ field imm9h = 1 (PowerOfTwo)
    // Fields: Rn=0, imm9l=0, Pt=0, imm9h=1
    let encoding: u32 = 0x85810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldr_p_bi_field_imm9h_3_poweroftwominusone_0_85830000() {
    // Encoding: 0x85830000
    // Test LDR_P.BI__ field imm9h = 3 (PowerOfTwoMinusOne)
    // Fields: Pt=0, imm9l=0, imm9h=3, Rn=0
    let encoding: u32 = 0x85830000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldr_p_bi_field_imm9h_4_poweroftwo_0_85840000() {
    // Encoding: 0x85840000
    // Test LDR_P.BI__ field imm9h = 4 (PowerOfTwo)
    // Fields: imm9h=4, Rn=0, Pt=0, imm9l=0
    let encoding: u32 = 0x85840000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldr_p_bi_field_imm9h_7_poweroftwominusone_0_85870000() {
    // Encoding: 0x85870000
    // Test LDR_P.BI__ field imm9h = 7 (PowerOfTwoMinusOne)
    // Fields: imm9h=7, Rn=0, Pt=0, imm9l=0
    let encoding: u32 = 0x85870000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldr_p_bi_field_imm9h_8_poweroftwo_0_85880000() {
    // Encoding: 0x85880000
    // Test LDR_P.BI__ field imm9h = 8 (PowerOfTwo)
    // Fields: Pt=0, imm9h=8, imm9l=0, Rn=0
    let encoding: u32 = 0x85880000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ldr_p_bi_field_imm9h_15_poweroftwominusone_0_858f0000() {
    // Encoding: 0x858F0000
    // Test LDR_P.BI__ field imm9h = 15 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, imm9h=15, Pt=0, Rn=0
    let encoding: u32 = 0x858F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldr_p_bi_field_imm9h_16_poweroftwo_0_85900000() {
    // Encoding: 0x85900000
    // Test LDR_P.BI__ field imm9h = 16 (PowerOfTwo)
    // Fields: Rn=0, imm9h=16, Pt=0, imm9l=0
    let encoding: u32 = 0x85900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ldr_p_bi_field_imm9h_31_poweroftwominusone_0_859f0000() {
    // Encoding: 0x859F0000
    // Test LDR_P.BI__ field imm9h = 31 (PowerOfTwoMinusOne)
    // Fields: imm9h=31, Rn=0, Pt=0, imm9l=0
    let encoding: u32 = 0x859F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ldr_p_bi_field_imm9h_32_poweroftwo_0_85a00000() {
    // Encoding: 0x85A00000
    // Test LDR_P.BI__ field imm9h = 32 (PowerOfTwo)
    // Fields: imm9l=0, Rn=0, imm9h=32, Pt=0
    let encoding: u32 = 0x85A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ldr_p_bi_field_imm9h_63_max_0_85bf0000() {
    // Encoding: 0x85BF0000
    // Test LDR_P.BI__ field imm9h = 63 (Max)
    // Fields: imm9h=63, imm9l=0, Pt=0, Rn=0
    let encoding: u32 = 0x85BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldr_p_bi_field_imm9l_0_zero_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ field imm9l = 0 (Zero)
    // Fields: imm9l=0, imm9h=0, Pt=0, Rn=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldr_p_bi_field_imm9l_1_poweroftwo_0_85800400() {
    // Encoding: 0x85800400
    // Test LDR_P.BI__ field imm9l = 1 (PowerOfTwo)
    // Fields: Rn=0, imm9h=0, Pt=0, imm9l=1
    let encoding: u32 = 0x85800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_ldr_p_bi_field_imm9l_3_poweroftwominusone_0_85800c00() {
    // Encoding: 0x85800C00
    // Test LDR_P.BI__ field imm9l = 3 (PowerOfTwoMinusOne)
    // Fields: imm9h=0, Rn=0, imm9l=3, Pt=0
    let encoding: u32 = 0x85800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_ldr_p_bi_field_imm9l_7_max_0_85801c00() {
    // Encoding: 0x85801C00
    // Test LDR_P.BI__ field imm9l = 7 (Max)
    // Fields: imm9h=0, imm9l=7, Rn=0, Pt=0
    let encoding: u32 = 0x85801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldr_p_bi_field_rn_0_min_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ field Rn = 0 (Min)
    // Fields: Rn=0, Pt=0, imm9l=0, imm9h=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldr_p_bi_field_rn_1_poweroftwo_0_85800020() {
    // Encoding: 0x85800020
    // Test LDR_P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: imm9l=0, imm9h=0, Rn=1, Pt=0
    let encoding: u32 = 0x85800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldr_p_bi_field_rn_30_poweroftwominusone_0_858003c0() {
    // Encoding: 0x858003C0
    // Test LDR_P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm9h=0, Pt=0, imm9l=0, Rn=30
    let encoding: u32 = 0x858003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldr_p_bi_field_rn_31_max_0_858003e0() {
    // Encoding: 0x858003E0
    // Test LDR_P.BI__ field Rn = 31 (Max)
    // Fields: imm9l=0, imm9h=0, Rn=31, Pt=0
    let encoding: u32 = 0x858003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldr_p_bi_field_pt_0_min_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ field Pt = 0 (Min)
    // Fields: Rn=0, Pt=0, imm9h=0, imm9l=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_ldr_p_bi_field_pt_1_poweroftwo_0_85800001() {
    // Encoding: 0x85800001
    // Test LDR_P.BI__ field Pt = 1 (PowerOfTwo)
    // Fields: imm9l=0, Rn=0, imm9h=0, Pt=1
    let encoding: u32 = 0x85800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_ldr_p_bi_field_pt_7_poweroftwominusone_0_85800007() {
    // Encoding: 0x85800007
    // Test LDR_P.BI__ field Pt = 7 (PowerOfTwoMinusOne)
    // Fields: imm9h=0, imm9l=0, Pt=7, Rn=0
    let encoding: u32 = 0x85800007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_ldr_p_bi_field_pt_15_max_0_8580000f() {
    // Encoding: 0x8580000F
    // Test LDR_P.BI__ field Pt = 15 (Max)
    // Fields: Pt=15, Rn=0, imm9h=0, imm9l=0
    let encoding: u32 = 0x8580000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm9h=0 (immediate value 0)
#[test]
fn test_ldr_p_bi_combo_0_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ field combination: imm9h=0, imm9l=0, Rn=0, Pt=0
    // Fields: imm9h=0, Pt=0, imm9l=0, Rn=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldr_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_0_858003e0() {
    // Encoding: 0x858003E0
    // Test LDR_P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pt=0, imm9h=0, imm9l=0
    let encoding: u32 = 0x858003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldr_p_bi_invalid_0_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm9h=0, Pt=0, Rn=0, imm9l=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldr_p_bi_invalid_1_0_85800000() {
    // Encoding: 0x85800000
    // Test LDR_P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm9h=0, imm9l=0, Pt=0, Rn=0
    let encoding: u32 = 0x85800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDR_P.BI__
/// ASL: `SimdFromField("Pt") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pt")
#[test]
fn test_ldr_p_bi_reg_write_0_85800000() {
    // Test LDR_P.BI__ register write: SimdFromField("Pt")
    // Encoding: 0x85800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDR_P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldr_p_bi_sp_rn_858003e0() {
    // Test LDR_P.BI__ with Rn = SP (31)
    // Encoding: 0x858003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x858003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rm_0_min_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a421c000() {
    // Encoding: 0xA421C000
    // Test LD2B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Pg=0, Rn=0
    let encoding: u32 = 0xA421C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a43ec000() {
    // Encoding: 0xA43EC000
    // Test LD2B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA43EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rm_31_max_c000_a43fc000() {
    // Encoding: 0xA43FC000
    // Test LD2B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xA43FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_pg_0_min_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a420c400() {
    // Encoding: 0xA420C400
    // Test LD2B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA420C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rn_0_min_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a420c020() {
    // Encoding: 0xA420C020
    // Test LD2B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA420C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a420c3c0() {
    // Encoding: 0xA420C3C0
    // Test LD2B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=0, Rn=30, Pg=0
    let encoding: u32 = 0xA420C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2b_z_p_br_contiguous_field_rn_31_max_c000_a420c3e0() {
    // Encoding: 0xA420C3E0
    // Test LD2B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA420C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2b_z_p_br_contiguous_field_zt_0_min_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2b_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a420c001() {
    // Encoding: 0xA420C001
    // Test LD2B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xA420C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2b_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a420c01e() {
    // Encoding: 0xA420C01E
    // Test LD2B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA420C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2b_z_p_br_contiguous_field_zt_31_max_c000_a420c01f() {
    // Encoding: 0xA420C01F
    // Test LD2B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Rm=0
    let encoding: u32 = 0xA420C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2b_z_p_br_contiguous_combo_0_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a420c3e0()
{
    // Encoding: 0xA420C3E0
    // Test LD2B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA420C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_br_contiguous_invalid_0_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_br_contiguous_invalid_1_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_br_contiguous_invalid_2_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_br_contiguous_invalid_3_c000_a420c000() {
    // Encoding: 0xA420C000
    // Test LD2B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2b_z_p_br_contiguous_sp_rn_a420c3e0() {
    // Test LD2B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA420C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA420C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_0_zero_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a401e000() {
    // Encoding: 0xA401E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA401E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a403e000() {
    // Encoding: 0xA403E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA403E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a404e000() {
    // Encoding: 0xA404E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA404E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a407e000() {
    // Encoding: 0xA407E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xA407E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a408e000() {
    // Encoding: 0xA408E000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA408E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_imm4_15_max_e000_a40fe000() {
    // Encoding: 0xA40FE000
    // Test LDNT1B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Zt=0, Pg=0
    let encoding: u32 = 0xA40FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_pg_0_min_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a400e400() {
    // Encoding: 0xA400E400
    // Test LDNT1B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA400E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_rn_0_min_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a400e020() {
    // Encoding: 0xA400E020
    // Test LDNT1B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA400E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a400e3c0() {
    // Encoding: 0xA400E3C0
    // Test LDNT1B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA400E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_rn_31_max_e000_a400e3e0() {
    // Encoding: 0xA400E3E0
    // Test LDNT1B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=31
    let encoding: u32 = 0xA400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_zt_0_min_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a400e001() {
    // Encoding: 0xA400E001
    // Test LDNT1B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA400E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a400e01e() {
    // Encoding: 0xA400E01E
    // Test LDNT1B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA400E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1b_z_p_bi_contiguous_field_zt_31_max_e000_a400e01f() {
    // Encoding: 0xA400E01F
    // Test LDNT1B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Zt=31, Pg=0
    let encoding: u32 = 0xA400E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_combo_0_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a400e3e0(
) {
    // Encoding: 0xA400E3E0
    // Test LDNT1B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_bi_contiguous_invalid_0_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_bi_contiguous_invalid_1_e000_a400e000() {
    // Encoding: 0xA400E000
    // Test LDNT1B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1b_z_p_bi_contiguous_reg_write_0_a400e000() {
    // Test LDNT1B_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA400E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1b_z_p_bi_contiguous_sp_rn_a400e3e0() {
    // Test LDNT1B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA400E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1H_Z.P.BI_U16 Tests
// ============================================================================

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_0_zero_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 0 (Zero)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_1_poweroftwo_a000_a4b1a000() {
    // Encoding: 0xA4B1A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=1, Pg=0
    let encoding: u32 = 0xA4B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_3_poweroftwominusone_a000_a4b3a000() {
    // Encoding: 0xA4B3A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=3, Pg=0
    let encoding: u32 = 0xA4B3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_4_poweroftwo_a000_a4b4a000() {
    // Encoding: 0xA4B4A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xA4B4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_7_poweroftwominusone_a000_a4b7a000() {
    // Encoding: 0xA4B7A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=7, Rn=0
    let encoding: u32 = 0xA4B7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_8_poweroftwo_a000_a4b8a000() {
    // Encoding: 0xA4B8A000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=8, Rn=0
    let encoding: u32 = 0xA4B8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_imm4_15_max_a000_a4bfa000() {
    // Encoding: 0xA4BFA000
    // Test LDNF1H_Z.P.BI_U16 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xA4BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_pg_0_min_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_pg_1_poweroftwo_a000_a4b0a400() {
    // Encoding: 0xA4B0A400
    // Test LDNF1H_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xA4B0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_rn_0_min_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_rn_1_poweroftwo_a000_a4b0a020() {
    // Encoding: 0xA4B0A020
    // Test LDNF1H_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4B0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_a4b0a3c0() {
    // Encoding: 0xA4B0A3C0
    // Test LDNF1H_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, imm4=0
    let encoding: u32 = 0xA4B0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1h_z_p_bi_u16_field_rn_31_max_a000_a4b0a3e0() {
    // Encoding: 0xA4B0A3E0
    // Test LDNF1H_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xA4B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1h_z_p_bi_u16_field_zt_0_min_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1h_z_p_bi_u16_field_zt_1_poweroftwo_a000_a4b0a001() {
    // Encoding: 0xA4B0A001
    // Test LDNF1H_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xA4B0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1h_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_a4b0a01e() {
    // Encoding: 0xA4B0A01E
    // Test LDNF1H_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4B0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1h_z_p_bi_u16_field_zt_31_max_a000_a4b0a01f() {
    // Encoding: 0xA4B0A01F
    // Test LDNF1H_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: imm4=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xA4B0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1h_z_p_bi_u16_combo_0_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1h_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4b0a3e0() {
    // Encoding: 0xA4B0A3E0
    // Test LDNF1H_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA4B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u16_invalid_0_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u16_invalid_1_a000_a4b0a000() {
    // Encoding: 0xA4B0A000
    // Test LDNF1H_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_0_zero_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a4d1a000() {
    // Encoding: 0xA4D1A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a4d3a000() {
    // Encoding: 0xA4D3A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a4d4a000() {
    // Encoding: 0xA4D4A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=4
    let encoding: u32 = 0xA4D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a4d7a000() {
    // Encoding: 0xA4D7A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=7, Rn=0
    let encoding: u32 = 0xA4D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a4d8a000() {
    // Encoding: 0xA4D8A000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=8, Zt=0
    let encoding: u32 = 0xA4D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_imm4_15_max_a000_a4dfa000() {
    // Encoding: 0xA4DFA000
    // Test LDNF1H_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_pg_0_min_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_pg_1_poweroftwo_a000_a4d0a400() {
    // Encoding: 0xA4D0A400
    // Test LDNF1H_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4D0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_rn_0_min_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_rn_1_poweroftwo_a000_a4d0a020() {
    // Encoding: 0xA4D0A020
    // Test LDNF1H_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4D0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a4d0a3c0() {
    // Encoding: 0xA4D0A3C0
    // Test LDNF1H_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=30
    let encoding: u32 = 0xA4D0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1h_z_p_bi_u32_field_rn_31_max_a000_a4d0a3e0() {
    // Encoding: 0xA4D0A3E0
    // Test LDNF1H_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA4D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1h_z_p_bi_u32_field_zt_0_min_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1h_z_p_bi_u32_field_zt_1_poweroftwo_a000_a4d0a001() {
    // Encoding: 0xA4D0A001
    // Test LDNF1H_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA4D0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1h_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a4d0a01e() {
    // Encoding: 0xA4D0A01E
    // Test LDNF1H_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4D0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1h_z_p_bi_u32_field_zt_31_max_a000_a4d0a01f() {
    // Encoding: 0xA4D0A01F
    // Test LDNF1H_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, imm4=0
    let encoding: u32 = 0xA4D0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1h_z_p_bi_u32_combo_0_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1h_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4d0a3e0() {
    // Encoding: 0xA4D0A3E0
    // Test LDNF1H_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA4D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u32_invalid_0_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u32_invalid_1_a000_a4d0a000() {
    // Encoding: 0xA4D0A000
    // Test LDNF1H_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_0_zero_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a4f1a000() {
    // Encoding: 0xA4F1A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a4f3a000() {
    // Encoding: 0xA4F3A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=3
    let encoding: u32 = 0xA4F3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a4f4a000() {
    // Encoding: 0xA4F4A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xA4F4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a4f7a000() {
    // Encoding: 0xA4F7A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Zt=0, Pg=0
    let encoding: u32 = 0xA4F7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a4f8a000() {
    // Encoding: 0xA4F8A000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=8
    let encoding: u32 = 0xA4F8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_imm4_15_max_a000_a4ffa000() {
    // Encoding: 0xA4FFA000
    // Test LDNF1H_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Pg=0, imm4=15, Rn=0, Zt=0
    let encoding: u32 = 0xA4FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_pg_0_min_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_pg_1_poweroftwo_a000_a4f0a400() {
    // Encoding: 0xA4F0A400
    // Test LDNF1H_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4F0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_rn_0_min_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_rn_1_poweroftwo_a000_a4f0a020() {
    // Encoding: 0xA4F0A020
    // Test LDNF1H_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, imm4=0, Zt=0
    let encoding: u32 = 0xA4F0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a4f0a3c0() {
    // Encoding: 0xA4F0A3C0
    // Test LDNF1H_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, imm4=0, Pg=0
    let encoding: u32 = 0xA4F0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1h_z_p_bi_u64_field_rn_31_max_a000_a4f0a3e0() {
    // Encoding: 0xA4F0A3E0
    // Test LDNF1H_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4F0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1h_z_p_bi_u64_field_zt_0_min_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1h_z_p_bi_u64_field_zt_1_poweroftwo_a000_a4f0a001() {
    // Encoding: 0xA4F0A001
    // Test LDNF1H_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4F0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1h_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a4f0a01e() {
    // Encoding: 0xA4F0A01E
    // Test LDNF1H_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Zt=30, Pg=0
    let encoding: u32 = 0xA4F0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1h_z_p_bi_u64_field_zt_31_max_a000_a4f0a01f() {
    // Encoding: 0xA4F0A01F
    // Test LDNF1H_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=31
    let encoding: u32 = 0xA4F0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1h_z_p_bi_u64_combo_0_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1h_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4f0a3e0() {
    // Encoding: 0xA4F0A3E0
    // Test LDNF1H_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA4F0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u64_invalid_0_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1h_z_p_bi_u64_invalid_1_a000_a4f0a000() {
    // Encoding: 0xA4F0A000
    // Test LDNF1H_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1h_z_p_bi_u16_reg_write_0_a4b0a000() {
    // Test LDNF1H_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0xA4B0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4B0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1H_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1h_z_p_bi_u16_sp_rn_a4b0a3e0() {
    // Test LDNF1H_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0xA4B0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4B0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1h_z_p_bi_u32_reg_write_0_a4d0a000() {
    // Test LDNF1H_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA4D0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4D0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1H_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1h_z_p_bi_u32_sp_rn_a4d0a3e0() {
    // Test LDNF1H_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA4D0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4D0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1h_z_p_bi_u64_reg_write_0_a4f0a000() {
    // Test LDNF1H_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA4F0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1H_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1h_z_p_bi_u64_sp_rn_a4f0a3e0() {
    // Test LDNF1H_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA4F0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4F0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1H_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_0_zero_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_1_poweroftwo_c000_84a1c000() {
    // Encoding: 0x84A1C000
    // Test LD1H_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=1, Pg=0, Zt=0
    let encoding: u32 = 0x84A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_3_poweroftwominusone_c000_84a3c000() {
    // Encoding: 0x84A3C000
    // Test LD1H_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_4_poweroftwo_c000_84a4c000() {
    // Encoding: 0x84A4C000
    // Test LD1H_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm5=4, Pg=0, Zn=0
    let encoding: u32 = 0x84A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_7_poweroftwominusone_c000_84a7c000() {
    // Encoding: 0x84A7C000
    // Test LD1H_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_8_poweroftwo_c000_84a8c000() {
    // Encoding: 0x84A8C000
    // Test LD1H_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x84A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_15_poweroftwominusone_c000_84afc000() {
    // Encoding: 0x84AFC000
    // Test LD1H_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=15, Zn=0, Zt=0
    let encoding: u32 = 0x84AFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_16_poweroftwo_c000_84b0c000() {
    // Encoding: 0x84B0C000
    // Test LD1H_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=16, Pg=0
    let encoding: u32 = 0x84B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1h_z_p_ai_s_field_imm5_31_max_c000_84bfc000() {
    // Encoding: 0x84BFC000
    // Test LD1H_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: imm5=31, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x84BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_ai_s_field_pg_0_min_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_ai_s_field_pg_1_poweroftwo_c000_84a0c400() {
    // Encoding: 0x84A0C400
    // Test LD1H_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zt=0, imm5=0
    let encoding: u32 = 0x84A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_ai_s_field_zn_0_min_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_ai_s_field_zn_1_poweroftwo_c000_84a0c020() {
    // Encoding: 0x84A0C020
    // Test LD1H_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0x84A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_ai_s_field_zn_30_poweroftwominusone_c000_84a0c3c0() {
    // Encoding: 0x84A0C3C0
    // Test LD1H_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=30, imm5=0, Pg=0
    let encoding: u32 = 0x84A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_ai_s_field_zn_31_max_c000_84a0c3e0() {
    // Encoding: 0x84A0C3E0
    // Test LD1H_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=31
    let encoding: u32 = 0x84A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_ai_s_field_zt_0_min_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S field Zt = 0 (Min)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_ai_s_field_zt_1_poweroftwo_c000_84a0c001() {
    // Encoding: 0x84A0C001
    // Test LD1H_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=1, Zn=0
    let encoding: u32 = 0x84A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_ai_s_field_zt_30_poweroftwominusone_c000_84a0c01e() {
    // Encoding: 0x84A0C01E
    // Test LD1H_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Zn=0, imm5=0
    let encoding: u32 = 0x84A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_ai_s_field_zt_31_max_c000_84a0c01f() {
    // Encoding: 0x84A0C01F
    // Test LD1H_Z.P.AI_S field Zt = 31 (Max)
    // Fields: imm5=0, Zn=0, Zt=31, Pg=0
    let encoding: u32 = 0x84A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1h_z_p_ai_s_combo_0_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_ai_s_invalid_0_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_ai_s_invalid_1_c000_84a0c000() {
    // Encoding: 0x84A0C000
    // Test LD1H_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_0_zero_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_1_poweroftwo_c000_c4a1c000() {
    // Encoding: 0xC4A1C000
    // Test LD1H_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_3_poweroftwominusone_c000_c4a3c000() {
    // Encoding: 0xC4A3C000
    // Test LD1H_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=3
    let encoding: u32 = 0xC4A3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_4_poweroftwo_c000_c4a4c000() {
    // Encoding: 0xC4A4C000
    // Test LD1H_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=4, Zn=0
    let encoding: u32 = 0xC4A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_7_poweroftwominusone_c000_c4a7c000() {
    // Encoding: 0xC4A7C000
    // Test LD1H_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=7
    let encoding: u32 = 0xC4A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_8_poweroftwo_c000_c4a8c000() {
    // Encoding: 0xC4A8C000
    // Test LD1H_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=8
    let encoding: u32 = 0xC4A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_15_poweroftwominusone_c000_c4afc000() {
    // Encoding: 0xC4AFC000
    // Test LD1H_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC4AFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_16_poweroftwo_c000_c4b0c000() {
    // Encoding: 0xC4B0C000
    // Test LD1H_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=16
    let encoding: u32 = 0xC4B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1h_z_p_ai_d_field_imm5_31_max_c000_c4bfc000() {
    // Encoding: 0xC4BFC000
    // Test LD1H_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC4BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_ai_d_field_pg_0_min_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D field Pg = 0 (Min)
    // Fields: imm5=0, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_ai_d_field_pg_1_poweroftwo_c000_c4a0c400() {
    // Encoding: 0xC4A0C400
    // Test LD1H_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Pg=1, Zt=0
    let encoding: u32 = 0xC4A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_ai_d_field_zn_0_min_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_ai_d_field_zn_1_poweroftwo_c000_c4a0c020() {
    // Encoding: 0xC4A0C020
    // Test LD1H_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC4A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_ai_d_field_zn_30_poweroftwominusone_c000_c4a0c3c0() {
    // Encoding: 0xC4A0C3C0
    // Test LD1H_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=0, Zn=30, Pg=0
    let encoding: u32 = 0xC4A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_ai_d_field_zn_31_max_c000_c4a0c3e0() {
    // Encoding: 0xC4A0C3E0
    // Test LD1H_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_ai_d_field_zt_0_min_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_ai_d_field_zt_1_poweroftwo_c000_c4a0c001() {
    // Encoding: 0xC4A0C001
    // Test LD1H_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Zt=1, Pg=0, Zn=0
    let encoding: u32 = 0xC4A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_ai_d_field_zt_30_poweroftwominusone_c000_c4a0c01e() {
    // Encoding: 0xC4A0C01E
    // Test LD1H_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=30, Pg=0, Zn=0
    let encoding: u32 = 0xC4A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_ai_d_field_zt_31_max_c000_c4a0c01f() {
    // Encoding: 0xC4A0C01F
    // Test LD1H_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC4A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1h_z_p_ai_d_combo_0_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_ai_d_invalid_0_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_ai_d_invalid_1_c000_c4a0c000() {
    // Encoding: 0xC4A0C000
    // Test LD1H_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_ai_s_reg_write_0_84a0c000() {
    // Test LD1H_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x84A0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_ai_d_reg_write_0_c4a0c000() {
    // Test LD1H_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC4A0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1H_Z.P.BR_U16 Tests
// ============================================================================

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u16_field_rm_0_min_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u16_field_rm_1_poweroftwo_4000_a4a14000() {
    // Encoding: 0xA4A14000
    // Test LD1H_Z.P.BR_U16 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Rm=1, Zt=0
    let encoding: u32 = 0xA4A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u16_field_rm_30_poweroftwominusone_4000_a4be4000() {
    // Encoding: 0xA4BE4000
    // Test LD1H_Z.P.BR_U16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xA4BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1h_z_p_br_u16_field_rm_31_max_4000_a4bf4000() {
    // Encoding: 0xA4BF4000
    // Test LD1H_Z.P.BR_U16 field Rm = 31 (Max)
    // Fields: Rm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u16_field_pg_0_min_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u16_field_pg_1_poweroftwo_4000_a4a04400() {
    // Encoding: 0xA4A04400
    // Test LD1H_Z.P.BR_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA4A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u16_field_rn_0_min_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u16_field_rn_1_poweroftwo_4000_a4a04020() {
    // Encoding: 0xA4A04020
    // Test LD1H_Z.P.BR_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u16_field_rn_30_poweroftwominusone_4000_a4a043c0() {
    // Encoding: 0xA4A043C0
    // Test LD1H_Z.P.BR_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Rm=0, Pg=0
    let encoding: u32 = 0xA4A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_br_u16_field_rn_31_max_4000_a4a043e0() {
    // Encoding: 0xA4A043E0
    // Test LD1H_Z.P.BR_U16 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xA4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_br_u16_field_zt_0_min_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_br_u16_field_zt_1_poweroftwo_4000_a4a04001() {
    // Encoding: 0xA4A04001
    // Test LD1H_Z.P.BR_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_br_u16_field_zt_30_poweroftwominusone_4000_a4a0401e() {
    // Encoding: 0xA4A0401E
    // Test LD1H_Z.P.BR_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, Rm=0
    let encoding: u32 = 0xA4A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_br_u16_field_zt_31_max_4000_a4a0401f() {
    // Encoding: 0xA4A0401F
    // Test LD1H_Z.P.BR_U16 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, Rm=0
    let encoding: u32 = 0xA4A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_br_u16_combo_0_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_br_u16_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a4a043e0() {
    // Encoding: 0xA4A043E0
    // Test LD1H_Z.P.BR_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u16_invalid_0_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u16_invalid_1_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u16_invalid_2_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u16_invalid_3_4000_a4a04000() {
    // Encoding: 0xA4A04000
    // Test LD1H_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u32_field_rm_0_min_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u32_field_rm_1_poweroftwo_4000_a4c14000() {
    // Encoding: 0xA4C14000
    // Test LD1H_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=1
    let encoding: u32 = 0xA4C14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u32_field_rm_30_poweroftwominusone_4000_a4de4000() {
    // Encoding: 0xA4DE4000
    // Test LD1H_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xA4DE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1h_z_p_br_u32_field_rm_31_max_4000_a4df4000() {
    // Encoding: 0xA4DF4000
    // Test LD1H_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4DF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u32_field_pg_0_min_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u32_field_pg_1_poweroftwo_4000_a4c04400() {
    // Encoding: 0xA4C04400
    // Test LD1H_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u32_field_rn_0_min_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u32_field_rn_1_poweroftwo_4000_a4c04020() {
    // Encoding: 0xA4C04020
    // Test LD1H_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA4C04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u32_field_rn_30_poweroftwominusone_4000_a4c043c0() {
    // Encoding: 0xA4C043C0
    // Test LD1H_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4C043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_br_u32_field_rn_31_max_4000_a4c043e0() {
    // Encoding: 0xA4C043E0
    // Test LD1H_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA4C043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_br_u32_field_zt_0_min_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_br_u32_field_zt_1_poweroftwo_4000_a4c04001() {
    // Encoding: 0xA4C04001
    // Test LD1H_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_br_u32_field_zt_30_poweroftwominusone_4000_a4c0401e() {
    // Encoding: 0xA4C0401E
    // Test LD1H_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=30
    let encoding: u32 = 0xA4C0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_br_u32_field_zt_31_max_4000_a4c0401f() {
    // Encoding: 0xA4C0401F
    // Test LD1H_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xA4C0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_br_u32_combo_0_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a4c043e0() {
    // Encoding: 0xA4C043E0
    // Test LD1H_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA4C043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u32_invalid_0_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u32_invalid_1_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u32_invalid_2_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u32_invalid_3_4000_a4c04000() {
    // Encoding: 0xA4C04000
    // Test LD1H_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u64_field_rm_0_min_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u64_field_rm_1_poweroftwo_4000_a4e14000() {
    // Encoding: 0xA4E14000
    // Test LD1H_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA4E14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u64_field_rm_30_poweroftwominusone_4000_a4fe4000() {
    // Encoding: 0xA4FE4000
    // Test LD1H_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=30
    let encoding: u32 = 0xA4FE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1h_z_p_br_u64_field_rm_31_max_4000_a4ff4000() {
    // Encoding: 0xA4FF4000
    // Test LD1H_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xA4FF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u64_field_pg_0_min_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u64_field_pg_1_poweroftwo_4000_a4e04400() {
    // Encoding: 0xA4E04400
    // Test LD1H_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0xA4E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_br_u64_field_rn_0_min_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_br_u64_field_rn_1_poweroftwo_4000_a4e04020() {
    // Encoding: 0xA4E04020
    // Test LD1H_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA4E04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_br_u64_field_rn_30_poweroftwominusone_4000_a4e043c0() {
    // Encoding: 0xA4E043C0
    // Test LD1H_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, Rm=0
    let encoding: u32 = 0xA4E043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_br_u64_field_rn_31_max_4000_a4e043e0() {
    // Encoding: 0xA4E043E0
    // Test LD1H_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA4E043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_br_u64_field_zt_0_min_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_br_u64_field_zt_1_poweroftwo_4000_a4e04001() {
    // Encoding: 0xA4E04001
    // Test LD1H_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4E04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_br_u64_field_zt_30_poweroftwominusone_4000_a4e0401e() {
    // Encoding: 0xA4E0401E
    // Test LD1H_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA4E0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_br_u64_field_zt_31_max_4000_a4e0401f() {
    // Encoding: 0xA4E0401F
    // Test LD1H_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=31
    let encoding: u32 = 0xA4E0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_br_u64_combo_0_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a4e043e0() {
    // Encoding: 0xA4E043E0
    // Test LD1H_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xA4E043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u64_invalid_0_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u64_invalid_1_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u64_invalid_2_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_br_u64_invalid_3_4000_a4e04000() {
    // Encoding: 0xA4E04000
    // Test LD1H_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_br_u16_reg_write_0_a4a04000() {
    // Test LD1H_Z.P.BR_U16 register write: SimdFromField("t")
    // Encoding: 0xA4A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BR_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_br_u16_sp_rn_a4a043e0() {
    // Test LD1H_Z.P.BR_U16 with Rn = SP (31)
    // Encoding: 0xA4A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_br_u32_reg_write_0_a4c04000() {
    // Test LD1H_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA4C04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_br_u32_sp_rn_a4c043e0() {
    // Test LD1H_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA4C043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_br_u64_reg_write_0_a4e04000() {
    // Test LD1H_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA4E04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_br_u64_sp_rn_a4e043e0() {
    // Test LD1H_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA4E043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SH_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_0_zero_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_1_poweroftwo_8000_84a18000() {
    // Encoding: 0x84A18000
    // Test LD1SH_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=1
    let encoding: u32 = 0x84A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_3_poweroftwominusone_8000_84a38000() {
    // Encoding: 0x84A38000
    // Test LD1SH_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=3
    let encoding: u32 = 0x84A38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_4_poweroftwo_8000_84a48000() {
    // Encoding: 0x84A48000
    // Test LD1SH_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0x84A48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_7_poweroftwominusone_8000_84a78000() {
    // Encoding: 0x84A78000
    // Test LD1SH_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_8_poweroftwo_8000_84a88000() {
    // Encoding: 0x84A88000
    // Test LD1SH_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=8
    let encoding: u32 = 0x84A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_15_poweroftwominusone_8000_84af8000() {
    // Encoding: 0x84AF8000
    // Test LD1SH_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=15
    let encoding: u32 = 0x84AF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_16_poweroftwo_8000_84b08000() {
    // Encoding: 0x84B08000
    // Test LD1SH_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=16, Zn=0
    let encoding: u32 = 0x84B08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1sh_z_p_ai_s_field_imm5_31_max_8000_84bf8000() {
    // Encoding: 0x84BF8000
    // Test LD1SH_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: imm5=31, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x84BF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_ai_s_field_pg_0_min_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_ai_s_field_pg_1_poweroftwo_8000_84a08400() {
    // Encoding: 0x84A08400
    // Test LD1SH_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Pg=1, Zt=0
    let encoding: u32 = 0x84A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_ai_s_field_zn_0_min_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_ai_s_field_zn_1_poweroftwo_8000_84a08020() {
    // Encoding: 0x84A08020
    // Test LD1SH_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=1
    let encoding: u32 = 0x84A08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_ai_s_field_zn_30_poweroftwominusone_8000_84a083c0() {
    // Encoding: 0x84A083C0
    // Test LD1SH_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zt=0, imm5=0
    let encoding: u32 = 0x84A083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_ai_s_field_zn_31_max_8000_84a083e0() {
    // Encoding: 0x84A083E0
    // Test LD1SH_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zn=31, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x84A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_ai_s_field_zt_0_min_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_ai_s_field_zt_1_poweroftwo_8000_84a08001() {
    // Encoding: 0x84A08001
    // Test LD1SH_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=1, imm5=0
    let encoding: u32 = 0x84A08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_ai_s_field_zt_30_poweroftwominusone_8000_84a0801e() {
    // Encoding: 0x84A0801E
    // Test LD1SH_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=30
    let encoding: u32 = 0x84A0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_ai_s_field_zt_31_max_8000_84a0801f() {
    // Encoding: 0x84A0801F
    // Test LD1SH_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zt=31, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1sh_z_p_ai_s_combo_0_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_ai_s_invalid_0_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_ai_s_invalid_1_8000_84a08000() {
    // Encoding: 0x84A08000
    // Test LD1SH_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0x84A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_0_zero_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_1_poweroftwo_8000_c4a18000() {
    // Encoding: 0xC4A18000
    // Test LD1SH_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_3_poweroftwominusone_8000_c4a38000() {
    // Encoding: 0xC4A38000
    // Test LD1SH_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=3, Zt=0, Pg=0
    let encoding: u32 = 0xC4A38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_4_poweroftwo_8000_c4a48000() {
    // Encoding: 0xC4A48000
    // Test LD1SH_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm5=4, Pg=0, Zn=0
    let encoding: u32 = 0xC4A48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_7_poweroftwominusone_8000_c4a78000() {
    // Encoding: 0xC4A78000
    // Test LD1SH_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC4A78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_8_poweroftwo_8000_c4a88000() {
    // Encoding: 0xC4A88000
    // Test LD1SH_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_15_poweroftwominusone_8000_c4af8000() {
    // Encoding: 0xC4AF8000
    // Test LD1SH_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=15, Zt=0, Pg=0
    let encoding: u32 = 0xC4AF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_16_poweroftwo_8000_c4b08000() {
    // Encoding: 0xC4B08000
    // Test LD1SH_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=16
    let encoding: u32 = 0xC4B08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1sh_z_p_ai_d_field_imm5_31_max_8000_c4bf8000() {
    // Encoding: 0xC4BF8000
    // Test LD1SH_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=31
    let encoding: u32 = 0xC4BF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_ai_d_field_pg_0_min_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_ai_d_field_pg_1_poweroftwo_8000_c4a08400() {
    // Encoding: 0xC4A08400
    // Test LD1SH_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=1, Zn=0
    let encoding: u32 = 0xC4A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_ai_d_field_zn_0_min_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_ai_d_field_zn_1_poweroftwo_8000_c4a08020() {
    // Encoding: 0xC4A08020
    // Test LD1SH_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0xC4A08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_ai_d_field_zn_30_poweroftwominusone_8000_c4a083c0() {
    // Encoding: 0xC4A083C0
    // Test LD1SH_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=30, Zt=0
    let encoding: u32 = 0xC4A083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_ai_d_field_zn_31_max_8000_c4a083e0() {
    // Encoding: 0xC4A083E0
    // Test LD1SH_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zt=0, imm5=0, Zn=31, Pg=0
    let encoding: u32 = 0xC4A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_ai_d_field_zt_0_min_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_ai_d_field_zt_1_poweroftwo_8000_c4a08001() {
    // Encoding: 0xC4A08001
    // Test LD1SH_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=1, Zn=0
    let encoding: u32 = 0xC4A08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_ai_d_field_zt_30_poweroftwominusone_8000_c4a0801e() {
    // Encoding: 0xC4A0801E
    // Test LD1SH_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=30, Pg=0, Zn=0
    let encoding: u32 = 0xC4A0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_ai_d_field_zt_31_max_8000_c4a0801f() {
    // Encoding: 0xC4A0801F
    // Test LD1SH_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zt=31, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4A0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1sh_z_p_ai_d_combo_0_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_ai_d_invalid_0_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_ai_d_invalid_1_8000_c4a08000() {
    // Encoding: 0xC4A08000
    // Test LD1SH_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_ai_s_reg_write_0_84a08000() {
    // Test LD1SH_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x84A08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_ai_d_reg_write_0_c4a08000() {
    // Test LD1SH_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC4A08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SH_Z.P.BR_S32 Tests
// ============================================================================

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s32_field_rm_0_min_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s32_field_rm_1_poweroftwo_4000_a5214000() {
    // Encoding: 0xA5214000
    // Test LD1SH_Z.P.BR_S32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA5214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_br_s32_field_rm_30_poweroftwominusone_4000_a53e4000() {
    // Encoding: 0xA53E4000
    // Test LD1SH_Z.P.BR_S32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=30
    let encoding: u32 = 0xA53E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sh_z_p_br_s32_field_rm_31_max_4000_a53f4000() {
    // Encoding: 0xA53F4000
    // Test LD1SH_Z.P.BR_S32 field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Rn=0, Pg=0
    let encoding: u32 = 0xA53F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s32_field_pg_0_min_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s32_field_pg_1_poweroftwo_4000_a5204400() {
    // Encoding: 0xA5204400
    // Test LD1SH_Z.P.BR_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA5204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s32_field_rn_0_min_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s32_field_rn_1_poweroftwo_4000_a5204020() {
    // Encoding: 0xA5204020
    // Test LD1SH_Z.P.BR_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, Rm=0
    let encoding: u32 = 0xA5204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_br_s32_field_rn_30_poweroftwominusone_4000_a52043c0() {
    // Encoding: 0xA52043C0
    // Test LD1SH_Z.P.BR_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA52043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_br_s32_field_rn_31_max_4000_a52043e0() {
    // Encoding: 0xA52043E0
    // Test LD1SH_Z.P.BR_S32 field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA52043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_br_s32_field_zt_0_min_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_br_s32_field_zt_1_poweroftwo_4000_a5204001() {
    // Encoding: 0xA5204001
    // Test LD1SH_Z.P.BR_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, Rm=0
    let encoding: u32 = 0xA5204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_br_s32_field_zt_30_poweroftwominusone_4000_a520401e() {
    // Encoding: 0xA520401E
    // Test LD1SH_Z.P.BR_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA520401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_br_s32_field_zt_31_max_4000_a520401f() {
    // Encoding: 0xA520401F
    // Test LD1SH_Z.P.BR_S32 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_br_s32_combo_0_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_br_s32_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a52043e0() {
    // Encoding: 0xA52043E0
    // Test LD1SH_Z.P.BR_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA52043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s32_invalid_0_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s32_invalid_1_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s32_invalid_2_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s32_invalid_3_4000_a5204000() {
    // Encoding: 0xA5204000
    // Test LD1SH_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s64_field_rm_0_min_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s64_field_rm_1_poweroftwo_4000_a5014000() {
    // Encoding: 0xA5014000
    // Test LD1SH_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=1
    let encoding: u32 = 0xA5014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_br_s64_field_rm_30_poweroftwominusone_4000_a51e4000() {
    // Encoding: 0xA51E4000
    // Test LD1SH_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=30
    let encoding: u32 = 0xA51E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sh_z_p_br_s64_field_rm_31_max_4000_a51f4000() {
    // Encoding: 0xA51F4000
    // Test LD1SH_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=31
    let encoding: u32 = 0xA51F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s64_field_pg_0_min_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s64_field_pg_1_poweroftwo_4000_a5004400() {
    // Encoding: 0xA5004400
    // Test LD1SH_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xA5004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_br_s64_field_rn_0_min_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_br_s64_field_rn_1_poweroftwo_4000_a5004020() {
    // Encoding: 0xA5004020
    // Test LD1SH_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_br_s64_field_rn_30_poweroftwominusone_4000_a50043c0() {
    // Encoding: 0xA50043C0
    // Test LD1SH_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA50043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_br_s64_field_rn_31_max_4000_a50043e0() {
    // Encoding: 0xA50043E0
    // Test LD1SH_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_br_s64_field_zt_0_min_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_br_s64_field_zt_1_poweroftwo_4000_a5004001() {
    // Encoding: 0xA5004001
    // Test LD1SH_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_br_s64_field_zt_30_poweroftwominusone_4000_a500401e() {
    // Encoding: 0xA500401E
    // Test LD1SH_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA500401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_br_s64_field_zt_31_max_4000_a500401f() {
    // Encoding: 0xA500401F
    // Test LD1SH_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xA500401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_br_s64_combo_0_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a50043e0() {
    // Encoding: 0xA50043E0
    // Test LD1SH_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s64_invalid_0_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s64_invalid_1_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s64_invalid_2_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_br_s64_invalid_3_4000_a5004000() {
    // Encoding: 0xA5004000
    // Test LD1SH_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_br_s32_reg_write_0_a5204000() {
    // Test LD1SH_Z.P.BR_S32 register write: SimdFromField("t")
    // Encoding: 0xA5204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BR_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_br_s32_sp_rn_a52043e0() {
    // Test LD1SH_Z.P.BR_S32 with Rn = SP (31)
    // Encoding: 0xA52043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA52043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_br_s64_reg_write_0_a5004000() {
    // Test LD1SH_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA5004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_br_s64_sp_rn_a50043e0() {
    // Test LD1SH_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA50043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA50043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_0_zero_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a481e000() {
    // Encoding: 0xA481E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xA481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a483e000() {
    // Encoding: 0xA483E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=3
    let encoding: u32 = 0xA483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a484e000() {
    // Encoding: 0xA484E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a487e000() {
    // Encoding: 0xA487E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Pg=0, Zt=0
    let encoding: u32 = 0xA487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a488e000() {
    // Encoding: 0xA488E000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=8, Zt=0
    let encoding: u32 = 0xA488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_imm4_15_max_e000_a48fe000() {
    // Encoding: 0xA48FE000
    // Test LDNT1H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Pg=0, Zt=0
    let encoding: u32 = 0xA48FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_pg_0_min_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a480e400() {
    // Encoding: 0xA480E400
    // Test LDNT1H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_rn_0_min_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a480e020() {
    // Encoding: 0xA480E020
    // Test LDNT1H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a480e3c0() {
    // Encoding: 0xA480E3C0
    // Test LDNT1H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_rn_31_max_e000_a480e3e0() {
    // Encoding: 0xA480E3E0
    // Test LDNT1H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_zt_0_min_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a480e001() {
    // Encoding: 0xA480E001
    // Test LDNT1H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xA480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a480e01e() {
    // Encoding: 0xA480E01E
    // Test LDNT1H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xA480E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1h_z_p_bi_contiguous_field_zt_31_max_e000_a480e01f() {
    // Encoding: 0xA480E01F
    // Test LDNT1H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA480E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_combo_0_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a480e3e0(
) {
    // Encoding: 0xA480E3E0
    // Test LDNT1H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_bi_contiguous_invalid_0_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_bi_contiguous_invalid_1_e000_a480e000() {
    // Encoding: 0xA480E000
    // Test LDNT1H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1h_z_p_bi_contiguous_reg_write_0_a480e000() {
    // Test LDNT1H_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA480E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1h_z_p_bi_contiguous_sp_rn_a480e3e0() {
    // Test LDNT1H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA480E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_0_zero_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a5e1e000() {
    // Encoding: 0xA5E1E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a5e3e000() {
    // Encoding: 0xA5E3E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=3, Rn=0
    let encoding: u32 = 0xA5E3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a5e4e000() {
    // Encoding: 0xA5E4E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xA5E4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a5e7e000() {
    // Encoding: 0xA5E7E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=7, Zt=0
    let encoding: u32 = 0xA5E7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a5e8e000() {
    // Encoding: 0xA5E8E000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=8
    let encoding: u32 = 0xA5E8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_imm4_15_max_e000_a5efe000() {
    // Encoding: 0xA5EFE000
    // Test LD4D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=15
    let encoding: u32 = 0xA5EFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_pg_0_min_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a5e0e400() {
    // Encoding: 0xA5E0E400
    // Test LD4D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_rn_0_min_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a5e0e020() {
    // Encoding: 0xA5E0E020
    // Test LD4D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA5E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a5e0e3c0() {
    // Encoding: 0xA5E0E3C0
    // Test LD4D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4d_z_p_bi_contiguous_field_rn_31_max_e000_a5e0e3e0() {
    // Encoding: 0xA5E0E3E0
    // Test LD4D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4d_z_p_bi_contiguous_field_zt_0_min_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a5e0e001() {
    // Encoding: 0xA5E0E001
    // Test LD4D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a5e0e01e() {
    // Encoding: 0xA5E0E01E
    // Test LD4D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4d_z_p_bi_contiguous_field_zt_31_max_e000_a5e0e01f() {
    // Encoding: 0xA5E0E01F
    // Test LD4D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, imm4=0
    let encoding: u32 = 0xA5E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld4d_z_p_bi_contiguous_combo_0_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a5e0e3e0()
{
    // Encoding: 0xA5E0E3E0
    // Test LD4D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, imm4=0
    let encoding: u32 = 0xA5E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_bi_contiguous_invalid_0_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_bi_contiguous_invalid_1_e000_a5e0e000() {
    // Encoding: 0xA5E0E000
    // Test LD4D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4d_z_p_bi_contiguous_sp_rn_a5e0e3e0() {
    // Test LD4D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA5E0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rm_0_min_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a5c1c000() {
    // Encoding: 0xA5C1C000
    // Test LD3D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=1, Zt=0, Rn=0
    let encoding: u32 = 0xA5C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a5dec000() {
    // Encoding: 0xA5DEC000
    // Test LD3D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=30, Rn=0, Zt=0
    let encoding: u32 = 0xA5DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rm_31_max_c000_a5dfc000() {
    // Encoding: 0xA5DFC000
    // Test LD3D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_pg_0_min_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a5c0c400() {
    // Encoding: 0xA5C0C400
    // Test LD3D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rn_0_min_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a5c0c020() {
    // Encoding: 0xA5C0C020
    // Test LD3D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Rn=1, Pg=0
    let encoding: u32 = 0xA5C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a5c0c3c0() {
    // Encoding: 0xA5C0C3C0
    // Test LD3D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=30
    let encoding: u32 = 0xA5C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3d_z_p_br_contiguous_field_rn_31_max_c000_a5c0c3e0() {
    // Encoding: 0xA5C0C3E0
    // Test LD3D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, Rm=0
    let encoding: u32 = 0xA5C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3d_z_p_br_contiguous_field_zt_0_min_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3d_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a5c0c001() {
    // Encoding: 0xA5C0C001
    // Test LD3D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xA5C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3d_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a5c0c01e() {
    // Encoding: 0xA5C0C01E
    // Test LD3D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA5C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3d_z_p_br_contiguous_field_zt_31_max_c000_a5c0c01f() {
    // Encoding: 0xA5C0C01F
    // Test LD3D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld3d_z_p_br_contiguous_combo_0_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a5c0c3e0()
{
    // Encoding: 0xA5C0C3E0
    // Test LD3D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_br_contiguous_invalid_0_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_br_contiguous_invalid_1_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_br_contiguous_invalid_2_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_br_contiguous_invalid_3_c000_a5c0c000() {
    // Encoding: 0xA5C0C000
    // Test LD3D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3d_z_p_br_contiguous_sp_rn_a5c0c3e0() {
    // Test LD3D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA5C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1B_Z.P.BI_U8 Tests
// ============================================================================

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_0_zero_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 0 (Zero)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_1_poweroftwo_a000_a411a000() {
    // Encoding: 0xA411A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=1, Rn=0, Zt=0
    let encoding: u32 = 0xA411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_3_poweroftwominusone_a000_a413a000() {
    // Encoding: 0xA413A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_4_poweroftwo_a000_a414a000() {
    // Encoding: 0xA414A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_7_poweroftwominusone_a000_a417a000() {
    // Encoding: 0xA417A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Rn=0, Pg=0
    let encoding: u32 = 0xA417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_8_poweroftwo_a000_a418a000() {
    // Encoding: 0xA418A000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=8, Pg=0
    let encoding: u32 = 0xA418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_imm4_15_max_a000_a41fa000() {
    // Encoding: 0xA41FA000
    // Test LDNF1B_Z.P.BI_U8 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA41FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_pg_0_min_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_pg_1_poweroftwo_a000_a410a400() {
    // Encoding: 0xA410A400
    // Test LDNF1B_Z.P.BI_U8 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA410A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_rn_0_min_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_rn_1_poweroftwo_a000_a410a020() {
    // Encoding: 0xA410A020
    // Test LDNF1B_Z.P.BI_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, imm4=0
    let encoding: u32 = 0xA410A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_rn_30_poweroftwominusone_a000_a410a3c0() {
    // Encoding: 0xA410A3C0
    // Test LDNF1B_Z.P.BI_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=30
    let encoding: u32 = 0xA410A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1b_z_p_bi_u8_field_rn_31_max_a000_a410a3e0() {
    // Encoding: 0xA410A3E0
    // Test LDNF1B_Z.P.BI_U8 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, imm4=0
    let encoding: u32 = 0xA410A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1b_z_p_bi_u8_field_zt_0_min_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1b_z_p_bi_u8_field_zt_1_poweroftwo_a000_a410a001() {
    // Encoding: 0xA410A001
    // Test LDNF1B_Z.P.BI_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Zt=1, Rn=0
    let encoding: u32 = 0xA410A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1b_z_p_bi_u8_field_zt_30_poweroftwominusone_a000_a410a01e() {
    // Encoding: 0xA410A01E
    // Test LDNF1B_Z.P.BI_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA410A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1b_z_p_bi_u8_field_zt_31_max_a000_a410a01f() {
    // Encoding: 0xA410A01F
    // Test LDNF1B_Z.P.BI_U8 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA410A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1b_z_p_bi_u8_combo_0_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1b_z_p_bi_u8_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a410a3e0() {
    // Encoding: 0xA410A3E0
    // Test LDNF1B_Z.P.BI_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA410A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u8_invalid_0_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u8_invalid_1_a000_a410a000() {
    // Encoding: 0xA410A000
    // Test LDNF1B_Z.P.BI_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_0_zero_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_1_poweroftwo_a000_a431a000() {
    // Encoding: 0xA431A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=1
    let encoding: u32 = 0xA431A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_3_poweroftwominusone_a000_a433a000() {
    // Encoding: 0xA433A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=3, Rn=0
    let encoding: u32 = 0xA433A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_4_poweroftwo_a000_a434a000() {
    // Encoding: 0xA434A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA434A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_7_poweroftwominusone_a000_a437a000() {
    // Encoding: 0xA437A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA437A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_8_poweroftwo_a000_a438a000() {
    // Encoding: 0xA438A000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=8
    let encoding: u32 = 0xA438A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_imm4_15_max_a000_a43fa000() {
    // Encoding: 0xA43FA000
    // Test LDNF1B_Z.P.BI_U16 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA43FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_pg_0_min_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_pg_1_poweroftwo_a000_a430a400() {
    // Encoding: 0xA430A400
    // Test LDNF1B_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA430A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_rn_0_min_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_rn_1_poweroftwo_a000_a430a020() {
    // Encoding: 0xA430A020
    // Test LDNF1B_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xA430A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_a430a3c0() {
    // Encoding: 0xA430A3C0
    // Test LDNF1B_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=30
    let encoding: u32 = 0xA430A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1b_z_p_bi_u16_field_rn_31_max_a000_a430a3e0() {
    // Encoding: 0xA430A3E0
    // Test LDNF1B_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA430A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1b_z_p_bi_u16_field_zt_0_min_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1b_z_p_bi_u16_field_zt_1_poweroftwo_a000_a430a001() {
    // Encoding: 0xA430A001
    // Test LDNF1B_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, imm4=0, Pg=0
    let encoding: u32 = 0xA430A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1b_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_a430a01e() {
    // Encoding: 0xA430A01E
    // Test LDNF1B_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=30
    let encoding: u32 = 0xA430A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1b_z_p_bi_u16_field_zt_31_max_a000_a430a01f() {
    // Encoding: 0xA430A01F
    // Test LDNF1B_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA430A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1b_z_p_bi_u16_combo_0_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1b_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a430a3e0() {
    // Encoding: 0xA430A3E0
    // Test LDNF1B_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA430A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u16_invalid_0_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u16_invalid_1_a000_a430a000() {
    // Encoding: 0xA430A000
    // Test LDNF1B_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA430A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_0_zero_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a451a000() {
    // Encoding: 0xA451A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=1, Pg=0
    let encoding: u32 = 0xA451A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a453a000() {
    // Encoding: 0xA453A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA453A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a454a000() {
    // Encoding: 0xA454A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=4, Rn=0
    let encoding: u32 = 0xA454A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a457a000() {
    // Encoding: 0xA457A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Pg=0, Zt=0
    let encoding: u32 = 0xA457A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a458a000() {
    // Encoding: 0xA458A000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA458A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_imm4_15_max_a000_a45fa000() {
    // Encoding: 0xA45FA000
    // Test LDNF1B_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA45FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_pg_0_min_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_pg_1_poweroftwo_a000_a450a400() {
    // Encoding: 0xA450A400
    // Test LDNF1B_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA450A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_rn_0_min_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_rn_1_poweroftwo_a000_a450a020() {
    // Encoding: 0xA450A020
    // Test LDNF1B_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xA450A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a450a3c0() {
    // Encoding: 0xA450A3C0
    // Test LDNF1B_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, imm4=0, Pg=0
    let encoding: u32 = 0xA450A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1b_z_p_bi_u32_field_rn_31_max_a000_a450a3e0() {
    // Encoding: 0xA450A3E0
    // Test LDNF1B_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA450A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1b_z_p_bi_u32_field_zt_0_min_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1b_z_p_bi_u32_field_zt_1_poweroftwo_a000_a450a001() {
    // Encoding: 0xA450A001
    // Test LDNF1B_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA450A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1b_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a450a01e() {
    // Encoding: 0xA450A01E
    // Test LDNF1B_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA450A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1b_z_p_bi_u32_field_zt_31_max_a000_a450a01f() {
    // Encoding: 0xA450A01F
    // Test LDNF1B_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, imm4=0
    let encoding: u32 = 0xA450A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1b_z_p_bi_u32_combo_0_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1b_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a450a3e0() {
    // Encoding: 0xA450A3E0
    // Test LDNF1B_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, imm4=0
    let encoding: u32 = 0xA450A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u32_invalid_0_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u32_invalid_1_a000_a450a000() {
    // Encoding: 0xA450A000
    // Test LDNF1B_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_0_zero_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a471a000() {
    // Encoding: 0xA471A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA471A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a473a000() {
    // Encoding: 0xA473A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Rn=0, Zt=0
    let encoding: u32 = 0xA473A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a474a000() {
    // Encoding: 0xA474A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA474A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a477a000() {
    // Encoding: 0xA477A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=7
    let encoding: u32 = 0xA477A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a478a000() {
    // Encoding: 0xA478A000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA478A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_imm4_15_max_a000_a47fa000() {
    // Encoding: 0xA47FA000
    // Test LDNF1B_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Zt=0, Pg=0
    let encoding: u32 = 0xA47FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_pg_0_min_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_pg_1_poweroftwo_a000_a470a400() {
    // Encoding: 0xA470A400
    // Test LDNF1B_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA470A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_rn_0_min_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_rn_1_poweroftwo_a000_a470a020() {
    // Encoding: 0xA470A020
    // Test LDNF1B_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA470A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a470a3c0() {
    // Encoding: 0xA470A3C0
    // Test LDNF1B_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, imm4=0
    let encoding: u32 = 0xA470A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1b_z_p_bi_u64_field_rn_31_max_a000_a470a3e0() {
    // Encoding: 0xA470A3E0
    // Test LDNF1B_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xA470A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1b_z_p_bi_u64_field_zt_0_min_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1b_z_p_bi_u64_field_zt_1_poweroftwo_a000_a470a001() {
    // Encoding: 0xA470A001
    // Test LDNF1B_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=1
    let encoding: u32 = 0xA470A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1b_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a470a01e() {
    // Encoding: 0xA470A01E
    // Test LDNF1B_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA470A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1b_z_p_bi_u64_field_zt_31_max_a000_a470a01f() {
    // Encoding: 0xA470A01F
    // Test LDNF1B_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xA470A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1b_z_p_bi_u64_combo_0_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1b_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a470a3e0() {
    // Encoding: 0xA470A3E0
    // Test LDNF1B_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Rn=31, Pg=0
    let encoding: u32 = 0xA470A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u64_invalid_0_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1b_z_p_bi_u64_invalid_1_a000_a470a000() {
    // Encoding: 0xA470A000
    // Test LDNF1B_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1b_z_p_bi_u8_reg_write_0_a410a000() {
    // Test LDNF1B_Z.P.BI_U8 register write: SimdFromField("t")
    // Encoding: 0xA410A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA410A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1b_z_p_bi_u8_sp_rn_a410a3e0() {
    // Test LDNF1B_Z.P.BI_U8 with Rn = SP (31)
    // Encoding: 0xA410A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA410A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1b_z_p_bi_u16_reg_write_0_a430a000() {
    // Test LDNF1B_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0xA430A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA430A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1b_z_p_bi_u16_sp_rn_a430a3e0() {
    // Test LDNF1B_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0xA430A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA430A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1b_z_p_bi_u32_reg_write_0_a450a000() {
    // Test LDNF1B_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA450A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA450A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1b_z_p_bi_u32_sp_rn_a450a3e0() {
    // Test LDNF1B_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA450A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA450A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1b_z_p_bi_u64_reg_write_0_a470a000() {
    // Test LDNF1B_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA470A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA470A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1B_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1b_z_p_bi_u64_sp_rn_a470a3e0() {
    // Test LDNF1B_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA470A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA470A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQH_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rm_0_min_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rm_1_poweroftwo_0_a4810000() {
    // Encoding: 0xA4810000
    // Test LD1RQH_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a49e0000() {
    // Encoding: 0xA49E0000
    // Test LD1RQH_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=30
    let encoding: u32 = 0xA49E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rm_31_max_0_a49f0000() {
    // Encoding: 0xA49F0000
    // Test LD1RQH_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Rn=0, Pg=0
    let encoding: u32 = 0xA49F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_pg_0_min_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_pg_1_poweroftwo_0_a4800400() {
    // Encoding: 0xA4800400
    // Test LD1RQH_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xA4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rn_0_min_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rn_1_poweroftwo_0_a4800020() {
    // Encoding: 0xA4800020
    // Test LD1RQH_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xA4800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a48003c0() {
    // Encoding: 0xA48003C0
    // Test LD1RQH_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Rm=0
    let encoding: u32 = 0xA48003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_rn_31_max_0_a48003e0() {
    // Encoding: 0xA48003E0
    // Test LD1RQH_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_zt_0_min_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_zt_1_poweroftwo_0_a4800001() {
    // Encoding: 0xA4800001
    // Test LD1RQH_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, Rm=0
    let encoding: u32 = 0xA4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a480001e() {
    // Encoding: 0xA480001E
    // Test LD1RQH_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rn=0, Rm=0
    let encoding: u32 = 0xA480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqh_z_p_br_contiguous_field_zt_31_max_0_a480001f() {
    // Encoding: 0xA480001F
    // Test LD1RQH_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqh_z_p_br_contiguous_combo_0_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqh_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a48003e0() {
    // Encoding: 0xA48003E0
    // Test LD1RQH_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_br_contiguous_invalid_0_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_br_contiguous_invalid_1_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_br_contiguous_invalid_2_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_br_contiguous_invalid_3_0_a4800000() {
    // Encoding: 0xA4800000
    // Test LD1RQH_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqh_z_p_br_contiguous_reg_write_0_a4800000() {
    // Test LD1RQH_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA4800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQH_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqh_z_p_br_contiguous_sp_rn_a48003e0() {
    // Test LD1RQH_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA48003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA48003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rm_0_min_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a4a1c000() {
    // Encoding: 0xA4A1C000
    // Test LD2H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a4bec000() {
    // Encoding: 0xA4BEC000
    // Test LD2H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4BEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rm_31_max_c000_a4bfc000() {
    // Encoding: 0xA4BFC000
    // Test LD2H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=31
    let encoding: u32 = 0xA4BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_pg_0_min_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a4a0c400() {
    // Encoding: 0xA4A0C400
    // Test LD2H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA4A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rn_0_min_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a4a0c020() {
    // Encoding: 0xA4A0C020
    // Test LD2H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xA4A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a4a0c3c0() {
    // Encoding: 0xA4A0C3C0
    // Test LD2H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xA4A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2h_z_p_br_contiguous_field_rn_31_max_c000_a4a0c3e0() {
    // Encoding: 0xA4A0C3E0
    // Test LD2H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2h_z_p_br_contiguous_field_zt_0_min_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2h_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a4a0c001() {
    // Encoding: 0xA4A0C001
    // Test LD2H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=1
    let encoding: u32 = 0xA4A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2h_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a4a0c01e() {
    // Encoding: 0xA4A0C01E
    // Test LD2H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2h_z_p_br_contiguous_field_zt_31_max_c000_a4a0c01f() {
    // Encoding: 0xA4A0C01F
    // Test LD2H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=31
    let encoding: u32 = 0xA4A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2h_z_p_br_contiguous_combo_0_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a4a0c3e0()
{
    // Encoding: 0xA4A0C3E0
    // Test LD2H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xA4A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_br_contiguous_invalid_0_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_br_contiguous_invalid_1_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_br_contiguous_invalid_2_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_br_contiguous_invalid_3_c000_a4a0c000() {
    // Encoding: 0xA4A0C000
    // Test LD2H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2h_z_p_br_contiguous_sp_rn_a4a0c3e0() {
    // Test LD2H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA4A0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1D_Z.P.BZ_D.x32.scaled Tests
// ============================================================================

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_xs_0_min_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_xs_1_max_4000_c5e04000() {
    // Encoding: 0xC5E04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=0, xs=1
    let encoding: u32 = 0xC5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zm_0_min_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_4000_c5a14000() {
    // Encoding: 0xC5A14000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_4000_c5be4000() {
    // Encoding: 0xC5BE4000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zt=0, Rn=0, Zm=30, Pg=0
    let encoding: u32 = 0xC5BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zm_31_max_4000_c5bf4000() {
    // Encoding: 0xC5BF4000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: xs=0, Rn=0, Zm=31, Zt=0, Pg=0
    let encoding: u32 = 0xC5BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_pg_0_min_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_4000_c5a04400() {
    // Encoding: 0xC5A04400
    // Test LD1D_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_rn_0_min_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_4000_c5a04020() {
    // Encoding: 0xC5A04020
    // Test LD1D_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zt=0, xs=0, Rn=1
    let encoding: u32 = 0xC5A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_4000_c5a043c0() {
    // Encoding: 0xC5A043C0
    // Test LD1D_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Pg=0, Rn=30, Zm=0
    let encoding: u32 = 0xC5A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_rn_31_max_4000_c5a043e0() {
    // Encoding: 0xC5A043E0
    // Test LD1D_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0xC5A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zt_0_min_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_4000_c5a04001() {
    // Encoding: 0xC5A04001
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, xs=0, Zt=1, Pg=0
    let encoding: u32 = 0xC5A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_4000_c5a0401e() {
    // Encoding: 0xC5A0401E
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zm=0, xs=0, Zt=30
    let encoding: u32 = 0xC5A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_field_zt_31_max_4000_c5a0401f() {
    // Encoding: 0xC5A0401F
    // Test LD1D_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_combo_0_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c5a043e0(
) {
    // Encoding: 0xC5A043E0
    // Test LD1D_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xC5A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_invalid_0_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_invalid_1_4000_c5a04000() {
    // Encoding: 0xC5A04000
    // Test LD1D_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_xs_0_min_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_xs_1_max_4000_c5c04000() {
    // Encoding: 0xC5C04000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Rn=0, Zm=0, xs=1, Zt=0
    let encoding: u32 = 0xC5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zm_0_min_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_4000_c5814000() {
    // Encoding: 0xC5814000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Rn=0, Zm=1, Zt=0
    let encoding: u32 = 0xC5814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_4000_c59e4000() {
    // Encoding: 0xC59E4000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zt=0, Zm=30, Rn=0
    let encoding: u32 = 0xC59E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zm_31_max_4000_c59f4000() {
    // Encoding: 0xC59F4000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=31, xs=0, Rn=0
    let encoding: u32 = 0xC59F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_pg_0_min_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_4000_c5804400() {
    // Encoding: 0xC5804400
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_rn_0_min_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_4000_c5804020() {
    // Encoding: 0xC5804020
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_4000_c58043c0() {
    // Encoding: 0xC58043C0
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC58043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_rn_31_max_4000_c58043e0() {
    // Encoding: 0xC58043E0
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zt_0_min_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_4000_c5804001() {
    // Encoding: 0xC5804001
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=1, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xC5804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_4000_c580401e() {
    // Encoding: 0xC580401E
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Zt=30, Pg=0, xs=0
    let encoding: u32 = 0xC580401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_field_zt_31_max_4000_c580401f() {
    // Encoding: 0xC580401F
    // Test LD1D_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xC580401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_combo_0_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c58043e0(
) {
    // Encoding: 0xC58043E0
    // Test LD1D_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Pg=0, Zm=0, Zt=0, Rn=31
    let encoding: u32 = 0xC58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_invalid_0_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_invalid_1_4000_c5804000() {
    // Encoding: 0xC5804000
    // Test LD1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, xs=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zm_0_min_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_c000_c5e1c000() {
    // Encoding: 0xC5E1C000
    // Test LD1D_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC5E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_c000_c5fec000() {
    // Encoding: 0xC5FEC000
    // Test LD1D_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=30
    let encoding: u32 = 0xC5FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zm_31_max_c000_c5ffc000() {
    // Encoding: 0xC5FFC000
    // Test LD1D_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=31
    let encoding: u32 = 0xC5FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_pg_0_min_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_c000_c5e0c400() {
    // Encoding: 0xC5E0C400
    // Test LD1D_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xC5E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_rn_0_min_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_c000_c5e0c020() {
    // Encoding: 0xC5E0C020
    // Test LD1D_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_c000_c5e0c3c0() {
    // Encoding: 0xC5E0C3C0
    // Test LD1D_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zm=0, Zt=0
    let encoding: u32 = 0xC5E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_rn_31_max_c000_c5e0c3e0() {
    // Encoding: 0xC5E0C3E0
    // Test LD1D_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC5E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zt_0_min_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_c000_c5e0c001() {
    // Encoding: 0xC5E0C001
    // Test LD1D_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC5E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_c000_c5e0c01e() {
    // Encoding: 0xC5E0C01E
    // Test LD1D_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC5E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_field_zt_31_max_c000_c5e0c01f() {
    // Encoding: 0xC5E0C01F
    // Test LD1D_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xC5E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_combo_0_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c5e0c3e0(
) {
    // Encoding: 0xC5E0C3E0
    // Test LD1D_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_invalid_0_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_invalid_1_c000_c5e0c000() {
    // Encoding: 0xC5E0C000
    // Test LD1D_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zm_0_min_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_c000_c5c1c000() {
    // Encoding: 0xC5C1C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_c000_c5dec000() {
    // Encoding: 0xC5DEC000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=30, Pg=0, Zt=0
    let encoding: u32 = 0xC5DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zm_31_max_c000_c5dfc000() {
    // Encoding: 0xC5DFC000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_pg_0_min_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_c000_c5c0c400() {
    // Encoding: 0xC5C0C400
    // Test LD1D_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0xC5C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_rn_0_min_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_c000_c5c0c020() {
    // Encoding: 0xC5C0C020
    // Test LD1D_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC5C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_c000_c5c0c3c0() {
    // Encoding: 0xC5C0C3C0
    // Test LD1D_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Zm=0
    let encoding: u32 = 0xC5C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_rn_31_max_c000_c5c0c3e0() {
    // Encoding: 0xC5C0C3E0
    // Test LD1D_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xC5C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zt_0_min_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_c000_c5c0c001() {
    // Encoding: 0xC5C0C001
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Zm=0
    let encoding: u32 = 0xC5C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_c000_c5c0c01e() {
    // Encoding: 0xC5C0C01E
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC5C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_field_zt_31_max_c000_c5c0c01f() {
    // Encoding: 0xC5C0C01F
    // Test LD1D_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xC5C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_combo_0_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c5c0c3e0(
) {
    // Encoding: 0xC5C0C3E0
    // Test LD1D_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_invalid_0_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_invalid_1_c000_c5c0c000() {
    // Encoding: 0xC5C0C000
    // Test LD1D_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_reg_write_0_c5a04000() {
    // Test LD1D_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_bz_d_x32_scaled_sp_rn_c5a043e0() {
    // Test LD1D_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC5A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_reg_write_0_c5804000() {
    // Test LD1D_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_bz_d_x32_unscaled_sp_rn_c58043e0() {
    // Test LD1D_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC58043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC58043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_reg_write_0_c5e0c000() {
    // Test LD1D_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC5E0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5E0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_bz_d_64_scaled_sp_rn_c5e0c3e0() {
    // Test LD1D_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC5E0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5E0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_reg_write_0_c5c0c000() {
    // Test LD1D_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5C0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5C0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_bz_d_64_unscaled_sp_rn_c5c0c3e0() {
    // Test LD1D_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC5C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SW_Z.P.BZ_D.x32.scaled Tests
// ============================================================================

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_xs_0_min_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_xs_1_max_0_c5600000() {
    // Encoding: 0xC5600000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zm=0, Zt=0, xs=1, Pg=0
    let encoding: u32 = 0xC5600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zm_0_min_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_0_c5210000() {
    // Encoding: 0xC5210000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, xs=0, Zm=1
    let encoding: u32 = 0xC5210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_0_c53e0000() {
    // Encoding: 0xC53E0000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=30
    let encoding: u32 = 0xC53E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zm_31_max_0_c53f0000() {
    // Encoding: 0xC53F0000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xC53F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_pg_0_min_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_0_c5200400() {
    // Encoding: 0xC5200400
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, xs=0, Pg=1, Rn=0
    let encoding: u32 = 0xC5200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_rn_0_min_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_0_c5200020() {
    // Encoding: 0xC5200020
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Rn=1, Pg=0, xs=0
    let encoding: u32 = 0xC5200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_0_c52003c0() {
    // Encoding: 0xC52003C0
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xC52003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_rn_31_max_0_c52003e0() {
    // Encoding: 0xC52003E0
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC52003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zt_0_min_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_0_c5200001() {
    // Encoding: 0xC5200001
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=1, xs=0, Pg=0
    let encoding: u32 = 0xC5200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_0_c520001e() {
    // Encoding: 0xC520001E
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=30
    let encoding: u32 = 0xC520001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_field_zt_31_max_0_c520001f() {
    // Encoding: 0xC520001F
    // Test LD1SW_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Zm=0, Zt=31, Rn=0, Pg=0
    let encoding: u32 = 0xC520001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_combo_0_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c52003e0()
{
    // Encoding: 0xC52003E0
    // Test LD1SW_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC52003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_invalid_0_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_invalid_1_0_c5200000() {
    // Encoding: 0xC5200000
    // Test LD1SW_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_xs_0_min_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_xs_1_max_0_c5400000() {
    // Encoding: 0xC5400000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, xs=1, Rn=0, Zt=0
    let encoding: u32 = 0xC5400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zm_0_min_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_0_c5010000() {
    // Encoding: 0xC5010000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Pg=0, Zm=1, Rn=0
    let encoding: u32 = 0xC5010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_0_c51e0000() {
    // Encoding: 0xC51E0000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xC51E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zm_31_max_0_c51f0000() {
    // Encoding: 0xC51F0000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Zt=0, Pg=0, Rn=0, Zm=31
    let encoding: u32 = 0xC51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_pg_0_min_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_0_c5000400() {
    // Encoding: 0xC5000400
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, xs=0, Pg=1, Rn=0
    let encoding: u32 = 0xC5000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_rn_0_min_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_0_c5000020() {
    // Encoding: 0xC5000020
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=0, Rn=1, Zt=0
    let encoding: u32 = 0xC5000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_0_c50003c0() {
    // Encoding: 0xC50003C0
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=30
    let encoding: u32 = 0xC50003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_rn_31_max_0_c50003e0() {
    // Encoding: 0xC50003E0
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=31
    let encoding: u32 = 0xC50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zt_0_min_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_0_c5000001() {
    // Encoding: 0xC5000001
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=1
    let encoding: u32 = 0xC5000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_0_c500001e() {
    // Encoding: 0xC500001E
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, xs=0, Zt=30, Zm=0
    let encoding: u32 = 0xC500001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_field_zt_31_max_0_c500001f() {
    // Encoding: 0xC500001F
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Pg=0, Zt=31, Zm=0, Rn=0
    let encoding: u32 = 0xC500001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_combo_0_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c50003e0(
) {
    // Encoding: 0xC50003E0
    // Test LD1SW_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_invalid_0_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_invalid_1_0_c5000000() {
    // Encoding: 0xC5000000
    // Test LD1SW_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zm_0_min_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_8000_c5618000() {
    // Encoding: 0xC5618000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5618000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_8000_c57e8000() {
    // Encoding: 0xC57E8000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zm=30, Zt=0
    let encoding: u32 = 0xC57E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zm_31_max_8000_c57f8000() {
    // Encoding: 0xC57F8000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC57F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_pg_0_min_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_8000_c5608400() {
    // Encoding: 0xC5608400
    // Test LD1SW_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=1
    let encoding: u32 = 0xC5608400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_rn_0_min_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_8000_c5608020() {
    // Encoding: 0xC5608020
    // Test LD1SW_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zm=0, Zt=0
    let encoding: u32 = 0xC5608020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_8000_c56083c0() {
    // Encoding: 0xC56083C0
    // Test LD1SW_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, Zm=0
    let encoding: u32 = 0xC56083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_rn_31_max_8000_c56083e0() {
    // Encoding: 0xC56083E0
    // Test LD1SW_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xC56083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zt_0_min_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_8000_c5608001() {
    // Encoding: 0xC5608001
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=1
    let encoding: u32 = 0xC5608001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_8000_c560801e() {
    // Encoding: 0xC560801E
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC560801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_field_zt_31_max_8000_c560801f() {
    // Encoding: 0xC560801F
    // Test LD1SW_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xC560801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_combo_0_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c56083e0(
) {
    // Encoding: 0xC56083E0
    // Test LD1SW_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC56083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_invalid_0_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_invalid_1_8000_c5608000() {
    // Encoding: 0xC5608000
    // Test LD1SW_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zm_0_min_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_8000_c5418000() {
    // Encoding: 0xC5418000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0xC5418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_8000_c55e8000() {
    // Encoding: 0xC55E8000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC55E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zm_31_max_8000_c55f8000() {
    // Encoding: 0xC55F8000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC55F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_pg_0_min_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_8000_c5408400() {
    // Encoding: 0xC5408400
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xC5408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_rn_0_min_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_8000_c5408020() {
    // Encoding: 0xC5408020
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC5408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_8000_c54083c0() {
    // Encoding: 0xC54083C0
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Zm=0, Pg=0
    let encoding: u32 = 0xC54083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_rn_31_max_8000_c54083e0() {
    // Encoding: 0xC54083E0
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC54083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zt_0_min_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_8000_c5408001() {
    // Encoding: 0xC5408001
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=1
    let encoding: u32 = 0xC5408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_8000_c540801e() {
    // Encoding: 0xC540801E
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=30, Rn=0, Pg=0
    let encoding: u32 = 0xC540801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_field_zt_31_max_8000_c540801f() {
    // Encoding: 0xC540801F
    // Test LD1SW_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, Zm=0
    let encoding: u32 = 0xC540801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_combo_0_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c54083e0(
) {
    // Encoding: 0xC54083E0
    // Test LD1SW_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xC54083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_invalid_0_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_invalid_1_8000_c5408000() {
    // Encoding: 0xC5408000
    // Test LD1SW_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_reg_write_0_c5200000() {
    // Test LD1SW_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_bz_d_x32_scaled_sp_rn_c52003e0() {
    // Test LD1SW_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC52003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC52003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_reg_write_0_c5000000() {
    // Test LD1SW_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_bz_d_x32_unscaled_sp_rn_c50003e0() {
    // Test LD1SW_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC50003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC50003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_reg_write_0_c5608000() {
    // Test LD1SW_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC5608000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5608000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_bz_d_64_scaled_sp_rn_c56083e0() {
    // Test LD1SW_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC56083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC56083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_reg_write_0_c5408000() {
    // Test LD1SW_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5408000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5408000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_bz_d_64_unscaled_sp_rn_c54083e0() {
    // Test LD1SW_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC54083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC54083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1W_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_xs_0_min_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_xs_1_max_4000_85604000() {
    // Encoding: 0x85604000
    // Test LD1W_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zm_0_min_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_4000_85214000() {
    // Encoding: 0x85214000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=1, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x85214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_4000_853e4000() {
    // Encoding: 0x853E4000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x853E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zm_31_max_4000_853f4000() {
    // Encoding: 0x853F4000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x853F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_pg_0_min_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_4000_85204400() {
    // Encoding: 0x85204400
    // Test LD1W_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=1, xs=0
    let encoding: u32 = 0x85204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_rn_0_min_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_4000_85204020() {
    // Encoding: 0x85204020
    // Test LD1W_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x85204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_4000_852043c0() {
    // Encoding: 0x852043C0
    // Test LD1W_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0x852043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_rn_31_max_4000_852043e0() {
    // Encoding: 0x852043E0
    // Test LD1W_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=31
    let encoding: u32 = 0x852043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zt_0_min_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_4000_85204001() {
    // Encoding: 0x85204001
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Zm=0, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x85204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_4000_8520401e() {
    // Encoding: 0x8520401E
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x8520401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_field_zt_31_max_4000_8520401f() {
    // Encoding: 0x8520401F
    // Test LD1W_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=31, xs=0
    let encoding: u32 = 0x8520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_combo_0_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_852043e0(
) {
    // Encoding: 0x852043E0
    // Test LD1W_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, xs=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0x852043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_invalid_0_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_invalid_1_4000_85204000() {
    // Encoding: 0x85204000
    // Test LD1W_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0x85204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_xs_0_min_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_xs_1_max_4000_c5604000() {
    // Encoding: 0xC5604000
    // Test LD1W_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: xs=1, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zm_0_min_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_4000_c5214000() {
    // Encoding: 0xC5214000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=1, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC5214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_4000_c53e4000() {
    // Encoding: 0xC53E4000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC53E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zm_31_max_4000_c53f4000() {
    // Encoding: 0xC53F4000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=31
    let encoding: u32 = 0xC53F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_pg_0_min_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_4000_c5204400() {
    // Encoding: 0xC5204400
    // Test LD1W_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=0, Pg=1, Rn=0, Zm=0
    let encoding: u32 = 0xC5204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_rn_0_min_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_4000_c5204020() {
    // Encoding: 0xC5204020
    // Test LD1W_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=0, Rn=1, Zt=0
    let encoding: u32 = 0xC5204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_4000_c52043c0() {
    // Encoding: 0xC52043C0
    // Test LD1W_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zm=0, Zt=0, Rn=30
    let encoding: u32 = 0xC52043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_rn_31_max_4000_c52043e0() {
    // Encoding: 0xC52043E0
    // Test LD1W_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: xs=0, Pg=0, Zm=0, Zt=0, Rn=31
    let encoding: u32 = 0xC52043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zt_0_min_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_4000_c5204001() {
    // Encoding: 0xC5204001
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=1, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC5204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_4000_c520401e() {
    // Encoding: 0xC520401E
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, xs=0, Zt=30
    let encoding: u32 = 0xC520401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_field_zt_31_max_4000_c520401f() {
    // Encoding: 0xC520401F
    // Test LD1W_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Rn=0, xs=0, Pg=0, Zm=0, Zt=31
    let encoding: u32 = 0xC520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_combo_0_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c52043e0(
) {
    // Encoding: 0xC52043E0
    // Test LD1W_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=31
    let encoding: u32 = 0xC52043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_invalid_0_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_invalid_1_4000_c5204000() {
    // Encoding: 0xC5204000
    // Test LD1W_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_xs_0_min_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_xs_1_max_4000_c5404000() {
    // Encoding: 0xC5404000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Zt=0, Pg=0, xs=1, Rn=0, Zm=0
    let encoding: u32 = 0xC5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zm_0_min_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_4000_c5014000() {
    // Encoding: 0xC5014000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Zm=1, Rn=0, Zt=0
    let encoding: u32 = 0xC5014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_4000_c51e4000() {
    // Encoding: 0xC51E4000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0xC51E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zm_31_max_4000_c51f4000() {
    // Encoding: 0xC51F4000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, xs=0, Rn=0, Zm=31, Zt=0
    let encoding: u32 = 0xC51F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_pg_0_min_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_4000_c5004400() {
    // Encoding: 0xC5004400
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0xC5004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_rn_0_min_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_4000_c5004020() {
    // Encoding: 0xC5004020
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=1
    let encoding: u32 = 0xC5004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_4000_c50043c0() {
    // Encoding: 0xC50043C0
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xC50043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_rn_31_max_4000_c50043e0() {
    // Encoding: 0xC50043E0
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, xs=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0xC50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zt_0_min_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_4000_c5004001() {
    // Encoding: 0xC5004001
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=1
    let encoding: u32 = 0xC5004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_4000_c500401e() {
    // Encoding: 0xC500401E
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC500401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_field_zt_31_max_4000_c500401f() {
    // Encoding: 0xC500401F
    // Test LD1W_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC500401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_combo_0_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c50043e0(
) {
    // Encoding: 0xC50043E0
    // Test LD1W_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, xs=0, Rn=31, Zm=0
    let encoding: u32 = 0xC50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_invalid_0_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_invalid_1_4000_c5004000() {
    // Encoding: 0xC5004000
    // Test LD1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_xs_0_min_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_xs_1_max_4000_85404000() {
    // Encoding: 0x85404000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=1
    let encoding: u32 = 0x85404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zm_0_min_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_4000_85014000() {
    // Encoding: 0x85014000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x85014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_4000_851e4000() {
    // Encoding: 0x851E4000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x851E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zm_31_max_4000_851f4000() {
    // Encoding: 0x851F4000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=31
    let encoding: u32 = 0x851F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_pg_0_min_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_4000_85004400() {
    // Encoding: 0x85004400
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x85004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_rn_0_min_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_4000_85004020() {
    // Encoding: 0x85004020
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x85004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_4000_850043c0() {
    // Encoding: 0x850043C0
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zm=0, Rn=30, Zt=0
    let encoding: u32 = 0x850043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_rn_31_max_4000_850043e0() {
    // Encoding: 0x850043E0
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0x850043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zt_0_min_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, xs=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_4000_85004001() {
    // Encoding: 0x85004001
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=1
    let encoding: u32 = 0x85004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_4000_8500401e() {
    // Encoding: 0x8500401E
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zm=0, Zt=30, Rn=0
    let encoding: u32 = 0x8500401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_field_zt_31_max_4000_8500401f() {
    // Encoding: 0x8500401F
    // Test LD1W_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0x8500401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_combo_0_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_850043e0(
) {
    // Encoding: 0x850043E0
    // Test LD1W_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Rn=31, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x850043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_invalid_0_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_invalid_1_4000_85004000() {
    // Encoding: 0x85004000
    // Test LD1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x85004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zm_0_min_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_c000_c561c000() {
    // Encoding: 0xC561C000
    // Test LD1W_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0xC561C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_c000_c57ec000() {
    // Encoding: 0xC57EC000
    // Test LD1W_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=30, Zt=0, Pg=0
    let encoding: u32 = 0xC57EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zm_31_max_c000_c57fc000() {
    // Encoding: 0xC57FC000
    // Test LD1W_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Rn=0, Zt=0
    let encoding: u32 = 0xC57FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_pg_0_min_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_c000_c560c400() {
    // Encoding: 0xC560C400
    // Test LD1W_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC560C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_rn_0_min_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_c000_c560c020() {
    // Encoding: 0xC560C020
    // Test LD1W_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC560C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_c000_c560c3c0() {
    // Encoding: 0xC560C3C0
    // Test LD1W_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC560C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_rn_31_max_c000_c560c3e0() {
    // Encoding: 0xC560C3E0
    // Test LD1W_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC560C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zt_0_min_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_c000_c560c001() {
    // Encoding: 0xC560C001
    // Test LD1W_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xC560C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_c000_c560c01e() {
    // Encoding: 0xC560C01E
    // Test LD1W_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=30, Zm=0
    let encoding: u32 = 0xC560C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_field_zt_31_max_c000_c560c01f() {
    // Encoding: 0xC560C01F
    // Test LD1W_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC560C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_combo_0_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c560c3e0(
) {
    // Encoding: 0xC560C3E0
    // Test LD1W_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC560C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_invalid_0_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_invalid_1_c000_c560c000() {
    // Encoding: 0xC560C000
    // Test LD1W_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zm_0_min_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_c000_c541c000() {
    // Encoding: 0xC541C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC541C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_c000_c55ec000() {
    // Encoding: 0xC55EC000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Zm=30, Pg=0
    let encoding: u32 = 0xC55EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zm_31_max_c000_c55fc000() {
    // Encoding: 0xC55FC000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Zm=31, Rn=0, Pg=0
    let encoding: u32 = 0xC55FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_pg_0_min_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_c000_c540c400() {
    // Encoding: 0xC540C400
    // Test LD1W_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xC540C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_rn_0_min_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_c000_c540c020() {
    // Encoding: 0xC540C020
    // Test LD1W_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Rn=1, Zt=0
    let encoding: u32 = 0xC540C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_c000_c540c3c0() {
    // Encoding: 0xC540C3C0
    // Test LD1W_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC540C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_rn_31_max_c000_c540c3e0() {
    // Encoding: 0xC540C3E0
    // Test LD1W_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, Zm=0
    let encoding: u32 = 0xC540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zt_0_min_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_c000_c540c001() {
    // Encoding: 0xC540C001
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=1
    let encoding: u32 = 0xC540C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_c000_c540c01e() {
    // Encoding: 0xC540C01E
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zt=30, Rn=0
    let encoding: u32 = 0xC540C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_field_zt_31_max_c000_c540c01f() {
    // Encoding: 0xC540C01F
    // Test LD1W_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC540C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_combo_0_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c540c3e0(
) {
    // Encoding: 0xC540C3E0
    // Test LD1W_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xC540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_invalid_0_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_invalid_1_c000_c540c000() {
    // Encoding: 0xC540C000
    // Test LD1W_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_reg_write_0_85204000() {
    // Test LD1W_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x85204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_s_x32_scaled_sp_rn_852043e0() {
    // Test LD1W_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x852043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x852043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_reg_write_0_c5204000() {
    // Test LD1W_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC5204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_d_x32_scaled_sp_rn_c52043e0() {
    // Test LD1W_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC52043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC52043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_reg_write_0_c5004000() {
    // Test LD1W_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC5004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_d_x32_unscaled_sp_rn_c50043e0() {
    // Test LD1W_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC50043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC50043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_reg_write_0_85004000() {
    // Test LD1W_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x85004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_s_x32_unscaled_sp_rn_850043e0() {
    // Test LD1W_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x850043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x850043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_reg_write_0_c560c000() {
    // Test LD1W_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC560C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_d_64_scaled_sp_rn_c560c3e0() {
    // Test LD1W_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC560C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC560C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_reg_write_0_c540c000() {
    // Test LD1W_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC540C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bz_d_64_unscaled_sp_rn_c540c3e0() {
    // Test LD1W_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC540C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC540C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1B_Z.P.BR_U8 Tests
// ============================================================================

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u8_field_rm_0_min_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u8_field_rm_1_poweroftwo_4000_a4014000() {
    // Encoding: 0xA4014000
    // Test LD1B_Z.P.BR_U8 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Pg=0, Rn=0
    let encoding: u32 = 0xA4014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u8_field_rm_30_poweroftwominusone_4000_a41e4000() {
    // Encoding: 0xA41E4000
    // Test LD1B_Z.P.BR_U8 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Rm=30, Zt=0
    let encoding: u32 = 0xA41E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1b_z_p_br_u8_field_rm_31_max_4000_a41f4000() {
    // Encoding: 0xA41F4000
    // Test LD1B_Z.P.BR_U8 field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Zt=0, Pg=0
    let encoding: u32 = 0xA41F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u8_field_pg_0_min_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u8_field_pg_1_poweroftwo_4000_a4004400() {
    // Encoding: 0xA4004400
    // Test LD1B_Z.P.BR_U8 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA4004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u8_field_rn_0_min_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u8_field_rn_1_poweroftwo_4000_a4004020() {
    // Encoding: 0xA4004020
    // Test LD1B_Z.P.BR_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xA4004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u8_field_rn_30_poweroftwominusone_4000_a40043c0() {
    // Encoding: 0xA40043C0
    // Test LD1B_Z.P.BR_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xA40043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_br_u8_field_rn_31_max_4000_a40043e0() {
    // Encoding: 0xA40043E0
    // Test LD1B_Z.P.BR_U8 field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_br_u8_field_zt_0_min_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_br_u8_field_zt_1_poweroftwo_4000_a4004001() {
    // Encoding: 0xA4004001
    // Test LD1B_Z.P.BR_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=1
    let encoding: u32 = 0xA4004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_br_u8_field_zt_30_poweroftwominusone_4000_a400401e() {
    // Encoding: 0xA400401E
    // Test LD1B_Z.P.BR_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA400401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_br_u8_field_zt_31_max_4000_a400401f() {
    // Encoding: 0xA400401F
    // Test LD1B_Z.P.BR_U8 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=31
    let encoding: u32 = 0xA400401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1b_z_p_br_u8_combo_0_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_br_u8_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a40043e0() {
    // Encoding: 0xA40043E0
    // Test LD1B_Z.P.BR_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u8_invalid_0_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u8_invalid_1_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u8_invalid_2_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u8_invalid_3_4000_a4004000() {
    // Encoding: 0xA4004000
    // Test LD1B_Z.P.BR_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u16_field_rm_0_min_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u16_field_rm_1_poweroftwo_4000_a4214000() {
    // Encoding: 0xA4214000
    // Test LD1B_Z.P.BR_U16 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Rm=1, Zt=0
    let encoding: u32 = 0xA4214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u16_field_rm_30_poweroftwominusone_4000_a43e4000() {
    // Encoding: 0xA43E4000
    // Test LD1B_Z.P.BR_U16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=30, Pg=0, Rn=0
    let encoding: u32 = 0xA43E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1b_z_p_br_u16_field_rm_31_max_4000_a43f4000() {
    // Encoding: 0xA43F4000
    // Test LD1B_Z.P.BR_U16 field Rm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xA43F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u16_field_pg_0_min_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u16_field_pg_1_poweroftwo_4000_a4204400() {
    // Encoding: 0xA4204400
    // Test LD1B_Z.P.BR_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u16_field_rn_0_min_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u16_field_rn_1_poweroftwo_4000_a4204020() {
    // Encoding: 0xA4204020
    // Test LD1B_Z.P.BR_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xA4204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u16_field_rn_30_poweroftwominusone_4000_a42043c0() {
    // Encoding: 0xA42043C0
    // Test LD1B_Z.P.BR_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=30
    let encoding: u32 = 0xA42043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_br_u16_field_rn_31_max_4000_a42043e0() {
    // Encoding: 0xA42043E0
    // Test LD1B_Z.P.BR_U16 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xA42043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_br_u16_field_zt_0_min_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_br_u16_field_zt_1_poweroftwo_4000_a4204001() {
    // Encoding: 0xA4204001
    // Test LD1B_Z.P.BR_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_br_u16_field_zt_30_poweroftwominusone_4000_a420401e() {
    // Encoding: 0xA420401E
    // Test LD1B_Z.P.BR_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA420401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_br_u16_field_zt_31_max_4000_a420401f() {
    // Encoding: 0xA420401F
    // Test LD1B_Z.P.BR_U16 field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xA420401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1b_z_p_br_u16_combo_0_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_br_u16_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a42043e0() {
    // Encoding: 0xA42043E0
    // Test LD1B_Z.P.BR_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xA42043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u16_invalid_0_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u16_invalid_1_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u16_invalid_2_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u16_invalid_3_4000_a4204000() {
    // Encoding: 0xA4204000
    // Test LD1B_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u32_field_rm_0_min_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u32_field_rm_1_poweroftwo_4000_a4414000() {
    // Encoding: 0xA4414000
    // Test LD1B_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4414000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u32_field_rm_30_poweroftwominusone_4000_a45e4000() {
    // Encoding: 0xA45E4000
    // Test LD1B_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=30
    let encoding: u32 = 0xA45E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1b_z_p_br_u32_field_rm_31_max_4000_a45f4000() {
    // Encoding: 0xA45F4000
    // Test LD1B_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Zt=0, Pg=0
    let encoding: u32 = 0xA45F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u32_field_pg_0_min_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u32_field_pg_1_poweroftwo_4000_a4404400() {
    // Encoding: 0xA4404400
    // Test LD1B_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA4404400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u32_field_rn_0_min_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u32_field_rn_1_poweroftwo_4000_a4404020() {
    // Encoding: 0xA4404020
    // Test LD1B_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=1
    let encoding: u32 = 0xA4404020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u32_field_rn_30_poweroftwominusone_4000_a44043c0() {
    // Encoding: 0xA44043C0
    // Test LD1B_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA44043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_br_u32_field_rn_31_max_4000_a44043e0() {
    // Encoding: 0xA44043E0
    // Test LD1B_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA44043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_br_u32_field_zt_0_min_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_br_u32_field_zt_1_poweroftwo_4000_a4404001() {
    // Encoding: 0xA4404001
    // Test LD1B_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=1
    let encoding: u32 = 0xA4404001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_br_u32_field_zt_30_poweroftwominusone_4000_a440401e() {
    // Encoding: 0xA440401E
    // Test LD1B_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA440401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_br_u32_field_zt_31_max_4000_a440401f() {
    // Encoding: 0xA440401F
    // Test LD1B_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xA440401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1b_z_p_br_u32_combo_0_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a44043e0() {
    // Encoding: 0xA44043E0
    // Test LD1B_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA44043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u32_invalid_0_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u32_invalid_1_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u32_invalid_2_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u32_invalid_3_4000_a4404000() {
    // Encoding: 0xA4404000
    // Test LD1B_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u64_field_rm_0_min_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u64_field_rm_1_poweroftwo_4000_a4614000() {
    // Encoding: 0xA4614000
    // Test LD1B_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4614000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u64_field_rm_30_poweroftwominusone_4000_a47e4000() {
    // Encoding: 0xA47E4000
    // Test LD1B_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA47E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1b_z_p_br_u64_field_rm_31_max_4000_a47f4000() {
    // Encoding: 0xA47F4000
    // Test LD1B_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xA47F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u64_field_pg_0_min_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u64_field_pg_1_poweroftwo_4000_a4604400() {
    // Encoding: 0xA4604400
    // Test LD1B_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA4604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_br_u64_field_rn_0_min_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_br_u64_field_rn_1_poweroftwo_4000_a4604020() {
    // Encoding: 0xA4604020
    // Test LD1B_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Rn=1, Pg=0
    let encoding: u32 = 0xA4604020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_br_u64_field_rn_30_poweroftwominusone_4000_a46043c0() {
    // Encoding: 0xA46043C0
    // Test LD1B_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA46043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_br_u64_field_rn_31_max_4000_a46043e0() {
    // Encoding: 0xA46043E0
    // Test LD1B_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA46043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_br_u64_field_zt_0_min_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_br_u64_field_zt_1_poweroftwo_4000_a4604001() {
    // Encoding: 0xA4604001
    // Test LD1B_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=1
    let encoding: u32 = 0xA4604001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_br_u64_field_zt_30_poweroftwominusone_4000_a460401e() {
    // Encoding: 0xA460401E
    // Test LD1B_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xA460401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_br_u64_field_zt_31_max_4000_a460401f() {
    // Encoding: 0xA460401F
    // Test LD1B_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xA460401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1b_z_p_br_u64_combo_0_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a46043e0() {
    // Encoding: 0xA46043E0
    // Test LD1B_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA46043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u64_invalid_0_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u64_invalid_1_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u64_invalid_2_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_br_u64_invalid_3_4000_a4604000() {
    // Encoding: 0xA4604000
    // Test LD1B_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_br_u8_reg_write_0_a4004000() {
    // Test LD1B_Z.P.BR_U8 register write: SimdFromField("t")
    // Encoding: 0xA4004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_br_u8_sp_rn_a40043e0() {
    // Test LD1B_Z.P.BR_U8 with Rn = SP (31)
    // Encoding: 0xA40043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA40043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_br_u16_reg_write_0_a4204000() {
    // Test LD1B_Z.P.BR_U16 register write: SimdFromField("t")
    // Encoding: 0xA4204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_br_u16_sp_rn_a42043e0() {
    // Test LD1B_Z.P.BR_U16 with Rn = SP (31)
    // Encoding: 0xA42043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA42043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_br_u32_reg_write_0_a4404000() {
    // Test LD1B_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA4404000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4404000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_br_u32_sp_rn_a44043e0() {
    // Test LD1B_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA44043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA44043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_br_u64_reg_write_0_a4604000() {
    // Test LD1B_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA4604000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4604000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_br_u64_sp_rn_a46043e0() {
    // Test LD1B_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA46043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA46043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1B_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_0_zero_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_1_poweroftwo_c000_8421c000() {
    // Encoding: 0x8421C000
    // Test LD1B_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=1, Zn=0, Pg=0
    let encoding: u32 = 0x8421C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_3_poweroftwominusone_c000_8423c000() {
    // Encoding: 0x8423C000
    // Test LD1B_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=3, Zn=0, Zt=0
    let encoding: u32 = 0x8423C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_4_poweroftwo_c000_8424c000() {
    // Encoding: 0x8424C000
    // Test LD1B_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x8424C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_7_poweroftwominusone_c000_8427c000() {
    // Encoding: 0x8427C000
    // Test LD1B_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x8427C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_8_poweroftwo_c000_8428c000() {
    // Encoding: 0x8428C000
    // Test LD1B_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm5=8, Zn=0, Pg=0
    let encoding: u32 = 0x8428C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_15_poweroftwominusone_c000_842fc000() {
    // Encoding: 0x842FC000
    // Test LD1B_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x842FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_16_poweroftwo_c000_8430c000() {
    // Encoding: 0x8430C000
    // Test LD1B_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8430C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1b_z_p_ai_s_field_imm5_31_max_c000_843fc000() {
    // Encoding: 0x843FC000
    // Test LD1B_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, Pg=0, imm5=31, Zn=0
    let encoding: u32 = 0x843FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_ai_s_field_pg_0_min_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_ai_s_field_pg_1_poweroftwo_c000_8420c400() {
    // Encoding: 0x8420C400
    // Test LD1B_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x8420C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_ai_s_field_zn_0_min_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_ai_s_field_zn_1_poweroftwo_c000_8420c020() {
    // Encoding: 0x8420C020
    // Test LD1B_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0x8420C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_ai_s_field_zn_30_poweroftwominusone_c000_8420c3c0() {
    // Encoding: 0x8420C3C0
    // Test LD1B_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=0, Zn=30, Zt=0
    let encoding: u32 = 0x8420C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_ai_s_field_zn_31_max_c000_8420c3e0() {
    // Encoding: 0x8420C3E0
    // Test LD1B_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0x8420C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_ai_s_field_zt_0_min_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_ai_s_field_zt_1_poweroftwo_c000_8420c001() {
    // Encoding: 0x8420C001
    // Test LD1B_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=1
    let encoding: u32 = 0x8420C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_ai_s_field_zt_30_poweroftwominusone_c000_8420c01e() {
    // Encoding: 0x8420C01E
    // Test LD1B_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=30
    let encoding: u32 = 0x8420C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_ai_s_field_zt_31_max_c000_8420c01f() {
    // Encoding: 0x8420C01F
    // Test LD1B_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zt=31, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x8420C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_ai_s_combo_0_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_ai_s_invalid_0_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_ai_s_invalid_1_c000_8420c000() {
    // Encoding: 0x8420C000
    // Test LD1B_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x8420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_0_zero_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_1_poweroftwo_c000_c421c000() {
    // Encoding: 0xC421C000
    // Test LD1B_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=1
    let encoding: u32 = 0xC421C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_3_poweroftwominusone_c000_c423c000() {
    // Encoding: 0xC423C000
    // Test LD1B_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=3, Zn=0, Zt=0
    let encoding: u32 = 0xC423C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_4_poweroftwo_c000_c424c000() {
    // Encoding: 0xC424C000
    // Test LD1B_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm5=4, Zn=0, Zt=0
    let encoding: u32 = 0xC424C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_7_poweroftwominusone_c000_c427c000() {
    // Encoding: 0xC427C000
    // Test LD1B_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC427C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_8_poweroftwo_c000_c428c000() {
    // Encoding: 0xC428C000
    // Test LD1B_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, imm5=8, Zt=0, Pg=0
    let encoding: u32 = 0xC428C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_15_poweroftwominusone_c000_c42fc000() {
    // Encoding: 0xC42FC000
    // Test LD1B_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=15, Zn=0, Zt=0
    let encoding: u32 = 0xC42FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_16_poweroftwo_c000_c430c000() {
    // Encoding: 0xC430C000
    // Test LD1B_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, imm5=16, Pg=0, Zt=0
    let encoding: u32 = 0xC430C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1b_z_p_ai_d_field_imm5_31_max_c000_c43fc000() {
    // Encoding: 0xC43FC000
    // Test LD1B_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC43FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_ai_d_field_pg_0_min_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_ai_d_field_pg_1_poweroftwo_c000_c420c400() {
    // Encoding: 0xC420C400
    // Test LD1B_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Zn=0, imm5=0
    let encoding: u32 = 0xC420C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_ai_d_field_zn_0_min_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_ai_d_field_zn_1_poweroftwo_c000_c420c020() {
    // Encoding: 0xC420C020
    // Test LD1B_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zn=1, Zt=0
    let encoding: u32 = 0xC420C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_ai_d_field_zn_30_poweroftwominusone_c000_c420c3c0() {
    // Encoding: 0xC420C3C0
    // Test LD1B_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=30, imm5=0, Pg=0
    let encoding: u32 = 0xC420C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_ai_d_field_zn_31_max_c000_c420c3e0() {
    // Encoding: 0xC420C3E0
    // Test LD1B_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zt=0, imm5=0
    let encoding: u32 = 0xC420C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_ai_d_field_zt_0_min_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_ai_d_field_zt_1_poweroftwo_c000_c420c001() {
    // Encoding: 0xC420C001
    // Test LD1B_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm5=0, Zt=1, Zn=0
    let encoding: u32 = 0xC420C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_ai_d_field_zt_30_poweroftwominusone_c000_c420c01e() {
    // Encoding: 0xC420C01E
    // Test LD1B_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC420C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_ai_d_field_zt_31_max_c000_c420c01f() {
    // Encoding: 0xC420C01F
    // Test LD1B_Z.P.AI_D field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zt=31, Zn=0
    let encoding: u32 = 0xC420C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_ai_d_combo_0_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_ai_d_invalid_0_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_ai_d_invalid_1_c000_c420c000() {
    // Encoding: 0xC420C000
    // Test LD1B_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC420C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_ai_s_reg_write_0_8420c000() {
    // Test LD1B_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x8420C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8420C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_ai_d_reg_write_0_c420c000() {
    // Test LD1B_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC420C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC420C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SB_Z.P.BR_S16 Tests
// ============================================================================

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s16_field_rm_0_min_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s16_field_rm_1_poweroftwo_4000_a5c14000() {
    // Encoding: 0xA5C14000
    // Test LD1SB_Z.P.BR_S16 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5C14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s16_field_rm_30_poweroftwominusone_4000_a5de4000() {
    // Encoding: 0xA5DE4000
    // Test LD1SB_Z.P.BR_S16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xA5DE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sb_z_p_br_s16_field_rm_31_max_4000_a5df4000() {
    // Encoding: 0xA5DF4000
    // Test LD1SB_Z.P.BR_S16 field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xA5DF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s16_field_pg_0_min_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s16_field_pg_1_poweroftwo_4000_a5c04400() {
    // Encoding: 0xA5C04400
    // Test LD1SB_Z.P.BR_S16 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, Rm=0
    let encoding: u32 = 0xA5C04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s16_field_rn_0_min_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s16_field_rn_1_poweroftwo_4000_a5c04020() {
    // Encoding: 0xA5C04020
    // Test LD1SB_Z.P.BR_S16 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=1, Zt=0
    let encoding: u32 = 0xA5C04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s16_field_rn_30_poweroftwominusone_4000_a5c043c0() {
    // Encoding: 0xA5C043C0
    // Test LD1SB_Z.P.BR_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_br_s16_field_rn_31_max_4000_a5c043e0() {
    // Encoding: 0xA5C043E0
    // Test LD1SB_Z.P.BR_S16 field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA5C043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_br_s16_field_zt_0_min_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_br_s16_field_zt_1_poweroftwo_4000_a5c04001() {
    // Encoding: 0xA5C04001
    // Test LD1SB_Z.P.BR_S16 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5C04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_br_s16_field_zt_30_poweroftwominusone_4000_a5c0401e() {
    // Encoding: 0xA5C0401E
    // Test LD1SB_Z.P.BR_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=30, Rm=0
    let encoding: u32 = 0xA5C0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_br_s16_field_zt_31_max_4000_a5c0401f() {
    // Encoding: 0xA5C0401F
    // Test LD1SB_Z.P.BR_S16 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=31
    let encoding: u32 = 0xA5C0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sb_z_p_br_s16_combo_0_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_br_s16_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a5c043e0() {
    // Encoding: 0xA5C043E0
    // Test LD1SB_Z.P.BR_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA5C043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s16_invalid_0_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s16_invalid_1_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s16_invalid_2_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s16_invalid_3_4000_a5c04000() {
    // Encoding: 0xA5C04000
    // Test LD1SB_Z.P.BR_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s32_field_rm_0_min_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s32_field_rm_1_poweroftwo_4000_a5a14000() {
    // Encoding: 0xA5A14000
    // Test LD1SB_Z.P.BR_S32 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=1
    let encoding: u32 = 0xA5A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s32_field_rm_30_poweroftwominusone_4000_a5be4000() {
    // Encoding: 0xA5BE4000
    // Test LD1SB_Z.P.BR_S32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xA5BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sb_z_p_br_s32_field_rm_31_max_4000_a5bf4000() {
    // Encoding: 0xA5BF4000
    // Test LD1SB_Z.P.BR_S32 field Rm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xA5BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s32_field_pg_0_min_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s32_field_pg_1_poweroftwo_4000_a5a04400() {
    // Encoding: 0xA5A04400
    // Test LD1SB_Z.P.BR_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s32_field_rn_0_min_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s32_field_rn_1_poweroftwo_4000_a5a04020() {
    // Encoding: 0xA5A04020
    // Test LD1SB_Z.P.BR_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s32_field_rn_30_poweroftwominusone_4000_a5a043c0() {
    // Encoding: 0xA5A043C0
    // Test LD1SB_Z.P.BR_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=30
    let encoding: u32 = 0xA5A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_br_s32_field_rn_31_max_4000_a5a043e0() {
    // Encoding: 0xA5A043E0
    // Test LD1SB_Z.P.BR_S32 field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Rm=0, Pg=0
    let encoding: u32 = 0xA5A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_br_s32_field_zt_0_min_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_br_s32_field_zt_1_poweroftwo_4000_a5a04001() {
    // Encoding: 0xA5A04001
    // Test LD1SB_Z.P.BR_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Rm=0
    let encoding: u32 = 0xA5A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_br_s32_field_zt_30_poweroftwominusone_4000_a5a0401e() {
    // Encoding: 0xA5A0401E
    // Test LD1SB_Z.P.BR_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_br_s32_field_zt_31_max_4000_a5a0401f() {
    // Encoding: 0xA5A0401F
    // Test LD1SB_Z.P.BR_S32 field Zt = 31 (Max)
    // Fields: Rm=0, Zt=31, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sb_z_p_br_s32_combo_0_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_br_s32_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a5a043e0() {
    // Encoding: 0xA5A043E0
    // Test LD1SB_Z.P.BR_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA5A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s32_invalid_0_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s32_invalid_1_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s32_invalid_2_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s32_invalid_3_4000_a5a04000() {
    // Encoding: 0xA5A04000
    // Test LD1SB_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s64_field_rm_0_min_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s64_field_rm_1_poweroftwo_4000_a5814000() {
    // Encoding: 0xA5814000
    // Test LD1SB_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s64_field_rm_30_poweroftwominusone_4000_a59e4000() {
    // Encoding: 0xA59E4000
    // Test LD1SB_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA59E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sb_z_p_br_s64_field_rm_31_max_4000_a59f4000() {
    // Encoding: 0xA59F4000
    // Test LD1SB_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=31, Rn=0
    let encoding: u32 = 0xA59F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s64_field_pg_0_min_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s64_field_pg_1_poweroftwo_4000_a5804400() {
    // Encoding: 0xA5804400
    // Test LD1SB_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_br_s64_field_rn_0_min_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_br_s64_field_rn_1_poweroftwo_4000_a5804020() {
    // Encoding: 0xA5804020
    // Test LD1SB_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xA5804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_br_s64_field_rn_30_poweroftwominusone_4000_a58043c0() {
    // Encoding: 0xA58043C0
    // Test LD1SB_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA58043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_br_s64_field_rn_31_max_4000_a58043e0() {
    // Encoding: 0xA58043E0
    // Test LD1SB_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_br_s64_field_zt_0_min_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_br_s64_field_zt_1_poweroftwo_4000_a5804001() {
    // Encoding: 0xA5804001
    // Test LD1SB_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA5804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_br_s64_field_zt_30_poweroftwominusone_4000_a580401e() {
    // Encoding: 0xA580401E
    // Test LD1SB_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA580401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_br_s64_field_zt_31_max_4000_a580401f() {
    // Encoding: 0xA580401F
    // Test LD1SB_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA580401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sb_z_p_br_s64_combo_0_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a58043e0() {
    // Encoding: 0xA58043E0
    // Test LD1SB_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xA58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s64_invalid_0_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s64_invalid_1_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s64_invalid_2_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_br_s64_invalid_3_4000_a5804000() {
    // Encoding: 0xA5804000
    // Test LD1SB_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_br_s16_reg_write_0_a5c04000() {
    // Test LD1SB_Z.P.BR_S16 register write: SimdFromField("t")
    // Encoding: 0xA5C04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BR_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_br_s16_sp_rn_a5c043e0() {
    // Test LD1SB_Z.P.BR_S16 with Rn = SP (31)
    // Encoding: 0xA5C043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_br_s32_reg_write_0_a5a04000() {
    // Test LD1SB_Z.P.BR_S32 register write: SimdFromField("t")
    // Encoding: 0xA5A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BR_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_br_s32_sp_rn_a5a043e0() {
    // Test LD1SB_Z.P.BR_S32 with Rn = SP (31)
    // Encoding: 0xA5A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_br_s64_reg_write_0_a5804000() {
    // Test LD1SB_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA5804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_br_s64_sp_rn_a58043e0() {
    // Test LD1SB_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA58043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA58043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SB_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_0_zero_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_1_poweroftwo_8000_84218000() {
    // Encoding: 0x84218000
    // Test LD1SB_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=1, Zn=0
    let encoding: u32 = 0x84218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_3_poweroftwominusone_8000_84238000() {
    // Encoding: 0x84238000
    // Test LD1SB_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=3, Zt=0
    let encoding: u32 = 0x84238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_4_poweroftwo_8000_84248000() {
    // Encoding: 0x84248000
    // Test LD1SB_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=4, Pg=0
    let encoding: u32 = 0x84248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_7_poweroftwominusone_8000_84278000() {
    // Encoding: 0x84278000
    // Test LD1SB_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=7, Pg=0, Zt=0
    let encoding: u32 = 0x84278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_8_poweroftwo_8000_84288000() {
    // Encoding: 0x84288000
    // Test LD1SB_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=8, Pg=0
    let encoding: u32 = 0x84288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_15_poweroftwominusone_8000_842f8000() {
    // Encoding: 0x842F8000
    // Test LD1SB_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=15
    let encoding: u32 = 0x842F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_16_poweroftwo_8000_84308000() {
    // Encoding: 0x84308000
    // Test LD1SB_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84308000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1sb_z_p_ai_s_field_imm5_31_max_8000_843f8000() {
    // Encoding: 0x843F8000
    // Test LD1SB_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: imm5=31, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0x843F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_ai_s_field_pg_0_min_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_ai_s_field_pg_1_poweroftwo_8000_84208400() {
    // Encoding: 0x84208400
    // Test LD1SB_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=1
    let encoding: u32 = 0x84208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_ai_s_field_zn_0_min_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_ai_s_field_zn_1_poweroftwo_8000_84208020() {
    // Encoding: 0x84208020
    // Test LD1SB_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=1
    let encoding: u32 = 0x84208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_ai_s_field_zn_30_poweroftwominusone_8000_842083c0() {
    // Encoding: 0x842083C0
    // Test LD1SB_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=30, Zt=0
    let encoding: u32 = 0x842083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_ai_s_field_zn_31_max_8000_842083e0() {
    // Encoding: 0x842083E0
    // Test LD1SB_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Pg=0, imm5=0, Zn=31, Zt=0
    let encoding: u32 = 0x842083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_ai_s_field_zt_0_min_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_ai_s_field_zt_1_poweroftwo_8000_84208001() {
    // Encoding: 0x84208001
    // Test LD1SB_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x84208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_ai_s_field_zt_30_poweroftwominusone_8000_8420801e() {
    // Encoding: 0x8420801E
    // Test LD1SB_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=30, imm5=0
    let encoding: u32 = 0x8420801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_ai_s_field_zt_31_max_8000_8420801f() {
    // Encoding: 0x8420801F
    // Test LD1SB_Z.P.AI_S field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=31
    let encoding: u32 = 0x8420801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1sb_z_p_ai_s_combo_0_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_ai_s_invalid_0_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_ai_s_invalid_1_8000_84208000() {
    // Encoding: 0x84208000
    // Test LD1SB_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0x84208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_0_zero_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_1_poweroftwo_8000_c4218000() {
    // Encoding: 0xC4218000
    // Test LD1SB_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=1, Zt=0
    let encoding: u32 = 0xC4218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_3_poweroftwominusone_8000_c4238000() {
    // Encoding: 0xC4238000
    // Test LD1SB_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=3, Zn=0, Zt=0
    let encoding: u32 = 0xC4238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_4_poweroftwo_8000_c4248000() {
    // Encoding: 0xC4248000
    // Test LD1SB_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=4, Zt=0
    let encoding: u32 = 0xC4248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_7_poweroftwominusone_8000_c4278000() {
    // Encoding: 0xC4278000
    // Test LD1SB_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=0, imm5=7, Pg=0
    let encoding: u32 = 0xC4278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_8_poweroftwo_8000_c4288000() {
    // Encoding: 0xC4288000
    // Test LD1SB_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_15_poweroftwominusone_8000_c42f8000() {
    // Encoding: 0xC42F8000
    // Test LD1SB_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=15
    let encoding: u32 = 0xC42F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_16_poweroftwo_8000_c4308000() {
    // Encoding: 0xC4308000
    // Test LD1SB_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=16, Zn=0
    let encoding: u32 = 0xC4308000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1sb_z_p_ai_d_field_imm5_31_max_8000_c43f8000() {
    // Encoding: 0xC43F8000
    // Test LD1SB_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, imm5=31, Zn=0, Zt=0
    let encoding: u32 = 0xC43F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_ai_d_field_pg_0_min_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_ai_d_field_pg_1_poweroftwo_8000_c4208400() {
    // Encoding: 0xC4208400
    // Test LD1SB_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Zn=0, Pg=1
    let encoding: u32 = 0xC4208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_ai_d_field_zn_0_min_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_ai_d_field_zn_1_poweroftwo_8000_c4208020() {
    // Encoding: 0xC4208020
    // Test LD1SB_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_ai_d_field_zn_30_poweroftwominusone_8000_c42083c0() {
    // Encoding: 0xC42083C0
    // Test LD1SB_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=30
    let encoding: u32 = 0xC42083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_ai_d_field_zn_31_max_8000_c42083e0() {
    // Encoding: 0xC42083E0
    // Test LD1SB_Z.P.AI_D field Zn = 31 (Max)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=31
    let encoding: u32 = 0xC42083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_ai_d_field_zt_0_min_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_ai_d_field_zt_1_poweroftwo_8000_c4208001() {
    // Encoding: 0xC4208001
    // Test LD1SB_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC4208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_ai_d_field_zt_30_poweroftwominusone_8000_c420801e() {
    // Encoding: 0xC420801E
    // Test LD1SB_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=30, Pg=0, imm5=0
    let encoding: u32 = 0xC420801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_ai_d_field_zt_31_max_8000_c420801f() {
    // Encoding: 0xC420801F
    // Test LD1SB_Z.P.AI_D field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zt=31, Zn=0
    let encoding: u32 = 0xC420801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1sb_z_p_ai_d_combo_0_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_ai_d_invalid_0_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_ai_d_invalid_1_8000_c4208000() {
    // Encoding: 0xC4208000
    // Test LD1SB_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_ai_s_reg_write_0_84208000() {
    // Test LD1SB_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x84208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_ai_d_reg_write_0_c4208000() {
    // Test LD1SB_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC4208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_0_zero_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a561e000() {
    // Encoding: 0xA561E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=1
    let encoding: u32 = 0xA561E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a563e000() {
    // Encoding: 0xA563E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA563E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a564e000() {
    // Encoding: 0xA564E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, imm4=4, Zt=0, Pg=0
    let encoding: u32 = 0xA564E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a567e000() {
    // Encoding: 0xA567E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA567E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a568e000() {
    // Encoding: 0xA568E000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=8, Rn=0
    let encoding: u32 = 0xA568E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_imm4_15_max_e000_a56fe000() {
    // Encoding: 0xA56FE000
    // Test LD4W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=15
    let encoding: u32 = 0xA56FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_pg_0_min_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a560e400() {
    // Encoding: 0xA560E400
    // Test LD4W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA560E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_rn_0_min_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a560e020() {
    // Encoding: 0xA560E020
    // Test LD4W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA560E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a560e3c0() {
    // Encoding: 0xA560E3C0
    // Test LD4W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA560E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4w_z_p_bi_contiguous_field_rn_31_max_e000_a560e3e0() {
    // Encoding: 0xA560E3E0
    // Test LD4W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA560E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4w_z_p_bi_contiguous_field_zt_0_min_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a560e001() {
    // Encoding: 0xA560E001
    // Test LD4W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA560E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a560e01e() {
    // Encoding: 0xA560E01E
    // Test LD4W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA560E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4w_z_p_bi_contiguous_field_zt_31_max_e000_a560e01f() {
    // Encoding: 0xA560E01F
    // Test LD4W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA560E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld4w_z_p_bi_contiguous_combo_0_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a560e3e0()
{
    // Encoding: 0xA560E3E0
    // Test LD4W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xA560E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_bi_contiguous_invalid_0_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_bi_contiguous_invalid_1_e000_a560e000() {
    // Encoding: 0xA560E000
    // Test LD4W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4w_z_p_bi_contiguous_sp_rn_a560e3e0() {
    // Test LD4W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA560E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA560E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rm_0_min_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a541c000() {
    // Encoding: 0xA541C000
    // Test LD3W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA541C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a55ec000() {
    // Encoding: 0xA55EC000
    // Test LD3W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xA55EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rm_31_max_c000_a55fc000() {
    // Encoding: 0xA55FC000
    // Test LD3W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA55FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_pg_0_min_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a540c400() {
    // Encoding: 0xA540C400
    // Test LD3W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA540C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rn_0_min_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a540c020() {
    // Encoding: 0xA540C020
    // Test LD3W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=1
    let encoding: u32 = 0xA540C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a540c3c0() {
    // Encoding: 0xA540C3C0
    // Test LD3W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA540C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3w_z_p_br_contiguous_field_rn_31_max_c000_a540c3e0() {
    // Encoding: 0xA540C3E0
    // Test LD3W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3w_z_p_br_contiguous_field_zt_0_min_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3w_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a540c001() {
    // Encoding: 0xA540C001
    // Test LD3W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=1
    let encoding: u32 = 0xA540C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3w_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a540c01e() {
    // Encoding: 0xA540C01E
    // Test LD3W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, Rm=0
    let encoding: u32 = 0xA540C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3w_z_p_br_contiguous_field_zt_31_max_c000_a540c01f() {
    // Encoding: 0xA540C01F
    // Test LD3W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA540C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld3w_z_p_br_contiguous_combo_0_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a540c3e0()
{
    // Encoding: 0xA540C3E0
    // Test LD3W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_br_contiguous_invalid_0_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_br_contiguous_invalid_1_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_br_contiguous_invalid_2_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_br_contiguous_invalid_3_c000_a540c000() {
    // Encoding: 0xA540C000
    // Test LD3W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3w_z_p_br_contiguous_sp_rn_a540c3e0() {
    // Test LD3W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA540C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA540C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1W_Z.P.BI_U32 Tests
// ============================================================================

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_0_zero_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a541a000() {
    // Encoding: 0xA541A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a543a000() {
    // Encoding: 0xA543A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA543A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a544a000() {
    // Encoding: 0xA544A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA544A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a547a000() {
    // Encoding: 0xA547A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Zt=0, Rn=0
    let encoding: u32 = 0xA547A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a548a000() {
    // Encoding: 0xA548A000
    // Test LD1W_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA548A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1w_z_p_bi_u32_field_imm4_15_max_a000_a54fa000() {
    // Encoding: 0xA54FA000
    // Test LD1W_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA54FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bi_u32_field_pg_0_min_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bi_u32_field_pg_1_poweroftwo_a000_a540a400() {
    // Encoding: 0xA540A400
    // Test LD1W_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA540A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bi_u32_field_rn_0_min_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bi_u32_field_rn_1_poweroftwo_a000_a540a020() {
    // Encoding: 0xA540A020
    // Test LD1W_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xA540A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a540a3c0() {
    // Encoding: 0xA540A3C0
    // Test LD1W_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA540A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bi_u32_field_rn_31_max_a000_a540a3e0() {
    // Encoding: 0xA540A3E0
    // Test LD1W_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bi_u32_field_zt_0_min_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bi_u32_field_zt_1_poweroftwo_a000_a540a001() {
    // Encoding: 0xA540A001
    // Test LD1W_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, imm4=0
    let encoding: u32 = 0xA540A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a540a01e() {
    // Encoding: 0xA540A01E
    // Test LD1W_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA540A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bi_u32_field_zt_31_max_a000_a540a01f() {
    // Encoding: 0xA540A01F
    // Test LD1W_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xA540A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1w_z_p_bi_u32_combo_0_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a540a3e0() {
    // Encoding: 0xA540A3E0
    // Test LD1W_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bi_u32_invalid_0_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bi_u32_invalid_1_a000_a540a000() {
    // Encoding: 0xA540A000
    // Test LD1W_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_0_zero_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a561a000() {
    // Encoding: 0xA561A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a563a000() {
    // Encoding: 0xA563A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=3, Zt=0, Pg=0
    let encoding: u32 = 0xA563A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a564a000() {
    // Encoding: 0xA564A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=4, Pg=0
    let encoding: u32 = 0xA564A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a567a000() {
    // Encoding: 0xA567A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=7, Pg=0
    let encoding: u32 = 0xA567A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a568a000() {
    // Encoding: 0xA568A000
    // Test LD1W_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=8, Rn=0
    let encoding: u32 = 0xA568A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1w_z_p_bi_u64_field_imm4_15_max_a000_a56fa000() {
    // Encoding: 0xA56FA000
    // Test LD1W_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xA56FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bi_u64_field_pg_0_min_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bi_u64_field_pg_1_poweroftwo_a000_a560a400() {
    // Encoding: 0xA560A400
    // Test LD1W_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA560A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_bi_u64_field_rn_0_min_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_bi_u64_field_rn_1_poweroftwo_a000_a560a020() {
    // Encoding: 0xA560A020
    // Test LD1W_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Rn=1, Pg=0
    let encoding: u32 = 0xA560A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a560a3c0() {
    // Encoding: 0xA560A3C0
    // Test LD1W_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA560A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_bi_u64_field_rn_31_max_a000_a560a3e0() {
    // Encoding: 0xA560A3E0
    // Test LD1W_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xA560A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_bi_u64_field_zt_0_min_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_bi_u64_field_zt_1_poweroftwo_a000_a560a001() {
    // Encoding: 0xA560A001
    // Test LD1W_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=1
    let encoding: u32 = 0xA560A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a560a01e() {
    // Encoding: 0xA560A01E
    // Test LD1W_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rn=0, imm4=0
    let encoding: u32 = 0xA560A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_bi_u64_field_zt_31_max_a000_a560a01f() {
    // Encoding: 0xA560A01F
    // Test LD1W_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA560A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1w_z_p_bi_u64_combo_0_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a560a3e0() {
    // Encoding: 0xA560A3E0
    // Test LD1W_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xA560A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bi_u64_invalid_0_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_bi_u64_invalid_1_a000_a560a000() {
    // Encoding: 0xA560A000
    // Test LD1W_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bi_u32_reg_write_0_a540a000() {
    // Test LD1W_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA540A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA540A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bi_u32_sp_rn_a540a3e0() {
    // Test LD1W_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA540A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA540A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_bi_u64_reg_write_0_a560a000() {
    // Test LD1W_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA560A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA560A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_bi_u64_sp_rn_a560a3e0() {
    // Test LD1W_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA560A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA560A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_0_zero_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a441e000() {
    // Encoding: 0xA441E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=1
    let encoding: u32 = 0xA441E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a443e000() {
    // Encoding: 0xA443E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Rn=0, Zt=0
    let encoding: u32 = 0xA443E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a444e000() {
    // Encoding: 0xA444E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA444E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a447e000() {
    // Encoding: 0xA447E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm4=7, Zt=0
    let encoding: u32 = 0xA447E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a448e000() {
    // Encoding: 0xA448E000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=8, Rn=0
    let encoding: u32 = 0xA448E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_imm4_15_max_e000_a44fe000() {
    // Encoding: 0xA44FE000
    // Test LD3B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=15
    let encoding: u32 = 0xA44FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_pg_0_min_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a440e400() {
    // Encoding: 0xA440E400
    // Test LD3B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=1
    let encoding: u32 = 0xA440E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_rn_0_min_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a440e020() {
    // Encoding: 0xA440E020
    // Test LD3B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=1
    let encoding: u32 = 0xA440E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a440e3c0() {
    // Encoding: 0xA440E3C0
    // Test LD3B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA440E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3b_z_p_bi_contiguous_field_rn_31_max_e000_a440e3e0() {
    // Encoding: 0xA440E3E0
    // Test LD3B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=31
    let encoding: u32 = 0xA440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3b_z_p_bi_contiguous_field_zt_0_min_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a440e001() {
    // Encoding: 0xA440E001
    // Test LD3B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA440E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a440e01e() {
    // Encoding: 0xA440E01E
    // Test LD3B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA440E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3b_z_p_bi_contiguous_field_zt_31_max_e000_a440e01f() {
    // Encoding: 0xA440E01F
    // Test LD3B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=31, Rn=0
    let encoding: u32 = 0xA440E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld3b_z_p_bi_contiguous_combo_0_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a440e3e0()
{
    // Encoding: 0xA440E3E0
    // Test LD3B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_bi_contiguous_invalid_0_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_bi_contiguous_invalid_1_e000_a440e000() {
    // Encoding: 0xA440E000
    // Test LD3B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3b_z_p_bi_contiguous_sp_rn_a440e3e0() {
    // Test LD3B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA440E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA440E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rm_0_min_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a461c000() {
    // Encoding: 0xA461C000
    // Test LD4B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA461C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a47ec000() {
    // Encoding: 0xA47EC000
    // Test LD4B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=30, Rn=0, Zt=0
    let encoding: u32 = 0xA47EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rm_31_max_c000_a47fc000() {
    // Encoding: 0xA47FC000
    // Test LD4B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Rn=0, Pg=0
    let encoding: u32 = 0xA47FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_pg_0_min_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a460c400() {
    // Encoding: 0xA460C400
    // Test LD4B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rn_0_min_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a460c020() {
    // Encoding: 0xA460C020
    // Test LD4B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a460c3c0() {
    // Encoding: 0xA460C3C0
    // Test LD4B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=30, Zt=0
    let encoding: u32 = 0xA460C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4b_z_p_br_contiguous_field_rn_31_max_c000_a460c3e0() {
    // Encoding: 0xA460C3E0
    // Test LD4B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA460C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4b_z_p_br_contiguous_field_zt_0_min_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4b_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a460c001() {
    // Encoding: 0xA460C001
    // Test LD4B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA460C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4b_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a460c01e() {
    // Encoding: 0xA460C01E
    // Test LD4B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA460C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4b_z_p_br_contiguous_field_zt_31_max_c000_a460c01f() {
    // Encoding: 0xA460C01F
    // Test LD4B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=31
    let encoding: u32 = 0xA460C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld4b_z_p_br_contiguous_combo_0_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a460c3e0()
{
    // Encoding: 0xA460C3E0
    // Test LD4B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA460C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_br_contiguous_invalid_0_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_br_contiguous_invalid_1_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_br_contiguous_invalid_2_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_br_contiguous_invalid_3_c000_a460c000() {
    // Encoding: 0xA460C000
    // Test LD4B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4b_z_p_br_contiguous_sp_rn_a460c3e0() {
    // Test LD4B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA460C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA460C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SW_Z.P.BI_S64 Tests
// ============================================================================

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_0_zero_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a481a000() {
    // Encoding: 0xA481A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=1, Rn=0, Pg=0
    let encoding: u32 = 0xA481A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a483a000() {
    // Encoding: 0xA483A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA483A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a484a000() {
    // Encoding: 0xA484A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA484A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a487a000() {
    // Encoding: 0xA487A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=7, Zt=0
    let encoding: u32 = 0xA487A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a488a000() {
    // Encoding: 0xA488A000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA488A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sw_z_p_bi_s64_field_imm4_15_max_a000_a48fa000() {
    // Encoding: 0xA48FA000
    // Test LD1SW_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xA48FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bi_s64_field_pg_0_min_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bi_s64_field_pg_1_poweroftwo_a000_a480a400() {
    // Encoding: 0xA480A400
    // Test LD1SW_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA480A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_bi_s64_field_rn_0_min_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_bi_s64_field_rn_1_poweroftwo_a000_a480a020() {
    // Encoding: 0xA480A020
    // Test LD1SW_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA480A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a480a3c0() {
    // Encoding: 0xA480A3C0
    // Test LD1SW_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA480A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_bi_s64_field_rn_31_max_a000_a480a3e0() {
    // Encoding: 0xA480A3E0
    // Test LD1SW_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, imm4=0
    let encoding: u32 = 0xA480A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_bi_s64_field_zt_0_min_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_bi_s64_field_zt_1_poweroftwo_a000_a480a001() {
    // Encoding: 0xA480A001
    // Test LD1SW_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA480A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a480a01e() {
    // Encoding: 0xA480A01E
    // Test LD1SW_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=30, imm4=0
    let encoding: u32 = 0xA480A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_bi_s64_field_zt_31_max_a000_a480a01f() {
    // Encoding: 0xA480A01F
    // Test LD1SW_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xA480A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sw_z_p_bi_s64_combo_0_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a480a3e0() {
    // Encoding: 0xA480A3E0
    // Test LD1SW_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xA480A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bi_s64_invalid_0_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_bi_s64_invalid_1_a000_a480a000() {
    // Encoding: 0xA480A000
    // Test LD1SW_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_bi_s64_reg_write_0_a480a000() {
    // Test LD1SW_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA480A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_bi_s64_sp_rn_a480a3e0() {
    // Test LD1SW_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA480A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1D_Z.P.BI_U64 Tests
// ============================================================================

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_0_zero_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a5e1a000() {
    // Encoding: 0xA5E1A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=1, Pg=0, Rn=0
    let encoding: u32 = 0xA5E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a5e3a000() {
    // Encoding: 0xA5E3A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=3, Rn=0
    let encoding: u32 = 0xA5E3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a5e4a000() {
    // Encoding: 0xA5E4A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, imm4=4, Pg=0, Zt=0
    let encoding: u32 = 0xA5E4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a5e7a000() {
    // Encoding: 0xA5E7A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=7
    let encoding: u32 = 0xA5E7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a5e8a000() {
    // Encoding: 0xA5E8A000
    // Test LD1D_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1d_z_p_bi_u64_field_imm4_15_max_a000_a5efa000() {
    // Encoding: 0xA5EFA000
    // Test LD1D_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5EFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bi_u64_field_pg_0_min_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bi_u64_field_pg_1_poweroftwo_a000_a5e0a400() {
    // Encoding: 0xA5E0A400
    // Test LD1D_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, imm4=0, Zt=0
    let encoding: u32 = 0xA5E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_bi_u64_field_rn_0_min_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_bi_u64_field_rn_1_poweroftwo_a000_a5e0a020() {
    // Encoding: 0xA5E0A020
    // Test LD1D_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a5e0a3c0() {
    // Encoding: 0xA5E0A3C0
    // Test LD1D_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA5E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_bi_u64_field_rn_31_max_a000_a5e0a3e0() {
    // Encoding: 0xA5E0A3E0
    // Test LD1D_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA5E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_bi_u64_field_zt_0_min_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_bi_u64_field_zt_1_poweroftwo_a000_a5e0a001() {
    // Encoding: 0xA5E0A001
    // Test LD1D_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA5E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a5e0a01e() {
    // Encoding: 0xA5E0A01E
    // Test LD1D_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, imm4=0
    let encoding: u32 = 0xA5E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_bi_u64_field_zt_31_max_a000_a5e0a01f() {
    // Encoding: 0xA5E0A01F
    // Test LD1D_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA5E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1d_z_p_bi_u64_combo_0_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5e0a3e0() {
    // Encoding: 0xA5E0A3E0
    // Test LD1D_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, imm4=0
    let encoding: u32 = 0xA5E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bi_u64_invalid_0_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_bi_u64_invalid_1_a000_a5e0a000() {
    // Encoding: 0xA5E0A000
    // Test LD1D_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_bi_u64_reg_write_0_a5e0a000() {
    // Test LD1D_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA5E0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_bi_u64_sp_rn_a5e0a3e0() {
    // Test LD1D_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA5E0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SH_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_0_zero_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_1_poweroftwo_a000_84a1a000() {
    // Encoding: 0x84A1A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=1
    let encoding: u32 = 0x84A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_84a3a000() {
    // Encoding: 0x84A3A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x84A3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_4_poweroftwo_a000_84a4a000() {
    // Encoding: 0x84A4A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=4
    let encoding: u32 = 0x84A4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_84a7a000() {
    // Encoding: 0x84A7A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=0, imm5=7, Pg=0
    let encoding: u32 = 0x84A7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_8_poweroftwo_a000_84a8a000() {
    // Encoding: 0x84A8A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=8
    let encoding: u32 = 0x84A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_84afa000() {
    // Encoding: 0x84AFA000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=15
    let encoding: u32 = 0x84AFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_16_poweroftwo_a000_84b0a000() {
    // Encoding: 0x84B0A000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sh_z_p_ai_s_field_imm5_31_max_a000_84bfa000() {
    // Encoding: 0x84BFA000
    // Test LDFF1SH_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Pg=0, imm5=31, Zn=0, Zt=0
    let encoding: u32 = 0x84BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_ai_s_field_pg_0_min_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_ai_s_field_pg_1_poweroftwo_a000_84a0a400() {
    // Encoding: 0x84A0A400
    // Test LDFF1SH_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=0, Pg=1
    let encoding: u32 = 0x84A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_ai_s_field_zn_0_min_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_ai_s_field_zn_1_poweroftwo_a000_84a0a020() {
    // Encoding: 0x84A0A020
    // Test LDFF1SH_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=1
    let encoding: u32 = 0x84A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_ai_s_field_zn_30_poweroftwominusone_a000_84a0a3c0() {
    // Encoding: 0x84A0A3C0
    // Test LDFF1SH_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=30, Zt=0
    let encoding: u32 = 0x84A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_ai_s_field_zn_31_max_a000_84a0a3e0() {
    // Encoding: 0x84A0A3E0
    // Test LDFF1SH_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=31
    let encoding: u32 = 0x84A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_ai_s_field_zt_0_min_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_ai_s_field_zt_1_poweroftwo_a000_84a0a001() {
    // Encoding: 0x84A0A001
    // Test LDFF1SH_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=1, Zn=0
    let encoding: u32 = 0x84A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_ai_s_field_zt_30_poweroftwominusone_a000_84a0a01e() {
    // Encoding: 0x84A0A01E
    // Test LDFF1SH_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=30
    let encoding: u32 = 0x84A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_ai_s_field_zt_31_max_a000_84a0a01f() {
    // Encoding: 0x84A0A01F
    // Test LDFF1SH_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=31
    let encoding: u32 = 0x84A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sh_z_p_ai_s_combo_0_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_ai_s_invalid_0_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_ai_s_invalid_1_a000_84a0a000() {
    // Encoding: 0x84A0A000
    // Test LDFF1SH_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0x84A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_0_zero_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_1_poweroftwo_a000_c4a1a000() {
    // Encoding: 0xC4A1A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=1, Zt=0, Pg=0
    let encoding: u32 = 0xC4A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_c4a3a000() {
    // Encoding: 0xC4A3A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=3
    let encoding: u32 = 0xC4A3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_4_poweroftwo_a000_c4a4a000() {
    // Encoding: 0xC4A4A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=4, Zt=0
    let encoding: u32 = 0xC4A4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_c4a7a000() {
    // Encoding: 0xC4A7A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC4A7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_8_poweroftwo_a000_c4a8a000() {
    // Encoding: 0xC4A8A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=8
    let encoding: u32 = 0xC4A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_c4afa000() {
    // Encoding: 0xC4AFA000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=15, Pg=0, Zt=0
    let encoding: u32 = 0xC4AFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_16_poweroftwo_a000_c4b0a000() {
    // Encoding: 0xC4B0A000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, imm5=16, Pg=0, Zn=0
    let encoding: u32 = 0xC4B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sh_z_p_ai_d_field_imm5_31_max_a000_c4bfa000() {
    // Encoding: 0xC4BFA000
    // Test LDFF1SH_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zn=0, imm5=31, Pg=0, Zt=0
    let encoding: u32 = 0xC4BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_ai_d_field_pg_0_min_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_ai_d_field_pg_1_poweroftwo_a000_c4a0a400() {
    // Encoding: 0xC4A0A400
    // Test LDFF1SH_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=1
    let encoding: u32 = 0xC4A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_ai_d_field_zn_0_min_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_ai_d_field_zn_1_poweroftwo_a000_c4a0a020() {
    // Encoding: 0xC4A0A020
    // Test LDFF1SH_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, imm5=0, Zt=0
    let encoding: u32 = 0xC4A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_ai_d_field_zn_30_poweroftwominusone_a000_c4a0a3c0() {
    // Encoding: 0xC4A0A3C0
    // Test LDFF1SH_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC4A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_ai_d_field_zn_31_max_a000_c4a0a3e0() {
    // Encoding: 0xC4A0A3E0
    // Test LDFF1SH_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=31
    let encoding: u32 = 0xC4A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_ai_d_field_zt_0_min_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D field Zt = 0 (Min)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_ai_d_field_zt_1_poweroftwo_a000_c4a0a001() {
    // Encoding: 0xC4A0A001
    // Test LDFF1SH_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_ai_d_field_zt_30_poweroftwominusone_a000_c4a0a01e() {
    // Encoding: 0xC4A0A01E
    // Test LDFF1SH_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=30
    let encoding: u32 = 0xC4A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_ai_d_field_zt_31_max_a000_c4a0a01f() {
    // Encoding: 0xC4A0A01F
    // Test LDFF1SH_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=31
    let encoding: u32 = 0xC4A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sh_z_p_ai_d_combo_0_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_ai_d_invalid_0_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_ai_d_invalid_1_a000_c4a0a000() {
    // Encoding: 0xC4A0A000
    // Test LDFF1SH_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xC4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_ai_s_reg_write_0_84a0a000() {
    // Test LDFF1SH_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x84A0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_ai_d_reg_write_0_c4a0a000() {
    // Test LDFF1SH_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC4A0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SH_Z.P.BR_S32 Tests
// ============================================================================

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rm_0_min_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rm_1_poweroftwo_6000_a5216000() {
    // Encoding: 0xA5216000
    // Test LDFF1SH_Z.P.BR_S32 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=1
    let encoding: u32 = 0xA5216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rm_30_poweroftwominusone_6000_a53e6000() {
    // Encoding: 0xA53E6000
    // Test LDFF1SH_Z.P.BR_S32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=30, Zt=0
    let encoding: u32 = 0xA53E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rm_31_max_6000_a53f6000() {
    // Encoding: 0xA53F6000
    // Test LDFF1SH_Z.P.BR_S32 field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA53F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_pg_0_min_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_pg_1_poweroftwo_6000_a5206400() {
    // Encoding: 0xA5206400
    // Test LDFF1SH_Z.P.BR_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rn_0_min_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rn_1_poweroftwo_6000_a5206020() {
    // Encoding: 0xA5206020
    // Test LDFF1SH_Z.P.BR_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rn_30_poweroftwominusone_6000_a52063c0() {
    // Encoding: 0xA52063C0
    // Test LDFF1SH_Z.P.BR_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA52063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_br_s32_field_rn_31_max_6000_a52063e0() {
    // Encoding: 0xA52063E0
    // Test LDFF1SH_Z.P.BR_S32 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_br_s32_field_zt_0_min_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_br_s32_field_zt_1_poweroftwo_6000_a5206001() {
    // Encoding: 0xA5206001
    // Test LDFF1SH_Z.P.BR_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Zt=1, Pg=0
    let encoding: u32 = 0xA5206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_br_s32_field_zt_30_poweroftwominusone_6000_a520601e() {
    // Encoding: 0xA520601E
    // Test LDFF1SH_Z.P.BR_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA520601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_br_s32_field_zt_31_max_6000_a520601f() {
    // Encoding: 0xA520601F
    // Test LDFF1SH_Z.P.BR_S32 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=31
    let encoding: u32 = 0xA520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sh_z_p_br_s32_combo_0_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_br_s32_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a52063e0() {
    // Encoding: 0xA52063E0
    // Test LDFF1SH_Z.P.BR_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_br_s32_invalid_0_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_br_s32_invalid_1_6000_a5206000() {
    // Encoding: 0xA5206000
    // Test LDFF1SH_Z.P.BR_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rm_0_min_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rm_1_poweroftwo_6000_a5016000() {
    // Encoding: 0xA5016000
    // Test LDFF1SH_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Rm=1, Pg=0
    let encoding: u32 = 0xA5016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rm_30_poweroftwominusone_6000_a51e6000() {
    // Encoding: 0xA51E6000
    // Test LDFF1SH_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA51E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rm_31_max_6000_a51f6000() {
    // Encoding: 0xA51F6000
    // Test LDFF1SH_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xA51F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_pg_0_min_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_pg_1_poweroftwo_6000_a5006400() {
    // Encoding: 0xA5006400
    // Test LDFF1SH_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, Rm=0
    let encoding: u32 = 0xA5006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rn_0_min_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rn_1_poweroftwo_6000_a5006020() {
    // Encoding: 0xA5006020
    // Test LDFF1SH_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, Rm=0
    let encoding: u32 = 0xA5006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rn_30_poweroftwominusone_6000_a50063c0() {
    // Encoding: 0xA50063C0
    // Test LDFF1SH_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=30, Zt=0
    let encoding: u32 = 0xA50063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_br_s64_field_rn_31_max_6000_a50063e0() {
    // Encoding: 0xA50063E0
    // Test LDFF1SH_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_br_s64_field_zt_0_min_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_br_s64_field_zt_1_poweroftwo_6000_a5006001() {
    // Encoding: 0xA5006001
    // Test LDFF1SH_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=1
    let encoding: u32 = 0xA5006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_br_s64_field_zt_30_poweroftwominusone_6000_a500601e() {
    // Encoding: 0xA500601E
    // Test LDFF1SH_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, Zt=30, Pg=0
    let encoding: u32 = 0xA500601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_br_s64_field_zt_31_max_6000_a500601f() {
    // Encoding: 0xA500601F
    // Test LDFF1SH_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Zt=31, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA500601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sh_z_p_br_s64_combo_0_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a50063e0() {
    // Encoding: 0xA50063E0
    // Test LDFF1SH_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_br_s64_invalid_0_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_br_s64_invalid_1_6000_a5006000() {
    // Encoding: 0xA5006000
    // Test LDFF1SH_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_br_s32_reg_write_0_a5206000() {
    // Test LDFF1SH_Z.P.BR_S32 register write: SimdFromField("t")
    // Encoding: 0xA5206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BR_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_br_s32_sp_rn_a52063e0() {
    // Test LDFF1SH_Z.P.BR_S32 with Rn = SP (31)
    // Encoding: 0xA52063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA52063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_br_s64_reg_write_0_a5006000() {
    // Test LDFF1SH_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA5006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_br_s64_sp_rn_a50063e0() {
    // Test LDFF1SH_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA50063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA50063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDR_Z.BI__ Tests
// ============================================================================

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldr_z_bi_field_imm9h_0_zero_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ field imm9h = 0 (Zero)
    // Fields: Rn=0, imm9h=0, imm9l=0, Zt=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldr_z_bi_field_imm9h_1_poweroftwo_4000_85814000() {
    // Encoding: 0x85814000
    // Test LDR_Z.BI__ field imm9h = 1 (PowerOfTwo)
    // Fields: imm9l=0, Rn=0, imm9h=1, Zt=0
    let encoding: u32 = 0x85814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldr_z_bi_field_imm9h_3_poweroftwominusone_4000_85834000() {
    // Encoding: 0x85834000
    // Test LDR_Z.BI__ field imm9h = 3 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Zt=0, imm9h=3, Rn=0
    let encoding: u32 = 0x85834000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldr_z_bi_field_imm9h_4_poweroftwo_4000_85844000() {
    // Encoding: 0x85844000
    // Test LDR_Z.BI__ field imm9h = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm9l=0, imm9h=4
    let encoding: u32 = 0x85844000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldr_z_bi_field_imm9h_7_poweroftwominusone_4000_85874000() {
    // Encoding: 0x85874000
    // Test LDR_Z.BI__ field imm9h = 7 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Rn=0, Zt=0, imm9h=7
    let encoding: u32 = 0x85874000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldr_z_bi_field_imm9h_8_poweroftwo_4000_85884000() {
    // Encoding: 0x85884000
    // Test LDR_Z.BI__ field imm9h = 8 (PowerOfTwo)
    // Fields: Zt=0, imm9l=0, Rn=0, imm9h=8
    let encoding: u32 = 0x85884000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ldr_z_bi_field_imm9h_15_poweroftwominusone_4000_858f4000() {
    // Encoding: 0x858F4000
    // Test LDR_Z.BI__ field imm9h = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm9h=15, Zt=0, imm9l=0
    let encoding: u32 = 0x858F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldr_z_bi_field_imm9h_16_poweroftwo_4000_85904000() {
    // Encoding: 0x85904000
    // Test LDR_Z.BI__ field imm9h = 16 (PowerOfTwo)
    // Fields: Zt=0, imm9h=16, Rn=0, imm9l=0
    let encoding: u32 = 0x85904000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ldr_z_bi_field_imm9h_31_poweroftwominusone_4000_859f4000() {
    // Encoding: 0x859F4000
    // Test LDR_Z.BI__ field imm9h = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm9h=31, Rn=0, imm9l=0
    let encoding: u32 = 0x859F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ldr_z_bi_field_imm9h_32_poweroftwo_4000_85a04000() {
    // Encoding: 0x85A04000
    // Test LDR_Z.BI__ field imm9h = 32 (PowerOfTwo)
    // Fields: imm9l=0, imm9h=32, Zt=0, Rn=0
    let encoding: u32 = 0x85A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ldr_z_bi_field_imm9h_63_max_4000_85bf4000() {
    // Encoding: 0x85BF4000
    // Test LDR_Z.BI__ field imm9h = 63 (Max)
    // Fields: Zt=0, imm9h=63, imm9l=0, Rn=0
    let encoding: u32 = 0x85BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldr_z_bi_field_imm9l_0_zero_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ field imm9l = 0 (Zero)
    // Fields: Zt=0, imm9h=0, imm9l=0, Rn=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldr_z_bi_field_imm9l_1_poweroftwo_4000_85804400() {
    // Encoding: 0x85804400
    // Test LDR_Z.BI__ field imm9l = 1 (PowerOfTwo)
    // Fields: imm9h=0, imm9l=1, Rn=0, Zt=0
    let encoding: u32 = 0x85804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_ldr_z_bi_field_imm9l_3_poweroftwominusone_4000_85804c00() {
    // Encoding: 0x85804C00
    // Test LDR_Z.BI__ field imm9l = 3 (PowerOfTwoMinusOne)
    // Fields: imm9h=0, Rn=0, Zt=0, imm9l=3
    let encoding: u32 = 0x85804C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_ldr_z_bi_field_imm9l_7_max_4000_85805c00() {
    // Encoding: 0x85805C00
    // Test LDR_Z.BI__ field imm9l = 7 (Max)
    // Fields: imm9h=0, imm9l=7, Rn=0, Zt=0
    let encoding: u32 = 0x85805C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldr_z_bi_field_rn_0_min_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ field Rn = 0 (Min)
    // Fields: Rn=0, imm9l=0, imm9h=0, Zt=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldr_z_bi_field_rn_1_poweroftwo_4000_85804020() {
    // Encoding: 0x85804020
    // Test LDR_Z.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm9h=0, Rn=1, imm9l=0
    let encoding: u32 = 0x85804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldr_z_bi_field_rn_30_poweroftwominusone_4000_858043c0() {
    // Encoding: 0x858043C0
    // Test LDR_Z.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Rn=30, Zt=0, imm9h=0
    let encoding: u32 = 0x858043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldr_z_bi_field_rn_31_max_4000_858043e0() {
    // Encoding: 0x858043E0
    // Test LDR_Z.BI__ field Rn = 31 (Max)
    // Fields: imm9l=0, imm9h=0, Rn=31, Zt=0
    let encoding: u32 = 0x858043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldr_z_bi_field_zt_0_min_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ field Zt = 0 (Min)
    // Fields: imm9l=0, Zt=0, Rn=0, imm9h=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldr_z_bi_field_zt_1_poweroftwo_4000_85804001() {
    // Encoding: 0x85804001
    // Test LDR_Z.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm9h=0, imm9l=0, Zt=1
    let encoding: u32 = 0x85804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldr_z_bi_field_zt_30_poweroftwominusone_4000_8580401e() {
    // Encoding: 0x8580401E
    // Test LDR_Z.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm9l=0, imm9h=0, Zt=30
    let encoding: u32 = 0x8580401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldr_z_bi_field_zt_31_max_4000_8580401f() {
    // Encoding: 0x8580401F
    // Test LDR_Z.BI__ field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, imm9h=0, imm9l=0
    let encoding: u32 = 0x8580401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm9h=0 (immediate value 0)
#[test]
fn test_ldr_z_bi_combo_0_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ field combination: imm9h=0, imm9l=0, Rn=0, Zt=0
    // Fields: imm9h=0, Zt=0, imm9l=0, Rn=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldr_z_bi_special_rn_31_stack_pointer_sp_may_require_alignment_16384_858043e0() {
    // Encoding: 0x858043E0
    // Test LDR_Z.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm9h=0, imm9l=0, Rn=31, Zt=0
    let encoding: u32 = 0x858043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldr_z_bi_invalid_0_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm9h=0, Rn=0, Zt=0, imm9l=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldr_z_bi_invalid_1_4000_85804000() {
    // Encoding: 0x85804000
    // Test LDR_Z.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm9h=0, Zt=0, Rn=0, imm9l=0
    let encoding: u32 = 0x85804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDR_Z.BI__
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldr_z_bi_reg_write_0_85804000() {
    // Test LDR_Z.BI__ register write: SimdFromField("t")
    // Encoding: 0x85804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDR_Z.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldr_z_bi_sp_rn_858043e0() {
    // Test LDR_Z.BI__ with Rn = SP (31)
    // Encoding: 0x858043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x858043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1H_Z.P.BR_U16 Tests
// ============================================================================

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u16_field_rm_0_min_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u16_field_rm_1_poweroftwo_6000_a4a16000() {
    // Encoding: 0xA4A16000
    // Test LDFF1H_Z.P.BR_U16 field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Zt=0, Pg=0
    let encoding: u32 = 0xA4A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u16_field_rm_30_poweroftwominusone_6000_a4be6000() {
    // Encoding: 0xA4BE6000
    // Test LDFF1H_Z.P.BR_U16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=30
    let encoding: u32 = 0xA4BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1h_z_p_br_u16_field_rm_31_max_6000_a4bf6000() {
    // Encoding: 0xA4BF6000
    // Test LDFF1H_Z.P.BR_U16 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xA4BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u16_field_pg_0_min_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u16_field_pg_1_poweroftwo_6000_a4a06400() {
    // Encoding: 0xA4A06400
    // Test LDFF1H_Z.P.BR_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA4A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u16_field_rn_0_min_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u16_field_rn_1_poweroftwo_6000_a4a06020() {
    // Encoding: 0xA4A06020
    // Test LDFF1H_Z.P.BR_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=1, Zt=0
    let encoding: u32 = 0xA4A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u16_field_rn_30_poweroftwominusone_6000_a4a063c0() {
    // Encoding: 0xA4A063C0
    // Test LDFF1H_Z.P.BR_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_br_u16_field_rn_31_max_6000_a4a063e0() {
    // Encoding: 0xA4A063E0
    // Test LDFF1H_Z.P.BR_U16 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, Rm=0
    let encoding: u32 = 0xA4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_br_u16_field_zt_0_min_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_br_u16_field_zt_1_poweroftwo_6000_a4a06001() {
    // Encoding: 0xA4A06001
    // Test LDFF1H_Z.P.BR_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_br_u16_field_zt_30_poweroftwominusone_6000_a4a0601e() {
    // Encoding: 0xA4A0601E
    // Test LDFF1H_Z.P.BR_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA4A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_br_u16_field_zt_31_max_6000_a4a0601f() {
    // Encoding: 0xA4A0601F
    // Test LDFF1H_Z.P.BR_U16 field Zt = 31 (Max)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=31
    let encoding: u32 = 0xA4A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1h_z_p_br_u16_combo_0_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_br_u16_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a4a063e0() {
    // Encoding: 0xA4A063E0
    // Test LDFF1H_Z.P.BR_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u16_invalid_0_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u16_invalid_1_6000_a4a06000() {
    // Encoding: 0xA4A06000
    // Test LDFF1H_Z.P.BR_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u32_field_rm_0_min_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u32_field_rm_1_poweroftwo_6000_a4c16000() {
    // Encoding: 0xA4C16000
    // Test LDFF1H_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA4C16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u32_field_rm_30_poweroftwominusone_6000_a4de6000() {
    // Encoding: 0xA4DE6000
    // Test LDFF1H_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=30
    let encoding: u32 = 0xA4DE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1h_z_p_br_u32_field_rm_31_max_6000_a4df6000() {
    // Encoding: 0xA4DF6000
    // Test LDFF1H_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Rn=0, Zt=0, Rm=31, Pg=0
    let encoding: u32 = 0xA4DF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u32_field_pg_0_min_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u32_field_pg_1_poweroftwo_6000_a4c06400() {
    // Encoding: 0xA4C06400
    // Test LDFF1H_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4C06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u32_field_rn_0_min_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u32_field_rn_1_poweroftwo_6000_a4c06020() {
    // Encoding: 0xA4C06020
    // Test LDFF1H_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4C06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u32_field_rn_30_poweroftwominusone_6000_a4c063c0() {
    // Encoding: 0xA4C063C0
    // Test LDFF1H_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=30, Zt=0
    let encoding: u32 = 0xA4C063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_br_u32_field_rn_31_max_6000_a4c063e0() {
    // Encoding: 0xA4C063E0
    // Test LDFF1H_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xA4C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_br_u32_field_zt_0_min_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_br_u32_field_zt_1_poweroftwo_6000_a4c06001() {
    // Encoding: 0xA4C06001
    // Test LDFF1H_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_br_u32_field_zt_30_poweroftwominusone_6000_a4c0601e() {
    // Encoding: 0xA4C0601E
    // Test LDFF1H_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_br_u32_field_zt_31_max_6000_a4c0601f() {
    // Encoding: 0xA4C0601F
    // Test LDFF1H_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4C0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1h_z_p_br_u32_combo_0_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a4c063e0() {
    // Encoding: 0xA4C063E0
    // Test LDFF1H_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA4C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u32_invalid_0_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u32_invalid_1_6000_a4c06000() {
    // Encoding: 0xA4C06000
    // Test LDFF1H_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u64_field_rm_0_min_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u64_field_rm_1_poweroftwo_6000_a4e16000() {
    // Encoding: 0xA4E16000
    // Test LDFF1H_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u64_field_rm_30_poweroftwominusone_6000_a4fe6000() {
    // Encoding: 0xA4FE6000
    // Test LDFF1H_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1h_z_p_br_u64_field_rm_31_max_6000_a4ff6000() {
    // Encoding: 0xA4FF6000
    // Test LDFF1H_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=31
    let encoding: u32 = 0xA4FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u64_field_pg_0_min_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u64_field_pg_1_poweroftwo_6000_a4e06400() {
    // Encoding: 0xA4E06400
    // Test LDFF1H_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0xA4E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_br_u64_field_rn_0_min_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_br_u64_field_rn_1_poweroftwo_6000_a4e06020() {
    // Encoding: 0xA4E06020
    // Test LDFF1H_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xA4E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_br_u64_field_rn_30_poweroftwominusone_6000_a4e063c0() {
    // Encoding: 0xA4E063C0
    // Test LDFF1H_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=30
    let encoding: u32 = 0xA4E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_br_u64_field_rn_31_max_6000_a4e063e0() {
    // Encoding: 0xA4E063E0
    // Test LDFF1H_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_br_u64_field_zt_0_min_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_br_u64_field_zt_1_poweroftwo_6000_a4e06001() {
    // Encoding: 0xA4E06001
    // Test LDFF1H_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_br_u64_field_zt_30_poweroftwominusone_6000_a4e0601e() {
    // Encoding: 0xA4E0601E
    // Test LDFF1H_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_br_u64_field_zt_31_max_6000_a4e0601f() {
    // Encoding: 0xA4E0601F
    // Test LDFF1H_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=31
    let encoding: u32 = 0xA4E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1h_z_p_br_u64_combo_0_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a4e063e0() {
    // Encoding: 0xA4E063E0
    // Test LDFF1H_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u64_invalid_0_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_br_u64_invalid_1_6000_a4e06000() {
    // Encoding: 0xA4E06000
    // Test LDFF1H_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_br_u16_reg_write_0_a4a06000() {
    // Test LDFF1H_Z.P.BR_U16 register write: SimdFromField("t")
    // Encoding: 0xA4A06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BR_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_br_u16_sp_rn_a4a063e0() {
    // Test LDFF1H_Z.P.BR_U16 with Rn = SP (31)
    // Encoding: 0xA4A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_br_u32_reg_write_0_a4c06000() {
    // Test LDFF1H_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA4C06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_br_u32_sp_rn_a4c063e0() {
    // Test LDFF1H_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA4C063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_br_u64_reg_write_0_a4e06000() {
    // Test LDFF1H_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA4E06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_br_u64_sp_rn_a4e063e0() {
    // Test LDFF1H_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA4E063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1H_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_0_zero_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_1_poweroftwo_e000_84a1e000() {
    // Encoding: 0x84A1E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x84A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_3_poweroftwominusone_e000_84a3e000() {
    // Encoding: 0x84A3E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=3, Zn=0
    let encoding: u32 = 0x84A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_4_poweroftwo_e000_84a4e000() {
    // Encoding: 0x84A4E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0x84A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_7_poweroftwominusone_e000_84a7e000() {
    // Encoding: 0x84A7E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=7
    let encoding: u32 = 0x84A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_8_poweroftwo_e000_84a8e000() {
    // Encoding: 0x84A8E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm5=8, Pg=0, Zn=0
    let encoding: u32 = 0x84A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_15_poweroftwominusone_e000_84afe000() {
    // Encoding: 0x84AFE000
    // Test LDFF1H_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=15, Pg=0, Zt=0
    let encoding: u32 = 0x84AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_16_poweroftwo_e000_84b0e000() {
    // Encoding: 0x84B0E000
    // Test LDFF1H_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=16
    let encoding: u32 = 0x84B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1h_z_p_ai_s_field_imm5_31_max_e000_84bfe000() {
    // Encoding: 0x84BFE000
    // Test LDFF1H_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Pg=0, Zn=0
    let encoding: u32 = 0x84BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_ai_s_field_pg_0_min_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_ai_s_field_pg_1_poweroftwo_e000_84a0e400() {
    // Encoding: 0x84A0E400
    // Test LDFF1H_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Zn=0, imm5=0
    let encoding: u32 = 0x84A0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_ai_s_field_zn_0_min_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_ai_s_field_zn_1_poweroftwo_e000_84a0e020() {
    // Encoding: 0x84A0E020
    // Test LDFF1H_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=1
    let encoding: u32 = 0x84A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_ai_s_field_zn_30_poweroftwominusone_e000_84a0e3c0() {
    // Encoding: 0x84A0E3C0
    // Test LDFF1H_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, imm5=0, Zt=0
    let encoding: u32 = 0x84A0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_ai_s_field_zn_31_max_e000_84a0e3e0() {
    // Encoding: 0x84A0E3E0
    // Test LDFF1H_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=31
    let encoding: u32 = 0x84A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_ai_s_field_zt_0_min_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_ai_s_field_zt_1_poweroftwo_e000_84a0e001() {
    // Encoding: 0x84A0E001
    // Test LDFF1H_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0x84A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_ai_s_field_zt_30_poweroftwominusone_e000_84a0e01e() {
    // Encoding: 0x84A0E01E
    // Test LDFF1H_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=30, imm5=0
    let encoding: u32 = 0x84A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_ai_s_field_zt_31_max_e000_84a0e01f() {
    // Encoding: 0x84A0E01F
    // Test LDFF1H_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=31
    let encoding: u32 = 0x84A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1h_z_p_ai_s_combo_0_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_ai_s_invalid_0_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_ai_s_invalid_1_e000_84a0e000() {
    // Encoding: 0x84A0E000
    // Test LDFF1H_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0x84A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_0_zero_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_1_poweroftwo_e000_c4a1e000() {
    // Encoding: 0xC4A1E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_3_poweroftwominusone_e000_c4a3e000() {
    // Encoding: 0xC4A3E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=3
    let encoding: u32 = 0xC4A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_4_poweroftwo_e000_c4a4e000() {
    // Encoding: 0xC4A4E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=4
    let encoding: u32 = 0xC4A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_7_poweroftwominusone_e000_c4a7e000() {
    // Encoding: 0xC4A7E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=7
    let encoding: u32 = 0xC4A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_8_poweroftwo_e000_c4a8e000() {
    // Encoding: 0xC4A8E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, imm5=8, Zt=0, Pg=0
    let encoding: u32 = 0xC4A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_15_poweroftwominusone_e000_c4afe000() {
    // Encoding: 0xC4AFE000
    // Test LDFF1H_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC4AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_16_poweroftwo_e000_c4b0e000() {
    // Encoding: 0xC4B0E000
    // Test LDFF1H_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, imm5=16, Pg=0, Zn=0
    let encoding: u32 = 0xC4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1h_z_p_ai_d_field_imm5_31_max_e000_c4bfe000() {
    // Encoding: 0xC4BFE000
    // Test LDFF1H_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, imm5=31, Zn=0, Zt=0
    let encoding: u32 = 0xC4BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_ai_d_field_pg_0_min_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_ai_d_field_pg_1_poweroftwo_e000_c4a0e400() {
    // Encoding: 0xC4A0E400
    // Test LDFF1H_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_ai_d_field_zn_0_min_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_ai_d_field_zn_1_poweroftwo_e000_c4a0e020() {
    // Encoding: 0xC4A0E020
    // Test LDFF1H_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_ai_d_field_zn_30_poweroftwominusone_e000_c4a0e3c0() {
    // Encoding: 0xC4A0E3C0
    // Test LDFF1H_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=30
    let encoding: u32 = 0xC4A0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_ai_d_field_zn_31_max_e000_c4a0e3e0() {
    // Encoding: 0xC4A0E3E0
    // Test LDFF1H_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_ai_d_field_zt_0_min_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_ai_d_field_zt_1_poweroftwo_e000_c4a0e001() {
    // Encoding: 0xC4A0E001
    // Test LDFF1H_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_ai_d_field_zt_30_poweroftwominusone_e000_c4a0e01e() {
    // Encoding: 0xC4A0E01E
    // Test LDFF1H_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=30, imm5=0, Pg=0
    let encoding: u32 = 0xC4A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_ai_d_field_zt_31_max_e000_c4a0e01f() {
    // Encoding: 0xC4A0E01F
    // Test LDFF1H_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Pg=0, imm5=0, Zt=31, Zn=0
    let encoding: u32 = 0xC4A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1h_z_p_ai_d_combo_0_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_ai_d_invalid_0_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_ai_d_invalid_1_e000_c4a0e000() {
    // Encoding: 0xC4A0E000
    // Test LDFF1H_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xC4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_ai_s_reg_write_0_84a0e000() {
    // Test LDFF1H_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x84A0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_ai_d_reg_write_0_c4a0e000() {
    // Test LDFF1H_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC4A0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RH_Z.P.BI_U16 Tests
// ============================================================================

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_0_zero_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 0 (Zero)
    // Fields: Rn=0, imm6=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_1_poweroftwo_a000_84c1a000() {
    // Encoding: 0x84C1A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm6=1, Pg=0, Zt=0
    let encoding: u32 = 0x84C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_3_poweroftwominusone_a000_84c3a000() {
    // Encoding: 0x84C3A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, imm6=3, Pg=0
    let encoding: u32 = 0x84C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_4_poweroftwo_a000_84c4a000() {
    // Encoding: 0x84C4A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm6=4, Pg=0
    let encoding: u32 = 0x84C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_7_poweroftwominusone_a000_84c7a000() {
    // Encoding: 0x84C7A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm6=7, Rn=0
    let encoding: u32 = 0x84C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_8_poweroftwo_a000_84c8a000() {
    // Encoding: 0x84C8A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 8 (PowerOfTwo)
    // Fields: Rn=0, imm6=8, Zt=0, Pg=0
    let encoding: u32 = 0x84C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_15_poweroftwominusone_a000_84cfa000() {
    // Encoding: 0x84CFA000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm6=15, Zt=0
    let encoding: u32 = 0x84CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_16_poweroftwo_a000_84d0a000() {
    // Encoding: 0x84D0A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 16 (PowerOfTwo)
    // Fields: Pg=0, imm6=16, Zt=0, Rn=0
    let encoding: u32 = 0x84D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_31_poweroftwominusone_a000_84dfa000() {
    // Encoding: 0x84DFA000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm6=31, Zt=0
    let encoding: u32 = 0x84DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_32_poweroftwo_a000_84e0a000() {
    // Encoding: 0x84E0A000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Rn=0, Zt=0
    let encoding: u32 = 0x84E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rh_z_p_bi_u16_field_imm6_63_max_a000_84ffa000() {
    // Encoding: 0x84FFA000
    // Test LD1RH_Z.P.BI_U16 field imm6 = 63 (Max)
    // Fields: imm6=63, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u16_field_pg_0_min_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u16_field_pg_1_poweroftwo_a000_84c0a400() {
    // Encoding: 0x84C0A400
    // Test LD1RH_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u16_field_rn_0_min_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u16_field_rn_1_poweroftwo_a000_84c0a020() {
    // Encoding: 0x84C0A020
    // Test LD1RH_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=0, Pg=0, Rn=1
    let encoding: u32 = 0x84C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rh_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_84c0a3c0() {
    // Encoding: 0x84C0A3C0
    // Test LD1RH_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0x84C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rh_z_p_bi_u16_field_rn_31_max_a000_84c0a3e0() {
    // Encoding: 0x84C0A3E0
    // Test LD1RH_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: imm6=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0x84C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rh_z_p_bi_u16_field_zt_0_min_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rh_z_p_bi_u16_field_zt_1_poweroftwo_a000_84c0a001() {
    // Encoding: 0x84C0A001
    // Test LD1RH_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, imm6=0
    let encoding: u32 = 0x84C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rh_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_84c0a01e() {
    // Encoding: 0x84C0A01E
    // Test LD1RH_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, imm6=0
    let encoding: u32 = 0x84C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rh_z_p_bi_u16_field_zt_31_max_a000_84c0a01f() {
    // Encoding: 0x84C0A01F
    // Test LD1RH_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: Rn=0, imm6=0, Zt=31, Pg=0
    let encoding: u32 = 0x84C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rh_z_p_bi_u16_combo_0_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: imm6=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rh_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_84c0a3e0() {
    // Encoding: 0x84C0A3E0
    // Test LD1RH_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x84C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u16_invalid_0_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u16_invalid_1_a000_84c0a000() {
    // Encoding: 0x84C0A000
    // Test LD1RH_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, imm6=0
    let encoding: u32 = 0x84C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_0_zero_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_1_poweroftwo_c000_84c1c000() {
    // Encoding: 0x84C1C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=1
    let encoding: u32 = 0x84C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_3_poweroftwominusone_c000_84c3c000() {
    // Encoding: 0x84C3C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm6=3, Rn=0
    let encoding: u32 = 0x84C3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_4_poweroftwo_c000_84c4c000() {
    // Encoding: 0x84C4C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=4
    let encoding: u32 = 0x84C4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_7_poweroftwominusone_c000_84c7c000() {
    // Encoding: 0x84C7C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=7, Pg=0, Rn=0
    let encoding: u32 = 0x84C7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_8_poweroftwo_c000_84c8c000() {
    // Encoding: 0x84C8C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm6=8, Zt=0
    let encoding: u32 = 0x84C8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_15_poweroftwominusone_c000_84cfc000() {
    // Encoding: 0x84CFC000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: imm6=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84CFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_16_poweroftwo_c000_84d0c000() {
    // Encoding: 0x84D0C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 16 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm6=16, Pg=0
    let encoding: u32 = 0x84D0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_31_poweroftwominusone_c000_84dfc000() {
    // Encoding: 0x84DFC000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm6=31, Pg=0, Zt=0
    let encoding: u32 = 0x84DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_32_poweroftwo_c000_84e0c000() {
    // Encoding: 0x84E0C000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 32 (PowerOfTwo)
    // Fields: Zt=0, imm6=32, Rn=0, Pg=0
    let encoding: u32 = 0x84E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rh_z_p_bi_u32_field_imm6_63_max_c000_84ffc000() {
    // Encoding: 0x84FFC000
    // Test LD1RH_Z.P.BI_U32 field imm6 = 63 (Max)
    // Fields: imm6=63, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u32_field_pg_0_min_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u32_field_pg_1_poweroftwo_c000_84c0c400() {
    // Encoding: 0x84C0C400
    // Test LD1RH_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, imm6=0
    let encoding: u32 = 0x84C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u32_field_rn_0_min_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u32_field_rn_1_poweroftwo_c000_84c0c020() {
    // Encoding: 0x84C0C020
    // Test LD1RH_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0x84C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rh_z_p_bi_u32_field_rn_30_poweroftwominusone_c000_84c0c3c0() {
    // Encoding: 0x84C0C3C0
    // Test LD1RH_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rh_z_p_bi_u32_field_rn_31_max_c000_84c0c3e0() {
    // Encoding: 0x84C0C3E0
    // Test LD1RH_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, imm6=0, Pg=0
    let encoding: u32 = 0x84C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rh_z_p_bi_u32_field_zt_0_min_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rh_z_p_bi_u32_field_zt_1_poweroftwo_c000_84c0c001() {
    // Encoding: 0x84C0C001
    // Test LD1RH_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0x84C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rh_z_p_bi_u32_field_zt_30_poweroftwominusone_c000_84c0c01e() {
    // Encoding: 0x84C0C01E
    // Test LD1RH_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=30, imm6=0
    let encoding: u32 = 0x84C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rh_z_p_bi_u32_field_zt_31_max_c000_84c0c01f() {
    // Encoding: 0x84C0C01F
    // Test LD1RH_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, imm6=0, Rn=0
    let encoding: u32 = 0x84C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rh_z_p_bi_u32_combo_0_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: imm6=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rh_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_49152_84c0c3e0() {
    // Encoding: 0x84C0C3E0
    // Test LD1RH_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=31
    let encoding: u32 = 0x84C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u32_invalid_0_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u32_invalid_1_c000_84c0c000() {
    // Encoding: 0x84C0C000
    // Test LD1RH_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_0_zero_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_1_poweroftwo_e000_84c1e000() {
    // Encoding: 0x84C1E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=1
    let encoding: u32 = 0x84C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_3_poweroftwominusone_e000_84c3e000() {
    // Encoding: 0x84C3E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84C3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_4_poweroftwo_e000_84c4e000() {
    // Encoding: 0x84C4E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_7_poweroftwominusone_e000_84c7e000() {
    // Encoding: 0x84C7E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm6=7, Rn=0
    let encoding: u32 = 0x84C7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_8_poweroftwo_e000_84c8e000() {
    // Encoding: 0x84C8E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm6=8, Zt=0, Rn=0
    let encoding: u32 = 0x84C8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_15_poweroftwominusone_e000_84cfe000() {
    // Encoding: 0x84CFE000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=15
    let encoding: u32 = 0x84CFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_16_poweroftwo_e000_84d0e000() {
    // Encoding: 0x84D0E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 16 (PowerOfTwo)
    // Fields: imm6=16, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_31_poweroftwominusone_e000_84dfe000() {
    // Encoding: 0x84DFE000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Rn=0, Pg=0
    let encoding: u32 = 0x84DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_32_poweroftwo_e000_84e0e000() {
    // Encoding: 0x84E0E000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Rn=0, Zt=0
    let encoding: u32 = 0x84E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rh_z_p_bi_u64_field_imm6_63_max_e000_84ffe000() {
    // Encoding: 0x84FFE000
    // Test LD1RH_Z.P.BI_U64 field imm6 = 63 (Max)
    // Fields: Zt=0, Rn=0, imm6=63, Pg=0
    let encoding: u32 = 0x84FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u64_field_pg_0_min_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Pg=0, imm6=0, Zt=0, Rn=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u64_field_pg_1_poweroftwo_e000_84c0e400() {
    // Encoding: 0x84C0E400
    // Test LD1RH_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=0, Pg=1, Rn=0
    let encoding: u32 = 0x84C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rh_z_p_bi_u64_field_rn_0_min_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rh_z_p_bi_u64_field_rn_1_poweroftwo_e000_84c0e020() {
    // Encoding: 0x84C0E020
    // Test LD1RH_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=1
    let encoding: u32 = 0x84C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rh_z_p_bi_u64_field_rn_30_poweroftwominusone_e000_84c0e3c0() {
    // Encoding: 0x84C0E3C0
    // Test LD1RH_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=30
    let encoding: u32 = 0x84C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rh_z_p_bi_u64_field_rn_31_max_e000_84c0e3e0() {
    // Encoding: 0x84C0E3E0
    // Test LD1RH_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, imm6=0, Rn=31, Zt=0
    let encoding: u32 = 0x84C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rh_z_p_bi_u64_field_zt_0_min_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rh_z_p_bi_u64_field_zt_1_poweroftwo_e000_84c0e001() {
    // Encoding: 0x84C0E001
    // Test LD1RH_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: imm6=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0x84C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rh_z_p_bi_u64_field_zt_30_poweroftwominusone_e000_84c0e01e() {
    // Encoding: 0x84C0E01E
    // Test LD1RH_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm6=0, Pg=0, Rn=0
    let encoding: u32 = 0x84C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rh_z_p_bi_u64_field_zt_31_max_e000_84c0e01f() {
    // Encoding: 0x84C0E01F
    // Test LD1RH_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0x84C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rh_z_p_bi_u64_combo_0_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm6=0, Zt=0, Rn=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rh_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_57344_84c0e3e0() {
    // Encoding: 0x84C0E3E0
    // Test LD1RH_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0x84C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u64_invalid_0_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rh_z_p_bi_u64_invalid_1_e000_84c0e000() {
    // Encoding: 0x84C0E000
    // Test LD1RH_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x84C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rh_z_p_bi_u16_reg_write_0_84c0a000() {
    // Test LD1RH_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0x84C0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RH_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rh_z_p_bi_u16_sp_rn_84c0a3e0() {
    // Test LD1RH_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0x84C0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rh_z_p_bi_u32_reg_write_0_84c0c000() {
    // Test LD1RH_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0x84C0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RH_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rh_z_p_bi_u32_sp_rn_84c0c3e0() {
    // Test LD1RH_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0x84C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rh_z_p_bi_u64_reg_write_0_84c0e000() {
    // Test LD1RH_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0x84C0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RH_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rh_z_p_bi_u64_sp_rn_84c0e3e0() {
    // Test LD1RH_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0x84C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RSH_Z.P.BI_S32 Tests
// ============================================================================

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_0_zero_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_1_poweroftwo_a000_8541a000() {
    // Encoding: 0x8541A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=1, Pg=0, Rn=0
    let encoding: u32 = 0x8541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_3_poweroftwominusone_a000_8543a000() {
    // Encoding: 0x8543A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8543A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_4_poweroftwo_a000_8544a000() {
    // Encoding: 0x8544A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 4 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, imm6=4
    let encoding: u32 = 0x8544A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_7_poweroftwominusone_a000_8547a000() {
    // Encoding: 0x8547A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=7
    let encoding: u32 = 0x8547A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_8_poweroftwo_a000_8548a000() {
    // Encoding: 0x8548A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm6=8, Zt=0, Rn=0
    let encoding: u32 = 0x8548A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_15_poweroftwominusone_a000_854fa000() {
    // Encoding: 0x854FA000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm6=15, Zt=0
    let encoding: u32 = 0x854FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_16_poweroftwo_a000_8550a000() {
    // Encoding: 0x8550A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm6=16, Rn=0
    let encoding: u32 = 0x8550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_31_poweroftwominusone_a000_855fa000() {
    // Encoding: 0x855FA000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: imm6=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x855FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_32_poweroftwo_a000_8560a000() {
    // Encoding: 0x8560A000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Zt=0, Rn=0
    let encoding: u32 = 0x8560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_imm6_63_max_a000_857fa000() {
    // Encoding: 0x857FA000
    // Test LD1RSH_Z.P.BI_S32 field imm6 = 63 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=63
    let encoding: u32 = 0x857FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_pg_0_min_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: imm6=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_pg_1_poweroftwo_a000_8540a400() {
    // Encoding: 0x8540A400
    // Test LD1RSH_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, imm6=0, Zt=0
    let encoding: u32 = 0x8540A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_rn_0_min_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: imm6=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_rn_1_poweroftwo_a000_8540a020() {
    // Encoding: 0x8540A020
    // Test LD1RSH_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, imm6=0
    let encoding: u32 = 0x8540A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_8540a3c0() {
    // Encoding: 0x8540A3C0
    // Test LD1RSH_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm6=0, Rn=30
    let encoding: u32 = 0x8540A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsh_z_p_bi_s32_field_rn_31_max_a000_8540a3e0() {
    // Encoding: 0x8540A3E0
    // Test LD1RSH_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: imm6=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0x8540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsh_z_p_bi_s32_field_zt_0_min_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsh_z_p_bi_s32_field_zt_1_poweroftwo_a000_8540a001() {
    // Encoding: 0x8540A001
    // Test LD1RSH_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm6=0
    let encoding: u32 = 0x8540A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsh_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_8540a01e() {
    // Encoding: 0x8540A01E
    // Test LD1RSH_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=30
    let encoding: u32 = 0x8540A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsh_z_p_bi_s32_field_zt_31_max_a000_8540a01f() {
    // Encoding: 0x8540A01F
    // Test LD1RSH_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0x8540A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsh_z_p_bi_s32_combo_0_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: imm6=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsh_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_8540a3e0() {
    // Encoding: 0x8540A3E0
    // Test LD1RSH_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0x8540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsh_z_p_bi_s32_invalid_0_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm6=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsh_z_p_bi_s32_invalid_1_a000_8540a000() {
    // Encoding: 0x8540A000
    // Test LD1RSH_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, imm6=0
    let encoding: u32 = 0x8540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_0_zero_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_1_poweroftwo_8000_85418000() {
    // Encoding: 0x85418000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm6=1, Rn=0
    let encoding: u32 = 0x85418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_3_poweroftwominusone_8000_85438000() {
    // Encoding: 0x85438000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=3
    let encoding: u32 = 0x85438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_4_poweroftwo_8000_85448000() {
    // Encoding: 0x85448000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x85448000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_7_poweroftwominusone_8000_85478000() {
    // Encoding: 0x85478000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=7, Rn=0, Pg=0
    let encoding: u32 = 0x85478000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_8_poweroftwo_8000_85488000() {
    // Encoding: 0x85488000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85488000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_15_poweroftwominusone_8000_854f8000() {
    // Encoding: 0x854F8000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: imm6=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x854F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_16_poweroftwo_8000_85508000() {
    // Encoding: 0x85508000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 16 (PowerOfTwo)
    // Fields: imm6=16, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_31_poweroftwominusone_8000_855f8000() {
    // Encoding: 0x855F8000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Pg=0, Rn=0
    let encoding: u32 = 0x855F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_32_poweroftwo_8000_85608000() {
    // Encoding: 0x85608000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=32
    let encoding: u32 = 0x85608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_imm6_63_max_8000_857f8000() {
    // Encoding: 0x857F8000
    // Test LD1RSH_Z.P.BI_S64 field imm6 = 63 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=63
    let encoding: u32 = 0x857F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_pg_0_min_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_pg_1_poweroftwo_8000_85408400() {
    // Encoding: 0x85408400
    // Test LD1RSH_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, imm6=0
    let encoding: u32 = 0x85408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_rn_0_min_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_rn_1_poweroftwo_8000_85408020() {
    // Encoding: 0x85408020
    // Test LD1RSH_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0x85408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_rn_30_poweroftwominusone_8000_854083c0() {
    // Encoding: 0x854083C0
    // Test LD1RSH_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x854083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsh_z_p_bi_s64_field_rn_31_max_8000_854083e0() {
    // Encoding: 0x854083E0
    // Test LD1RSH_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x854083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsh_z_p_bi_s64_field_zt_0_min_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsh_z_p_bi_s64_field_zt_1_poweroftwo_8000_85408001() {
    // Encoding: 0x85408001
    // Test LD1RSH_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm6=0, Rn=0
    let encoding: u32 = 0x85408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsh_z_p_bi_s64_field_zt_30_poweroftwominusone_8000_8540801e() {
    // Encoding: 0x8540801E
    // Test LD1RSH_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=30
    let encoding: u32 = 0x8540801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsh_z_p_bi_s64_field_zt_31_max_8000_8540801f() {
    // Encoding: 0x8540801F
    // Test LD1RSH_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm6=0, Rn=0
    let encoding: u32 = 0x8540801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsh_z_p_bi_s64_combo_0_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, imm6=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsh_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_32768_854083e0() {
    // Encoding: 0x854083E0
    // Test LD1RSH_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, imm6=0
    let encoding: u32 = 0x854083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsh_z_p_bi_s64_invalid_0_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsh_z_p_bi_s64_invalid_1_8000_85408000() {
    // Encoding: 0x85408000
    // Test LD1RSH_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, imm6=0, Rn=0
    let encoding: u32 = 0x85408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsh_z_p_bi_s32_reg_write_0_8540a000() {
    // Test LD1RSH_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0x8540A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSH_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsh_z_p_bi_s32_sp_rn_8540a3e0() {
    // Test LD1RSH_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0x8540A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsh_z_p_bi_s64_reg_write_0_85408000() {
    // Test LD1RSH_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0x85408000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85408000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSH_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsh_z_p_bi_s64_sp_rn_854083e0() {
    // Test LD1RSH_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0x854083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x854083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1D_Z.P.AI_D Tests
// ============================================================================

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_0_zero_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_1_poweroftwo_c000_c5a1c000() {
    // Encoding: 0xC5A1C000
    // Test LD1D_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_3_poweroftwominusone_c000_c5a3c000() {
    // Encoding: 0xC5A3C000
    // Test LD1D_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC5A3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_4_poweroftwo_c000_c5a4c000() {
    // Encoding: 0xC5A4C000
    // Test LD1D_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm5=4, Zn=0, Pg=0
    let encoding: u32 = 0xC5A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_7_poweroftwominusone_c000_c5a7c000() {
    // Encoding: 0xC5A7C000
    // Test LD1D_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=7
    let encoding: u32 = 0xC5A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_8_poweroftwo_c000_c5a8c000() {
    // Encoding: 0xC5A8C000
    // Test LD1D_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=8, Pg=0
    let encoding: u32 = 0xC5A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_15_poweroftwominusone_c000_c5afc000() {
    // Encoding: 0xC5AFC000
    // Test LD1D_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=15, Zn=0, Pg=0
    let encoding: u32 = 0xC5AFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_16_poweroftwo_c000_c5b0c000() {
    // Encoding: 0xC5B0C000
    // Test LD1D_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=16, Pg=0
    let encoding: u32 = 0xC5B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1d_z_p_ai_d_field_imm5_31_max_c000_c5bfc000() {
    // Encoding: 0xC5BFC000
    // Test LD1D_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC5BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_ai_d_field_pg_0_min_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D field Pg = 0 (Min)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_ai_d_field_pg_1_poweroftwo_c000_c5a0c400() {
    // Encoding: 0xC5A0C400
    // Test LD1D_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=1
    let encoding: u32 = 0xC5A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_ai_d_field_zn_0_min_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_ai_d_field_zn_1_poweroftwo_c000_c5a0c020() {
    // Encoding: 0xC5A0C020
    // Test LD1D_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0xC5A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_ai_d_field_zn_30_poweroftwominusone_c000_c5a0c3c0() {
    // Encoding: 0xC5A0C3C0
    // Test LD1D_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=30
    let encoding: u32 = 0xC5A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_ai_d_field_zn_31_max_c000_c5a0c3e0() {
    // Encoding: 0xC5A0C3E0
    // Test LD1D_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0xC5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_ai_d_field_zt_0_min_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_ai_d_field_zt_1_poweroftwo_c000_c5a0c001() {
    // Encoding: 0xC5A0C001
    // Test LD1D_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=1
    let encoding: u32 = 0xC5A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_ai_d_field_zt_30_poweroftwominusone_c000_c5a0c01e() {
    // Encoding: 0xC5A0C01E
    // Test LD1D_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=30, Pg=0, Zn=0
    let encoding: u32 = 0xC5A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_ai_d_field_zt_31_max_c000_c5a0c01f() {
    // Encoding: 0xC5A0C01F
    // Test LD1D_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=31
    let encoding: u32 = 0xC5A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1d_z_p_ai_d_combo_0_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_ai_d_invalid_0_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_ai_d_invalid_1_c000_c5a0c000() {
    // Encoding: 0xC5A0C000
    // Test LD1D_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_ai_d_reg_write_0_c5a0c000() {
    // Test LD1D_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC5A0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1D_Z.P.BR_U64 Tests
// ============================================================================

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_br_u64_field_rm_0_min_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_br_u64_field_rm_1_poweroftwo_4000_a5e14000() {
    // Encoding: 0xA5E14000
    // Test LD1D_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5E14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_br_u64_field_rm_30_poweroftwominusone_4000_a5fe4000() {
    // Encoding: 0xA5FE4000
    // Test LD1D_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5FE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1d_z_p_br_u64_field_rm_31_max_4000_a5ff4000() {
    // Encoding: 0xA5FF4000
    // Test LD1D_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xA5FF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_br_u64_field_pg_0_min_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_br_u64_field_pg_1_poweroftwo_4000_a5e04400() {
    // Encoding: 0xA5E04400
    // Test LD1D_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0xA5E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1d_z_p_br_u64_field_rn_0_min_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1d_z_p_br_u64_field_rn_1_poweroftwo_4000_a5e04020() {
    // Encoding: 0xA5E04020
    // Test LD1D_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5E04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1d_z_p_br_u64_field_rn_30_poweroftwominusone_4000_a5e043c0() {
    // Encoding: 0xA5E043C0
    // Test LD1D_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5E043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1d_z_p_br_u64_field_rn_31_max_4000_a5e043e0() {
    // Encoding: 0xA5E043E0
    // Test LD1D_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5E043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1d_z_p_br_u64_field_zt_0_min_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1d_z_p_br_u64_field_zt_1_poweroftwo_4000_a5e04001() {
    // Encoding: 0xA5E04001
    // Test LD1D_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xA5E04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1d_z_p_br_u64_field_zt_30_poweroftwominusone_4000_a5e0401e() {
    // Encoding: 0xA5E0401E
    // Test LD1D_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5E0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1d_z_p_br_u64_field_zt_31_max_4000_a5e0401f() {
    // Encoding: 0xA5E0401F
    // Test LD1D_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Zt=31, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1d_z_p_br_u64_combo_0_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1d_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a5e043e0() {
    // Encoding: 0xA5E043E0
    // Test LD1D_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA5E043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_br_u64_invalid_0_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_br_u64_invalid_1_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_br_u64_invalid_2_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1d_z_p_br_u64_invalid_3_4000_a5e04000() {
    // Encoding: 0xA5E04000
    // Test LD1D_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1d_z_p_br_u64_reg_write_0_a5e04000() {
    // Test LD1D_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA5E04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1D_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1d_z_p_br_u64_sp_rn_a5e043e0() {
    // Test LD1D_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA5E043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1W_Z.P.BI_U32 Tests
// ============================================================================

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_0_zero_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a551a000() {
    // Encoding: 0xA551A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Pg=0, Zt=0
    let encoding: u32 = 0xA551A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a553a000() {
    // Encoding: 0xA553A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA553A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a554a000() {
    // Encoding: 0xA554A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Zt=0, Rn=0
    let encoding: u32 = 0xA554A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a557a000() {
    // Encoding: 0xA557A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=7
    let encoding: u32 = 0xA557A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a558a000() {
    // Encoding: 0xA558A000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Zt=0, Rn=0
    let encoding: u32 = 0xA558A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_imm4_15_max_a000_a55fa000() {
    // Encoding: 0xA55FA000
    // Test LDNF1W_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=15
    let encoding: u32 = 0xA55FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_pg_0_min_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_pg_1_poweroftwo_a000_a550a400() {
    // Encoding: 0xA550A400
    // Test LDNF1W_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Pg=1, Zt=0
    let encoding: u32 = 0xA550A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_rn_0_min_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_rn_1_poweroftwo_a000_a550a020() {
    // Encoding: 0xA550A020
    // Test LDNF1W_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA550A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a550a3c0() {
    // Encoding: 0xA550A3C0
    // Test LDNF1W_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA550A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1w_z_p_bi_u32_field_rn_31_max_a000_a550a3e0() {
    // Encoding: 0xA550A3E0
    // Test LDNF1W_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA550A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1w_z_p_bi_u32_field_zt_0_min_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1w_z_p_bi_u32_field_zt_1_poweroftwo_a000_a550a001() {
    // Encoding: 0xA550A001
    // Test LDNF1W_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=1, Pg=0
    let encoding: u32 = 0xA550A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1w_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a550a01e() {
    // Encoding: 0xA550A01E
    // Test LDNF1W_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA550A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1w_z_p_bi_u32_field_zt_31_max_a000_a550a01f() {
    // Encoding: 0xA550A01F
    // Test LDNF1W_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: Zt=31, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA550A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1w_z_p_bi_u32_combo_0_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1w_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a550a3e0() {
    // Encoding: 0xA550A3E0
    // Test LDNF1W_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Rn=31, Pg=0
    let encoding: u32 = 0xA550A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1w_z_p_bi_u32_invalid_0_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1w_z_p_bi_u32_invalid_1_a000_a550a000() {
    // Encoding: 0xA550A000
    // Test LDNF1W_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_0_zero_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a571a000() {
    // Encoding: 0xA571A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a573a000() {
    // Encoding: 0xA573A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=3, Zt=0
    let encoding: u32 = 0xA573A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a574a000() {
    // Encoding: 0xA574A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA574A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a577a000() {
    // Encoding: 0xA577A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA577A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a578a000() {
    // Encoding: 0xA578A000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA578A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_imm4_15_max_a000_a57fa000() {
    // Encoding: 0xA57FA000
    // Test LDNF1W_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Rn=0, Pg=0, imm4=15, Zt=0
    let encoding: u32 = 0xA57FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_pg_0_min_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_pg_1_poweroftwo_a000_a570a400() {
    // Encoding: 0xA570A400
    // Test LDNF1W_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA570A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_rn_0_min_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_rn_1_poweroftwo_a000_a570a020() {
    // Encoding: 0xA570A020
    // Test LDNF1W_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA570A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a570a3c0() {
    // Encoding: 0xA570A3C0
    // Test LDNF1W_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA570A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1w_z_p_bi_u64_field_rn_31_max_a000_a570a3e0() {
    // Encoding: 0xA570A3E0
    // Test LDNF1W_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA570A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1w_z_p_bi_u64_field_zt_0_min_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1w_z_p_bi_u64_field_zt_1_poweroftwo_a000_a570a001() {
    // Encoding: 0xA570A001
    // Test LDNF1W_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, imm4=0
    let encoding: u32 = 0xA570A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1w_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a570a01e() {
    // Encoding: 0xA570A01E
    // Test LDNF1W_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=30
    let encoding: u32 = 0xA570A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1w_z_p_bi_u64_field_zt_31_max_a000_a570a01f() {
    // Encoding: 0xA570A01F
    // Test LDNF1W_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xA570A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1w_z_p_bi_u64_combo_0_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1w_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a570a3e0() {
    // Encoding: 0xA570A3E0
    // Test LDNF1W_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xA570A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1w_z_p_bi_u64_invalid_0_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1w_z_p_bi_u64_invalid_1_a000_a570a000() {
    // Encoding: 0xA570A000
    // Test LDNF1W_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1w_z_p_bi_u32_reg_write_0_a550a000() {
    // Test LDNF1W_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA550A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA550A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1W_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1w_z_p_bi_u32_sp_rn_a550a3e0() {
    // Test LDNF1W_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA550A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA550A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1w_z_p_bi_u64_reg_write_0_a570a000() {
    // Test LDNF1W_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA570A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA570A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1W_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1w_z_p_bi_u64_sp_rn_a570a3e0() {
    // Test LDNF1W_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA570A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA570A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1SH_Z.P.BI_S32 Tests
// ============================================================================

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_0_zero_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_1_poweroftwo_a000_a531a000() {
    // Encoding: 0xA531A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_3_poweroftwominusone_a000_a533a000() {
    // Encoding: 0xA533A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=3, Pg=0
    let encoding: u32 = 0xA533A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_4_poweroftwo_a000_a534a000() {
    // Encoding: 0xA534A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xA534A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_7_poweroftwominusone_a000_a537a000() {
    // Encoding: 0xA537A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA537A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_8_poweroftwo_a000_a538a000() {
    // Encoding: 0xA538A000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Zt=0, Rn=0
    let encoding: u32 = 0xA538A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_imm4_15_max_a000_a53fa000() {
    // Encoding: 0xA53FA000
    // Test LDNF1SH_Z.P.BI_S32 field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA53FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_pg_0_min_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_pg_1_poweroftwo_a000_a530a400() {
    // Encoding: 0xA530A400
    // Test LDNF1SH_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xA530A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_rn_0_min_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_rn_1_poweroftwo_a000_a530a020() {
    // Encoding: 0xA530A020
    // Test LDNF1SH_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=1
    let encoding: u32 = 0xA530A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_a530a3c0() {
    // Encoding: 0xA530A3C0
    // Test LDNF1SH_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, imm4=0
    let encoding: u32 = 0xA530A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_rn_31_max_a000_a530a3e0() {
    // Encoding: 0xA530A3E0
    // Test LDNF1SH_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA530A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_zt_0_min_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_zt_1_poweroftwo_a000_a530a001() {
    // Encoding: 0xA530A001
    // Test LDNF1SH_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xA530A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_a530a01e() {
    // Encoding: 0xA530A01E
    // Test LDNF1SH_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xA530A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sh_z_p_bi_s32_field_zt_31_max_a000_a530a01f() {
    // Encoding: 0xA530A01F
    // Test LDNF1SH_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: Zt=31, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA530A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sh_z_p_bi_s32_combo_0_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sh_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a530a3e0() {
    // Encoding: 0xA530A3E0
    // Test LDNF1SH_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA530A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sh_z_p_bi_s32_invalid_0_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sh_z_p_bi_s32_invalid_1_a000_a530a000() {
    // Encoding: 0xA530A000
    // Test LDNF1SH_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_0_zero_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a511a000() {
    // Encoding: 0xA511A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=1
    let encoding: u32 = 0xA511A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a513a000() {
    // Encoding: 0xA513A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=3
    let encoding: u32 = 0xA513A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a514a000() {
    // Encoding: 0xA514A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Zt=0, Rn=0
    let encoding: u32 = 0xA514A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a517a000() {
    // Encoding: 0xA517A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA517A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a518a000() {
    // Encoding: 0xA518A000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xA518A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_imm4_15_max_a000_a51fa000() {
    // Encoding: 0xA51FA000
    // Test LDNF1SH_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Pg=0, Rn=0
    let encoding: u32 = 0xA51FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_pg_0_min_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_pg_1_poweroftwo_a000_a510a400() {
    // Encoding: 0xA510A400
    // Test LDNF1SH_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, imm4=0, Zt=0
    let encoding: u32 = 0xA510A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_rn_0_min_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_rn_1_poweroftwo_a000_a510a020() {
    // Encoding: 0xA510A020
    // Test LDNF1SH_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, imm4=0
    let encoding: u32 = 0xA510A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a510a3c0() {
    // Encoding: 0xA510A3C0
    // Test LDNF1SH_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, imm4=0
    let encoding: u32 = 0xA510A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_rn_31_max_a000_a510a3e0() {
    // Encoding: 0xA510A3E0
    // Test LDNF1SH_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA510A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_zt_0_min_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_zt_1_poweroftwo_a000_a510a001() {
    // Encoding: 0xA510A001
    // Test LDNF1SH_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=1
    let encoding: u32 = 0xA510A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a510a01e() {
    // Encoding: 0xA510A01E
    // Test LDNF1SH_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA510A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sh_z_p_bi_s64_field_zt_31_max_a000_a510a01f() {
    // Encoding: 0xA510A01F
    // Test LDNF1SH_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, imm4=0, Pg=0
    let encoding: u32 = 0xA510A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sh_z_p_bi_s64_combo_0_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sh_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a510a3e0() {
    // Encoding: 0xA510A3E0
    // Test LDNF1SH_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA510A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sh_z_p_bi_s64_invalid_0_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sh_z_p_bi_s64_invalid_1_a000_a510a000() {
    // Encoding: 0xA510A000
    // Test LDNF1SH_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA510A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sh_z_p_bi_s32_reg_write_0_a530a000() {
    // Test LDNF1SH_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0xA530A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA530A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SH_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sh_z_p_bi_s32_sp_rn_a530a3e0() {
    // Test LDNF1SH_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0xA530A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA530A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sh_z_p_bi_s64_reg_write_0_a510a000() {
    // Test LDNF1SH_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA510A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA510A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SH_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sh_z_p_bi_s64_sp_rn_a510a3e0() {
    // Test LDNF1SH_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA510A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA510A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SB_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_xs_0_min_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_xs_1_max_0_c4400000() {
    // Encoding: 0xC4400000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zm_0_min_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_0_c4010000() {
    // Encoding: 0xC4010000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, xs=0, Zm=1
    let encoding: u32 = 0xC4010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_0_c41e0000() {
    // Encoding: 0xC41E0000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=30, xs=0
    let encoding: u32 = 0xC41E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zm_31_max_0_c41f0000() {
    // Encoding: 0xC41F0000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, xs=0, Zm=31
    let encoding: u32 = 0xC41F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_pg_0_min_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_0_c4000400() {
    // Encoding: 0xC4000400
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_rn_0_min_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_0_c4000020() {
    // Encoding: 0xC4000020
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=1
    let encoding: u32 = 0xC4000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_0_c40003c0() {
    // Encoding: 0xC40003C0
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zt=0, Rn=30, Zm=0
    let encoding: u32 = 0xC40003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_rn_31_max_0_c40003e0() {
    // Encoding: 0xC40003E0
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, xs=0, Zm=0
    let encoding: u32 = 0xC40003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zt_0_min_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_0_c4000001() {
    // Encoding: 0xC4000001
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=1
    let encoding: u32 = 0xC4000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_0_c400001e() {
    // Encoding: 0xC400001E
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xC400001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_field_zt_31_max_0_c400001f() {
    // Encoding: 0xC400001F
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=31
    let encoding: u32 = 0xC400001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_combo_0_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c40003e0(
) {
    // Encoding: 0xC40003E0
    // Test LD1SB_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Rn=31, Zt=0, Zm=0
    let encoding: u32 = 0xC40003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_invalid_0_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_invalid_1_0_c4000000() {
    // Encoding: 0xC4000000
    // Test LD1SB_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC4000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_xs_0_min_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_xs_1_max_0_84400000() {
    // Encoding: 0x84400000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zm_0_min_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_0_84010000() {
    // Encoding: 0x84010000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0x84010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_0_841e0000() {
    // Encoding: 0x841E0000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zt=0, Zm=30, Pg=0, Rn=0
    let encoding: u32 = 0x841E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zm_31_max_0_841f0000() {
    // Encoding: 0x841F0000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=31, xs=0
    let encoding: u32 = 0x841F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_pg_0_min_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_0_84000400() {
    // Encoding: 0x84000400
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, xs=0, Zm=0
    let encoding: u32 = 0x84000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_rn_0_min_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_0_84000020() {
    // Encoding: 0x84000020
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x84000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_0_840003c0() {
    // Encoding: 0x840003C0
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x840003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_rn_31_max_0_840003e0() {
    // Encoding: 0x840003E0
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0x840003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zt_0_min_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_0_84000001() {
    // Encoding: 0x84000001
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0x84000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_0_8400001e() {
    // Encoding: 0x8400001E
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=0, Zt=30, Zm=0
    let encoding: u32 = 0x8400001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_field_zt_31_max_0_8400001f() {
    // Encoding: 0x8400001F
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0x8400001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_combo_0_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_840003e0(
) {
    // Encoding: 0x840003E0
    // Test LD1SB_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, xs=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0x840003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_invalid_0_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_invalid_1_0_84000000() {
    // Encoding: 0x84000000
    // Test LD1SB_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0x84000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zm_0_min_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_8000_c4418000() {
    // Encoding: 0xC4418000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=1, Pg=0
    let encoding: u32 = 0xC4418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_8000_c45e8000() {
    // Encoding: 0xC45E8000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=30
    let encoding: u32 = 0xC45E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zm_31_max_8000_c45f8000() {
    // Encoding: 0xC45F8000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC45F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_pg_0_min_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_8000_c4408400() {
    // Encoding: 0xC4408400
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=1
    let encoding: u32 = 0xC4408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_rn_0_min_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_8000_c4408020() {
    // Encoding: 0xC4408020
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xC4408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_8000_c44083c0() {
    // Encoding: 0xC44083C0
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zm=0, Zt=0
    let encoding: u32 = 0xC44083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_rn_31_max_8000_c44083e0() {
    // Encoding: 0xC44083E0
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=31
    let encoding: u32 = 0xC44083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zt_0_min_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_8000_c4408001() {
    // Encoding: 0xC4408001
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=1
    let encoding: u32 = 0xC4408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_8000_c440801e() {
    // Encoding: 0xC440801E
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0xC440801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_field_zt_31_max_8000_c440801f() {
    // Encoding: 0xC440801F
    // Test LD1SB_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xC440801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_combo_0_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c44083e0(
) {
    // Encoding: 0xC44083E0
    // Test LD1SB_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC44083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_invalid_0_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_invalid_1_8000_c4408000() {
    // Encoding: 0xC4408000
    // Test LD1SB_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_reg_write_0_c4000000() {
    // Test LD1SB_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bz_d_x32_unscaled_sp_rn_c40003e0() {
    // Test LD1SB_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC40003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC40003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_reg_write_0_84000000() {
    // Test LD1SB_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bz_s_x32_unscaled_sp_rn_840003e0() {
    // Test LD1SB_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x840003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x840003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_reg_write_0_c4408000() {
    // Test LD1SB_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4408000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4408000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bz_d_64_unscaled_sp_rn_c44083e0() {
    // Test LD1SB_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC44083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC44083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1B_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_xs_0_min_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_xs_1_max_4000_c4404000() {
    // Encoding: 0xC4404000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Zt=0, xs=1, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zm_0_min_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_4000_c4014000() {
    // Encoding: 0xC4014000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xC4014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_4000_c41e4000() {
    // Encoding: 0xC41E4000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=30, xs=0
    let encoding: u32 = 0xC41E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zm_31_max_4000_c41f4000() {
    // Encoding: 0xC41F4000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, xs=0, Rn=0, Zm=31
    let encoding: u32 = 0xC41F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_pg_0_min_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_4000_c4004400() {
    // Encoding: 0xC4004400
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xC4004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_rn_0_min_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_4000_c4004020() {
    // Encoding: 0xC4004020
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Zm=0, Rn=1, Zt=0
    let encoding: u32 = 0xC4004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_4000_c40043c0() {
    // Encoding: 0xC40043C0
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zt=0, xs=0, Rn=30
    let encoding: u32 = 0xC40043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_rn_31_max_4000_c40043e0() {
    // Encoding: 0xC40043E0
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zt_0_min_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_4000_c4004001() {
    // Encoding: 0xC4004001
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xC4004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_4000_c400401e() {
    // Encoding: 0xC400401E
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC400401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_field_zt_31_max_4000_c400401f() {
    // Encoding: 0xC400401F
    // Test LD1B_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC400401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_combo_0_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c40043e0(
) {
    // Encoding: 0xC40043E0
    // Test LD1B_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0xC40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_invalid_0_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_invalid_1_4000_c4004000() {
    // Encoding: 0xC4004000
    // Test LD1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_xs_0_min_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_xs_1_max_4000_84404000() {
    // Encoding: 0x84404000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, xs=1, Zt=0
    let encoding: u32 = 0x84404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zm_0_min_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_4000_84014000() {
    // Encoding: 0x84014000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_4000_841e4000() {
    // Encoding: 0x841E4000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=30
    let encoding: u32 = 0x841E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zm_31_max_4000_841f4000() {
    // Encoding: 0x841F4000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Zm=31, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x841F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_pg_0_min_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_4000_84004400() {
    // Encoding: 0x84004400
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x84004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_rn_0_min_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_4000_84004020() {
    // Encoding: 0x84004020
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0x84004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_4000_840043c0() {
    // Encoding: 0x840043C0
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x840043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_rn_31_max_4000_840043e0() {
    // Encoding: 0x840043E0
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x840043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zt_0_min_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_4000_84004001() {
    // Encoding: 0x84004001
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=1, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x84004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_4000_8400401e() {
    // Encoding: 0x8400401E
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0x8400401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_field_zt_31_max_4000_8400401f() {
    // Encoding: 0x8400401F
    // Test LD1B_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=31, xs=0, Rn=0
    let encoding: u32 = 0x8400401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_combo_0_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_840043e0(
) {
    // Encoding: 0x840043E0
    // Test LD1B_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0x840043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_invalid_0_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_invalid_1_4000_84004000() {
    // Encoding: 0x84004000
    // Test LD1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zm_0_min_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_c000_c441c000() {
    // Encoding: 0xC441C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=1, Rn=0, Pg=0
    let encoding: u32 = 0xC441C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_c000_c45ec000() {
    // Encoding: 0xC45EC000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zt=0, Rn=0
    let encoding: u32 = 0xC45EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zm_31_max_c000_c45fc000() {
    // Encoding: 0xC45FC000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=31
    let encoding: u32 = 0xC45FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_pg_0_min_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_c000_c440c400() {
    // Encoding: 0xC440C400
    // Test LD1B_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC440C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_rn_0_min_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_c000_c440c020() {
    // Encoding: 0xC440C020
    // Test LD1B_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC440C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_c000_c440c3c0() {
    // Encoding: 0xC440C3C0
    // Test LD1B_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=30
    let encoding: u32 = 0xC440C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_rn_31_max_c000_c440c3e0() {
    // Encoding: 0xC440C3E0
    // Test LD1B_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Zm=0, Pg=0
    let encoding: u32 = 0xC440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zt_0_min_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_c000_c440c001() {
    // Encoding: 0xC440C001
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=1, Pg=0
    let encoding: u32 = 0xC440C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_c000_c440c01e() {
    // Encoding: 0xC440C01E
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xC440C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_field_zt_31_max_c000_c440c01f() {
    // Encoding: 0xC440C01F
    // Test LD1B_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xC440C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_combo_0_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c440c3e0(
) {
    // Encoding: 0xC440C3E0
    // Test LD1B_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, Zm=0
    let encoding: u32 = 0xC440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_invalid_0_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_invalid_1_c000_c440c000() {
    // Encoding: 0xC440C000
    // Test LD1B_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_reg_write_0_c4004000() {
    // Test LD1B_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bz_d_x32_unscaled_sp_rn_c40043e0() {
    // Test LD1B_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC40043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC40043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_reg_write_0_84004000() {
    // Test LD1B_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84004000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84004000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bz_s_x32_unscaled_sp_rn_840043e0() {
    // Test LD1B_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x840043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x840043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_reg_write_0_c440c000() {
    // Test LD1B_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC440C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bz_d_64_unscaled_sp_rn_c440c3e0() {
    // Test LD1B_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC440C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1W_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_0_zero_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_1_poweroftwo_c000_8521c000() {
    // Encoding: 0x8521C000
    // Test LD1W_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=1, Pg=0, Zn=0
    let encoding: u32 = 0x8521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_3_poweroftwominusone_c000_8523c000() {
    // Encoding: 0x8523C000
    // Test LD1W_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=3, Pg=0, Zt=0
    let encoding: u32 = 0x8523C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_4_poweroftwo_c000_8524c000() {
    // Encoding: 0x8524C000
    // Test LD1W_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x8524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_7_poweroftwominusone_c000_8527c000() {
    // Encoding: 0x8527C000
    // Test LD1W_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=7
    let encoding: u32 = 0x8527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_8_poweroftwo_c000_8528c000() {
    // Encoding: 0x8528C000
    // Test LD1W_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=8
    let encoding: u32 = 0x8528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_15_poweroftwominusone_c000_852fc000() {
    // Encoding: 0x852FC000
    // Test LD1W_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=15
    let encoding: u32 = 0x852FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_16_poweroftwo_c000_8530c000() {
    // Encoding: 0x8530C000
    // Test LD1W_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0x8530C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1w_z_p_ai_s_field_imm5_31_max_c000_853fc000() {
    // Encoding: 0x853FC000
    // Test LD1W_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: imm5=31, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x853FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_ai_s_field_pg_0_min_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_ai_s_field_pg_1_poweroftwo_c000_8520c400() {
    // Encoding: 0x8520C400
    // Test LD1W_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zt=0, imm5=0
    let encoding: u32 = 0x8520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_ai_s_field_zn_0_min_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_ai_s_field_zn_1_poweroftwo_c000_8520c020() {
    // Encoding: 0x8520C020
    // Test LD1W_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zt=0, imm5=0
    let encoding: u32 = 0x8520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_ai_s_field_zn_30_poweroftwominusone_c000_8520c3c0() {
    // Encoding: 0x8520C3C0
    // Test LD1W_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0x8520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_ai_s_field_zn_31_max_c000_8520c3e0() {
    // Encoding: 0x8520C3E0
    // Test LD1W_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, imm5=0, Zt=0
    let encoding: u32 = 0x8520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_ai_s_field_zt_0_min_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_ai_s_field_zt_1_poweroftwo_c000_8520c001() {
    // Encoding: 0x8520C001
    // Test LD1W_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0x8520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_ai_s_field_zt_30_poweroftwominusone_c000_8520c01e() {
    // Encoding: 0x8520C01E
    // Test LD1W_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=30, imm5=0, Pg=0
    let encoding: u32 = 0x8520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_ai_s_field_zt_31_max_c000_8520c01f() {
    // Encoding: 0x8520C01F
    // Test LD1W_Z.P.AI_S field Zt = 31 (Max)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=31
    let encoding: u32 = 0x8520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1w_z_p_ai_s_combo_0_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_ai_s_invalid_0_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_ai_s_invalid_1_c000_8520c000() {
    // Encoding: 0x8520C000
    // Test LD1W_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0x8520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_0_zero_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_1_poweroftwo_c000_c521c000() {
    // Encoding: 0xC521C000
    // Test LD1W_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=1, Pg=0
    let encoding: u32 = 0xC521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_3_poweroftwominusone_c000_c523c000() {
    // Encoding: 0xC523C000
    // Test LD1W_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, imm5=3, Pg=0
    let encoding: u32 = 0xC523C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_4_poweroftwo_c000_c524c000() {
    // Encoding: 0xC524C000
    // Test LD1W_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, imm5=4, Pg=0, Zt=0
    let encoding: u32 = 0xC524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_7_poweroftwominusone_c000_c527c000() {
    // Encoding: 0xC527C000
    // Test LD1W_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=7, Zn=0
    let encoding: u32 = 0xC527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_8_poweroftwo_c000_c528c000() {
    // Encoding: 0xC528C000
    // Test LD1W_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=8, Zn=0
    let encoding: u32 = 0xC528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_15_poweroftwominusone_c000_c52fc000() {
    // Encoding: 0xC52FC000
    // Test LD1W_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm5=15, Zn=0
    let encoding: u32 = 0xC52FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_16_poweroftwo_c000_c530c000() {
    // Encoding: 0xC530C000
    // Test LD1W_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC530C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1w_z_p_ai_d_field_imm5_31_max_c000_c53fc000() {
    // Encoding: 0xC53FC000
    // Test LD1W_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC53FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_ai_d_field_pg_0_min_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_ai_d_field_pg_1_poweroftwo_c000_c520c400() {
    // Encoding: 0xC520C400
    // Test LD1W_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Pg=1, Zt=0
    let encoding: u32 = 0xC520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_ai_d_field_zn_0_min_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_ai_d_field_zn_1_poweroftwo_c000_c520c020() {
    // Encoding: 0xC520C020
    // Test LD1W_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=1
    let encoding: u32 = 0xC520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_ai_d_field_zn_30_poweroftwominusone_c000_c520c3c0() {
    // Encoding: 0xC520C3C0
    // Test LD1W_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, imm5=0, Zt=0
    let encoding: u32 = 0xC520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_ai_d_field_zn_31_max_c000_c520c3e0() {
    // Encoding: 0xC520C3E0
    // Test LD1W_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zt=0, imm5=0, Zn=31, Pg=0
    let encoding: u32 = 0xC520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_ai_d_field_zt_0_min_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_ai_d_field_zt_1_poweroftwo_c000_c520c001() {
    // Encoding: 0xC520C001
    // Test LD1W_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_ai_d_field_zt_30_poweroftwominusone_c000_c520c01e() {
    // Encoding: 0xC520C01E
    // Test LD1W_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=0, Zt=30, Pg=0
    let encoding: u32 = 0xC520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_ai_d_field_zt_31_max_c000_c520c01f() {
    // Encoding: 0xC520C01F
    // Test LD1W_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=31
    let encoding: u32 = 0xC520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1w_z_p_ai_d_combo_0_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_ai_d_invalid_0_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_ai_d_invalid_1_c000_c520c000() {
    // Encoding: 0xC520C000
    // Test LD1W_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_ai_s_reg_write_0_8520c000() {
    // Test LD1W_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x8520C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8520C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_ai_d_reg_write_0_c520c000() {
    // Test LD1W_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC520C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC520C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1W_Z.P.BR_U32 Tests
// ============================================================================

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u32_field_rm_0_min_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u32_field_rm_1_poweroftwo_4000_a5414000() {
    // Encoding: 0xA5414000
    // Test LD1W_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xA5414000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_br_u32_field_rm_30_poweroftwominusone_4000_a55e4000() {
    // Encoding: 0xA55E4000
    // Test LD1W_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA55E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1w_z_p_br_u32_field_rm_31_max_4000_a55f4000() {
    // Encoding: 0xA55F4000
    // Test LD1W_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xA55F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u32_field_pg_0_min_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u32_field_pg_1_poweroftwo_4000_a5404400() {
    // Encoding: 0xA5404400
    // Test LD1W_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0xA5404400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u32_field_rn_0_min_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u32_field_rn_1_poweroftwo_4000_a5404020() {
    // Encoding: 0xA5404020
    // Test LD1W_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5404020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_br_u32_field_rn_30_poweroftwominusone_4000_a54043c0() {
    // Encoding: 0xA54043C0
    // Test LD1W_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=30
    let encoding: u32 = 0xA54043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_br_u32_field_rn_31_max_4000_a54043e0() {
    // Encoding: 0xA54043E0
    // Test LD1W_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xA54043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_br_u32_field_zt_0_min_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_br_u32_field_zt_1_poweroftwo_4000_a5404001() {
    // Encoding: 0xA5404001
    // Test LD1W_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5404001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_br_u32_field_zt_30_poweroftwominusone_4000_a540401e() {
    // Encoding: 0xA540401E
    // Test LD1W_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA540401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_br_u32_field_zt_31_max_4000_a540401f() {
    // Encoding: 0xA540401F
    // Test LD1W_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA540401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1w_z_p_br_u32_combo_0_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a54043e0() {
    // Encoding: 0xA54043E0
    // Test LD1W_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA54043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u32_invalid_0_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u32_invalid_1_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u32_invalid_2_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u32_invalid_3_4000_a5404000() {
    // Encoding: 0xA5404000
    // Test LD1W_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u64_field_rm_0_min_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u64_field_rm_1_poweroftwo_4000_a5614000() {
    // Encoding: 0xA5614000
    // Test LD1W_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xA5614000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_br_u64_field_rm_30_poweroftwominusone_4000_a57e4000() {
    // Encoding: 0xA57E4000
    // Test LD1W_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA57E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1w_z_p_br_u64_field_rm_31_max_4000_a57f4000() {
    // Encoding: 0xA57F4000
    // Test LD1W_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA57F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u64_field_pg_0_min_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u64_field_pg_1_poweroftwo_4000_a5604400() {
    // Encoding: 0xA5604400
    // Test LD1W_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1w_z_p_br_u64_field_rn_0_min_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1w_z_p_br_u64_field_rn_1_poweroftwo_4000_a5604020() {
    // Encoding: 0xA5604020
    // Test LD1W_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xA5604020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1w_z_p_br_u64_field_rn_30_poweroftwominusone_4000_a56043c0() {
    // Encoding: 0xA56043C0
    // Test LD1W_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xA56043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1w_z_p_br_u64_field_rn_31_max_4000_a56043e0() {
    // Encoding: 0xA56043E0
    // Test LD1W_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA56043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1w_z_p_br_u64_field_zt_0_min_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1w_z_p_br_u64_field_zt_1_poweroftwo_4000_a5604001() {
    // Encoding: 0xA5604001
    // Test LD1W_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Zt=1, Pg=0
    let encoding: u32 = 0xA5604001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1w_z_p_br_u64_field_zt_30_poweroftwominusone_4000_a560401e() {
    // Encoding: 0xA560401E
    // Test LD1W_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rn=0, Rm=0
    let encoding: u32 = 0xA560401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1w_z_p_br_u64_field_zt_31_max_4000_a560401f() {
    // Encoding: 0xA560401F
    // Test LD1W_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=31
    let encoding: u32 = 0xA560401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1w_z_p_br_u64_combo_0_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1w_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a56043e0() {
    // Encoding: 0xA56043E0
    // Test LD1W_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Rm=0, Pg=0
    let encoding: u32 = 0xA56043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u64_invalid_0_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u64_invalid_1_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u64_invalid_2_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1w_z_p_br_u64_invalid_3_4000_a5604000() {
    // Encoding: 0xA5604000
    // Test LD1W_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_br_u32_reg_write_0_a5404000() {
    // Test LD1W_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA5404000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5404000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_br_u32_sp_rn_a54043e0() {
    // Test LD1W_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA54043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA54043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1w_z_p_br_u64_reg_write_0_a5604000() {
    // Test LD1W_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA5604000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5604000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1W_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1w_z_p_br_u64_sp_rn_a56043e0() {
    // Test LD1W_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA56043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA56043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rm_0_min_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a441c000() {
    // Encoding: 0xA441C000
    // Test LD3B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xA441C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a45ec000() {
    // Encoding: 0xA45EC000
    // Test LD3B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA45EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rm_31_max_c000_a45fc000() {
    // Encoding: 0xA45FC000
    // Test LD3B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA45FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_pg_0_min_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a440c400() {
    // Encoding: 0xA440C400
    // Test LD3B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=1
    let encoding: u32 = 0xA440C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rn_0_min_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a440c020() {
    // Encoding: 0xA440C020
    // Test LD3B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=1, Zt=0
    let encoding: u32 = 0xA440C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a440c3c0() {
    // Encoding: 0xA440C3C0
    // Test LD3B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xA440C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3b_z_p_br_contiguous_field_rn_31_max_c000_a440c3e0() {
    // Encoding: 0xA440C3E0
    // Test LD3B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, Rm=0
    let encoding: u32 = 0xA440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3b_z_p_br_contiguous_field_zt_0_min_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3b_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a440c001() {
    // Encoding: 0xA440C001
    // Test LD3B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA440C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3b_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a440c01e() {
    // Encoding: 0xA440C01E
    // Test LD3B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA440C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3b_z_p_br_contiguous_field_zt_31_max_c000_a440c01f() {
    // Encoding: 0xA440C01F
    // Test LD3B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, Rm=0
    let encoding: u32 = 0xA440C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld3b_z_p_br_contiguous_combo_0_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a440c3e0()
{
    // Encoding: 0xA440C3E0
    // Test LD3B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA440C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_br_contiguous_invalid_0_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_br_contiguous_invalid_1_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_br_contiguous_invalid_2_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3b_z_p_br_contiguous_invalid_3_c000_a440c000() {
    // Encoding: 0xA440C000
    // Test LD3B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3b_z_p_br_contiguous_sp_rn_a440c3e0() {
    // Test LD3B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA440C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA440C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_0_zero_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a461e000() {
    // Encoding: 0xA461E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA461E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a463e000() {
    // Encoding: 0xA463E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=3
    let encoding: u32 = 0xA463E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a464e000() {
    // Encoding: 0xA464E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=4, Zt=0
    let encoding: u32 = 0xA464E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a467e000() {
    // Encoding: 0xA467E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA467E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a468e000() {
    // Encoding: 0xA468E000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, imm4=8, Zt=0, Pg=0
    let encoding: u32 = 0xA468E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_imm4_15_max_e000_a46fe000() {
    // Encoding: 0xA46FE000
    // Test LD4B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xA46FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_pg_0_min_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a460e400() {
    // Encoding: 0xA460E400
    // Test LD4B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA460E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_rn_0_min_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a460e020() {
    // Encoding: 0xA460E020
    // Test LD4B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA460E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a460e3c0() {
    // Encoding: 0xA460E3C0
    // Test LD4B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA460E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4b_z_p_bi_contiguous_field_rn_31_max_e000_a460e3e0() {
    // Encoding: 0xA460E3E0
    // Test LD4B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4b_z_p_bi_contiguous_field_zt_0_min_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a460e001() {
    // Encoding: 0xA460E001
    // Test LD4B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xA460E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a460e01e() {
    // Encoding: 0xA460E01E
    // Test LD4B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, imm4=0, Rn=0
    let encoding: u32 = 0xA460E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4b_z_p_bi_contiguous_field_zt_31_max_e000_a460e01f() {
    // Encoding: 0xA460E01F
    // Test LD4B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA460E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld4b_z_p_bi_contiguous_combo_0_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a460e3e0()
{
    // Encoding: 0xA460E3E0
    // Test LD4B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA460E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_bi_contiguous_invalid_0_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4b_z_p_bi_contiguous_invalid_1_e000_a460e000() {
    // Encoding: 0xA460E000
    // Test LD4B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4b_z_p_bi_contiguous_sp_rn_a460e3e0() {
    // Test LD4B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA460E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA460E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SW_Z.P.AI_D Tests
// ============================================================================

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_0_zero_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_1_poweroftwo_8000_c5218000() {
    // Encoding: 0xC5218000
    // Test LD1SW_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm5=1, Zt=0, Zn=0
    let encoding: u32 = 0xC5218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_3_poweroftwominusone_8000_c5238000() {
    // Encoding: 0xC5238000
    // Test LD1SW_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC5238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_4_poweroftwo_8000_c5248000() {
    // Encoding: 0xC5248000
    // Test LD1SW_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=4
    let encoding: u32 = 0xC5248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_7_poweroftwominusone_8000_c5278000() {
    // Encoding: 0xC5278000
    // Test LD1SW_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_8_poweroftwo_8000_c5288000() {
    // Encoding: 0xC5288000
    // Test LD1SW_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=8
    let encoding: u32 = 0xC5288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_15_poweroftwominusone_8000_c52f8000() {
    // Encoding: 0xC52F8000
    // Test LD1SW_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=15, Zt=0
    let encoding: u32 = 0xC52F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_16_poweroftwo_8000_c5308000() {
    // Encoding: 0xC5308000
    // Test LD1SW_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=16, Zn=0
    let encoding: u32 = 0xC5308000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ld1sw_z_p_ai_d_field_imm5_31_max_8000_c53f8000() {
    // Encoding: 0xC53F8000
    // Test LD1SW_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=31
    let encoding: u32 = 0xC53F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_ai_d_field_pg_0_min_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_ai_d_field_pg_1_poweroftwo_8000_c5208400() {
    // Encoding: 0xC5208400
    // Test LD1SW_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, Pg=1, imm5=0
    let encoding: u32 = 0xC5208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_ai_d_field_zn_0_min_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_ai_d_field_zn_1_poweroftwo_8000_c5208020() {
    // Encoding: 0xC5208020
    // Test LD1SW_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=1
    let encoding: u32 = 0xC5208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_ai_d_field_zn_30_poweroftwominusone_8000_c52083c0() {
    // Encoding: 0xC52083C0
    // Test LD1SW_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC52083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_ai_d_field_zn_31_max_8000_c52083e0() {
    // Encoding: 0xC52083E0
    // Test LD1SW_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC52083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_ai_d_field_zt_0_min_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_ai_d_field_zt_1_poweroftwo_8000_c5208001() {
    // Encoding: 0xC5208001
    // Test LD1SW_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Zt=1, Pg=0
    let encoding: u32 = 0xC5208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_ai_d_field_zt_30_poweroftwominusone_8000_c520801e() {
    // Encoding: 0xC520801E
    // Test LD1SW_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=30
    let encoding: u32 = 0xC520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_ai_d_field_zt_31_max_8000_c520801f() {
    // Encoding: 0xC520801F
    // Test LD1SW_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm5=0, Zn=0
    let encoding: u32 = 0xC520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ld1sw_z_p_ai_d_combo_0_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_ai_d_invalid_0_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_ai_d_invalid_1_8000_c5208000() {
    // Encoding: 0xC5208000
    // Test LD1SW_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_ai_d_reg_write_0_c5208000() {
    // Test LD1SW_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC5208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SW_Z.P.BR_S64 Tests
// ============================================================================

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_br_s64_field_rm_0_min_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_br_s64_field_rm_1_poweroftwo_4000_a4814000() {
    // Encoding: 0xA4814000
    // Test LD1SW_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_br_s64_field_rm_30_poweroftwominusone_4000_a49e4000() {
    // Encoding: 0xA49E4000
    // Test LD1SW_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1sw_z_p_br_s64_field_rm_31_max_4000_a49f4000() {
    // Encoding: 0xA49F4000
    // Test LD1SW_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_br_s64_field_pg_0_min_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_br_s64_field_pg_1_poweroftwo_4000_a4804400() {
    // Encoding: 0xA4804400
    // Test LD1SW_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, Rm=0
    let encoding: u32 = 0xA4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sw_z_p_br_s64_field_rn_0_min_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sw_z_p_br_s64_field_rn_1_poweroftwo_4000_a4804020() {
    // Encoding: 0xA4804020
    // Test LD1SW_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xA4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sw_z_p_br_s64_field_rn_30_poweroftwominusone_4000_a48043c0() {
    // Encoding: 0xA48043C0
    // Test LD1SW_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sw_z_p_br_s64_field_rn_31_max_4000_a48043e0() {
    // Encoding: 0xA48043E0
    // Test LD1SW_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sw_z_p_br_s64_field_zt_0_min_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sw_z_p_br_s64_field_zt_1_poweroftwo_4000_a4804001() {
    // Encoding: 0xA4804001
    // Test LD1SW_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=1
    let encoding: u32 = 0xA4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sw_z_p_br_s64_field_zt_30_poweroftwominusone_4000_a480401e() {
    // Encoding: 0xA480401E
    // Test LD1SW_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, Rm=0
    let encoding: u32 = 0xA480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sw_z_p_br_s64_field_zt_31_max_4000_a480401f() {
    // Encoding: 0xA480401F
    // Test LD1SW_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=31
    let encoding: u32 = 0xA480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1sw_z_p_br_s64_combo_0_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sw_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_16384_a48043e0() {
    // Encoding: 0xA48043E0
    // Test LD1SW_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_br_s64_invalid_0_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_br_s64_invalid_1_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_br_s64_invalid_2_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sw_z_p_br_s64_invalid_3_4000_a4804000() {
    // Encoding: 0xA4804000
    // Test LD1SW_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sw_z_p_br_s64_reg_write_0_a4804000() {
    // Test LD1SW_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA4804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SW_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sw_z_p_br_s64_sp_rn_a48043e0() {
    // Test LD1SW_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA48043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA48043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1D_Z.P.BI_U64 Tests
// ============================================================================

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_0_zero_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a5f1a000() {
    // Encoding: 0xA5F1A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=1
    let encoding: u32 = 0xA5F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a5f3a000() {
    // Encoding: 0xA5F3A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=3
    let encoding: u32 = 0xA5F3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a5f4a000() {
    // Encoding: 0xA5F4A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5F4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a5f7a000() {
    // Encoding: 0xA5F7A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5F7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a5f8a000() {
    // Encoding: 0xA5F8A000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xA5F8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_imm4_15_max_a000_a5ffa000() {
    // Encoding: 0xA5FFA000
    // Test LDNF1D_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: Zt=0, Pg=0, imm4=15, Rn=0
    let encoding: u32 = 0xA5FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_pg_0_min_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_pg_1_poweroftwo_a000_a5f0a400() {
    // Encoding: 0xA5F0A400
    // Test LDNF1D_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5F0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_rn_0_min_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_rn_1_poweroftwo_a000_a5f0a020() {
    // Encoding: 0xA5F0A020
    // Test LDNF1D_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5F0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a5f0a3c0() {
    // Encoding: 0xA5F0A3C0
    // Test LDNF1D_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5F0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1d_z_p_bi_u64_field_rn_31_max_a000_a5f0a3e0() {
    // Encoding: 0xA5F0A3E0
    // Test LDNF1D_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA5F0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1d_z_p_bi_u64_field_zt_0_min_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1d_z_p_bi_u64_field_zt_1_poweroftwo_a000_a5f0a001() {
    // Encoding: 0xA5F0A001
    // Test LDNF1D_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=1
    let encoding: u32 = 0xA5F0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1d_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a5f0a01e() {
    // Encoding: 0xA5F0A01E
    // Test LDNF1D_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA5F0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1d_z_p_bi_u64_field_zt_31_max_a000_a5f0a01f() {
    // Encoding: 0xA5F0A01F
    // Test LDNF1D_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA5F0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1d_z_p_bi_u64_combo_0_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1d_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5f0a3e0() {
    // Encoding: 0xA5F0A3E0
    // Test LDNF1D_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA5F0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1d_z_p_bi_u64_invalid_0_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1d_z_p_bi_u64_invalid_1_a000_a5f0a000() {
    // Encoding: 0xA5F0A000
    // Test LDNF1D_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1d_z_p_bi_u64_reg_write_0_a5f0a000() {
    // Test LDNF1D_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA5F0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5F0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1D_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1d_z_p_bi_u64_sp_rn_a5f0a3e0() {
    // Test LDNF1D_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA5F0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5F0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1B_Z.P.BI_U8 Tests
// ============================================================================

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_0_zero_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_1_poweroftwo_a000_a401a000() {
    // Encoding: 0xA401A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xA401A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_3_poweroftwominusone_a000_a403a000() {
    // Encoding: 0xA403A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA403A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_4_poweroftwo_a000_a404a000() {
    // Encoding: 0xA404A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=4
    let encoding: u32 = 0xA404A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_7_poweroftwominusone_a000_a407a000() {
    // Encoding: 0xA407A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=7
    let encoding: u32 = 0xA407A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_8_poweroftwo_a000_a408a000() {
    // Encoding: 0xA408A000
    // Test LD1B_Z.P.BI_U8 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA408A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1b_z_p_bi_u8_field_imm4_15_max_a000_a40fa000() {
    // Encoding: 0xA40FA000
    // Test LD1B_Z.P.BI_U8 field imm4 = 15 (Max)
    // Fields: Rn=0, Pg=0, imm4=15, Zt=0
    let encoding: u32 = 0xA40FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u8_field_pg_0_min_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u8_field_pg_1_poweroftwo_a000_a400a400() {
    // Encoding: 0xA400A400
    // Test LD1B_Z.P.BI_U8 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA400A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u8_field_rn_0_min_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u8_field_rn_1_poweroftwo_a000_a400a020() {
    // Encoding: 0xA400A020
    // Test LD1B_Z.P.BI_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA400A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bi_u8_field_rn_30_poweroftwominusone_a000_a400a3c0() {
    // Encoding: 0xA400A3C0
    // Test LD1B_Z.P.BI_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=30
    let encoding: u32 = 0xA400A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bi_u8_field_rn_31_max_a000_a400a3e0() {
    // Encoding: 0xA400A3E0
    // Test LD1B_Z.P.BI_U8 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA400A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bi_u8_field_zt_0_min_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bi_u8_field_zt_1_poweroftwo_a000_a400a001() {
    // Encoding: 0xA400A001
    // Test LD1B_Z.P.BI_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=1, Pg=0
    let encoding: u32 = 0xA400A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bi_u8_field_zt_30_poweroftwominusone_a000_a400a01e() {
    // Encoding: 0xA400A01E
    // Test LD1B_Z.P.BI_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA400A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bi_u8_field_zt_31_max_a000_a400a01f() {
    // Encoding: 0xA400A01F
    // Test LD1B_Z.P.BI_U8 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA400A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_bi_u8_combo_0_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bi_u8_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a400a3e0() {
    // Encoding: 0xA400A3E0
    // Test LD1B_Z.P.BI_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA400A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u8_invalid_0_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u8_invalid_1_a000_a400a000() {
    // Encoding: 0xA400A000
    // Test LD1B_Z.P.BI_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_0_zero_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_1_poweroftwo_a000_a421a000() {
    // Encoding: 0xA421A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA421A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_3_poweroftwominusone_a000_a423a000() {
    // Encoding: 0xA423A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA423A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_4_poweroftwo_a000_a424a000() {
    // Encoding: 0xA424A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA424A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_7_poweroftwominusone_a000_a427a000() {
    // Encoding: 0xA427A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA427A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_8_poweroftwo_a000_a428a000() {
    // Encoding: 0xA428A000
    // Test LD1B_Z.P.BI_U16 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, imm4=8, Pg=0, Zt=0
    let encoding: u32 = 0xA428A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1b_z_p_bi_u16_field_imm4_15_max_a000_a42fa000() {
    // Encoding: 0xA42FA000
    // Test LD1B_Z.P.BI_U16 field imm4 = 15 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=15
    let encoding: u32 = 0xA42FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u16_field_pg_0_min_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u16_field_pg_1_poweroftwo_a000_a420a400() {
    // Encoding: 0xA420A400
    // Test LD1B_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, imm4=0
    let encoding: u32 = 0xA420A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u16_field_rn_0_min_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u16_field_rn_1_poweroftwo_a000_a420a020() {
    // Encoding: 0xA420A020
    // Test LD1B_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA420A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_a420a3c0() {
    // Encoding: 0xA420A3C0
    // Test LD1B_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA420A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bi_u16_field_rn_31_max_a000_a420a3e0() {
    // Encoding: 0xA420A3E0
    // Test LD1B_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: Rn=31, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bi_u16_field_zt_0_min_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bi_u16_field_zt_1_poweroftwo_a000_a420a001() {
    // Encoding: 0xA420A001
    // Test LD1B_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=1
    let encoding: u32 = 0xA420A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_a420a01e() {
    // Encoding: 0xA420A01E
    // Test LD1B_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, imm4=0, Rn=0
    let encoding: u32 = 0xA420A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bi_u16_field_zt_31_max_a000_a420a01f() {
    // Encoding: 0xA420A01F
    // Test LD1B_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xA420A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_bi_u16_combo_0_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a420a3e0() {
    // Encoding: 0xA420A3E0
    // Test LD1B_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA420A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u16_invalid_0_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u16_invalid_1_a000_a420a000() {
    // Encoding: 0xA420A000
    // Test LD1B_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_0_zero_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a441a000() {
    // Encoding: 0xA441A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA441A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a443a000() {
    // Encoding: 0xA443A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA443A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a444a000() {
    // Encoding: 0xA444A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=4, Pg=0
    let encoding: u32 = 0xA444A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a447a000() {
    // Encoding: 0xA447A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA447A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a448a000() {
    // Encoding: 0xA448A000
    // Test LD1B_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA448A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1b_z_p_bi_u32_field_imm4_15_max_a000_a44fa000() {
    // Encoding: 0xA44FA000
    // Test LD1B_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA44FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u32_field_pg_0_min_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u32_field_pg_1_poweroftwo_a000_a440a400() {
    // Encoding: 0xA440A400
    // Test LD1B_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA440A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u32_field_rn_0_min_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u32_field_rn_1_poweroftwo_a000_a440a020() {
    // Encoding: 0xA440A020
    // Test LD1B_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA440A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a440a3c0() {
    // Encoding: 0xA440A3C0
    // Test LD1B_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA440A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bi_u32_field_rn_31_max_a000_a440a3e0() {
    // Encoding: 0xA440A3E0
    // Test LD1B_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bi_u32_field_zt_0_min_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bi_u32_field_zt_1_poweroftwo_a000_a440a001() {
    // Encoding: 0xA440A001
    // Test LD1B_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA440A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a440a01e() {
    // Encoding: 0xA440A01E
    // Test LD1B_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA440A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bi_u32_field_zt_31_max_a000_a440a01f() {
    // Encoding: 0xA440A01F
    // Test LD1B_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xA440A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_bi_u32_combo_0_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a440a3e0() {
    // Encoding: 0xA440A3E0
    // Test LD1B_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u32_invalid_0_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u32_invalid_1_a000_a440a000() {
    // Encoding: 0xA440A000
    // Test LD1B_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_0_zero_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a461a000() {
    // Encoding: 0xA461A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xA461A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a463a000() {
    // Encoding: 0xA463A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm4=3, Zt=0
    let encoding: u32 = 0xA463A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a464a000() {
    // Encoding: 0xA464A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, imm4=4, Zt=0, Pg=0
    let encoding: u32 = 0xA464A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a467a000() {
    // Encoding: 0xA467A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA467A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a468a000() {
    // Encoding: 0xA468A000
    // Test LD1B_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA468A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1b_z_p_bi_u64_field_imm4_15_max_a000_a46fa000() {
    // Encoding: 0xA46FA000
    // Test LD1B_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA46FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u64_field_pg_0_min_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u64_field_pg_1_poweroftwo_a000_a460a400() {
    // Encoding: 0xA460A400
    // Test LD1B_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, imm4=0
    let encoding: u32 = 0xA460A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1b_z_p_bi_u64_field_rn_0_min_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1b_z_p_bi_u64_field_rn_1_poweroftwo_a000_a460a020() {
    // Encoding: 0xA460A020
    // Test LD1B_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=1
    let encoding: u32 = 0xA460A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1b_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a460a3c0() {
    // Encoding: 0xA460A3C0
    // Test LD1B_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA460A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1b_z_p_bi_u64_field_rn_31_max_a000_a460a3e0() {
    // Encoding: 0xA460A3E0
    // Test LD1B_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, imm4=0
    let encoding: u32 = 0xA460A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1b_z_p_bi_u64_field_zt_0_min_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1b_z_p_bi_u64_field_zt_1_poweroftwo_a000_a460a001() {
    // Encoding: 0xA460A001
    // Test LD1B_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA460A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1b_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a460a01e() {
    // Encoding: 0xA460A01E
    // Test LD1B_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA460A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1b_z_p_bi_u64_field_zt_31_max_a000_a460a01f() {
    // Encoding: 0xA460A01F
    // Test LD1B_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA460A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1b_z_p_bi_u64_combo_0_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1b_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a460a3e0() {
    // Encoding: 0xA460A3E0
    // Test LD1B_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA460A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u64_invalid_0_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1b_z_p_bi_u64_invalid_1_a000_a460a000() {
    // Encoding: 0xA460A000
    // Test LD1B_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bi_u8_reg_write_0_a400a000() {
    // Test LD1B_Z.P.BI_U8 register write: SimdFromField("t")
    // Encoding: 0xA400A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bi_u8_sp_rn_a400a3e0() {
    // Test LD1B_Z.P.BI_U8 with Rn = SP (31)
    // Encoding: 0xA400A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bi_u16_reg_write_0_a420a000() {
    // Test LD1B_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0xA420A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA420A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bi_u16_sp_rn_a420a3e0() {
    // Test LD1B_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0xA420A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA420A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bi_u32_reg_write_0_a440a000() {
    // Test LD1B_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA440A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA440A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bi_u32_sp_rn_a440a3e0() {
    // Test LD1B_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA440A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA440A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1b_z_p_bi_u64_reg_write_0_a460a000() {
    // Test LD1B_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA460A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA460A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1B_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1b_z_p_bi_u64_sp_rn_a460a3e0() {
    // Test LD1B_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA460A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA460A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SB_Z.P.BI_S16 Tests
// ============================================================================

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_0_zero_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_1_poweroftwo_a000_a5c1a000() {
    // Encoding: 0xA5C1A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=1, Rn=0
    let encoding: u32 = 0xA5C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_3_poweroftwominusone_a000_a5c3a000() {
    // Encoding: 0xA5C3A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=3, Pg=0
    let encoding: u32 = 0xA5C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_4_poweroftwo_a000_a5c4a000() {
    // Encoding: 0xA5C4A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA5C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_7_poweroftwominusone_a000_a5c7a000() {
    // Encoding: 0xA5C7A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=7, Rn=0
    let encoding: u32 = 0xA5C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_8_poweroftwo_a000_a5c8a000() {
    // Encoding: 0xA5C8A000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sb_z_p_bi_s16_field_imm4_15_max_a000_a5cfa000() {
    // Encoding: 0xA5CFA000
    // Test LD1SB_Z.P.BI_S16 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Pg=0, Rn=0
    let encoding: u32 = 0xA5CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s16_field_pg_0_min_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s16_field_pg_1_poweroftwo_a000_a5c0a400() {
    // Encoding: 0xA5C0A400
    // Test LD1SB_Z.P.BI_S16 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA5C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s16_field_rn_0_min_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s16_field_rn_1_poweroftwo_a000_a5c0a020() {
    // Encoding: 0xA5C0A020
    // Test LD1SB_Z.P.BI_S16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bi_s16_field_rn_30_poweroftwominusone_a000_a5c0a3c0() {
    // Encoding: 0xA5C0A3C0
    // Test LD1SB_Z.P.BI_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bi_s16_field_rn_31_max_a000_a5c0a3e0() {
    // Encoding: 0xA5C0A3E0
    // Test LD1SB_Z.P.BI_S16 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bi_s16_field_zt_0_min_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bi_s16_field_zt_1_poweroftwo_a000_a5c0a001() {
    // Encoding: 0xA5C0A001
    // Test LD1SB_Z.P.BI_S16 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, imm4=0
    let encoding: u32 = 0xA5C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bi_s16_field_zt_30_poweroftwominusone_a000_a5c0a01e() {
    // Encoding: 0xA5C0A01E
    // Test LD1SB_Z.P.BI_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bi_s16_field_zt_31_max_a000_a5c0a01f() {
    // Encoding: 0xA5C0A01F
    // Test LD1SB_Z.P.BI_S16 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xA5C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sb_z_p_bi_s16_combo_0_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bi_s16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5c0a3e0() {
    // Encoding: 0xA5C0A3E0
    // Test LD1SB_Z.P.BI_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s16_invalid_0_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s16_invalid_1_a000_a5c0a000() {
    // Encoding: 0xA5C0A000
    // Test LD1SB_Z.P.BI_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_0_zero_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_1_poweroftwo_a000_a5a1a000() {
    // Encoding: 0xA5A1A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=1, Pg=0, Rn=0
    let encoding: u32 = 0xA5A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_3_poweroftwominusone_a000_a5a3a000() {
    // Encoding: 0xA5A3A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_4_poweroftwo_a000_a5a4a000() {
    // Encoding: 0xA5A4A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA5A4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_7_poweroftwominusone_a000_a5a7a000() {
    // Encoding: 0xA5A7A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xA5A7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_8_poweroftwo_a000_a5a8a000() {
    // Encoding: 0xA5A8A000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sb_z_p_bi_s32_field_imm4_15_max_a000_a5afa000() {
    // Encoding: 0xA5AFA000
    // Test LD1SB_Z.P.BI_S32 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xA5AFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s32_field_pg_0_min_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s32_field_pg_1_poweroftwo_a000_a5a0a400() {
    // Encoding: 0xA5A0A400
    // Test LD1SB_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s32_field_rn_0_min_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s32_field_rn_1_poweroftwo_a000_a5a0a020() {
    // Encoding: 0xA5A0A020
    // Test LD1SB_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_a5a0a3c0() {
    // Encoding: 0xA5A0A3C0
    // Test LD1SB_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=30, Zt=0
    let encoding: u32 = 0xA5A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bi_s32_field_rn_31_max_a000_a5a0a3e0() {
    // Encoding: 0xA5A0A3E0
    // Test LD1SB_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bi_s32_field_zt_0_min_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bi_s32_field_zt_1_poweroftwo_a000_a5a0a001() {
    // Encoding: 0xA5A0A001
    // Test LD1SB_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_a5a0a01e() {
    // Encoding: 0xA5A0A01E
    // Test LD1SB_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, imm4=0
    let encoding: u32 = 0xA5A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bi_s32_field_zt_31_max_a000_a5a0a01f() {
    // Encoding: 0xA5A0A01F
    // Test LD1SB_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sb_z_p_bi_s32_combo_0_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5a0a3e0() {
    // Encoding: 0xA5A0A3E0
    // Test LD1SB_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s32_invalid_0_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s32_invalid_1_a000_a5a0a000() {
    // Encoding: 0xA5A0A000
    // Test LD1SB_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_0_zero_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a581a000() {
    // Encoding: 0xA581A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=1
    let encoding: u32 = 0xA581A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a583a000() {
    // Encoding: 0xA583A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=3, Zt=0, Pg=0
    let encoding: u32 = 0xA583A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a584a000() {
    // Encoding: 0xA584A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Zt=0, Rn=0
    let encoding: u32 = 0xA584A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a587a000() {
    // Encoding: 0xA587A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Zt=0, Pg=0
    let encoding: u32 = 0xA587A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a588a000() {
    // Encoding: 0xA588A000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sb_z_p_bi_s64_field_imm4_15_max_a000_a58fa000() {
    // Encoding: 0xA58FA000
    // Test LD1SB_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA58FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s64_field_pg_0_min_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s64_field_pg_1_poweroftwo_a000_a580a400() {
    // Encoding: 0xA580A400
    // Test LD1SB_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=1
    let encoding: u32 = 0xA580A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sb_z_p_bi_s64_field_rn_0_min_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sb_z_p_bi_s64_field_rn_1_poweroftwo_a000_a580a020() {
    // Encoding: 0xA580A020
    // Test LD1SB_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sb_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a580a3c0() {
    // Encoding: 0xA580A3C0
    // Test LD1SB_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA580A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sb_z_p_bi_s64_field_rn_31_max_a000_a580a3e0() {
    // Encoding: 0xA580A3E0
    // Test LD1SB_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA580A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sb_z_p_bi_s64_field_zt_0_min_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sb_z_p_bi_s64_field_zt_1_poweroftwo_a000_a580a001() {
    // Encoding: 0xA580A001
    // Test LD1SB_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA580A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sb_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a580a01e() {
    // Encoding: 0xA580A01E
    // Test LD1SB_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=30
    let encoding: u32 = 0xA580A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sb_z_p_bi_s64_field_zt_31_max_a000_a580a01f() {
    // Encoding: 0xA580A01F
    // Test LD1SB_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Zt=31, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA580A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sb_z_p_bi_s64_combo_0_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sb_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a580a3e0() {
    // Encoding: 0xA580A3E0
    // Test LD1SB_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xA580A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s64_invalid_0_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sb_z_p_bi_s64_invalid_1_a000_a580a000() {
    // Encoding: 0xA580A000
    // Test LD1SB_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bi_s16_reg_write_0_a5c0a000() {
    // Test LD1SB_Z.P.BI_S16 register write: SimdFromField("t")
    // Encoding: 0xA5C0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BI_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bi_s16_sp_rn_a5c0a3e0() {
    // Test LD1SB_Z.P.BI_S16 with Rn = SP (31)
    // Encoding: 0xA5C0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bi_s32_reg_write_0_a5a0a000() {
    // Test LD1SB_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0xA5A0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bi_s32_sp_rn_a5a0a3e0() {
    // Test LD1SB_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0xA5A0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sb_z_p_bi_s64_reg_write_0_a580a000() {
    // Test LD1SB_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA580A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SB_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sb_z_p_bi_s64_sp_rn_a580a3e0() {
    // Test LD1SB_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA580A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rm_0_min_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a561c000() {
    // Encoding: 0xA561C000
    // Test LD4W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA561C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a57ec000() {
    // Encoding: 0xA57EC000
    // Test LD4W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Zt=0, Pg=0
    let encoding: u32 = 0xA57EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rm_31_max_c000_a57fc000() {
    // Encoding: 0xA57FC000
    // Test LD4W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xA57FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_pg_0_min_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a560c400() {
    // Encoding: 0xA560C400
    // Test LD4W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA560C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rn_0_min_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a560c020() {
    // Encoding: 0xA560C020
    // Test LD4W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=1, Rm=0
    let encoding: u32 = 0xA560C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a560c3c0() {
    // Encoding: 0xA560C3C0
    // Test LD4W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, Rm=0
    let encoding: u32 = 0xA560C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4w_z_p_br_contiguous_field_rn_31_max_c000_a560c3e0() {
    // Encoding: 0xA560C3E0
    // Test LD4W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Pg=0, Rm=0
    let encoding: u32 = 0xA560C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4w_z_p_br_contiguous_field_zt_0_min_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4w_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a560c001() {
    // Encoding: 0xA560C001
    // Test LD4W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA560C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4w_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a560c01e() {
    // Encoding: 0xA560C01E
    // Test LD4W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA560C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4w_z_p_br_contiguous_field_zt_31_max_c000_a560c01f() {
    // Encoding: 0xA560C01F
    // Test LD4W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Rm=0, Zt=31, Pg=0
    let encoding: u32 = 0xA560C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld4w_z_p_br_contiguous_combo_0_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a560c3e0()
{
    // Encoding: 0xA560C3E0
    // Test LD4W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA560C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_br_contiguous_invalid_0_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_br_contiguous_invalid_1_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_br_contiguous_invalid_2_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4w_z_p_br_contiguous_invalid_3_c000_a560c000() {
    // Encoding: 0xA560C000
    // Test LD4W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4w_z_p_br_contiguous_sp_rn_a560c3e0() {
    // Test LD4W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA560C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA560C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_0_zero_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a541e000() {
    // Encoding: 0xA541E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xA541E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a543e000() {
    // Encoding: 0xA543E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=3, Zt=0
    let encoding: u32 = 0xA543E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a544e000() {
    // Encoding: 0xA544E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xA544E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a547e000() {
    // Encoding: 0xA547E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xA547E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a548e000() {
    // Encoding: 0xA548E000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA548E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_imm4_15_max_e000_a54fe000() {
    // Encoding: 0xA54FE000
    // Test LD3W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=15
    let encoding: u32 = 0xA54FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_pg_0_min_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a540e400() {
    // Encoding: 0xA540E400
    // Test LD3W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, imm4=0, Rn=0
    let encoding: u32 = 0xA540E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_rn_0_min_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a540e020() {
    // Encoding: 0xA540E020
    // Test LD3W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA540E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a540e3c0() {
    // Encoding: 0xA540E3C0
    // Test LD3W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA540E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3w_z_p_bi_contiguous_field_rn_31_max_e000_a540e3e0() {
    // Encoding: 0xA540E3E0
    // Test LD3W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3w_z_p_bi_contiguous_field_zt_0_min_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a540e001() {
    // Encoding: 0xA540E001
    // Test LD3W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA540E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a540e01e() {
    // Encoding: 0xA540E01E
    // Test LD3W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, imm4=0, Rn=0
    let encoding: u32 = 0xA540E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3w_z_p_bi_contiguous_field_zt_31_max_e000_a540e01f() {
    // Encoding: 0xA540E01F
    // Test LD3W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, imm4=0
    let encoding: u32 = 0xA540E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld3w_z_p_bi_contiguous_combo_0_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a540e3e0()
{
    // Encoding: 0xA540E3E0
    // Test LD3W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_bi_contiguous_invalid_0_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3w_z_p_bi_contiguous_invalid_1_e000_a540e000() {
    // Encoding: 0xA540E000
    // Test LD3W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3w_z_p_bi_contiguous_sp_rn_a540e3e0() {
    // Test LD3W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA540E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA540E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rm_0_min_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a481c000() {
    // Encoding: 0xA481C000
    // Test LDNT1H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA481C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a49ec000() {
    // Encoding: 0xA49EC000
    // Test LDNT1H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Zt=0, Pg=0
    let encoding: u32 = 0xA49EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rm_31_max_c000_a49fc000() {
    // Encoding: 0xA49FC000
    // Test LDNT1H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=31, Rn=0
    let encoding: u32 = 0xA49FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_pg_0_min_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a480c400() {
    // Encoding: 0xA480C400
    // Test LDNT1H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=1
    let encoding: u32 = 0xA480C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rn_0_min_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a480c020() {
    // Encoding: 0xA480C020
    // Test LDNT1H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA480C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a480c3c0() {
    // Encoding: 0xA480C3C0
    // Test LDNT1H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA480C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_rn_31_max_c000_a480c3e0() {
    // Encoding: 0xA480C3E0
    // Test LDNT1H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA480C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_zt_0_min_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a480c001() {
    // Encoding: 0xA480C001
    // Test LDNT1H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xA480C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a480c01e() {
    // Encoding: 0xA480C01E
    // Test LDNT1H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA480C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1h_z_p_br_contiguous_field_zt_31_max_c000_a480c01f() {
    // Encoding: 0xA480C01F
    // Test LDNT1H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA480C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldnt1h_z_p_br_contiguous_combo_0_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a480c3e0(
) {
    // Encoding: 0xA480C3E0
    // Test LDNT1H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rm=0, Rn=31, Pg=0
    let encoding: u32 = 0xA480C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_br_contiguous_invalid_0_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_br_contiguous_invalid_1_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_br_contiguous_invalid_2_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1h_z_p_br_contiguous_invalid_3_c000_a480c000() {
    // Encoding: 0xA480C000
    // Test LDNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1h_z_p_br_contiguous_reg_write_0_a480c000() {
    // Test LDNT1H_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA480C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1h_z_p_br_contiguous_sp_rn_a480c3e0() {
    // Test LDNT1H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA480C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA480C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rm_0_min_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a5e1c000() {
    // Encoding: 0xA5E1C000
    // Test LD4D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=1
    let encoding: u32 = 0xA5E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a5fec000() {
    // Encoding: 0xA5FEC000
    // Test LD4D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xA5FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rm_31_max_c000_a5ffc000() {
    // Encoding: 0xA5FFC000
    // Test LD4D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xA5FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_pg_0_min_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a5e0c400() {
    // Encoding: 0xA5E0C400
    // Test LD4D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rn_0_min_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a5e0c020() {
    // Encoding: 0xA5E0C020
    // Test LD4D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=1, Rm=0
    let encoding: u32 = 0xA5E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a5e0c3c0() {
    // Encoding: 0xA5E0C3C0
    // Test LD4D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4d_z_p_br_contiguous_field_rn_31_max_c000_a5e0c3e0() {
    // Encoding: 0xA5E0C3E0
    // Test LD4D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xA5E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4d_z_p_br_contiguous_field_zt_0_min_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4d_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a5e0c001() {
    // Encoding: 0xA5E0C001
    // Test LD4D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4d_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a5e0c01e() {
    // Encoding: 0xA5E0C01E
    // Test LD4D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA5E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4d_z_p_br_contiguous_field_zt_31_max_c000_a5e0c01f() {
    // Encoding: 0xA5E0C01F
    // Test LD4D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xA5E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld4d_z_p_br_contiguous_combo_0_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a5e0c3e0()
{
    // Encoding: 0xA5E0C3E0
    // Test LD4D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rm=0, Rn=31, Pg=0
    let encoding: u32 = 0xA5E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_br_contiguous_invalid_0_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_br_contiguous_invalid_1_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_br_contiguous_invalid_2_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4d_z_p_br_contiguous_invalid_3_c000_a5e0c000() {
    // Encoding: 0xA5E0C000
    // Test LD4D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4d_z_p_br_contiguous_sp_rn_a5e0c3e0() {
    // Test LD4D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA5E0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1H_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_xs_0_min_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_xs_1_max_6000_84e06000() {
    // Encoding: 0x84E06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Zm=0, Rn=0, Zt=0, xs=1, Pg=0
    let encoding: u32 = 0x84E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zm_0_min_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_6000_84a16000() {
    // Encoding: 0x84A16000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_6000_84be6000() {
    // Encoding: 0x84BE6000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=0, Zm=30, Pg=0, Zt=0
    let encoding: u32 = 0x84BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zm_31_max_6000_84bf6000() {
    // Encoding: 0x84BF6000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_pg_0_min_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_6000_84a06400() {
    // Encoding: 0x84A06400
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0x84A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_rn_0_min_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, xs=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_6000_84a06020() {
    // Encoding: 0x84A06020
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_6000_84a063c0() {
    // Encoding: 0x84A063C0
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0x84A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_rn_31_max_6000_84a063e0() {
    // Encoding: 0x84A063E0
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x84A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zt_0_min_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_6000_84a06001() {
    // Encoding: 0x84A06001
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0x84A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_6000_84a0601e() {
    // Encoding: 0x84A0601E
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_field_zt_31_max_6000_84a0601f() {
    // Encoding: 0x84A0601F
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Zm=0, Zt=31, Pg=0, xs=0
    let encoding: u32 = 0x84A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_combo_0_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_84a063e0(
) {
    // Encoding: 0x84A063E0
    // Test LDFF1H_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0, xs=0
    let encoding: u32 = 0x84A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_invalid_0_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_invalid_1_6000_84a06000() {
    // Encoding: 0x84A06000
    // Test LDFF1H_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_xs_0_min_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Zm=0, xs=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_xs_1_max_6000_c4e06000() {
    // Encoding: 0xC4E06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: xs=1, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zm_0_min_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_6000_c4a16000() {
    // Encoding: 0xC4A16000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC4A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_6000_c4be6000() {
    // Encoding: 0xC4BE6000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zm=30, xs=0, Rn=0
    let encoding: u32 = 0xC4BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zm_31_max_6000_c4bf6000() {
    // Encoding: 0xC4BF6000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Rn=0, Zm=31, xs=0, Pg=0
    let encoding: u32 = 0xC4BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_pg_0_min_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_6000_c4a06400() {
    // Encoding: 0xC4A06400
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xC4A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_rn_0_min_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_6000_c4a06020() {
    // Encoding: 0xC4A06020
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, xs=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_6000_c4a063c0() {
    // Encoding: 0xC4A063C0
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC4A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_rn_31_max_6000_c4a063e0() {
    // Encoding: 0xC4A063E0
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zt_0_min_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_6000_c4a06001() {
    // Encoding: 0xC4A06001
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=1, xs=0, Pg=0
    let encoding: u32 = 0xC4A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_6000_c4a0601e() {
    // Encoding: 0xC4A0601E
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_field_zt_31_max_6000_c4a0601f() {
    // Encoding: 0xC4A0601F
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, xs=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xC4A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_combo_0_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c4a063e0(
) {
    // Encoding: 0xC4A063E0
    // Test LDFF1H_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_invalid_0_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_invalid_1_6000_c4a06000() {
    // Encoding: 0xC4A06000
    // Test LDFF1H_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_xs_0_min_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_xs_1_max_6000_c4c06000() {
    // Encoding: 0xC4C06000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zm_0_min_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_6000_c4816000() {
    // Encoding: 0xC4816000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Pg=0, Zt=0, Zm=1
    let encoding: u32 = 0xC4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_6000_c49e6000() {
    // Encoding: 0xC49E6000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zm_31_max_6000_c49f6000() {
    // Encoding: 0xC49F6000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_pg_0_min_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_6000_c4806400() {
    // Encoding: 0xC4806400
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=1
    let encoding: u32 = 0xC4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_rn_0_min_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_6000_c4806020() {
    // Encoding: 0xC4806020
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_6000_c48063c0() {
    // Encoding: 0xC48063C0
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=0, Rn=30, xs=0, Pg=0
    let encoding: u32 = 0xC48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_rn_31_max_6000_c48063e0() {
    // Encoding: 0xC48063E0
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zt_0_min_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_6000_c4806001() {
    // Encoding: 0xC4806001
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_6000_c480601e() {
    // Encoding: 0xC480601E
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_field_zt_31_max_6000_c480601f() {
    // Encoding: 0xC480601F
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_combo_0_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c48063e0(
) {
    // Encoding: 0xC48063E0
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=31, xs=0
    let encoding: u32 = 0xC48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_invalid_0_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_invalid_1_6000_c4806000() {
    // Encoding: 0xC4806000
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_xs_0_min_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_xs_1_max_6000_84c06000() {
    // Encoding: 0x84C06000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0, xs=1
    let encoding: u32 = 0x84C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zm_0_min_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_6000_84816000() {
    // Encoding: 0x84816000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=0, Zm=1, Pg=0, Rn=0
    let encoding: u32 = 0x84816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_6000_849e6000() {
    // Encoding: 0x849E6000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zt=0, Zm=30, Rn=0
    let encoding: u32 = 0x849E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zm_31_max_6000_849f6000() {
    // Encoding: 0x849F6000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x849F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_pg_0_min_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_6000_84806400() {
    // Encoding: 0x84806400
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=1, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_rn_0_min_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_6000_84806020() {
    // Encoding: 0x84806020
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x84806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_6000_848063c0() {
    // Encoding: 0x848063C0
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=30
    let encoding: u32 = 0x848063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_rn_31_max_6000_848063e0() {
    // Encoding: 0x848063E0
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0x848063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zt_0_min_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_6000_84806001() {
    // Encoding: 0x84806001
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0x84806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_6000_8480601e() {
    // Encoding: 0x8480601E
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=30
    let encoding: u32 = 0x8480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_field_zt_31_max_6000_8480601f() {
    // Encoding: 0x8480601F
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0x8480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_combo_0_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_848063e0(
) {
    // Encoding: 0x848063E0
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zt=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0x848063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_invalid_0_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_invalid_1_6000_84806000() {
    // Encoding: 0x84806000
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zm_0_min_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_e000_c4e1e000() {
    // Encoding: 0xC4E1E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_e000_c4fee000() {
    // Encoding: 0xC4FEE000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zm=30, Zt=0
    let encoding: u32 = 0xC4FEE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zm_31_max_e000_c4ffe000() {
    // Encoding: 0xC4FFE000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_pg_0_min_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_e000_c4e0e400() {
    // Encoding: 0xC4E0E400
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=1
    let encoding: u32 = 0xC4E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_rn_0_min_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_e000_c4e0e020() {
    // Encoding: 0xC4E0E020
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_e000_c4e0e3c0() {
    // Encoding: 0xC4E0E3C0
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Zm=0
    let encoding: u32 = 0xC4E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_rn_31_max_e000_c4e0e3e0() {
    // Encoding: 0xC4E0E3E0
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zt_0_min_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_e000_c4e0e001() {
    // Encoding: 0xC4E0E001
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xC4E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_e000_c4e0e01e() {
    // Encoding: 0xC4E0E01E
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zt=30, Rn=0
    let encoding: u32 = 0xC4E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_field_zt_31_max_e000_c4e0e01f() {
    // Encoding: 0xC4E0E01F
    // Test LDFF1H_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xC4E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_combo_0_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c4e0e3e0(
) {
    // Encoding: 0xC4E0E3E0
    // Test LDFF1H_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, Zm=0
    let encoding: u32 = 0xC4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_invalid_0_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_invalid_1_e000_c4e0e000() {
    // Encoding: 0xC4E0E000
    // Test LDFF1H_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zm_0_min_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_e000_c4c1e000() {
    // Encoding: 0xC4C1E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_e000_c4dee000() {
    // Encoding: 0xC4DEE000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4DEE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zm_31_max_e000_c4dfe000() {
    // Encoding: 0xC4DFE000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, Zm=31, Rn=0
    let encoding: u32 = 0xC4DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_pg_0_min_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_e000_c4c0e400() {
    // Encoding: 0xC4C0E400
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_rn_0_min_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_e000_c4c0e020() {
    // Encoding: 0xC4C0E020
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xC4C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_e000_c4c0e3c0() {
    // Encoding: 0xC4C0E3C0
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_rn_31_max_e000_c4c0e3e0() {
    // Encoding: 0xC4C0E3E0
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC4C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zt_0_min_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_e000_c4c0e001() {
    // Encoding: 0xC4C0E001
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, Zm=0
    let encoding: u32 = 0xC4C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_e000_c4c0e01e() {
    // Encoding: 0xC4C0E01E
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_field_zt_31_max_e000_c4c0e01f() {
    // Encoding: 0xC4C0E01F
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_combo_0_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c4c0e3e0(
) {
    // Encoding: 0xC4C0E3E0
    // Test LDFF1H_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xC4C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_invalid_0_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_invalid_1_e000_c4c0e000() {
    // Encoding: 0xC4C0E000
    // Test LDFF1H_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_reg_write_0_84a06000() {
    // Test LDFF1H_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_s_x32_scaled_sp_rn_84a063e0() {
    // Test LDFF1H_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_reg_write_0_c4a06000() {
    // Test LDFF1H_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_d_x32_scaled_sp_rn_c4a063e0() {
    // Test LDFF1H_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_reg_write_0_c4806000() {
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_d_x32_unscaled_sp_rn_c48063e0() {
    // Test LDFF1H_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_reg_write_0_84806000() {
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_s_x32_unscaled_sp_rn_848063e0() {
    // Test LDFF1H_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_reg_write_0_c4e0e000() {
    // Test LDFF1H_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_d_64_scaled_sp_rn_c4e0e3e0() {
    // Test LDFF1H_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_reg_write_0_c4c0e000() {
    // Test LDFF1H_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1H_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1h_z_p_bz_d_64_unscaled_sp_rn_c4c0e3e0() {
    // Test LDFF1H_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_0_zero_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a5c1e000() {
    // Encoding: 0xA5C1E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xA5C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a5c3e000() {
    // Encoding: 0xA5C3E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5C3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a5c4e000() {
    // Encoding: 0xA5C4E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5C4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a5c7e000() {
    // Encoding: 0xA5C7E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Rn=0, Pg=0
    let encoding: u32 = 0xA5C7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a5c8e000() {
    // Encoding: 0xA5C8E000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5C8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_imm4_15_max_e000_a5cfe000() {
    // Encoding: 0xA5CFE000
    // Test LD3D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=15
    let encoding: u32 = 0xA5CFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_pg_0_min_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a5c0e400() {
    // Encoding: 0xA5C0E400
    // Test LD3D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA5C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_rn_0_min_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a5c0e020() {
    // Encoding: 0xA5C0E020
    // Test LD3D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a5c0e3c0() {
    // Encoding: 0xA5C0E3C0
    // Test LD3D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, imm4=0
    let encoding: u32 = 0xA5C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3d_z_p_bi_contiguous_field_rn_31_max_e000_a5c0e3e0() {
    // Encoding: 0xA5C0E3E0
    // Test LD3D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3d_z_p_bi_contiguous_field_zt_0_min_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a5c0e001() {
    // Encoding: 0xA5C0E001
    // Test LD3D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA5C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a5c0e01e() {
    // Encoding: 0xA5C0E01E
    // Test LD3D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=30
    let encoding: u32 = 0xA5C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3d_z_p_bi_contiguous_field_zt_31_max_e000_a5c0e01f() {
    // Encoding: 0xA5C0E01F
    // Test LD3D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, imm4=0
    let encoding: u32 = 0xA5C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld3d_z_p_bi_contiguous_combo_0_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a5c0e3e0()
{
    // Encoding: 0xA5C0E3E0
    // Test LD3D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA5C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_bi_contiguous_invalid_0_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3d_z_p_bi_contiguous_invalid_1_e000_a5c0e000() {
    // Encoding: 0xA5C0E000
    // Test LD3D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3d_z_p_bi_contiguous_sp_rn_a5c0e3e0() {
    // Test LD3D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA5C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQH_Z.P.BI_U16 Tests
// ============================================================================

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_0_zero_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 0 (Zero)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_1_poweroftwo_2000_a4812000() {
    // Encoding: 0xA4812000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_3_poweroftwominusone_2000_a4832000() {
    // Encoding: 0xA4832000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA4832000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_4_poweroftwo_2000_a4842000() {
    // Encoding: 0xA4842000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=4, Rn=0
    let encoding: u32 = 0xA4842000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_7_poweroftwominusone_2000_a4872000() {
    // Encoding: 0xA4872000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_8_poweroftwo_2000_a4882000() {
    // Encoding: 0xA4882000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=8, Rn=0
    let encoding: u32 = 0xA4882000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_imm4_15_max_2000_a48f2000() {
    // Encoding: 0xA48F2000
    // Test LD1RQH_Z.P.BI_U16 field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Zt=0, Pg=0
    let encoding: u32 = 0xA48F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_pg_0_min_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_pg_1_poweroftwo_2000_a4802400() {
    // Encoding: 0xA4802400
    // Test LD1RQH_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, imm4=0, Rn=0
    let encoding: u32 = 0xA4802400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_rn_0_min_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_rn_1_poweroftwo_2000_a4802020() {
    // Encoding: 0xA4802020
    // Test LD1RQH_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA4802020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_rn_30_poweroftwominusone_2000_a48023c0() {
    // Encoding: 0xA48023C0
    // Test LD1RQH_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Rn=30, Pg=0
    let encoding: u32 = 0xA48023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqh_z_p_bi_u16_field_rn_31_max_2000_a48023e0() {
    // Encoding: 0xA48023E0
    // Test LD1RQH_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA48023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqh_z_p_bi_u16_field_zt_0_min_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqh_z_p_bi_u16_field_zt_1_poweroftwo_2000_a4802001() {
    // Encoding: 0xA4802001
    // Test LD1RQH_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4802001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqh_z_p_bi_u16_field_zt_30_poweroftwominusone_2000_a480201e() {
    // Encoding: 0xA480201E
    // Test LD1RQH_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA480201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqh_z_p_bi_u16_field_zt_31_max_2000_a480201f() {
    // Encoding: 0xA480201F
    // Test LD1RQH_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=31
    let encoding: u32 = 0xA480201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1rqh_z_p_bi_u16_combo_0_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqh_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_8192_a48023e0() {
    // Encoding: 0xA48023E0
    // Test LD1RQH_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA48023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_bi_u16_invalid_0_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqh_z_p_bi_u16_invalid_1_2000_a4802000() {
    // Encoding: 0xA4802000
    // Test LD1RQH_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqh_z_p_bi_u16_reg_write_0_a4802000() {
    // Test LD1RQH_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0xA4802000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4802000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQH_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqh_z_p_bi_u16_sp_rn_a48023e0() {
    // Test LD1RQH_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0xA48023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA48023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SH_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_xs_0_min_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_xs_1_max_2000_84e02000() {
    // Encoding: 0x84E02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Pg=0, xs=1, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zm_0_min_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_2000_84a12000() {
    // Encoding: 0x84A12000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x84A12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_2000_84be2000() {
    // Encoding: 0x84BE2000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0x84BE2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zm_31_max_2000_84bf2000() {
    // Encoding: 0x84BF2000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x84BF2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_pg_0_min_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_2000_84a02400() {
    // Encoding: 0x84A02400
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=1
    let encoding: u32 = 0x84A02400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_rn_0_min_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_2000_84a02020() {
    // Encoding: 0x84A02020
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_2000_84a023c0() {
    // Encoding: 0x84A023C0
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, Zm=0, xs=0
    let encoding: u32 = 0x84A023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_rn_31_max_2000_84a023e0() {
    // Encoding: 0x84A023E0
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0x84A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zt_0_min_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_2000_84a02001() {
    // Encoding: 0x84A02001
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=1, xs=0, Pg=0
    let encoding: u32 = 0x84A02001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_2000_84a0201e() {
    // Encoding: 0x84A0201E
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x84A0201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_field_zt_31_max_2000_84a0201f() {
    // Encoding: 0x84A0201F
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Pg=0, Zm=0, Zt=31, Rn=0
    let encoding: u32 = 0x84A0201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_combo_0_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_84a023e0(
) {
    // Encoding: 0x84A023E0
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0x84A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_invalid_0_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_invalid_1_2000_84a02000() {
    // Encoding: 0x84A02000
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0x84A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_xs_0_min_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_xs_1_max_2000_c4e02000() {
    // Encoding: 0xC4E02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Zm=0, Pg=0, Zt=0, xs=1, Rn=0
    let encoding: u32 = 0xC4E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zm_0_min_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_2000_c4a12000() {
    // Encoding: 0xC4A12000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zm=1, Rn=0, xs=0
    let encoding: u32 = 0xC4A12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_2000_c4be2000() {
    // Encoding: 0xC4BE2000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Zm=30, Pg=0, xs=0
    let encoding: u32 = 0xC4BE2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zm_31_max_2000_c4bf2000() {
    // Encoding: 0xC4BF2000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, xs=0, Zm=31, Rn=0
    let encoding: u32 = 0xC4BF2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_pg_0_min_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_2000_c4a02400() {
    // Encoding: 0xC4A02400
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, xs=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4A02400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_rn_0_min_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_2000_c4a02020() {
    // Encoding: 0xC4A02020
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_2000_c4a023c0() {
    // Encoding: 0xC4A023C0
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, xs=0, Zm=0
    let encoding: u32 = 0xC4A023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_rn_31_max_2000_c4a023e0() {
    // Encoding: 0xC4A023E0
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zt_0_min_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_2000_c4a02001() {
    // Encoding: 0xC4A02001
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zt=1, Rn=0, xs=0
    let encoding: u32 = 0xC4A02001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_2000_c4a0201e() {
    // Encoding: 0xC4A0201E
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=0, Zt=30, Pg=0, Zm=0
    let encoding: u32 = 0xC4A0201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_field_zt_31_max_2000_c4a0201f() {
    // Encoding: 0xC4A0201F
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=31
    let encoding: u32 = 0xC4A0201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_combo_0_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_c4a023e0(
) {
    // Encoding: 0xC4A023E0
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xC4A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_invalid_0_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_invalid_1_2000_c4a02000() {
    // Encoding: 0xC4A02000
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_xs_0_min_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_xs_1_max_2000_c4c02000() {
    // Encoding: 0xC4C02000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zm_0_min_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_2000_c4812000() {
    // Encoding: 0xC4812000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0xC4812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_2000_c49e2000() {
    // Encoding: 0xC49E2000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=30, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC49E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zm_31_max_2000_c49f2000() {
    // Encoding: 0xC49F2000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=31
    let encoding: u32 = 0xC49F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_pg_0_min_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_2000_c4802400() {
    // Encoding: 0xC4802400
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=1, xs=0
    let encoding: u32 = 0xC4802400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_rn_0_min_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_2000_c4802020() {
    // Encoding: 0xC4802020
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xC4802020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_2000_c48023c0() {
    // Encoding: 0xC48023C0
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC48023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_rn_31_max_2000_c48023e0() {
    // Encoding: 0xC48023E0
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC48023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zt_0_min_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_2000_c4802001() {
    // Encoding: 0xC4802001
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4802001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_2000_c480201e() {
    // Encoding: 0xC480201E
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=30, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xC480201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_field_zt_31_max_2000_c480201f() {
    // Encoding: 0xC480201F
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Pg=0, Zt=31, Zm=0, Rn=0
    let encoding: u32 = 0xC480201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_combo_0_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_c48023e0(
) {
    // Encoding: 0xC48023E0
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Zm=0, Zt=0, Rn=31
    let encoding: u32 = 0xC48023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_invalid_0_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_invalid_1_2000_c4802000() {
    // Encoding: 0xC4802000
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_xs_0_min_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_xs_1_max_2000_84c02000() {
    // Encoding: 0x84C02000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=1
    let encoding: u32 = 0x84C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zm_0_min_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_2000_84812000() {
    // Encoding: 0x84812000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Rn=0, Zm=1, Zt=0
    let encoding: u32 = 0x84812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_2000_849e2000() {
    // Encoding: 0x849E2000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, xs=0, Pg=0
    let encoding: u32 = 0x849E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zm_31_max_2000_849f2000() {
    // Encoding: 0x849F2000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Zt=0, Rn=0, Zm=31, Pg=0
    let encoding: u32 = 0x849F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_pg_0_min_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_2000_84802400() {
    // Encoding: 0x84802400
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=1, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0x84802400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_rn_0_min_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_2000_84802020() {
    // Encoding: 0x84802020
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=1
    let encoding: u32 = 0x84802020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_2000_848023c0() {
    // Encoding: 0x848023C0
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=30
    let encoding: u32 = 0x848023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_rn_31_max_2000_848023e0() {
    // Encoding: 0x848023E0
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0, xs=0
    let encoding: u32 = 0x848023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zt_0_min_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_2000_84802001() {
    // Encoding: 0x84802001
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, xs=0, Zt=1, Pg=0
    let encoding: u32 = 0x84802001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_2000_8480201e() {
    // Encoding: 0x8480201E
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0x8480201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_field_zt_31_max_2000_8480201f() {
    // Encoding: 0x8480201F
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=31
    let encoding: u32 = 0x8480201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_combo_0_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_848023e0(
) {
    // Encoding: 0x848023E0
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, Rn=31, xs=0, Zt=0
    let encoding: u32 = 0x848023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_invalid_0_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_invalid_1_2000_84802000() {
    // Encoding: 0x84802000
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0x84802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zm_0_min_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_a000_c4e1a000() {
    // Encoding: 0xC4E1A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_a000_c4fea000() {
    // Encoding: 0xC4FEA000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=30
    let encoding: u32 = 0xC4FEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zm_31_max_a000_c4ffa000() {
    // Encoding: 0xC4FFA000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=31, Rn=0
    let encoding: u32 = 0xC4FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_pg_0_min_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_a000_c4e0a400() {
    // Encoding: 0xC4E0A400
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0xC4E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_rn_0_min_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_a000_c4e0a020() {
    // Encoding: 0xC4E0A020
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=1
    let encoding: u32 = 0xC4E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_a000_c4e0a3c0() {
    // Encoding: 0xC4E0A3C0
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_rn_31_max_a000_c4e0a3e0() {
    // Encoding: 0xC4E0A3E0
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zt_0_min_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_a000_c4e0a001() {
    // Encoding: 0xC4E0A001
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC4E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_a000_c4e0a01e() {
    // Encoding: 0xC4E0A01E
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_field_zt_31_max_a000_c4e0a01f() {
    // Encoding: 0xC4E0A01F
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xC4E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_combo_0_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_c4e0a3e0(
) {
    // Encoding: 0xC4E0A3E0
    // Test LDFF1SH_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_invalid_0_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_invalid_1_a000_c4e0a000() {
    // Encoding: 0xC4E0A000
    // Test LDFF1SH_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zm_0_min_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_c4c1a000() {
    // Encoding: 0xC4C1A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_c4dea000() {
    // Encoding: 0xC4DEA000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0xC4DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zm_31_max_a000_c4dfa000() {
    // Encoding: 0xC4DFA000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Pg=0, Zt=0
    let encoding: u32 = 0xC4DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_pg_0_min_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_c4c0a400() {
    // Encoding: 0xC4C0A400
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_rn_0_min_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_c4c0a020() {
    // Encoding: 0xC4C0A020
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=1, Pg=0
    let encoding: u32 = 0xC4C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_c4c0a3c0() {
    // Encoding: 0xC4C0A3C0
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xC4C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_rn_31_max_a000_c4c0a3e0() {
    // Encoding: 0xC4C0A3E0
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xC4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zt_0_min_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_c4c0a001() {
    // Encoding: 0xC4C0A001
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Zm=0
    let encoding: u32 = 0xC4C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_c4c0a01e() {
    // Encoding: 0xC4C0A01E
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC4C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_field_zt_31_max_a000_c4c0a01f() {
    // Encoding: 0xC4C0A01F
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Zm=0, Zt=31, Rn=0
    let encoding: u32 = 0xC4C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_combo_0_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_c4c0a3e0(
) {
    // Encoding: 0xC4C0A3E0
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xC4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_invalid_0_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_invalid_1_a000_c4c0a000() {
    // Encoding: 0xC4C0A000
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_reg_write_0_84a02000() {
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A02000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A02000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_scaled_sp_rn_84a023e0() {
    // Test LDFF1SH_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_reg_write_0_c4a02000() {
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A02000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A02000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_scaled_sp_rn_c4a023e0() {
    // Test LDFF1SH_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_reg_write_0_c4802000() {
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4802000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4802000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_d_x32_unscaled_sp_rn_c48023e0() {
    // Test LDFF1SH_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_reg_write_0_84802000() {
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84802000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84802000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_s_x32_unscaled_sp_rn_848023e0() {
    // Test LDFF1SH_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_reg_write_0_c4e0a000() {
    // Test LDFF1SH_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_d_64_scaled_sp_rn_c4e0a3e0() {
    // Test LDFF1SH_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_reg_write_0_c4c0a000() {
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sh_z_p_bz_d_64_unscaled_sp_rn_c4c0a3e0() {
    // Test LDFF1SH_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_0_zero_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a4a1e000() {
    // Encoding: 0xA4A1E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=1, Pg=0
    let encoding: u32 = 0xA4A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a4a3e000() {
    // Encoding: 0xA4A3E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=3
    let encoding: u32 = 0xA4A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a4a4e000() {
    // Encoding: 0xA4A4E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Zt=0, Rn=0
    let encoding: u32 = 0xA4A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a4a7e000() {
    // Encoding: 0xA4A7E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=7
    let encoding: u32 = 0xA4A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a4a8e000() {
    // Encoding: 0xA4A8E000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_imm4_15_max_e000_a4afe000() {
    // Encoding: 0xA4AFE000
    // Test LD2H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Pg=0, Rn=0
    let encoding: u32 = 0xA4AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_pg_0_min_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a4a0e400() {
    // Encoding: 0xA4A0E400
    // Test LD2H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4A0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_rn_0_min_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a4a0e020() {
    // Encoding: 0xA4A0E020
    // Test LD2H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a4a0e3c0() {
    // Encoding: 0xA4A0E3C0
    // Test LD2H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA4A0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2h_z_p_bi_contiguous_field_rn_31_max_e000_a4a0e3e0() {
    // Encoding: 0xA4A0E3E0
    // Test LD2H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA4A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2h_z_p_bi_contiguous_field_zt_0_min_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a4a0e001() {
    // Encoding: 0xA4A0E001
    // Test LD2H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a4a0e01e() {
    // Encoding: 0xA4A0E01E
    // Test LD2H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, imm4=0
    let encoding: u32 = 0xA4A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2h_z_p_bi_contiguous_field_zt_31_max_e000_a4a0e01f() {
    // Encoding: 0xA4A0E01F
    // Test LD2H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=31
    let encoding: u32 = 0xA4A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld2h_z_p_bi_contiguous_combo_0_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a4a0e3e0()
{
    // Encoding: 0xA4A0E3E0
    // Test LD2H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Rn=31, Pg=0
    let encoding: u32 = 0xA4A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_bi_contiguous_invalid_0_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2h_z_p_bi_contiguous_invalid_1_e000_a4a0e000() {
    // Encoding: 0xA4A0E000
    // Test LD2H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2h_z_p_bi_contiguous_sp_rn_a4a0e3e0() {
    // Test LD2H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA4A0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1H_Z.P.BI_U16 Tests
// ============================================================================

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_0_zero_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 0 (Zero)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_1_poweroftwo_a000_a4a1a000() {
    // Encoding: 0xA4A1A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_3_poweroftwominusone_a000_a4a3a000() {
    // Encoding: 0xA4A3A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=3, Zt=0
    let encoding: u32 = 0xA4A3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_4_poweroftwo_a000_a4a4a000() {
    // Encoding: 0xA4A4A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=4
    let encoding: u32 = 0xA4A4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_7_poweroftwominusone_a000_a4a7a000() {
    // Encoding: 0xA4A7A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_8_poweroftwo_a000_a4a8a000() {
    // Encoding: 0xA4A8A000
    // Test LD1H_Z.P.BI_U16 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=8, Pg=0
    let encoding: u32 = 0xA4A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1h_z_p_bi_u16_field_imm4_15_max_a000_a4afa000() {
    // Encoding: 0xA4AFA000
    // Test LD1H_Z.P.BI_U16 field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, imm4=15, Rn=0
    let encoding: u32 = 0xA4AFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u16_field_pg_0_min_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u16_field_pg_1_poweroftwo_a000_a4a0a400() {
    // Encoding: 0xA4A0A400
    // Test LD1H_Z.P.BI_U16 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u16_field_rn_0_min_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 field Rn = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u16_field_rn_1_poweroftwo_a000_a4a0a020() {
    // Encoding: 0xA4A0A020
    // Test LD1H_Z.P.BI_U16 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, imm4=0
    let encoding: u32 = 0xA4A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bi_u16_field_rn_30_poweroftwominusone_a000_a4a0a3c0() {
    // Encoding: 0xA4A0A3C0
    // Test LD1H_Z.P.BI_U16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, imm4=0, Zt=0
    let encoding: u32 = 0xA4A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bi_u16_field_rn_31_max_a000_a4a0a3e0() {
    // Encoding: 0xA4A0A3E0
    // Test LD1H_Z.P.BI_U16 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA4A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bi_u16_field_zt_0_min_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bi_u16_field_zt_1_poweroftwo_a000_a4a0a001() {
    // Encoding: 0xA4A0A001
    // Test LD1H_Z.P.BI_U16 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bi_u16_field_zt_30_poweroftwominusone_a000_a4a0a01e() {
    // Encoding: 0xA4A0A01E
    // Test LD1H_Z.P.BI_U16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, imm4=0
    let encoding: u32 = 0xA4A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bi_u16_field_zt_31_max_a000_a4a0a01f() {
    // Encoding: 0xA4A0A01F
    // Test LD1H_Z.P.BI_U16 field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA4A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1h_z_p_bi_u16_combo_0_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bi_u16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4a0a3e0() {
    // Encoding: 0xA4A0A3E0
    // Test LD1H_Z.P.BI_U16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, imm4=0
    let encoding: u32 = 0xA4A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u16_invalid_0_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u16_invalid_1_a000_a4a0a000() {
    // Encoding: 0xA4A0A000
    // Test LD1H_Z.P.BI_U16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_0_zero_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_1_poweroftwo_a000_a4c1a000() {
    // Encoding: 0xA4C1A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=1
    let encoding: u32 = 0xA4C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_3_poweroftwominusone_a000_a4c3a000() {
    // Encoding: 0xA4C3A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_4_poweroftwo_a000_a4c4a000() {
    // Encoding: 0xA4C4A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_7_poweroftwominusone_a000_a4c7a000() {
    // Encoding: 0xA4C7A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_8_poweroftwo_a000_a4c8a000() {
    // Encoding: 0xA4C8A000
    // Test LD1H_Z.P.BI_U32 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=8, Rn=0
    let encoding: u32 = 0xA4C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1h_z_p_bi_u32_field_imm4_15_max_a000_a4cfa000() {
    // Encoding: 0xA4CFA000
    // Test LD1H_Z.P.BI_U32 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u32_field_pg_0_min_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u32_field_pg_1_poweroftwo_a000_a4c0a400() {
    // Encoding: 0xA4C0A400
    // Test LD1H_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA4C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u32_field_rn_0_min_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u32_field_rn_1_poweroftwo_a000_a4c0a020() {
    // Encoding: 0xA4C0A020
    // Test LD1H_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bi_u32_field_rn_30_poweroftwominusone_a000_a4c0a3c0() {
    // Encoding: 0xA4C0A3C0
    // Test LD1H_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bi_u32_field_rn_31_max_a000_a4c0a3e0() {
    // Encoding: 0xA4C0A3E0
    // Test LD1H_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=31
    let encoding: u32 = 0xA4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bi_u32_field_zt_0_min_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bi_u32_field_zt_1_poweroftwo_a000_a4c0a001() {
    // Encoding: 0xA4C0A001
    // Test LD1H_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, imm4=0
    let encoding: u32 = 0xA4C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bi_u32_field_zt_30_poweroftwominusone_a000_a4c0a01e() {
    // Encoding: 0xA4C0A01E
    // Test LD1H_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bi_u32_field_zt_31_max_a000_a4c0a01f() {
    // Encoding: 0xA4C0A01F
    // Test LD1H_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: imm4=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1h_z_p_bi_u32_combo_0_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4c0a3e0() {
    // Encoding: 0xA4C0A3E0
    // Test LD1H_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u32_invalid_0_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u32_invalid_1_a000_a4c0a000() {
    // Encoding: 0xA4C0A000
    // Test LD1H_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_0_zero_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_1_poweroftwo_a000_a4e1a000() {
    // Encoding: 0xA4E1A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xA4E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_3_poweroftwominusone_a000_a4e3a000() {
    // Encoding: 0xA4E3A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xA4E3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_4_poweroftwo_a000_a4e4a000() {
    // Encoding: 0xA4E4A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_7_poweroftwominusone_a000_a4e7a000() {
    // Encoding: 0xA4E7A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=7, Rn=0
    let encoding: u32 = 0xA4E7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_8_poweroftwo_a000_a4e8a000() {
    // Encoding: 0xA4E8A000
    // Test LD1H_Z.P.BI_U64 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1h_z_p_bi_u64_field_imm4_15_max_a000_a4efa000() {
    // Encoding: 0xA4EFA000
    // Test LD1H_Z.P.BI_U64 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4EFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u64_field_pg_0_min_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u64_field_pg_1_poweroftwo_a000_a4e0a400() {
    // Encoding: 0xA4E0A400
    // Test LD1H_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, imm4=0
    let encoding: u32 = 0xA4E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bi_u64_field_rn_0_min_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bi_u64_field_rn_1_poweroftwo_a000_a4e0a020() {
    // Encoding: 0xA4E0A020
    // Test LD1H_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xA4E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bi_u64_field_rn_30_poweroftwominusone_a000_a4e0a3c0() {
    // Encoding: 0xA4E0A3C0
    // Test LD1H_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xA4E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bi_u64_field_rn_31_max_a000_a4e0a3e0() {
    // Encoding: 0xA4E0A3E0
    // Test LD1H_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bi_u64_field_zt_0_min_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bi_u64_field_zt_1_poweroftwo_a000_a4e0a001() {
    // Encoding: 0xA4E0A001
    // Test LD1H_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=1
    let encoding: u32 = 0xA4E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bi_u64_field_zt_30_poweroftwominusone_a000_a4e0a01e() {
    // Encoding: 0xA4E0A01E
    // Test LD1H_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bi_u64_field_zt_31_max_a000_a4e0a01f() {
    // Encoding: 0xA4E0A01F
    // Test LD1H_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1h_z_p_bi_u64_combo_0_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a4e0a3e0() {
    // Encoding: 0xA4E0A3E0
    // Test LD1H_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u64_invalid_0_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bi_u64_invalid_1_a000_a4e0a000() {
    // Encoding: 0xA4E0A000
    // Test LD1H_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bi_u16_reg_write_0_a4a0a000() {
    // Test LD1H_Z.P.BI_U16 register write: SimdFromField("t")
    // Encoding: 0xA4A0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BI_U16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bi_u16_sp_rn_a4a0a3e0() {
    // Test LD1H_Z.P.BI_U16 with Rn = SP (31)
    // Encoding: 0xA4A0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4A0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bi_u32_reg_write_0_a4c0a000() {
    // Test LD1H_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0xA4C0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bi_u32_sp_rn_a4c0a3e0() {
    // Test LD1H_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0xA4C0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bi_u64_reg_write_0_a4e0a000() {
    // Test LD1H_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0xA4E0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bi_u64_sp_rn_a4e0a3e0() {
    // Test LD1H_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0xA4E0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SH_Z.P.BI_S32 Tests
// ============================================================================

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_0_zero_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 0 (Zero)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_1_poweroftwo_a000_a521a000() {
    // Encoding: 0xA521A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=1, Zt=0, Rn=0
    let encoding: u32 = 0xA521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_3_poweroftwominusone_a000_a523a000() {
    // Encoding: 0xA523A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=3
    let encoding: u32 = 0xA523A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_4_poweroftwo_a000_a524a000() {
    // Encoding: 0xA524A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA524A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_7_poweroftwominusone_a000_a527a000() {
    // Encoding: 0xA527A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA527A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_8_poweroftwo_a000_a528a000() {
    // Encoding: 0xA528A000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=8, Pg=0
    let encoding: u32 = 0xA528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sh_z_p_bi_s32_field_imm4_15_max_a000_a52fa000() {
    // Encoding: 0xA52FA000
    // Test LD1SH_Z.P.BI_S32 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA52FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bi_s32_field_pg_0_min_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bi_s32_field_pg_1_poweroftwo_a000_a520a400() {
    // Encoding: 0xA520A400
    // Test LD1SH_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bi_s32_field_rn_0_min_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bi_s32_field_rn_1_poweroftwo_a000_a520a020() {
    // Encoding: 0xA520A020
    // Test LD1SH_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, imm4=0, Zt=0
    let encoding: u32 = 0xA520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_a520a3c0() {
    // Encoding: 0xA520A3C0
    // Test LD1SH_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=30
    let encoding: u32 = 0xA520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bi_s32_field_rn_31_max_a000_a520a3e0() {
    // Encoding: 0xA520A3E0
    // Test LD1SH_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bi_s32_field_zt_0_min_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bi_s32_field_zt_1_poweroftwo_a000_a520a001() {
    // Encoding: 0xA520A001
    // Test LD1SH_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, imm4=0
    let encoding: u32 = 0xA520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_a520a01e() {
    // Encoding: 0xA520A01E
    // Test LD1SH_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bi_s32_field_zt_31_max_a000_a520a01f() {
    // Encoding: 0xA520A01F
    // Test LD1SH_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=31
    let encoding: u32 = 0xA520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sh_z_p_bi_s32_combo_0_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a520a3e0() {
    // Encoding: 0xA520A3E0
    // Test LD1SH_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bi_s32_invalid_0_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bi_s32_invalid_1_a000_a520a000() {
    // Encoding: 0xA520A000
    // Test LD1SH_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_0_zero_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a501a000() {
    // Encoding: 0xA501A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a503a000() {
    // Encoding: 0xA503A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=3
    let encoding: u32 = 0xA503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a504a000() {
    // Encoding: 0xA504A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=4, Zt=0
    let encoding: u32 = 0xA504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a507a000() {
    // Encoding: 0xA507A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=7, Pg=0
    let encoding: u32 = 0xA507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a508a000() {
    // Encoding: 0xA508A000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xA508A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1sh_z_p_bi_s64_field_imm4_15_max_a000_a50fa000() {
    // Encoding: 0xA50FA000
    // Test LD1SH_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xA50FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bi_s64_field_pg_0_min_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bi_s64_field_pg_1_poweroftwo_a000_a500a400() {
    // Encoding: 0xA500A400
    // Test LD1SH_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, imm4=0
    let encoding: u32 = 0xA500A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bi_s64_field_rn_0_min_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bi_s64_field_rn_1_poweroftwo_a000_a500a020() {
    // Encoding: 0xA500A020
    // Test LD1SH_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA500A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a500a3c0() {
    // Encoding: 0xA500A3C0
    // Test LD1SH_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA500A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bi_s64_field_rn_31_max_a000_a500a3e0() {
    // Encoding: 0xA500A3E0
    // Test LD1SH_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA500A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bi_s64_field_zt_0_min_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bi_s64_field_zt_1_poweroftwo_a000_a500a001() {
    // Encoding: 0xA500A001
    // Test LD1SH_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=1
    let encoding: u32 = 0xA500A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a500a01e() {
    // Encoding: 0xA500A01E
    // Test LD1SH_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=30
    let encoding: u32 = 0xA500A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bi_s64_field_zt_31_max_a000_a500a01f() {
    // Encoding: 0xA500A01F
    // Test LD1SH_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xA500A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1sh_z_p_bi_s64_combo_0_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a500a3e0() {
    // Encoding: 0xA500A3E0
    // Test LD1SH_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA500A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bi_s64_invalid_0_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bi_s64_invalid_1_a000_a500a000() {
    // Encoding: 0xA500A000
    // Test LD1SH_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bi_s32_reg_write_0_a520a000() {
    // Test LD1SH_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0xA520A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA520A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bi_s32_sp_rn_a520a3e0() {
    // Test LD1SH_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0xA520A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA520A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bi_s64_reg_write_0_a500a000() {
    // Test LD1SH_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA500A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bi_s64_sp_rn_a500a3e0() {
    // Test LD1SH_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA500A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1D_Z.P.BR_U64 Tests
// ============================================================================

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_br_u64_field_rm_0_min_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_br_u64_field_rm_1_poweroftwo_6000_a5e16000() {
    // Encoding: 0xA5E16000
    // Test LDFF1D_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=1
    let encoding: u32 = 0xA5E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_br_u64_field_rm_30_poweroftwominusone_6000_a5fe6000() {
    // Encoding: 0xA5FE6000
    // Test LDFF1D_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1d_z_p_br_u64_field_rm_31_max_6000_a5ff6000() {
    // Encoding: 0xA5FF6000
    // Test LDFF1D_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=31, Zt=0
    let encoding: u32 = 0xA5FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_br_u64_field_pg_0_min_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_br_u64_field_pg_1_poweroftwo_6000_a5e06400() {
    // Encoding: 0xA5E06400
    // Test LDFF1D_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, Rm=0
    let encoding: u32 = 0xA5E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_br_u64_field_rn_0_min_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_br_u64_field_rn_1_poweroftwo_6000_a5e06020() {
    // Encoding: 0xA5E06020
    // Test LDFF1D_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Rm=0, Pg=0
    let encoding: u32 = 0xA5E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1d_z_p_br_u64_field_rn_30_poweroftwominusone_6000_a5e063c0() {
    // Encoding: 0xA5E063C0
    // Test LDFF1D_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=30
    let encoding: u32 = 0xA5E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1d_z_p_br_u64_field_rn_31_max_6000_a5e063e0() {
    // Encoding: 0xA5E063E0
    // Test LDFF1D_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xA5E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_br_u64_field_zt_0_min_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_br_u64_field_zt_1_poweroftwo_6000_a5e06001() {
    // Encoding: 0xA5E06001
    // Test LDFF1D_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_br_u64_field_zt_30_poweroftwominusone_6000_a5e0601e() {
    // Encoding: 0xA5E0601E
    // Test LDFF1D_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA5E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_br_u64_field_zt_31_max_6000_a5e0601f() {
    // Encoding: 0xA5E0601F
    // Test LDFF1D_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1d_z_p_br_u64_combo_0_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1d_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a5e063e0() {
    // Encoding: 0xA5E063E0
    // Test LDFF1D_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_br_u64_invalid_0_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_br_u64_invalid_1_6000_a5e06000() {
    // Encoding: 0xA5E06000
    // Test LDFF1D_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_br_u64_reg_write_0_a5e06000() {
    // Test LDFF1D_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA5E06000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E06000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1D_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1d_z_p_br_u64_sp_rn_a5e063e0() {
    // Test LDFF1D_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA5E063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5E063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1D_Z.P.AI_D Tests
// ============================================================================

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_0_zero_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_1_poweroftwo_e000_c5a1e000() {
    // Encoding: 0xC5A1E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=1, Zt=0
    let encoding: u32 = 0xC5A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_3_poweroftwominusone_e000_c5a3e000() {
    // Encoding: 0xC5A3E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=3
    let encoding: u32 = 0xC5A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_4_poweroftwo_e000_c5a4e000() {
    // Encoding: 0xC5A4E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=4, Zt=0
    let encoding: u32 = 0xC5A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_7_poweroftwominusone_e000_c5a7e000() {
    // Encoding: 0xC5A7E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=7
    let encoding: u32 = 0xC5A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_8_poweroftwo_e000_c5a8e000() {
    // Encoding: 0xC5A8E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=8, Zn=0
    let encoding: u32 = 0xC5A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_15_poweroftwominusone_e000_c5afe000() {
    // Encoding: 0xC5AFE000
    // Test LDFF1D_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC5AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_16_poweroftwo_e000_c5b0e000() {
    // Encoding: 0xC5B0E000
    // Test LDFF1D_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=16, Zt=0
    let encoding: u32 = 0xC5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1d_z_p_ai_d_field_imm5_31_max_e000_c5bfe000() {
    // Encoding: 0xC5BFE000
    // Test LDFF1D_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=31
    let encoding: u32 = 0xC5BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1d_z_p_ai_d_field_pg_0_min_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1d_z_p_ai_d_field_pg_1_poweroftwo_e000_c5a0e400() {
    // Encoding: 0xC5A0E400
    // Test LDFF1D_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, Pg=1, imm5=0
    let encoding: u32 = 0xC5A0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_ai_d_field_zn_0_min_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_ai_d_field_zn_1_poweroftwo_e000_c5a0e020() {
    // Encoding: 0xC5A0E020
    // Test LDFF1D_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=1, imm5=0, Pg=0
    let encoding: u32 = 0xC5A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_ai_d_field_zn_30_poweroftwominusone_e000_c5a0e3c0() {
    // Encoding: 0xC5A0E3C0
    // Test LDFF1D_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=0, Zn=30, Pg=0
    let encoding: u32 = 0xC5A0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_ai_d_field_zn_31_max_e000_c5a0e3e0() {
    // Encoding: 0xC5A0E3E0
    // Test LDFF1D_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=31
    let encoding: u32 = 0xC5A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1d_z_p_ai_d_field_zt_0_min_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D field Zt = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1d_z_p_ai_d_field_zt_1_poweroftwo_e000_c5a0e001() {
    // Encoding: 0xC5A0E001
    // Test LDFF1D_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, imm5=0, Zt=1, Zn=0
    let encoding: u32 = 0xC5A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1d_z_p_ai_d_field_zt_30_poweroftwominusone_e000_c5a0e01e() {
    // Encoding: 0xC5A0E01E
    // Test LDFF1D_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xC5A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1d_z_p_ai_d_field_zt_31_max_e000_c5a0e01f() {
    // Encoding: 0xC5A0E01F
    // Test LDFF1D_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zt=31, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xC5A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1d_z_p_ai_d_combo_0_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_ai_d_invalid_0_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1d_z_p_ai_d_invalid_1_e000_c5a0e000() {
    // Encoding: 0xC5A0E000
    // Test LDFF1D_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1D_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1d_z_p_ai_d_reg_write_0_c5a0e000() {
    // Test LDFF1D_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC5A0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC5A0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RD_Z.P.BI_U64 Tests
// ============================================================================

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_0_zero_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 0 (Zero)
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_1_poweroftwo_e000_85c1e000() {
    // Encoding: 0x85C1E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=1, Pg=0, Rn=0
    let encoding: u32 = 0x85C1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_3_poweroftwominusone_e000_85c3e000() {
    // Encoding: 0x85C3E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=3, Rn=0, Pg=0
    let encoding: u32 = 0x85C3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_4_poweroftwo_e000_85c4e000() {
    // Encoding: 0x85C4E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_7_poweroftwominusone_e000_85c7e000() {
    // Encoding: 0x85C7E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=7
    let encoding: u32 = 0x85C7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_8_poweroftwo_e000_85c8e000() {
    // Encoding: 0x85C8E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x85C8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_15_poweroftwominusone_e000_85cfe000() {
    // Encoding: 0x85CFE000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm6=15, Pg=0
    let encoding: u32 = 0x85CFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_16_poweroftwo_e000_85d0e000() {
    // Encoding: 0x85D0E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 16 (PowerOfTwo)
    // Fields: imm6=16, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_31_poweroftwominusone_e000_85dfe000() {
    // Encoding: 0x85DFE000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm6=31, Zt=0
    let encoding: u32 = 0x85DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_32_poweroftwo_e000_85e0e000() {
    // Encoding: 0x85E0E000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, imm6=32, Zt=0, Rn=0
    let encoding: u32 = 0x85E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rd_z_p_bi_u64_field_imm6_63_max_e000_85ffe000() {
    // Encoding: 0x85FFE000
    // Test LD1RD_Z.P.BI_U64 field imm6 = 63 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, imm6=63
    let encoding: u32 = 0x85FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rd_z_p_bi_u64_field_pg_0_min_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rd_z_p_bi_u64_field_pg_1_poweroftwo_e000_85c0e400() {
    // Encoding: 0x85C0E400
    // Test LD1RD_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm6=0, Pg=1, Zt=0
    let encoding: u32 = 0x85C0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rd_z_p_bi_u64_field_rn_0_min_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm6=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rd_z_p_bi_u64_field_rn_1_poweroftwo_e000_85c0e020() {
    // Encoding: 0x85C0E020
    // Test LD1RD_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0x85C0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rd_z_p_bi_u64_field_rn_30_poweroftwominusone_e000_85c0e3c0() {
    // Encoding: 0x85C0E3C0
    // Test LD1RD_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, imm6=0
    let encoding: u32 = 0x85C0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rd_z_p_bi_u64_field_rn_31_max_e000_85c0e3e0() {
    // Encoding: 0x85C0E3E0
    // Test LD1RD_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, imm6=0
    let encoding: u32 = 0x85C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rd_z_p_bi_u64_field_zt_0_min_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rd_z_p_bi_u64_field_zt_1_poweroftwo_e000_85c0e001() {
    // Encoding: 0x85C0E001
    // Test LD1RD_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm6=0, Rn=0
    let encoding: u32 = 0x85C0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rd_z_p_bi_u64_field_zt_30_poweroftwominusone_e000_85c0e01e() {
    // Encoding: 0x85C0E01E
    // Test LD1RD_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x85C0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rd_z_p_bi_u64_field_zt_31_max_e000_85c0e01f() {
    // Encoding: 0x85C0E01F
    // Test LD1RD_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Rn=0, imm6=0, Zt=31, Pg=0
    let encoding: u32 = 0x85C0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rd_z_p_bi_u64_combo_0_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rd_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_57344_85c0e3e0() {
    // Encoding: 0x85C0E3E0
    // Test LD1RD_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, imm6=0, Pg=0
    let encoding: u32 = 0x85C0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rd_z_p_bi_u64_invalid_0_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rd_z_p_bi_u64_invalid_1_e000_85c0e000() {
    // Encoding: 0x85C0E000
    // Test LD1RD_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x85C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rd_z_p_bi_u64_reg_write_0_85c0e000() {
    // Test LD1RD_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0x85C0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RD_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rd_z_p_bi_u64_sp_rn_85c0e3e0() {
    // Test LD1RD_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0x85C0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x85C0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQB_Z.P.BI_U8 Tests
// ============================================================================

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_0_zero_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_1_poweroftwo_2000_a4012000() {
    // Encoding: 0xA4012000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_3_poweroftwominusone_2000_a4032000() {
    // Encoding: 0xA4032000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm4=3, Zt=0
    let encoding: u32 = 0xA4032000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_4_poweroftwo_2000_a4042000() {
    // Encoding: 0xA4042000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm4=4, Pg=0, Rn=0
    let encoding: u32 = 0xA4042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_7_poweroftwominusone_2000_a4072000() {
    // Encoding: 0xA4072000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_8_poweroftwo_2000_a4082000() {
    // Encoding: 0xA4082000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_imm4_15_max_2000_a40f2000() {
    // Encoding: 0xA40F2000
    // Test LD1RQB_Z.P.BI_U8 field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xA40F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_pg_0_min_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_pg_1_poweroftwo_2000_a4002400() {
    // Encoding: 0xA4002400
    // Test LD1RQB_Z.P.BI_U8 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=1
    let encoding: u32 = 0xA4002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_rn_0_min_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 field Rn = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_rn_1_poweroftwo_2000_a4002020() {
    // Encoding: 0xA4002020
    // Test LD1RQB_Z.P.BI_U8 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Rn=1, Pg=0
    let encoding: u32 = 0xA4002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_rn_30_poweroftwominusone_2000_a40023c0() {
    // Encoding: 0xA40023C0
    // Test LD1RQB_Z.P.BI_U8 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA40023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqb_z_p_bi_u8_field_rn_31_max_2000_a40023e0() {
    // Encoding: 0xA40023E0
    // Test LD1RQB_Z.P.BI_U8 field Rn = 31 (Max)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA40023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqb_z_p_bi_u8_field_zt_0_min_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqb_z_p_bi_u8_field_zt_1_poweroftwo_2000_a4002001() {
    // Encoding: 0xA4002001
    // Test LD1RQB_Z.P.BI_U8 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm4=0, Rn=0
    let encoding: u32 = 0xA4002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqb_z_p_bi_u8_field_zt_30_poweroftwominusone_2000_a400201e() {
    // Encoding: 0xA400201E
    // Test LD1RQB_Z.P.BI_U8 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA400201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqb_z_p_bi_u8_field_zt_31_max_2000_a400201f() {
    // Encoding: 0xA400201F
    // Test LD1RQB_Z.P.BI_U8 field Zt = 31 (Max)
    // Fields: imm4=0, Zt=31, Rn=0, Pg=0
    let encoding: u32 = 0xA400201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld1rqb_z_p_bi_u8_combo_0_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqb_z_p_bi_u8_special_rn_31_stack_pointer_sp_may_require_alignment_8192_a40023e0() {
    // Encoding: 0xA40023E0
    // Test LD1RQB_Z.P.BI_U8 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA40023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_bi_u8_invalid_0_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqb_z_p_bi_u8_invalid_1_2000_a4002000() {
    // Encoding: 0xA4002000
    // Test LD1RQB_Z.P.BI_U8 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqb_z_p_bi_u8_reg_write_0_a4002000() {
    // Test LD1RQB_Z.P.BI_U8 register write: SimdFromField("t")
    // Encoding: 0xA4002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQB_Z.P.BI_U8
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqb_z_p_bi_u8_sp_rn_a40023e0() {
    // Test LD1RQB_Z.P.BI_U8 with Rn = SP (31)
    // Encoding: 0xA40023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA40023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1W_Z.P.BR_U32 Tests
// ============================================================================

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u32_field_rm_0_min_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 field Rm = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u32_field_rm_1_poweroftwo_6000_a5416000() {
    // Encoding: 0xA5416000
    // Test LDFF1W_Z.P.BR_U32 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Rm=1, Zt=0
    let encoding: u32 = 0xA5416000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_br_u32_field_rm_30_poweroftwominusone_6000_a55e6000() {
    // Encoding: 0xA55E6000
    // Test LDFF1W_Z.P.BR_U32 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA55E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1w_z_p_br_u32_field_rm_31_max_6000_a55f6000() {
    // Encoding: 0xA55F6000
    // Test LDFF1W_Z.P.BR_U32 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xA55F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u32_field_pg_0_min_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u32_field_pg_1_poweroftwo_6000_a5406400() {
    // Encoding: 0xA5406400
    // Test LDFF1W_Z.P.BR_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5406400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u32_field_rn_0_min_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u32_field_rn_1_poweroftwo_6000_a5406020() {
    // Encoding: 0xA5406020
    // Test LDFF1W_Z.P.BR_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA5406020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_br_u32_field_rn_30_poweroftwominusone_6000_a54063c0() {
    // Encoding: 0xA54063C0
    // Test LDFF1W_Z.P.BR_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA54063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_br_u32_field_rn_31_max_6000_a54063e0() {
    // Encoding: 0xA54063E0
    // Test LDFF1W_Z.P.BR_U32 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA54063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_br_u32_field_zt_0_min_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_br_u32_field_zt_1_poweroftwo_6000_a5406001() {
    // Encoding: 0xA5406001
    // Test LDFF1W_Z.P.BR_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rm=0, Rn=0
    let encoding: u32 = 0xA5406001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_br_u32_field_zt_30_poweroftwominusone_6000_a540601e() {
    // Encoding: 0xA540601E
    // Test LDFF1W_Z.P.BR_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA540601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_br_u32_field_zt_31_max_6000_a540601f() {
    // Encoding: 0xA540601F
    // Test LDFF1W_Z.P.BR_U32 field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xA540601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1w_z_p_br_u32_combo_0_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_br_u32_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a54063e0() {
    // Encoding: 0xA54063E0
    // Test LDFF1W_Z.P.BR_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA54063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_br_u32_invalid_0_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_br_u32_invalid_1_6000_a5406000() {
    // Encoding: 0xA5406000
    // Test LDFF1W_Z.P.BR_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u64_field_rm_0_min_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u64_field_rm_1_poweroftwo_6000_a5616000() {
    // Encoding: 0xA5616000
    // Test LDFF1W_Z.P.BR_U64 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Pg=0, Rn=0
    let encoding: u32 = 0xA5616000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_br_u64_field_rm_30_poweroftwominusone_6000_a57e6000() {
    // Encoding: 0xA57E6000
    // Test LDFF1W_Z.P.BR_U64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xA57E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1w_z_p_br_u64_field_rm_31_max_6000_a57f6000() {
    // Encoding: 0xA57F6000
    // Test LDFF1W_Z.P.BR_U64 field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA57F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u64_field_pg_0_min_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u64_field_pg_1_poweroftwo_6000_a5606400() {
    // Encoding: 0xA5606400
    // Test LDFF1W_Z.P.BR_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_br_u64_field_rn_0_min_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_br_u64_field_rn_1_poweroftwo_6000_a5606020() {
    // Encoding: 0xA5606020
    // Test LDFF1W_Z.P.BR_U64 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xA5606020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1w_z_p_br_u64_field_rn_30_poweroftwominusone_6000_a56063c0() {
    // Encoding: 0xA56063C0
    // Test LDFF1W_Z.P.BR_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xA56063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1w_z_p_br_u64_field_rn_31_max_6000_a56063e0() {
    // Encoding: 0xA56063E0
    // Test LDFF1W_Z.P.BR_U64 field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA56063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_br_u64_field_zt_0_min_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_br_u64_field_zt_1_poweroftwo_6000_a5606001() {
    // Encoding: 0xA5606001
    // Test LDFF1W_Z.P.BR_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5606001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_br_u64_field_zt_30_poweroftwominusone_6000_a560601e() {
    // Encoding: 0xA560601E
    // Test LDFF1W_Z.P.BR_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA560601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_br_u64_field_zt_31_max_6000_a560601f() {
    // Encoding: 0xA560601F
    // Test LDFF1W_Z.P.BR_U64 field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=31
    let encoding: u32 = 0xA560601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1w_z_p_br_u64_combo_0_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1w_z_p_br_u64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a56063e0() {
    // Encoding: 0xA56063E0
    // Test LDFF1W_Z.P.BR_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA56063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_br_u64_invalid_0_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_br_u64_invalid_1_6000_a5606000() {
    // Encoding: 0xA5606000
    // Test LDFF1W_Z.P.BR_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_br_u32_reg_write_0_a5406000() {
    // Test LDFF1W_Z.P.BR_U32 register write: SimdFromField("t")
    // Encoding: 0xA5406000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5406000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BR_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_br_u32_sp_rn_a54063e0() {
    // Test LDFF1W_Z.P.BR_U32 with Rn = SP (31)
    // Encoding: 0xA54063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA54063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_br_u64_reg_write_0_a5606000() {
    // Test LDFF1W_Z.P.BR_U64 register write: SimdFromField("t")
    // Encoding: 0xA5606000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5606000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.BR_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1w_z_p_br_u64_sp_rn_a56063e0() {
    // Test LDFF1W_Z.P.BR_U64 with Rn = SP (31)
    // Encoding: 0xA56063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA56063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1W_Z.P.AI_S Tests
// ============================================================================

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_0_zero_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_1_poweroftwo_e000_8521e000() {
    // Encoding: 0x8521E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=1, Pg=0
    let encoding: u32 = 0x8521E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_3_poweroftwominusone_e000_8523e000() {
    // Encoding: 0x8523E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=3, Zt=0, Zn=0
    let encoding: u32 = 0x8523E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_4_poweroftwo_e000_8524e000() {
    // Encoding: 0x8524E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=4
    let encoding: u32 = 0x8524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_7_poweroftwominusone_e000_8527e000() {
    // Encoding: 0x8527E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=7, Zn=0, Pg=0
    let encoding: u32 = 0x8527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_8_poweroftwo_e000_8528e000() {
    // Encoding: 0x8528E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=8
    let encoding: u32 = 0x8528E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_15_poweroftwominusone_e000_852fe000() {
    // Encoding: 0x852FE000
    // Test LDFF1W_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=15
    let encoding: u32 = 0x852FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_16_poweroftwo_e000_8530e000() {
    // Encoding: 0x8530E000
    // Test LDFF1W_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=16
    let encoding: u32 = 0x8530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1w_z_p_ai_s_field_imm5_31_max_e000_853fe000() {
    // Encoding: 0x853FE000
    // Test LDFF1W_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Pg=0, imm5=31, Zn=0, Zt=0
    let encoding: u32 = 0x853FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_ai_s_field_pg_0_min_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_ai_s_field_pg_1_poweroftwo_e000_8520e400() {
    // Encoding: 0x8520E400
    // Test LDFF1W_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=1
    let encoding: u32 = 0x8520E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_ai_s_field_zn_0_min_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_ai_s_field_zn_1_poweroftwo_e000_8520e020() {
    // Encoding: 0x8520E020
    // Test LDFF1W_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=1
    let encoding: u32 = 0x8520E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_ai_s_field_zn_30_poweroftwominusone_e000_8520e3c0() {
    // Encoding: 0x8520E3C0
    // Test LDFF1W_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Zn=30, imm5=0
    let encoding: u32 = 0x8520E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_ai_s_field_zn_31_max_e000_8520e3e0() {
    // Encoding: 0x8520E3E0
    // Test LDFF1W_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zn=31, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0x8520E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_ai_s_field_zt_0_min_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S field Zt = 0 (Min)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_ai_s_field_zt_1_poweroftwo_e000_8520e001() {
    // Encoding: 0x8520E001
    // Test LDFF1W_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm5=0, Zn=0
    let encoding: u32 = 0x8520E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_ai_s_field_zt_30_poweroftwominusone_e000_8520e01e() {
    // Encoding: 0x8520E01E
    // Test LDFF1W_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=30
    let encoding: u32 = 0x8520E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_ai_s_field_zt_31_max_e000_8520e01f() {
    // Encoding: 0x8520E01F
    // Test LDFF1W_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0x8520E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1w_z_p_ai_s_combo_0_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_ai_s_invalid_0_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_ai_s_invalid_1_e000_8520e000() {
    // Encoding: 0x8520E000
    // Test LDFF1W_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0x8520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_0_zero_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_1_poweroftwo_e000_c521e000() {
    // Encoding: 0xC521E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=1
    let encoding: u32 = 0xC521E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_3_poweroftwominusone_e000_c523e000() {
    // Encoding: 0xC523E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=3, Zt=0
    let encoding: u32 = 0xC523E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_4_poweroftwo_e000_c524e000() {
    // Encoding: 0xC524E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, imm5=4, Pg=0, Zt=0
    let encoding: u32 = 0xC524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_7_poweroftwominusone_e000_c527e000() {
    // Encoding: 0xC527E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_8_poweroftwo_e000_c528e000() {
    // Encoding: 0xC528E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=8
    let encoding: u32 = 0xC528E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_15_poweroftwominusone_e000_c52fe000() {
    // Encoding: 0xC52FE000
    // Test LDFF1W_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=15, Pg=0, Zn=0
    let encoding: u32 = 0xC52FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_16_poweroftwo_e000_c530e000() {
    // Encoding: 0xC530E000
    // Test LDFF1W_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=16, Zt=0
    let encoding: u32 = 0xC530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1w_z_p_ai_d_field_imm5_31_max_e000_c53fe000() {
    // Encoding: 0xC53FE000
    // Test LDFF1W_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, imm5=31, Zn=0, Zt=0
    let encoding: u32 = 0xC53FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1w_z_p_ai_d_field_pg_0_min_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1w_z_p_ai_d_field_pg_1_poweroftwo_e000_c520e400() {
    // Encoding: 0xC520E400
    // Test LDFF1W_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=1
    let encoding: u32 = 0xC520E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_ai_d_field_zn_0_min_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_ai_d_field_zn_1_poweroftwo_e000_c520e020() {
    // Encoding: 0xC520E020
    // Test LDFF1W_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=1
    let encoding: u32 = 0xC520E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_ai_d_field_zn_30_poweroftwominusone_e000_c520e3c0() {
    // Encoding: 0xC520E3C0
    // Test LDFF1W_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC520E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_ai_d_field_zn_31_max_e000_c520e3e0() {
    // Encoding: 0xC520E3E0
    // Test LDFF1W_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC520E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1w_z_p_ai_d_field_zt_0_min_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1w_z_p_ai_d_field_zt_1_poweroftwo_e000_c520e001() {
    // Encoding: 0xC520E001
    // Test LDFF1W_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=1, imm5=0, Pg=0
    let encoding: u32 = 0xC520E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1w_z_p_ai_d_field_zt_30_poweroftwominusone_e000_c520e01e() {
    // Encoding: 0xC520E01E
    // Test LDFF1W_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC520E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1w_z_p_ai_d_field_zt_31_max_e000_c520e01f() {
    // Encoding: 0xC520E01F
    // Test LDFF1W_Z.P.AI_D field Zt = 31 (Max)
    // Fields: imm5=0, Zn=0, Zt=31, Pg=0
    let encoding: u32 = 0xC520E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1w_z_p_ai_d_combo_0_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_ai_d_invalid_0_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1w_z_p_ai_d_invalid_1_e000_c520e000() {
    // Encoding: 0xC520E000
    // Test LDFF1W_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1W_Z.P.AI_S
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_ai_s_reg_write_0_8520e000() {
    // Test LDFF1W_Z.P.AI_S register write: SimdFromField("t")
    // Encoding: 0x8520E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8520E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1W_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1w_z_p_ai_d_reg_write_0_c520e000() {
    // Test LDFF1W_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC520E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC520E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RW_Z.P.BI_U32 Tests
// ============================================================================

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_0_zero_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 0 (Zero)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_1_poweroftwo_c000_8541c000() {
    // Encoding: 0x8541C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 1 (PowerOfTwo)
    // Fields: imm6=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x8541C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_3_poweroftwominusone_c000_8543c000() {
    // Encoding: 0x8543C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x8543C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_4_poweroftwo_c000_8544c000() {
    // Encoding: 0x8544C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x8544C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_7_poweroftwominusone_c000_8547c000() {
    // Encoding: 0x8547C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x8547C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_8_poweroftwo_c000_8548c000() {
    // Encoding: 0x8548C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm6=8, Zt=0
    let encoding: u32 = 0x8548C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_15_poweroftwominusone_c000_854fc000() {
    // Encoding: 0x854FC000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm6=15, Pg=0
    let encoding: u32 = 0x854FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_16_poweroftwo_c000_8550c000() {
    // Encoding: 0x8550C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm6=16, Pg=0
    let encoding: u32 = 0x8550C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_31_poweroftwominusone_c000_855fc000() {
    // Encoding: 0x855FC000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm6=31, Rn=0
    let encoding: u32 = 0x855FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_32_poweroftwo_c000_8560c000() {
    // Encoding: 0x8560C000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 32 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=32
    let encoding: u32 = 0x8560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rw_z_p_bi_u32_field_imm6_63_max_c000_857fc000() {
    // Encoding: 0x857FC000
    // Test LD1RW_Z.P.BI_U32 field imm6 = 63 (Max)
    // Fields: Rn=0, imm6=63, Zt=0, Pg=0
    let encoding: u32 = 0x857FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rw_z_p_bi_u32_field_pg_0_min_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 field Pg = 0 (Min)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rw_z_p_bi_u32_field_pg_1_poweroftwo_c000_8540c400() {
    // Encoding: 0x8540C400
    // Test LD1RW_Z.P.BI_U32 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm6=0, Pg=1
    let encoding: u32 = 0x8540C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rw_z_p_bi_u32_field_rn_0_min_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 field Rn = 0 (Min)
    // Fields: Pg=0, imm6=0, Zt=0, Rn=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rw_z_p_bi_u32_field_rn_1_poweroftwo_c000_8540c020() {
    // Encoding: 0x8540C020
    // Test LD1RW_Z.P.BI_U32 field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm6=0, Zt=0, Rn=1
    let encoding: u32 = 0x8540C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rw_z_p_bi_u32_field_rn_30_poweroftwominusone_c000_8540c3c0() {
    // Encoding: 0x8540C3C0
    // Test LD1RW_Z.P.BI_U32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, imm6=0
    let encoding: u32 = 0x8540C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rw_z_p_bi_u32_field_rn_31_max_c000_8540c3e0() {
    // Encoding: 0x8540C3E0
    // Test LD1RW_Z.P.BI_U32 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Pg=0, imm6=0
    let encoding: u32 = 0x8540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rw_z_p_bi_u32_field_zt_0_min_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm6=0, Zt=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rw_z_p_bi_u32_field_zt_1_poweroftwo_c000_8540c001() {
    // Encoding: 0x8540C001
    // Test LD1RW_Z.P.BI_U32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, imm6=0
    let encoding: u32 = 0x8540C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rw_z_p_bi_u32_field_zt_30_poweroftwominusone_c000_8540c01e() {
    // Encoding: 0x8540C01E
    // Test LD1RW_Z.P.BI_U32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x8540C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rw_z_p_bi_u32_field_zt_31_max_c000_8540c01f() {
    // Encoding: 0x8540C01F
    // Test LD1RW_Z.P.BI_U32 field Zt = 31 (Max)
    // Fields: imm6=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0x8540C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rw_z_p_bi_u32_combo_0_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rw_z_p_bi_u32_special_rn_31_stack_pointer_sp_may_require_alignment_49152_8540c3e0() {
    // Encoding: 0x8540C3E0
    // Test LD1RW_Z.P.BI_U32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8540C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rw_z_p_bi_u32_invalid_0_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm6=0, Pg=0, Zt=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rw_z_p_bi_u32_invalid_1_c000_8540c000() {
    // Encoding: 0x8540C000
    // Test LD1RW_Z.P.BI_U32 invalid encoding: Unconditional UNDEFINED
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x8540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_0_zero_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 0 (Zero)
    // Fields: imm6=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_1_poweroftwo_e000_8541e000() {
    // Encoding: 0x8541E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm6=1, Rn=0
    let encoding: u32 = 0x8541E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_3_poweroftwominusone_e000_8543e000() {
    // Encoding: 0x8543E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=3, Rn=0, Pg=0
    let encoding: u32 = 0x8543E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_4_poweroftwo_e000_8544e000() {
    // Encoding: 0x8544E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=4
    let encoding: u32 = 0x8544E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_7_poweroftwominusone_e000_8547e000() {
    // Encoding: 0x8547E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x8547E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_8_poweroftwo_e000_8548e000() {
    // Encoding: 0x8548E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm6=8
    let encoding: u32 = 0x8548E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_15_poweroftwominusone_e000_854fe000() {
    // Encoding: 0x854FE000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=15
    let encoding: u32 = 0x854FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_16_poweroftwo_e000_8550e000() {
    // Encoding: 0x8550E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm6=16
    let encoding: u32 = 0x8550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_31_poweroftwominusone_e000_855fe000() {
    // Encoding: 0x855FE000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=31, Rn=0, Pg=0
    let encoding: u32 = 0x855FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_32_poweroftwo_e000_8560e000() {
    // Encoding: 0x8560E000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 32 (PowerOfTwo)
    // Fields: Rn=0, imm6=32, Pg=0, Zt=0
    let encoding: u32 = 0x8560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rw_z_p_bi_u64_field_imm6_63_max_e000_857fe000() {
    // Encoding: 0x857FE000
    // Test LD1RW_Z.P.BI_U64 field imm6 = 63 (Max)
    // Fields: Pg=0, Zt=0, imm6=63, Rn=0
    let encoding: u32 = 0x857FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rw_z_p_bi_u64_field_pg_0_min_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm6=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rw_z_p_bi_u64_field_pg_1_poweroftwo_e000_8540e400() {
    // Encoding: 0x8540E400
    // Test LD1RW_Z.P.BI_U64 field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm6=0, Zt=0, Pg=1
    let encoding: u32 = 0x8540E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rw_z_p_bi_u64_field_rn_0_min_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 field Rn = 0 (Min)
    // Fields: imm6=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rw_z_p_bi_u64_field_rn_1_poweroftwo_e000_8540e020() {
    // Encoding: 0x8540E020
    // Test LD1RW_Z.P.BI_U64 field Rn = 1 (PowerOfTwo)
    // Fields: imm6=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0x8540E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rw_z_p_bi_u64_field_rn_30_poweroftwominusone_e000_8540e3c0() {
    // Encoding: 0x8540E3C0
    // Test LD1RW_Z.P.BI_U64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, imm6=0
    let encoding: u32 = 0x8540E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rw_z_p_bi_u64_field_rn_31_max_e000_8540e3e0() {
    // Encoding: 0x8540E3E0
    // Test LD1RW_Z.P.BI_U64 field Rn = 31 (Max)
    // Fields: imm6=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x8540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rw_z_p_bi_u64_field_zt_0_min_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 field Zt = 0 (Min)
    // Fields: Pg=0, imm6=0, Rn=0, Zt=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rw_z_p_bi_u64_field_zt_1_poweroftwo_e000_8540e001() {
    // Encoding: 0x8540E001
    // Test LD1RW_Z.P.BI_U64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm6=0, Rn=0
    let encoding: u32 = 0x8540E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rw_z_p_bi_u64_field_zt_30_poweroftwominusone_e000_8540e01e() {
    // Encoding: 0x8540E01E
    // Test LD1RW_Z.P.BI_U64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x8540E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rw_z_p_bi_u64_field_zt_31_max_e000_8540e01f() {
    // Encoding: 0x8540E01F
    // Test LD1RW_Z.P.BI_U64 field Zt = 31 (Max)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=31
    let encoding: u32 = 0x8540E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rw_z_p_bi_u64_combo_0_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm6=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rw_z_p_bi_u64_special_rn_31_stack_pointer_sp_may_require_alignment_57344_8540e3e0() {
    // Encoding: 0x8540E3E0
    // Test LD1RW_Z.P.BI_U64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x8540E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rw_z_p_bi_u64_invalid_0_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm6=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rw_z_p_bi_u64_invalid_1_e000_8540e000() {
    // Encoding: 0x8540E000
    // Test LD1RW_Z.P.BI_U64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x8540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rw_z_p_bi_u32_reg_write_0_8540c000() {
    // Test LD1RW_Z.P.BI_U32 register write: SimdFromField("t")
    // Encoding: 0x8540C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RW_Z.P.BI_U32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rw_z_p_bi_u32_sp_rn_8540c3e0() {
    // Test LD1RW_Z.P.BI_U32 with Rn = SP (31)
    // Encoding: 0x8540C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rw_z_p_bi_u64_reg_write_0_8540e000() {
    // Test LD1RW_Z.P.BI_U64 register write: SimdFromField("t")
    // Encoding: 0x8540E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RW_Z.P.BI_U64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rw_z_p_bi_u64_sp_rn_8540e3e0() {
    // Test LD1RW_Z.P.BI_U64 with Rn = SP (31)
    // Encoding: 0x8540E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8540E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RSW_Z.P.BI_S64 Tests
// ============================================================================

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_0_zero_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 0 (Zero)
    // Fields: imm6=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_1_poweroftwo_8000_84c18000() {
    // Encoding: 0x84C18000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm6=1, Rn=0, Pg=0
    let encoding: u32 = 0x84C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_3_poweroftwominusone_8000_84c38000() {
    // Encoding: 0x84C38000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm6=3, Rn=0, Pg=0
    let encoding: u32 = 0x84C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_4_poweroftwo_8000_84c48000() {
    // Encoding: 0x84C48000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=4
    let encoding: u32 = 0x84C48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_7_poweroftwominusone_8000_84c78000() {
    // Encoding: 0x84C78000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=7
    let encoding: u32 = 0x84C78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_8_poweroftwo_8000_84c88000() {
    // Encoding: 0x84C88000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84C88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_15_poweroftwominusone_8000_84cf8000() {
    // Encoding: 0x84CF8000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm6=15
    let encoding: u32 = 0x84CF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_16_poweroftwo_8000_84d08000() {
    // Encoding: 0x84D08000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 16 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm6=16, Zt=0
    let encoding: u32 = 0x84D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_31_poweroftwominusone_8000_84df8000() {
    // Encoding: 0x84DF8000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm6=31, Pg=0
    let encoding: u32 = 0x84DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_32_poweroftwo_8000_84e08000() {
    // Encoding: 0x84E08000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 32 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm6=32, Pg=0
    let encoding: u32 = 0x84E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field imm6 16 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_imm6_63_max_8000_84ff8000() {
    // Encoding: 0x84FF8000
    // Test LD1RSW_Z.P.BI_S64 field imm6 = 63 (Max)
    // Fields: Rn=0, imm6=63, Pg=0, Zt=0
    let encoding: u32 = 0x84FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_pg_0_min_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: Rn=0, imm6=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_pg_1_poweroftwo_8000_84c08400() {
    // Encoding: 0x84C08400
    // Test LD1RSW_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm6=0, Rn=0, Zt=0
    let encoding: u32 = 0x84C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_rn_0_min_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, imm6=0, Zt=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_rn_1_poweroftwo_8000_84c08020() {
    // Encoding: 0x84C08020
    // Test LD1RSW_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, imm6=0
    let encoding: u32 = 0x84C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_rn_30_poweroftwominusone_8000_84c083c0() {
    // Encoding: 0x84C083C0
    // Test LD1RSW_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, imm6=0, Zt=0, Pg=0
    let encoding: u32 = 0x84C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rsw_z_p_bi_s64_field_rn_31_max_8000_84c083e0() {
    // Encoding: 0x84C083E0
    // Test LD1RSW_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Pg=0, imm6=0, Rn=31, Zt=0
    let encoding: u32 = 0x84C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rsw_z_p_bi_s64_field_zt_0_min_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Zt=0, imm6=0, Rn=0, Pg=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rsw_z_p_bi_s64_field_zt_1_poweroftwo_8000_84c08001() {
    // Encoding: 0x84C08001
    // Test LD1RSW_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm6=0, Rn=0
    let encoding: u32 = 0x84C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rsw_z_p_bi_s64_field_zt_30_poweroftwominusone_8000_84c0801e() {
    // Encoding: 0x84C0801E
    // Test LD1RSW_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0x84C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rsw_z_p_bi_s64_field_zt_31_max_8000_84c0801f() {
    // Encoding: 0x84C0801F
    // Test LD1RSW_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Rn=0, imm6=0, Pg=0, Zt=31
    let encoding: u32 = 0x84C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_ld1rsw_z_p_bi_s64_combo_0_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 field combination: imm6=0, Pg=0, Rn=0, Zt=0
    // Fields: imm6=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rsw_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_32768_84c083e0() {
    // Encoding: 0x84C083E0
    // Test LD1RSW_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, imm6=0, Pg=0
    let encoding: u32 = 0x84C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rsw_z_p_bi_s64_invalid_0_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm6=0, Rn=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rsw_z_p_bi_s64_invalid_1_8000_84c08000() {
    // Encoding: 0x84C08000
    // Test LD1RSW_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, imm6=0
    let encoding: u32 = 0x84C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rsw_z_p_bi_s64_reg_write_0_84c08000() {
    // Test LD1RSW_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0x84C08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RSW_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rsw_z_p_bi_s64_sp_rn_84c083e0() {
    // Test LD1RSW_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0x84C083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84C083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SB_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_xs_0_min_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_xs_1_max_2000_c4402000() {
    // Encoding: 0xC4402000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=1
    let encoding: u32 = 0xC4402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zm_0_min_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_2000_c4012000() {
    // Encoding: 0xC4012000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zm=1, Zt=0, Pg=0
    let encoding: u32 = 0xC4012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_2000_c41e2000() {
    // Encoding: 0xC41E2000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xC41E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zm_31_max_2000_c41f2000() {
    // Encoding: 0xC41F2000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Zm=31, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC41F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_pg_0_min_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_2000_c4002400() {
    // Encoding: 0xC4002400
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_rn_0_min_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_2000_c4002020() {
    // Encoding: 0xC4002020
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_2000_c40023c0() {
    // Encoding: 0xC40023C0
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=30, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC40023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_rn_31_max_2000_c40023e0() {
    // Encoding: 0xC40023E0
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, xs=0, Zt=0, Rn=31, Zm=0
    let encoding: u32 = 0xC40023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zt_0_min_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_2000_c4002001() {
    // Encoding: 0xC4002001
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=1
    let encoding: u32 = 0xC4002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_2000_c400201e() {
    // Encoding: 0xC400201E
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0xC400201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_field_zt_31_max_2000_c400201f() {
    // Encoding: 0xC400201F
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC400201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_combo_0_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_c40023e0(
) {
    // Encoding: 0xC40023E0
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xC40023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_invalid_0_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_invalid_1_2000_c4002000() {
    // Encoding: 0xC4002000
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC4002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_xs_0_min_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_xs_1_max_2000_84402000() {
    // Encoding: 0x84402000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zm_0_min_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_2000_84012000() {
    // Encoding: 0x84012000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x84012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_2000_841e2000() {
    // Encoding: 0x841E2000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0x841E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zm_31_max_2000_841f2000() {
    // Encoding: 0x841F2000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=31
    let encoding: u32 = 0x841F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_pg_0_min_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_2000_84002400() {
    // Encoding: 0x84002400
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, xs=0, Pg=1, Rn=0
    let encoding: u32 = 0x84002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_rn_0_min_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_2000_84002020() {
    // Encoding: 0x84002020
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Zm=0, Zt=0, Rn=1
    let encoding: u32 = 0x84002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_2000_840023c0() {
    // Encoding: 0x840023C0
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x840023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_rn_31_max_2000_840023e0() {
    // Encoding: 0x840023E0
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, xs=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0x840023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zt_0_min_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_2000_84002001() {
    // Encoding: 0x84002001
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Rn=0, Zt=1, Zm=0
    let encoding: u32 = 0x84002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_2000_8400201e() {
    // Encoding: 0x8400201E
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0x8400201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_field_zt_31_max_2000_8400201f() {
    // Encoding: 0x8400201F
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=31
    let encoding: u32 = 0x8400201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_combo_0_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_8192_840023e0(
) {
    // Encoding: 0x840023E0
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Rn=31, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x840023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_invalid_0_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_invalid_1_2000_84002000() {
    // Encoding: 0x84002000
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x84002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zm_0_min_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_c441a000() {
    // Encoding: 0xC441A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zm=1, Rn=0
    let encoding: u32 = 0xC441A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_c45ea000() {
    // Encoding: 0xC45EA000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC45EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zm_31_max_a000_c45fa000() {
    // Encoding: 0xC45FA000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Pg=0, Zt=0
    let encoding: u32 = 0xC45FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_pg_0_min_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_c440a400() {
    // Encoding: 0xC440A400
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC440A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_rn_0_min_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_c440a020() {
    // Encoding: 0xC440A020
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Zm=0, Pg=0
    let encoding: u32 = 0xC440A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_c440a3c0() {
    // Encoding: 0xC440A3C0
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC440A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_rn_31_max_a000_c440a3e0() {
    // Encoding: 0xC440A3E0
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zt_0_min_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_c440a001() {
    // Encoding: 0xC440A001
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Zm=0, Pg=0
    let encoding: u32 = 0xC440A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_c440a01e() {
    // Encoding: 0xC440A01E
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zt=30, Rn=0
    let encoding: u32 = 0xC440A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_field_zt_31_max_a000_c440a01f() {
    // Encoding: 0xC440A01F
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Zm=0, Zt=31, Pg=0
    let encoding: u32 = 0xC440A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_combo_0_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_c440a3e0(
) {
    // Encoding: 0xC440A3E0
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, Zm=0
    let encoding: u32 = 0xC440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_invalid_0_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_invalid_1_a000_c440a000() {
    // Encoding: 0xC440A000
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_reg_write_0_c4002000() {
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_bz_d_x32_unscaled_sp_rn_c40023e0() {
    // Test LDFF1SB_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC40023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC40023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_reg_write_0_84002000() {
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_bz_s_x32_unscaled_sp_rn_840023e0() {
    // Test LDFF1SB_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x840023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x840023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_reg_write_0_c440a000() {
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC440A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SB_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sb_z_p_bz_d_64_unscaled_sp_rn_c440a3e0() {
    // Test LDFF1SB_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC440A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_0_zero_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a421e000() {
    // Encoding: 0xA421E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA421E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a423e000() {
    // Encoding: 0xA423E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=3
    let encoding: u32 = 0xA423E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a424e000() {
    // Encoding: 0xA424E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Rn=0, Zt=0
    let encoding: u32 = 0xA424E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a427e000() {
    // Encoding: 0xA427E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, imm4=7, Pg=0
    let encoding: u32 = 0xA427E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a428e000() {
    // Encoding: 0xA428E000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA428E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_imm4_15_max_e000_a42fe000() {
    // Encoding: 0xA42FE000
    // Test LD2B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA42FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_pg_0_min_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a420e400() {
    // Encoding: 0xA420E400
    // Test LD2B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA420E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_rn_0_min_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a420e020() {
    // Encoding: 0xA420E020
    // Test LD2B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=1
    let encoding: u32 = 0xA420E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a420e3c0() {
    // Encoding: 0xA420E3C0
    // Test LD2B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA420E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2b_z_p_bi_contiguous_field_rn_31_max_e000_a420e3e0() {
    // Encoding: 0xA420E3E0
    // Test LD2B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA420E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2b_z_p_bi_contiguous_field_zt_0_min_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a420e001() {
    // Encoding: 0xA420E001
    // Test LD2B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xA420E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a420e01e() {
    // Encoding: 0xA420E01E
    // Test LD2B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA420E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2b_z_p_bi_contiguous_field_zt_31_max_e000_a420e01f() {
    // Encoding: 0xA420E01F
    // Test LD2B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Zt=31, Pg=0
    let encoding: u32 = 0xA420E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld2b_z_p_bi_contiguous_combo_0_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a420e3e0()
{
    // Encoding: 0xA420E3E0
    // Test LD2B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA420E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_bi_contiguous_invalid_0_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2b_z_p_bi_contiguous_invalid_1_e000_a420e000() {
    // Encoding: 0xA420E000
    // Test LD2B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2b_z_p_bi_contiguous_sp_rn_a420e3e0() {
    // Test LD2B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA420E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA420E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a401c000() {
    // Encoding: 0xA401C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA401C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a41ec000() {
    // Encoding: 0xA41EC000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xA41EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_31_max_c000_a41fc000() {
    // Encoding: 0xA41FC000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=31
    let encoding: u32 = 0xA41FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_pg_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a400c400() {
    // Encoding: 0xA400C400
    // Test LDNT1B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA400C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a400c020() {
    // Encoding: 0xA400C020
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA400C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a400c3c0() {
    // Encoding: 0xA400C3C0
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA400C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_31_max_c000_a400c3e0() {
    // Encoding: 0xA400C3E0
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a400c001() {
    // Encoding: 0xA400C001
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA400C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a400c01e() {
    // Encoding: 0xA400C01E
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=30
    let encoding: u32 = 0xA400C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_31_max_c000_a400c01f() {
    // Encoding: 0xA400C01F
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=31
    let encoding: u32 = 0xA400C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_0_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a400c3e0(
) {
    // Encoding: 0xA400C3E0
    // Test LDNT1B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, Rm=0
    let encoding: u32 = 0xA400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_0_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_1_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_2_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_3_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1b_z_p_br_contiguous_reg_write_0_a400c000() {
    // Test LDNT1B_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA400C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1b_z_p_br_contiguous_sp_rn_a400c3e0() {
    // Test LDNT1B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA400C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SW_Z.P.AI_D Tests
// ============================================================================

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_0_zero_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_1_poweroftwo_a000_c521a000() {
    // Encoding: 0xC521A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=1
    let encoding: u32 = 0xC521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_c523a000() {
    // Encoding: 0xC523A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=3, Zt=0
    let encoding: u32 = 0xC523A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_4_poweroftwo_a000_c524a000() {
    // Encoding: 0xC524A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=4, Zt=0
    let encoding: u32 = 0xC524A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_c527a000() {
    // Encoding: 0xC527A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC527A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_8_poweroftwo_a000_c528a000() {
    // Encoding: 0xC528A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_c52fa000() {
    // Encoding: 0xC52FA000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC52FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_16_poweroftwo_a000_c530a000() {
    // Encoding: 0xC530A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_31_max_a000_c53fa000() {
    // Encoding: 0xC53FA000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, Zn=0, imm5=31, Zt=0
    let encoding: u32 = 0xC53FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_ai_d_field_pg_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_ai_d_field_pg_1_poweroftwo_a000_c520a400() {
    // Encoding: 0xC520A400
    // Test LDFF1SW_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=1, Zt=0, Zn=0
    let encoding: u32 = 0xC520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_1_poweroftwo_a000_c520a020() {
    // Encoding: 0xC520A020
    // Test LDFF1SW_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zt=0, Zn=1, Pg=0
    let encoding: u32 = 0xC520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_30_poweroftwominusone_a000_c520a3c0() {
    // Encoding: 0xC520A3C0
    // Test LDFF1SW_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_31_max_a000_c520a3e0() {
    // Encoding: 0xC520A3E0
    // Test LDFF1SW_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zn=31, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xC520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_1_poweroftwo_a000_c520a001() {
    // Encoding: 0xC520A001
    // Test LDFF1SW_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=1, imm5=0
    let encoding: u32 = 0xC520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_30_poweroftwominusone_a000_c520a01e() {
    // Encoding: 0xC520A01E
    // Test LDFF1SW_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xC520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_31_max_a000_c520a01f() {
    // Encoding: 0xC520A01F
    // Test LDFF1SW_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zt=31, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xC520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_0_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_ai_d_invalid_0_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_ai_d_invalid_1_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_ai_d_reg_write_0_c520a000() {
    // Test LDFF1SW_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC520A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC520A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SW_Z.P.BR_S64 Tests
// ============================================================================

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_1_poweroftwo_6000_a4816000() {
    // Encoding: 0xA4816000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=1, Rn=0
    let encoding: u32 = 0xA4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_30_poweroftwominusone_6000_a49e6000() {
    // Encoding: 0xA49E6000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xA49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_31_max_6000_a49f6000() {
    // Encoding: 0xA49F6000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xA49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_pg_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_pg_1_poweroftwo_6000_a4806400() {
    // Encoding: 0xA4806400
    // Test LDFF1SW_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_1_poweroftwo_6000_a4806020() {
    // Encoding: 0xA4806020
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_30_poweroftwominusone_6000_a48063c0() {
    // Encoding: 0xA48063C0
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xA48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_31_max_6000_a48063e0() {
    // Encoding: 0xA48063E0
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Zt=0, Rm=0, Rn=31, Pg=0
    let encoding: u32 = 0xA48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_1_poweroftwo_6000_a4806001() {
    // Encoding: 0xA4806001
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_30_poweroftwominusone_6000_a480601e() {
    // Encoding: 0xA480601E
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Rm=0
    let encoding: u32 = 0xA480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_31_max_6000_a480601f() {
    // Encoding: 0xA480601F
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_0_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a48063e0() {
    // Encoding: 0xA48063E0
    // Test LDFF1SW_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_br_s64_invalid_0_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_br_s64_invalid_1_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_br_s64_reg_write_0_a4806000() {
    // Test LDFF1SW_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA4806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_br_s64_sp_rn_a48063e0() {
    // Test LDFF1SW_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA48063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA48063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1B_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_xs_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_xs_1_max_6000_c4406000() {
    // Encoding: 0xC4406000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Zt=0, Pg=0, xs=1, Rn=0, Zm=0
    let encoding: u32 = 0xC4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_6000_c4016000() {
    // Encoding: 0xC4016000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zm=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_6000_c41e6000() {
    // Encoding: 0xC41E6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC41E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_31_max_6000_c41f6000() {
    // Encoding: 0xC41F6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Rn=0, Pg=0, Zm=31, Zt=0
    let encoding: u32 = 0xC41F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_pg_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_6000_c4006400() {
    // Encoding: 0xC4006400
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=1
    let encoding: u32 = 0xC4006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_6000_c4006020() {
    // Encoding: 0xC4006020
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xC4006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_6000_c40063c0() {
    // Encoding: 0xC40063C0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC40063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_31_max_6000_c40063e0() {
    // Encoding: 0xC40063E0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, xs=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_6000_c4006001() {
    // Encoding: 0xC4006001
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_6000_c400601e() {
    // Encoding: 0xC400601E
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=30
    let encoding: u32 = 0xC400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_31_max_6000_c400601f() {
    // Encoding: 0xC400601F
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=31
    let encoding: u32 = 0xC400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_0_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c40063e0(
) {
    // Encoding: 0xC40063E0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=31
    let encoding: u32 = 0xC40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_invalid_0_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_invalid_1_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_xs_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_xs_1_max_6000_84406000() {
    // Encoding: 0x84406000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_6000_84016000() {
    // Encoding: 0x84016000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Rn=0, Zm=1, Pg=0
    let encoding: u32 = 0x84016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_6000_841e6000() {
    // Encoding: 0x841E6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0x841E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_31_max_6000_841f6000() {
    // Encoding: 0x841F6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0x841F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_pg_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_6000_84006400() {
    // Encoding: 0x84006400
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0x84006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_6000_84006020() {
    // Encoding: 0x84006020
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Rn=1, Zt=0, xs=0
    let encoding: u32 = 0x84006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_6000_840063c0() {
    // Encoding: 0x840063C0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, xs=0, Rn=30, Zt=0
    let encoding: u32 = 0x840063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_31_max_6000_840063e0() {
    // Encoding: 0x840063E0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x840063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_6000_84006001() {
    // Encoding: 0x84006001
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, xs=0, Zt=1, Zm=0
    let encoding: u32 = 0x84006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_6000_8400601e() {
    // Encoding: 0x8400601E
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0x8400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_31_max_6000_8400601f() {
    // Encoding: 0x8400601F
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0, xs=0
    let encoding: u32 = 0x8400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_0_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_840063e0(
) {
    // Encoding: 0x840063E0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x840063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_invalid_0_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_invalid_1_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_e000_c441e000() {
    // Encoding: 0xC441E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, Pg=0, Zt=0
    let encoding: u32 = 0xC441E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_e000_c45ee000() {
    // Encoding: 0xC45EE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC45EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_31_max_e000_c45fe000() {
    // Encoding: 0xC45FE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zt=0, Zm=31, Pg=0
    let encoding: u32 = 0xC45FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_pg_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_e000_c440e400() {
    // Encoding: 0xC440E400
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Pg=1, Zt=0
    let encoding: u32 = 0xC440E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_e000_c440e020() {
    // Encoding: 0xC440E020
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, Zm=0
    let encoding: u32 = 0xC440E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_e000_c440e3c0() {
    // Encoding: 0xC440E3C0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xC440E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_31_max_e000_c440e3e0() {
    // Encoding: 0xC440E3E0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=31
    let encoding: u32 = 0xC440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_e000_c440e001() {
    // Encoding: 0xC440E001
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC440E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_e000_c440e01e() {
    // Encoding: 0xC440E01E
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xC440E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_31_max_e000_c440e01f() {
    // Encoding: 0xC440E01F
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC440E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_0_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c440e3e0(
) {
    // Encoding: 0xC440E3E0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0xC440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_invalid_0_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_invalid_1_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_reg_write_0_c4006000() {
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_sp_rn_c40063e0() {
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC40063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC40063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_reg_write_0_84006000() {
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_sp_rn_840063e0() {
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x840063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x840063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_reg_write_0_c440e000() {
    // Test LDFF1B_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC440E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_sp_rn_c440e3e0() {
    // Test LDFF1B_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC440E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQW_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_1_poweroftwo_0_a5010000() {
    // Encoding: 0xA5010000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA5010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a51e0000() {
    // Encoding: 0xA51E0000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=30
    let encoding: u32 = 0xA51E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_31_max_0_a51f0000() {
    // Encoding: 0xA51F0000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xA51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_pg_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_pg_1_poweroftwo_0_a5000400() {
    // Encoding: 0xA5000400
    // Test LD1RQW_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xA5000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_1_poweroftwo_0_a5000020() {
    // Encoding: 0xA5000020
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a50003c0() {
    // Encoding: 0xA50003C0
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA50003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_31_max_0_a50003e0() {
    // Encoding: 0xA50003E0
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_1_poweroftwo_0_a5000001() {
    // Encoding: 0xA5000001
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a500001e() {
    // Encoding: 0xA500001E
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA500001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_31_max_0_a500001f() {
    // Encoding: 0xA500001F
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=31
    let encoding: u32 = 0xA500001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_0_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqw_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a50003e0() {
    // Encoding: 0xA50003E0
    // Test LD1RQW_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_0_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_1_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_2_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_3_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqw_z_p_br_contiguous_reg_write_0_a5000000() {
    // Test LD1RQW_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA5000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqw_z_p_br_contiguous_sp_rn_a50003e0() {
    // Test LD1RQW_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA50003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA50003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a521c000() {
    // Encoding: 0xA521C000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a53ec000() {
    // Encoding: 0xA53EC000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xA53EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_31_max_c000_a53fc000() {
    // Encoding: 0xA53FC000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Zt=0, Pg=0
    let encoding: u32 = 0xA53FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_pg_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a520c400() {
    // Encoding: 0xA520C400
    // Test LD2W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a520c020() {
    // Encoding: 0xA520C020
    // Test LD2W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=1
    let encoding: u32 = 0xA520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a520c3c0() {
    // Encoding: 0xA520C3C0
    // Test LD2W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_31_max_c000_a520c3e0() {
    // Encoding: 0xA520C3E0
    // Test LD2W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=31
    let encoding: u32 = 0xA520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a520c001() {
    // Encoding: 0xA520C001
    // Test LD2W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xA520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a520c01e() {
    // Encoding: 0xA520C01E
    // Test LD2W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_31_max_c000_a520c01f() {
    // Encoding: 0xA520C01F
    // Test LD2W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_0_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a520c3e0()
{
    // Encoding: 0xA520C3E0
    // Test LD2W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_0_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_1_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_2_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_3_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2w_z_p_br_contiguous_sp_rn_a520c3e0() {
    // Test LD2W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA520C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA520C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1SB_Z.P.BI_S16 Tests
// ============================================================================

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_0_zero_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_1_poweroftwo_a000_a5d1a000() {
    // Encoding: 0xA5D1A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_3_poweroftwominusone_a000_a5d3a000() {
    // Encoding: 0xA5D3A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_4_poweroftwo_a000_a5d4a000() {
    // Encoding: 0xA5D4A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_7_poweroftwominusone_a000_a5d7a000() {
    // Encoding: 0xA5D7A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_8_poweroftwo_a000_a5d8a000() {
    // Encoding: 0xA5D8A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_15_max_a000_a5dfa000() {
    // Encoding: 0xA5DFA000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_pg_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_pg_1_poweroftwo_a000_a5d0a400() {
    // Encoding: 0xA5D0A400
    // Test LDNF1SB_Z.P.BI_S16 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5D0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_1_poweroftwo_a000_a5d0a020() {
    // Encoding: 0xA5D0A020
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5D0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_30_poweroftwominusone_a000_a5d0a3c0() {
    // Encoding: 0xA5D0A3C0
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA5D0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_31_max_a000_a5d0a3e0() {
    // Encoding: 0xA5D0A3E0
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_1_poweroftwo_a000_a5d0a001() {
    // Encoding: 0xA5D0A001
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA5D0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_30_poweroftwominusone_a000_a5d0a01e() {
    // Encoding: 0xA5D0A01E
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5D0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_31_max_a000_a5d0a01f() {
    // Encoding: 0xA5D0A01F
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, imm4=0
    let encoding: u32 = 0xA5D0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_0_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5d0a3e0() {
    // Encoding: 0xA5D0A3E0
    // Test LDNF1SB_Z.P.BI_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xA5D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s16_invalid_0_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s16_invalid_1_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_0_zero_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_1_poweroftwo_a000_a5b1a000() {
    // Encoding: 0xA5B1A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_3_poweroftwominusone_a000_a5b3a000() {
    // Encoding: 0xA5B3A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Rn=0, Zt=0
    let encoding: u32 = 0xA5B3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_4_poweroftwo_a000_a5b4a000() {
    // Encoding: 0xA5B4A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5B4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_7_poweroftwominusone_a000_a5b7a000() {
    // Encoding: 0xA5B7A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5B7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_8_poweroftwo_a000_a5b8a000() {
    // Encoding: 0xA5B8A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=8, Pg=0
    let encoding: u32 = 0xA5B8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_15_max_a000_a5bfa000() {
    // Encoding: 0xA5BFA000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, imm4=15, Rn=0
    let encoding: u32 = 0xA5BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_pg_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_pg_1_poweroftwo_a000_a5b0a400() {
    // Encoding: 0xA5B0A400
    // Test LDNF1SB_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5B0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_1_poweroftwo_a000_a5b0a020() {
    // Encoding: 0xA5B0A020
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, imm4=0
    let encoding: u32 = 0xA5B0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_a5b0a3c0() {
    // Encoding: 0xA5B0A3C0
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, imm4=0
    let encoding: u32 = 0xA5B0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_31_max_a000_a5b0a3e0() {
    // Encoding: 0xA5B0A3E0
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA5B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_1_poweroftwo_a000_a5b0a001() {
    // Encoding: 0xA5B0A001
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5B0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_a5b0a01e() {
    // Encoding: 0xA5B0A01E
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=30
    let encoding: u32 = 0xA5B0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_31_max_a000_a5b0a01f() {
    // Encoding: 0xA5B0A01F
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: Zt=31, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5B0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_0_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5b0a3e0() {
    // Encoding: 0xA5B0A3E0
    // Test LDNF1SB_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA5B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s32_invalid_0_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s32_invalid_1_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_0_zero_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a591a000() {
    // Encoding: 0xA591A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA591A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a593a000() {
    // Encoding: 0xA593A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Rn=0, Zt=0
    let encoding: u32 = 0xA593A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a594a000() {
    // Encoding: 0xA594A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA594A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a597a000() {
    // Encoding: 0xA597A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=7
    let encoding: u32 = 0xA597A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a598a000() {
    // Encoding: 0xA598A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=8
    let encoding: u32 = 0xA598A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_15_max_a000_a59fa000() {
    // Encoding: 0xA59FA000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA59FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_pg_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_pg_1_poweroftwo_a000_a590a400() {
    // Encoding: 0xA590A400
    // Test LDNF1SB_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xA590A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_1_poweroftwo_a000_a590a020() {
    // Encoding: 0xA590A020
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm4=0, Pg=0
    let encoding: u32 = 0xA590A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a590a3c0() {
    // Encoding: 0xA590A3C0
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, imm4=0, Pg=0
    let encoding: u32 = 0xA590A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_31_max_a000_a590a3e0() {
    // Encoding: 0xA590A3E0
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xA590A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_1_poweroftwo_a000_a590a001() {
    // Encoding: 0xA590A001
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xA590A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a590a01e() {
    // Encoding: 0xA590A01E
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xA590A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_31_max_a000_a590a01f() {
    // Encoding: 0xA590A01F
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA590A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_0_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a590a3e0() {
    // Encoding: 0xA590A3E0
    // Test LDNF1SB_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA590A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s64_invalid_0_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s64_invalid_1_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s16_reg_write_0_a5d0a000() {
    // Test LDNF1SB_Z.P.BI_S16 register write: SimdFromField("t")
    // Encoding: 0xA5D0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5D0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s16_sp_rn_a5d0a3e0() {
    // Test LDNF1SB_Z.P.BI_S16 with Rn = SP (31)
    // Encoding: 0xA5D0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5D0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s32_reg_write_0_a5b0a000() {
    // Test LDNF1SB_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0xA5B0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5B0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s32_sp_rn_a5b0a3e0() {
    // Test LDNF1SB_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0xA5B0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5B0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s64_reg_write_0_a590a000() {
    // Test LDNF1SB_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA590A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA590A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s64_sp_rn_a590a3e0() {
    // Test LDNF1SB_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA590A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA590A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_0_zero_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a501e000() {
    // Encoding: 0xA501E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA501E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a503e000() {
    // Encoding: 0xA503E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA503E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a504e000() {
    // Encoding: 0xA504E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=4, Rn=0
    let encoding: u32 = 0xA504E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a507e000() {
    // Encoding: 0xA507E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xA507E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a508e000() {
    // Encoding: 0xA508E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA508E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_15_max_e000_a50fe000() {
    // Encoding: 0xA50FE000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Pg=0, imm4=15, Zt=0
    let encoding: u32 = 0xA50FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_pg_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a500e400() {
    // Encoding: 0xA500E400
    // Test LDNT1W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA500E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a500e020() {
    // Encoding: 0xA500E020
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA500E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a500e3c0() {
    // Encoding: 0xA500E3C0
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=30, Zt=0
    let encoding: u32 = 0xA500E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_31_max_e000_a500e3e0() {
    // Encoding: 0xA500E3E0
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a500e001() {
    // Encoding: 0xA500E001
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA500E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a500e01e() {
    // Encoding: 0xA500E01E
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA500E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_31_max_e000_a500e01f() {
    // Encoding: 0xA500E01F
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xA500E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_0_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a500e3e0(
) {
    // Encoding: 0xA500E3E0
    // Test LDNT1W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_bi_contiguous_invalid_0_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_bi_contiguous_invalid_1_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1w_z_p_bi_contiguous_reg_write_0_a500e000() {
    // Test LDNT1W_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA500E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_sp_rn_a500e3e0() {
    // Test LDNT1W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA500E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_0_zero_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a581e000() {
    // Encoding: 0xA581E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA581E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a583e000() {
    // Encoding: 0xA583E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=3
    let encoding: u32 = 0xA583E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a584e000() {
    // Encoding: 0xA584E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=4
    let encoding: u32 = 0xA584E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a587e000() {
    // Encoding: 0xA587E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA587E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a588e000() {
    // Encoding: 0xA588E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Rn=0, Pg=0
    let encoding: u32 = 0xA588E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_15_max_e000_a58fe000() {
    // Encoding: 0xA58FE000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, imm4=15, Pg=0
    let encoding: u32 = 0xA58FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_pg_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a580e400() {
    // Encoding: 0xA580E400
    // Test LDNT1D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=1
    let encoding: u32 = 0xA580E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a580e020() {
    // Encoding: 0xA580E020
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA580E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a580e3c0() {
    // Encoding: 0xA580E3C0
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA580E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_31_max_e000_a580e3e0() {
    // Encoding: 0xA580E3E0
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a580e001() {
    // Encoding: 0xA580E001
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA580E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a580e01e() {
    // Encoding: 0xA580E01E
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xA580E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_31_max_e000_a580e01f() {
    // Encoding: 0xA580E01F
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA580E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_0_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a580e3e0(
) {
    // Encoding: 0xA580E3E0
    // Test LDNT1D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_bi_contiguous_invalid_0_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_bi_contiguous_invalid_1_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1d_z_p_bi_contiguous_reg_write_0_a580e000() {
    // Test LDNT1D_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA580E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_sp_rn_a580e3e0() {
    // Test LDNT1D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA580E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_0_zero_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a4e1e000() {
    // Encoding: 0xA4E1E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xA4E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a4e3e000() {
    // Encoding: 0xA4E3E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Pg=0, Rn=0
    let encoding: u32 = 0xA4E3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a4e4e000() {
    // Encoding: 0xA4E4E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=4
    let encoding: u32 = 0xA4E4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a4e7e000() {
    // Encoding: 0xA4E7E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a4e8e000() {
    // Encoding: 0xA4E8E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xA4E8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_15_max_e000_a4efe000() {
    // Encoding: 0xA4EFE000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4EFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_pg_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a4e0e400() {
    // Encoding: 0xA4E0E400
    // Test LD4H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a4e0e020() {
    // Encoding: 0xA4E0E020
    // Test LD4H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a4e0e3c0() {
    // Encoding: 0xA4E0E3C0
    // Test LD4H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xA4E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_31_max_e000_a4e0e3e0() {
    // Encoding: 0xA4E0E3E0
    // Test LD4H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a4e0e001() {
    // Encoding: 0xA4E0E001
    // Test LD4H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA4E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a4e0e01e() {
    // Encoding: 0xA4E0E01E
    // Test LD4H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_31_max_e000_a4e0e01f() {
    // Encoding: 0xA4E0E01F
    // Test LD4H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=31
    let encoding: u32 = 0xA4E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_0_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a4e0e3e0()
{
    // Encoding: 0xA4E0E3E0
    // Test LD4H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_bi_contiguous_invalid_0_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_bi_contiguous_invalid_1_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4h_z_p_bi_contiguous_sp_rn_a4e0e3e0() {
    // Test LD4H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA4E0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a4c1c000() {
    // Encoding: 0xA4C1C000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Zt=0, Pg=0
    let encoding: u32 = 0xA4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a4dec000() {
    // Encoding: 0xA4DEC000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=30
    let encoding: u32 = 0xA4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_31_max_c000_a4dfc000() {
    // Encoding: 0xA4DFC000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_pg_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a4c0c400() {
    // Encoding: 0xA4C0C400
    // Test LD3H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a4c0c020() {
    // Encoding: 0xA4C0C020
    // Test LD3H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a4c0c3c0() {
    // Encoding: 0xA4C0C3C0
    // Test LD3H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_31_max_c000_a4c0c3e0() {
    // Encoding: 0xA4C0C3E0
    // Test LD3H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a4c0c001() {
    // Encoding: 0xA4C0C001
    // Test LD3H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a4c0c01e() {
    // Encoding: 0xA4C0C01E
    // Test LD3H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_31_max_c000_a4c0c01f() {
    // Encoding: 0xA4C0C01F
    // Test LD3H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Rm=0
    let encoding: u32 = 0xA4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_0_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a4c0c3e0()
{
    // Encoding: 0xA4C0C3E0
    // Test LD3H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_0_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_1_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_2_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_3_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3h_z_p_br_contiguous_sp_rn_a4c0c3e0() {
    // Test LD3H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA4C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SH_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_xs_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_xs_1_max_0_84e00000() {
    // Encoding: 0x84E00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Zm=0, Rn=0, xs=1, Zt=0, Pg=0
    let encoding: u32 = 0x84E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_0_84a10000() {
    // Encoding: 0x84A10000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_0_84be0000() {
    // Encoding: 0x84BE0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=30
    let encoding: u32 = 0x84BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_31_max_0_84bf0000() {
    // Encoding: 0x84BF0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, xs=0, Zm=31
    let encoding: u32 = 0x84BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_pg_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_0_84a00400() {
    // Encoding: 0x84A00400
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0x84A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_0_84a00020() {
    // Encoding: 0x84A00020
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Pg=0, xs=0, Rn=1
    let encoding: u32 = 0x84A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_0_84a003c0() {
    // Encoding: 0x84A003C0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0x84A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_31_max_0_84a003e0() {
    // Encoding: 0x84A003E0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: xs=0, Rn=31, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0x84A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_0_84a00001() {
    // Encoding: 0x84A00001
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zt=1, xs=0, Rn=0
    let encoding: u32 = 0x84A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_0_84a0001e() {
    // Encoding: 0x84A0001E
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0x84A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_31_max_0_84a0001f() {
    // Encoding: 0x84A0001F
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_0_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_84a003e0()
{
    // Encoding: 0x84A003E0
    // Test LD1SH_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0x84A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_invalid_0_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_invalid_1_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_xs_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_xs_1_max_0_c4e00000() {
    // Encoding: 0xC4E00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Zt=0, xs=1, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_0_c4a10000() {
    // Encoding: 0xC4A10000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, xs=0, Zm=1, Pg=0
    let encoding: u32 = 0xC4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_0_c4be0000() {
    // Encoding: 0xC4BE0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=0, Zm=30, Zt=0
    let encoding: u32 = 0xC4BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_31_max_0_c4bf0000() {
    // Encoding: 0xC4BF0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_pg_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: xs=0, Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_0_c4a00400() {
    // Encoding: 0xC4A00400
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=1, xs=0
    let encoding: u32 = 0xC4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_0_c4a00020() {
    // Encoding: 0xC4A00020
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC4A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_0_c4a003c0() {
    // Encoding: 0xC4A003C0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC4A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_31_max_0_c4a003e0() {
    // Encoding: 0xC4A003E0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_0_c4a00001() {
    // Encoding: 0xC4A00001
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=1
    let encoding: u32 = 0xC4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_0_c4a0001e() {
    // Encoding: 0xC4A0001E
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, xs=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_31_max_0_c4a0001f() {
    // Encoding: 0xC4A0001F
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0, xs=0
    let encoding: u32 = 0xC4A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_0_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c4a003e0()
{
    // Encoding: 0xC4A003E0
    // Test LD1SH_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_invalid_0_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_invalid_1_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_xs_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_xs_1_max_0_c4c00000() {
    // Encoding: 0xC4C00000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, xs=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_0_c4810000() {
    // Encoding: 0xC4810000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zm=1, Zt=0, Pg=0
    let encoding: u32 = 0xC4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_0_c49e0000() {
    // Encoding: 0xC49E0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC49E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_31_max_0_c49f0000() {
    // Encoding: 0xC49F0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Rn=0, Zt=0, Zm=31, Pg=0
    let encoding: u32 = 0xC49F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_pg_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_0_c4800400() {
    // Encoding: 0xC4800400
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_0_c4800020() {
    // Encoding: 0xC4800020
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=1, xs=0, Pg=0
    let encoding: u32 = 0xC4800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_0_c48003c0() {
    // Encoding: 0xC48003C0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC48003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_31_max_0_c48003e0() {
    // Encoding: 0xC48003E0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_0_c4800001() {
    // Encoding: 0xC4800001
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=1, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_0_c480001e() {
    // Encoding: 0xC480001E
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_31_max_0_c480001f() {
    // Encoding: 0xC480001F
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, Zm=0, xs=0
    let encoding: u32 = 0xC480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_0_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c48003e0(
) {
    // Encoding: 0xC48003E0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_invalid_0_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_invalid_1_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_xs_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_xs_1_max_0_84c00000() {
    // Encoding: 0x84C00000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0, xs=1
    let encoding: u32 = 0x84C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_0_84810000() {
    // Encoding: 0x84810000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_0_849e0000() {
    // Encoding: 0x849E0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x849E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_31_max_0_849f0000() {
    // Encoding: 0x849F0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Pg=0, Rn=0, Zm=31, Zt=0
    let encoding: u32 = 0x849F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_pg_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_0_84800400() {
    // Encoding: 0x84800400
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=1
    let encoding: u32 = 0x84800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_0_84800020() {
    // Encoding: 0x84800020
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0x84800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_0_848003c0() {
    // Encoding: 0x848003C0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x848003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_31_max_0_848003e0() {
    // Encoding: 0x848003E0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Zm=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0x848003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_0_84800001() {
    // Encoding: 0x84800001
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=1, Pg=0, xs=0
    let encoding: u32 = 0x84800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_0_8480001e() {
    // Encoding: 0x8480001E
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0x8480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_31_max_0_8480001f() {
    // Encoding: 0x8480001F
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, xs=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0x8480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_0_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_848003e0(
) {
    // Encoding: 0x848003E0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Pg=0, xs=0, Rn=31
    let encoding: u32 = 0x848003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_invalid_0_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_invalid_1_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_8000_c4e18000() {
    // Encoding: 0xC4E18000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC4E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_8000_c4fe8000() {
    // Encoding: 0xC4FE8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, Pg=0
    let encoding: u32 = 0xC4FE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_31_max_8000_c4ff8000() {
    // Encoding: 0xC4FF8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_pg_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_8000_c4e08400() {
    // Encoding: 0xC4E08400
    // Test LD1SH_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, Zm=0
    let encoding: u32 = 0xC4E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_8000_c4e08020() {
    // Encoding: 0xC4E08020
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4E08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_8000_c4e083c0() {
    // Encoding: 0xC4E083C0
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xC4E083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_31_max_8000_c4e083e0() {
    // Encoding: 0xC4E083E0
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xC4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_8000_c4e08001() {
    // Encoding: 0xC4E08001
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=1
    let encoding: u32 = 0xC4E08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_8000_c4e0801e() {
    // Encoding: 0xC4E0801E
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=30
    let encoding: u32 = 0xC4E0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_31_max_8000_c4e0801f() {
    // Encoding: 0xC4E0801F
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=31
    let encoding: u32 = 0xC4E0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_0_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c4e083e0(
) {
    // Encoding: 0xC4E083E0
    // Test LD1SH_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_invalid_0_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_invalid_1_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_8000_c4c18000() {
    // Encoding: 0xC4C18000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_8000_c4de8000() {
    // Encoding: 0xC4DE8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_31_max_8000_c4df8000() {
    // Encoding: 0xC4DF8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_pg_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_8000_c4c08400() {
    // Encoding: 0xC4C08400
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_8000_c4c08020() {
    // Encoding: 0xC4C08020
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_8000_c4c083c0() {
    // Encoding: 0xC4C083C0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xC4C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_31_max_8000_c4c083e0() {
    // Encoding: 0xC4C083E0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xC4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_8000_c4c08001() {
    // Encoding: 0xC4C08001
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xC4C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_8000_c4c0801e() {
    // Encoding: 0xC4C0801E
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_31_max_8000_c4c0801f() {
    // Encoding: 0xC4C0801F
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Zt=31, Rn=0, Pg=0
    let encoding: u32 = 0xC4C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_0_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c4c083e0(
) {
    // Encoding: 0xC4C083E0
    // Test LD1SH_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_invalid_0_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_invalid_1_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_reg_write_0_84a00000() {
    // Test LD1SH_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_sp_rn_84a003e0() {
    // Test LD1SH_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_reg_write_0_c4a00000() {
    // Test LD1SH_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_sp_rn_c4a003e0() {
    // Test LD1SH_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_reg_write_0_c4800000() {
    // Test LD1SH_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_sp_rn_c48003e0() {
    // Test LD1SH_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_reg_write_0_84800000() {
    // Test LD1SH_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_sp_rn_848003e0() {
    // Test LD1SH_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_reg_write_0_c4e08000() {
    // Test LD1SH_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_sp_rn_c4e083e0() {
    // Test LD1SH_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_reg_write_0_c4c08000() {
    // Test LD1SH_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_sp_rn_c4c083e0() {
    // Test LD1SH_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQD_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_1_poweroftwo_0_a5810000() {
    // Encoding: 0xA5810000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xA5810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a59e0000() {
    // Encoding: 0xA59E0000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=30
    let encoding: u32 = 0xA59E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_31_max_0_a59f0000() {
    // Encoding: 0xA59F0000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA59F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_pg_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_pg_1_poweroftwo_0_a5800400() {
    // Encoding: 0xA5800400
    // Test LD1RQD_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA5800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_1_poweroftwo_0_a5800020() {
    // Encoding: 0xA5800020
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA5800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a58003c0() {
    // Encoding: 0xA58003C0
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xA58003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_31_max_0_a58003e0() {
    // Encoding: 0xA58003E0
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_1_poweroftwo_0_a5800001() {
    // Encoding: 0xA5800001
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xA5800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a580001e() {
    // Encoding: 0xA580001E
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA580001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_31_max_0_a580001f() {
    // Encoding: 0xA580001F
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=31
    let encoding: u32 = 0xA580001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_0_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqd_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a58003e0() {
    // Encoding: 0xA58003E0
    // Test LD1RQD_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_0_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_1_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_2_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_3_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqd_z_p_br_contiguous_reg_write_0_a5800000() {
    // Test LD1RQD_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA5800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqd_z_p_br_contiguous_sp_rn_a58003e0() {
    // Test LD1RQD_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA58003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA58003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a5a1c000() {
    // Encoding: 0xA5A1C000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA5A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a5bec000() {
    // Encoding: 0xA5BEC000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=30, Zt=0
    let encoding: u32 = 0xA5BEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_31_max_c000_a5bfc000() {
    // Encoding: 0xA5BFC000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=31
    let encoding: u32 = 0xA5BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_pg_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a5a0c400() {
    // Encoding: 0xA5A0C400
    // Test LD2D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a5a0c020() {
    // Encoding: 0xA5A0C020
    // Test LD2D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=1
    let encoding: u32 = 0xA5A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a5a0c3c0() {
    // Encoding: 0xA5A0C3C0
    // Test LD2D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA5A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_31_max_c000_a5a0c3e0() {
    // Encoding: 0xA5A0C3E0
    // Test LD2D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xA5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a5a0c001() {
    // Encoding: 0xA5A0C001
    // Test LD2D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a5a0c01e() {
    // Encoding: 0xA5A0C01E
    // Test LD2D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_31_max_c000_a5a0c01f() {
    // Encoding: 0xA5A0C01F
    // Test LD2D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xA5A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_0_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a5a0c3e0()
{
    // Encoding: 0xA5A0C3E0
    // Test LD2D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_0_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_1_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_2_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_3_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2d_z_p_br_contiguous_sp_rn_a5a0c3e0() {
    // Test LD2D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA5A0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1H_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_xs_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_xs_1_max_4000_84e04000() {
    // Encoding: 0x84E04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Zt=0, Zm=0, xs=1, Rn=0, Pg=0
    let encoding: u32 = 0x84E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_4000_84a14000() {
    // Encoding: 0x84A14000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, xs=0, Zm=1, Zt=0
    let encoding: u32 = 0x84A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_4000_84be4000() {
    // Encoding: 0x84BE4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=30, Pg=0, Rn=0
    let encoding: u32 = 0x84BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_31_max_4000_84bf4000() {
    // Encoding: 0x84BF4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x84BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_pg_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_4000_84a04400() {
    // Encoding: 0x84A04400
    // Test LD1H_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=1
    let encoding: u32 = 0x84A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_4000_84a04020() {
    // Encoding: 0x84A04020
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0x84A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_4000_84a043c0() {
    // Encoding: 0x84A043C0
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Zm=0, xs=0
    let encoding: u32 = 0x84A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_31_max_4000_84a043e0() {
    // Encoding: 0x84A043E0
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_4000_84a04001() {
    // Encoding: 0x84A04001
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0x84A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_4000_84a0401e() {
    // Encoding: 0x84A0401E
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0x84A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_31_max_4000_84a0401f() {
    // Encoding: 0x84A0401F
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=31, xs=0
    let encoding: u32 = 0x84A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_0_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_84a043e0(
) {
    // Encoding: 0x84A043E0
    // Test LD1H_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0x84A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_invalid_0_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_invalid_1_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_xs_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_xs_1_max_4000_c4e04000() {
    // Encoding: 0xC4E04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zm=0, xs=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_4000_c4a14000() {
    // Encoding: 0xC4A14000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC4A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_4000_c4be4000() {
    // Encoding: 0xC4BE4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_31_max_4000_c4bf4000() {
    // Encoding: 0xC4BF4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, Zt=0, xs=0, Zm=31, Pg=0
    let encoding: u32 = 0xC4BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_pg_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_4000_c4a04400() {
    // Encoding: 0xC4A04400
    // Test LD1H_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=1, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_4000_c4a04020() {
    // Encoding: 0xC4A04020
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_4000_c4a043c0() {
    // Encoding: 0xC4A043C0
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=30, Zm=0, Zt=0
    let encoding: u32 = 0xC4A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_31_max_4000_c4a043e0() {
    // Encoding: 0xC4A043E0
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xC4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_4000_c4a04001() {
    // Encoding: 0xC4A04001
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=1
    let encoding: u32 = 0xC4A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_4000_c4a0401e() {
    // Encoding: 0xC4A0401E
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zt=30, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_31_max_4000_c4a0401f() {
    // Encoding: 0xC4A0401F
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=31, xs=0
    let encoding: u32 = 0xC4A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_0_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c4a043e0(
) {
    // Encoding: 0xC4A043E0
    // Test LD1H_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Pg=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xC4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_invalid_0_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_invalid_1_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_xs_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_xs_1_max_4000_c4c04000() {
    // Encoding: 0xC4C04000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, xs=1, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_4000_c4814000() {
    // Encoding: 0xC4814000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Rn=0, Zm=1, Zt=0
    let encoding: u32 = 0xC4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_4000_c49e4000() {
    // Encoding: 0xC49E4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_31_max_4000_c49f4000() {
    // Encoding: 0xC49F4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=31, Rn=0, xs=0
    let encoding: u32 = 0xC49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_pg_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_4000_c4804400() {
    // Encoding: 0xC4804400
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, xs=0, Zm=0
    let encoding: u32 = 0xC4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_4000_c4804020() {
    // Encoding: 0xC4804020
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xC4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_4000_c48043c0() {
    // Encoding: 0xC48043C0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_31_max_4000_c48043e0() {
    // Encoding: 0xC48043E0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xC48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_4000_c4804001() {
    // Encoding: 0xC4804001
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=1, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_4000_c480401e() {
    // Encoding: 0xC480401E
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_31_max_4000_c480401f() {
    // Encoding: 0xC480401F
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, xs=0, Zm=0
    let encoding: u32 = 0xC480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_0_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c48043e0(
) {
    // Encoding: 0xC48043E0
    // Test LD1H_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_invalid_0_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_invalid_1_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_xs_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_xs_1_max_4000_84c04000() {
    // Encoding: 0x84C04000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, xs=1, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x84C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_4000_84814000() {
    // Encoding: 0x84814000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Zm=1, Pg=0, xs=0
    let encoding: u32 = 0x84814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_4000_849e4000() {
    // Encoding: 0x849E4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x849E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_31_max_4000_849f4000() {
    // Encoding: 0x849F4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Pg=0, Rn=0, Zm=31, Zt=0
    let encoding: u32 = 0x849F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_pg_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_4000_84804400() {
    // Encoding: 0x84804400
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Pg=1, xs=0, Rn=0
    let encoding: u32 = 0x84804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_4000_84804020() {
    // Encoding: 0x84804020
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0x84804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_4000_848043c0() {
    // Encoding: 0x848043C0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0x848043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_31_max_4000_848043e0() {
    // Encoding: 0x848043E0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=31, xs=0
    let encoding: u32 = 0x848043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_4000_84804001() {
    // Encoding: 0x84804001
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=1
    let encoding: u32 = 0x84804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_4000_8480401e() {
    // Encoding: 0x8480401E
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=30
    let encoding: u32 = 0x8480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_31_max_4000_8480401f() {
    // Encoding: 0x8480401F
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, xs=0, Zt=31, Pg=0, Zm=0
    let encoding: u32 = 0x8480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_0_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_848043e0(
) {
    // Encoding: 0x848043E0
    // Test LD1H_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0x848043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_invalid_0_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_invalid_1_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_c000_c4e1c000() {
    // Encoding: 0xC4E1C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, Zt=0, Rn=0
    let encoding: u32 = 0xC4E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_c000_c4fec000() {
    // Encoding: 0xC4FEC000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=30
    let encoding: u32 = 0xC4FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_31_max_c000_c4ffc000() {
    // Encoding: 0xC4FFC000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_pg_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_c000_c4e0c400() {
    // Encoding: 0xC4E0C400
    // Test LD1H_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=1
    let encoding: u32 = 0xC4E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_c000_c4e0c020() {
    // Encoding: 0xC4E0C020
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_c000_c4e0c3c0() {
    // Encoding: 0xC4E0C3C0
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_31_max_c000_c4e0c3e0() {
    // Encoding: 0xC4E0C3E0
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_c000_c4e0c001() {
    // Encoding: 0xC4E0C001
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_c000_c4e0c01e() {
    // Encoding: 0xC4E0C01E
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Zm=0, Rn=0
    let encoding: u32 = 0xC4E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_31_max_c000_c4e0c01f() {
    // Encoding: 0xC4E0C01F
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xC4E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_0_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c4e0c3e0(
) {
    // Encoding: 0xC4E0C3E0
    // Test LD1H_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Rn=31, Zm=0
    let encoding: u32 = 0xC4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_invalid_0_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_invalid_1_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_c000_c4c1c000() {
    // Encoding: 0xC4C1C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_c000_c4dec000() {
    // Encoding: 0xC4DEC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_31_max_c000_c4dfc000() {
    // Encoding: 0xC4DFC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zt=0, Rn=0
    let encoding: u32 = 0xC4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_pg_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_c000_c4c0c400() {
    // Encoding: 0xC4C0C400
    // Test LD1H_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Zm=0, Rn=0
    let encoding: u32 = 0xC4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_c000_c4c0c020() {
    // Encoding: 0xC4C0C020
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_c000_c4c0c3c0() {
    // Encoding: 0xC4C0C3C0
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=30
    let encoding: u32 = 0xC4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_31_max_c000_c4c0c3e0() {
    // Encoding: 0xC4C0C3E0
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xC4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_c000_c4c0c001() {
    // Encoding: 0xC4C0C001
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=1
    let encoding: u32 = 0xC4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_c000_c4c0c01e() {
    // Encoding: 0xC4C0C01E
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Zm=0, Pg=0
    let encoding: u32 = 0xC4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_31_max_c000_c4c0c01f() {
    // Encoding: 0xC4C0C01F
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_0_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c4c0c3e0(
) {
    // Encoding: 0xC4C0C3E0
    // Test LD1H_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xC4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_invalid_0_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_invalid_1_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_reg_write_0_84a04000() {
    // Test LD1H_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_sp_rn_84a043e0() {
    // Test LD1H_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_reg_write_0_c4a04000() {
    // Test LD1H_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_sp_rn_c4a043e0() {
    // Test LD1H_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_reg_write_0_c4804000() {
    // Test LD1H_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_sp_rn_c48043e0() {
    // Test LD1H_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_reg_write_0_84804000() {
    // Test LD1H_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_sp_rn_848043e0() {
    // Test LD1H_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_reg_write_0_c4e0c000() {
    // Test LD1H_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_sp_rn_c4e0c3e0() {
    // Test LD1H_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_reg_write_0_c4c0c000() {
    // Test LD1H_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_sp_rn_c4c0c3e0() {
    // Test LD1H_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
