//! A64 vector arithmetic tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// aarch64_vector_arithmetic_unary_diff_neg_fp16 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_q_0_min_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Q = 0 (Min)
    // Fields: Q=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_q_1_max_f800_4ef8f800() {
    // Encoding: 0x4EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Q = 1 (Max)
    // Fields: U=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x4EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_u_0_min_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field U = 0 (Min)
    // Fields: Q=0, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_u_1_max_f800_2ef8f800() {
    // Encoding: 0x2EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field U = 1 (Max)
    // Fields: Rn=0, Q=0, U=1, Rd=0
    let encoding: u32 = 0x2EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rn_0_min_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rn_1_poweroftwo_f800_0ef8f820() {
    // Encoding: 0x0EF8F820
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, Rd=0, Rn=1
    let encoding: u32 = 0x0EF8F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rn_30_poweroftwominusone_f800_0ef8fbc0() {
    // Encoding: 0x0EF8FBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x0EF8FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rn_31_max_f800_0ef8fbe0() {
    // Encoding: 0x0EF8FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rn = 31 (Max)
    // Fields: Q=0, U=0, Rn=31, Rd=0
    let encoding: u32 = 0x0EF8FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rd_0_min_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rd = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rd_1_poweroftwo_f800_0ef8f801() {
    // Encoding: 0x0EF8F801
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, U=0, Q=0
    let encoding: u32 = 0x0EF8F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rd_30_poweroftwominusone_f800_0ef8f81e() {
    // Encoding: 0x0EF8F81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, U=0, Rd=30, Rn=0
    let encoding: u32 = 0x0EF8F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_field_rd_31_max_f800_0ef8f81f() {
    // Encoding: 0x0EF8F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, Rn=0, U=0
    let encoding: u32 = 0x0EF8F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_0_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_1_f800_4ef8f800() {
    // Encoding: 0x4EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=1, U=0, Rn=0, Rd=0
    // Fields: Q=1, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x4EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_2_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_3_f800_2ef8f800() {
    // Encoding: 0x2EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, U=1
    let encoding: u32 = 0x2EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_4_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_5_f800_0ef8f820() {
    // Encoding: 0x0EF8F820
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=1, Rd=0
    // Fields: U=0, Q=0, Rd=0, Rn=1
    let encoding: u32 = 0x0EF8F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_6_f800_0ef8fbc0() {
    // Encoding: 0x0EF8FBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=30, Rd=0
    // Fields: Rn=30, Q=0, U=0, Rd=0
    let encoding: u32 = 0x0EF8FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_7_f800_0ef8fbe0() {
    // Encoding: 0x0EF8FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=31, Rd=0
    // Fields: Rd=0, Rn=31, Q=0, U=0
    let encoding: u32 = 0x0EF8FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_8_f800_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_9_f800_0ef8f801() {
    // Encoding: 0x0EF8F801
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=1
    // Fields: Rd=1, U=0, Rn=0, Q=0
    let encoding: u32 = 0x0EF8F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_10_f800_0ef8f81e() {
    // Encoding: 0x0EF8F81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=30
    // Fields: Q=0, U=0, Rd=30, Rn=0
    let encoding: u32 = 0x0EF8F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_11_f800_0ef8f81f() {
    // Encoding: 0x0EF8F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, U=0, Q=0
    let encoding: u32 = 0x0EF8F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_12_f800_0ef8f821() {
    // Encoding: 0x0EF8F821
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=1, Rd=1
    // Fields: Q=0, Rn=1, U=0, Rd=1
    let encoding: u32 = 0x0EF8F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_combo_13_f800_0ef8fbff() {
    // Encoding: 0x0EF8FBFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 field combination: Q=0, U=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, Q=0, U=0
    let encoding: u32 = 0x0EF8FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_special_q_0_size_variant_0_63488_0ef8f800() {
    // Encoding: 0x0EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 special value Q = 0 (Size variant 0)
    // Fields: U=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_special_q_1_size_variant_1_63488_4ef8f800() {
    // Encoding: 0x4EF8F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 special value Q = 1 (Size variant 1)
    // Fields: Rn=0, U=0, Rd=0, Q=1
    let encoding: u32 = 0x4EF8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_special_rn_31_stack_pointer_sp_may_require_alignment_63488_0ef8fbe0() {
    // Encoding: 0x0EF8FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, U=0, Rn=31
    let encoding: u32 = 0x0EF8FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_0ef8f81f() {
    // Encoding: 0x0EF8F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, U=0, Q=0
    let encoding: u32 = 0x0EF8F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_q_0_min_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Q = 0 (Min)
    // Fields: Q=0, Rn=0, U=0, Rd=0, sz=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_q_1_max_f800_4ea0f800() {
    // Encoding: 0x4EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Q = 1 (Max)
    // Fields: U=0, Rd=0, sz=0, Rn=0, Q=1
    let encoding: u32 = 0x4EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_u_0_min_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field U = 0 (Min)
    // Fields: Q=0, Rd=0, U=0, sz=0, Rn=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_u_1_max_f800_2ea0f800() {
    // Encoding: 0x2EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field U = 1 (Max)
    // Fields: Rd=0, sz=0, U=1, Rn=0, Q=0
    let encoding: u32 = 0x2EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_sz_0_min_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field sz = 0 (Min)
    // Fields: Rd=0, sz=0, Rn=0, U=0, Q=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_sz_1_max_f800_0ee0f800() {
    // Encoding: 0x0EE0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field sz = 1 (Max)
    // Fields: U=0, Rd=0, sz=1, Q=0, Rn=0
    let encoding: u32 = 0x0EE0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rn_0_min_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0, U=0, sz=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rn_1_poweroftwo_f800_0ea0f820() {
    // Encoding: 0x0EA0F820
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, U=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rn_30_poweroftwominusone_f800_0ea0fbc0() {
    // Encoding: 0x0EA0FBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Q=0, sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x0EA0FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rn_31_max_f800_0ea0fbe0() {
    // Encoding: 0x0EA0FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rn = 31 (Max)
    // Fields: U=0, Rn=31, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0EA0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rd_0_min_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rd = 0 (Min)
    // Fields: Rd=0, Q=0, U=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rd_1_poweroftwo_f800_0ea0f801() {
    // Encoding: 0x0EA0F801
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, U=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rd_30_poweroftwominusone_f800_0ea0f81e() {
    // Encoding: 0x0EA0F81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=30, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA0F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_field_rd_31_max_f800_0ea0f81f() {
    // Encoding: 0x0EA0F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field Rd = 31 (Max)
    // Fields: Q=0, U=0, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x0EA0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_0_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, U=0, Rd=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_1_f800_4ea0f800() {
    // Encoding: 0x4EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=1, U=0, sz=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Q=1, sz=0, Rn=0
    let encoding: u32 = 0x4EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_2_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_3_f800_2ea0f800() {
    // Encoding: 0x2EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=1, sz=0, Rn=0, Rd=0
    // Fields: U=1, Q=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x2EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_4_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_5_f800_0ee0f800() {
    // Encoding: 0x0EE0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=1, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Q=0, sz=1, Rn=0
    let encoding: u32 = 0x0EE0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_6_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, U=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_7_f800_0ea0f820() {
    // Encoding: 0x0EA0F820
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=1, Rd=0
    // Fields: sz=0, Q=0, Rn=1, Rd=0, U=0
    let encoding: u32 = 0x0EA0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_8_f800_0ea0fbc0() {
    // Encoding: 0x0EA0FBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, Q=0, sz=0, U=0
    let encoding: u32 = 0x0EA0FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_9_f800_0ea0fbe0() {
    // Encoding: 0x0EA0FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=31, Rd=0
    // Fields: U=0, Rn=31, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_10_f800_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, U=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_11_f800_0ea0f801() {
    // Encoding: 0x0EA0F801
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=1
    // Fields: Rn=0, U=0, Q=0, sz=0, Rd=1
    let encoding: u32 = 0x0EA0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_12_f800_0ea0f81e() {
    // Encoding: 0x0EA0F81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=30
    // Fields: Q=0, Rd=30, U=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA0F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_13_f800_0ea0f81f() {
    // Encoding: 0x0EA0F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=0, Rd=31
    // Fields: Rd=31, sz=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_14_f800_0ea0f821() {
    // Encoding: 0x0EA0F821
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=1, Rd=1
    // Fields: Rd=1, sz=0, Q=0, U=0, Rn=1
    let encoding: u32 = 0x0EA0F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_combo_15_f800_0ea0fbff() {
    // Encoding: 0x0EA0FBFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_float field combination: Q=0, U=0, sz=0, Rn=31, Rd=31
    // Fields: Q=0, Rn=31, Rd=31, sz=0, U=0
    let encoding: u32 = 0x0EA0FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_q_0_size_variant_0_63488_0ee0f800() {
    // Encoding: 0x0EE0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value Q = 0 (Size variant 0)
    // Fields: Q=0, sz=1, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x0EE0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_q_1_size_variant_1_63488_4ee0f800() {
    // Encoding: 0x4EE0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rn=0, Q=1, sz=1, U=0
    let encoding: u32 = 0x4EE0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_sz_0_size_variant_0_63488_0ea0f800() {
    // Encoding: 0x0EA0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value sz = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, U=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_sz_1_size_variant_1_63488_0ee0f800() {
    // Encoding: 0x0EE0F800
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value sz = 1 (Size variant 1)
    // Fields: Q=0, Rn=0, sz=1, Rd=0, U=0
    let encoding: u32 = 0x0EE0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_rn_31_stack_pointer_sp_may_require_alignment_63488_0ee0fbe0() {
    // Encoding: 0x0EE0FBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, U=0, Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x0EE0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_0ee0f81f() {
    // Encoding: 0x0EE0F81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_float special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, Q=0, Rd=31, sz=1, Rn=0
    let encoding: u32 = 0x0EE0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_reg_write_0_0ef8f800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 register write: SimdFromField("d")
    // Encoding: 0x0EF8F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF8F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_sp_rn_0ef8fbe0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 with Rn = SP (31)
    // Encoding: 0x0EF8FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF8FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_fp16
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_fp16_zr_rd_0ef8f81f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_fp16 with Rd = ZR (31)
    // Encoding: 0x0EF8F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF8F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_reg_write_0_0ea0f800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_float register write: SimdFromField("d")
    // Encoding: 0x0EA0F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_sp_rn_0ea0fbe0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_float with Rn = SP (31)
    // Encoding: 0x0EA0FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_float
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_float_zr_rd_0ea0f81f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_float with Rd = ZR (31)
    // Encoding: 0x0EA0F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_fp16_round Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_q_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0, o1=0, U=0, o2=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_q_1_max_8800_4e798800() {
    // Encoding: 0x4E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field Q = 1 (Max)
    // Fields: Rd=0, Q=1, o2=0, U=0, Rn=0, o1=0
    let encoding: u32 = 0x4E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_u_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field U = 0 (Min)
    // Fields: U=0, Rn=0, o1=0, Rd=0, o2=0, Q=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_u_1_max_8800_2e798800() {
    // Encoding: 0x2E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field U = 1 (Max)
    // Fields: U=1, o2=0, Rd=0, Rn=0, Q=0, o1=0
    let encoding: u32 = 0x2E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_o2_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field o2 = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, U=0, o1=0, o2=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_o2_1_max_8800_0ef98800() {
    // Encoding: 0x0EF98800
    // Test aarch64_vector_arithmetic_unary_fp16_round field o2 = 1 (Max)
    // Fields: o1=0, Rn=0, Q=0, o2=1, Rd=0, U=0
    let encoding: u32 = 0x0EF98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_o1_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field o1 = 0 (Min)
    // Fields: Rd=0, o1=0, o2=0, U=0, Rn=0, Q=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_o1_1_max_8800_0e799800() {
    // Encoding: 0x0E799800
    // Test aarch64_vector_arithmetic_unary_fp16_round field o1 = 1 (Max)
    // Fields: o1=1, o2=0, U=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E799800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rn_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rn = 0 (Min)
    // Fields: Rn=0, o1=0, Q=0, U=0, o2=0, Rd=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rn_1_poweroftwo_8800_0e798820() {
    // Encoding: 0x0E798820
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, o2=0, Rn=1, Rd=0, o1=0
    let encoding: u32 = 0x0E798820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rn_30_poweroftwominusone_8800_0e798bc0() {
    // Encoding: 0x0E798BC0
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, U=0, Rn=30, o2=0, o1=0, Rd=0
    let encoding: u32 = 0x0E798BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rn_31_max_8800_0e798be0() {
    // Encoding: 0x0E798BE0
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rn = 31 (Max)
    // Fields: o2=0, Q=0, o1=0, Rn=31, U=0, Rd=0
    let encoding: u32 = 0x0E798BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rd_0_min_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rd = 0 (Min)
    // Fields: o2=0, U=0, Rn=0, o1=0, Rd=0, Q=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rd_1_poweroftwo_8800_0e798801() {
    // Encoding: 0x0E798801
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rd = 1 (PowerOfTwo)
    // Fields: o1=0, o2=0, Rn=0, Rd=1, U=0, Q=0
    let encoding: u32 = 0x0E798801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rd_30_poweroftwominusone_8800_0e79881e() {
    // Encoding: 0x0E79881E
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, o1=0, Rn=0, Rd=30, o2=0, Q=0
    let encoding: u32 = 0x0E79881E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_field_rd_31_max_8800_0e79881f() {
    // Encoding: 0x0E79881F
    // Test aarch64_vector_arithmetic_unary_fp16_round field Rd = 31 (Max)
    // Fields: Rd=31, o2=0, Q=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E79881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_0_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o1=0, Rn=0, o2=0, Rd=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_1_8800_4e798800() {
    // Encoding: 0x4E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=1, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, Rd=0, Q=1, o1=0, U=0, Rn=0
    let encoding: u32 = 0x4E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_2_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, o2=0, U=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_3_8800_2e798800() {
    // Encoding: 0x2E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=1, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, o2=0, o1=0, Rn=0, Rd=0, U=1
    let encoding: u32 = 0x2E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_4_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, Rd=0, o2=0, U=0, Q=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_5_8800_0ef98800() {
    // Encoding: 0x0EF98800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=1, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, U=0, o1=0, o2=1, Rn=0
    let encoding: u32 = 0x0EF98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_6_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o1=0, o2=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_7_8800_0e799800() {
    // Encoding: 0x0E799800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=1, Rn=0, Rd=0
    // Fields: o2=0, Rd=0, U=0, Rn=0, o1=1, Q=0
    let encoding: u32 = 0x0E799800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_8_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, o2=0, U=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_9_8800_0e798820() {
    // Encoding: 0x0E798820
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=1, Rd=0
    // Fields: Q=0, Rd=0, Rn=1, o1=0, o2=0, U=0
    let encoding: u32 = 0x0E798820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_10_8800_0e798bc0() {
    // Encoding: 0x0E798BC0
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=30, Rd=0
    // Fields: U=0, Rd=0, Q=0, o2=0, o1=0, Rn=30
    let encoding: u32 = 0x0E798BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_11_8800_0e798be0() {
    // Encoding: 0x0E798BE0
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=31, Rd=0
    // Fields: o2=0, Rd=0, o1=0, Q=0, Rn=31, U=0
    let encoding: u32 = 0x0E798BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_12_8800_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, o2=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_13_8800_0e798801() {
    // Encoding: 0x0E798801
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=1
    // Fields: Q=0, Rd=1, o2=0, o1=0, U=0, Rn=0
    let encoding: u32 = 0x0E798801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_14_8800_0e79881e() {
    // Encoding: 0x0E79881E
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=30
    // Fields: Rd=30, Q=0, U=0, o2=0, o1=0, Rn=0
    let encoding: u32 = 0x0E79881E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_15_8800_0e79881f() {
    // Encoding: 0x0E79881F
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=31
    // Fields: Q=0, U=0, o1=0, Rn=0, Rd=31, o2=0
    let encoding: u32 = 0x0E79881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_16_8800_0e798821() {
    // Encoding: 0x0E798821
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=1, Rd=1
    // Fields: o1=0, Rn=1, Rd=1, Q=0, U=0, o2=0
    let encoding: u32 = 0x0E798821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_combo_17_8800_0e798bff() {
    // Encoding: 0x0E798BFF
    // Test aarch64_vector_arithmetic_unary_fp16_round field combination: Q=0, U=0, o2=0, o1=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, U=0, o1=0, o2=0, Q=0
    let encoding: u32 = 0x0E798BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_special_q_0_size_variant_0_34816_0e798800() {
    // Encoding: 0x0E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round special value Q = 0 (Size variant 0)
    // Fields: Rd=0, o1=0, Rn=0, Q=0, o2=0, U=0
    let encoding: u32 = 0x0E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_special_q_1_size_variant_1_34816_4e798800() {
    // Encoding: 0x4E798800
    // Test aarch64_vector_arithmetic_unary_fp16_round special value Q = 1 (Size variant 1)
    // Fields: o2=0, Q=1, U=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E798800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_special_rn_31_stack_pointer_sp_may_require_alignment_34816_0e798be0() {
    // Encoding: 0x0E798BE0
    // Test aarch64_vector_arithmetic_unary_fp16_round special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, o2=0, U=0, o1=0, Q=0
    let encoding: u32 = 0x0E798BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_34816_0e79881f() {
    // Encoding: 0x0E79881F
    // Test aarch64_vector_arithmetic_unary_fp16_round special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, o1=0, Q=0, o2=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E79881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_q_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field Q = 0 (Min)
    // Fields: Rd=0, U=0, Rn=0, o2=0, sz=0, o1=0, Q=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_q_1_max_8800_4e218800() {
    // Encoding: 0x4E218800
    // Test aarch64_vector_arithmetic_unary_float_round field Q = 1 (Max)
    // Fields: U=0, sz=0, o1=0, Rn=0, Rd=0, o2=0, Q=1
    let encoding: u32 = 0x4E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_u_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field U = 0 (Min)
    // Fields: o2=0, o1=0, Rn=0, U=0, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_u_1_max_8800_2e218800() {
    // Encoding: 0x2E218800
    // Test aarch64_vector_arithmetic_unary_float_round field U = 1 (Max)
    // Fields: o1=0, U=1, sz=0, Rn=0, o2=0, Rd=0, Q=0
    let encoding: u32 = 0x2E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_o2_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field o2 = 0 (Min)
    // Fields: Q=0, U=0, sz=0, Rn=0, o2=0, o1=0, Rd=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_o2_1_max_8800_0ea18800() {
    // Encoding: 0x0EA18800
    // Test aarch64_vector_arithmetic_unary_float_round field o2 = 1 (Max)
    // Fields: U=0, Rn=0, Rd=0, Q=0, o2=1, sz=0, o1=0
    let encoding: u32 = 0x0EA18800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_sz_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field sz = 0 (Min)
    // Fields: sz=0, Rn=0, U=0, Rd=0, o1=0, o2=0, Q=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_sz_1_max_8800_0e618800() {
    // Encoding: 0x0E618800
    // Test aarch64_vector_arithmetic_unary_float_round field sz = 1 (Max)
    // Fields: o1=0, Rd=0, Q=0, U=0, Rn=0, o2=0, sz=1
    let encoding: u32 = 0x0E618800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_o1_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field o1 = 0 (Min)
    // Fields: Q=0, sz=0, o2=0, o1=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_o1_1_max_8800_0e219800() {
    // Encoding: 0x0E219800
    // Test aarch64_vector_arithmetic_unary_float_round field o1 = 1 (Max)
    // Fields: sz=0, Rn=0, U=0, Rd=0, o1=1, o2=0, Q=0
    let encoding: u32 = 0x0E219800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rn_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field Rn = 0 (Min)
    // Fields: o2=0, o1=0, Rd=0, U=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rn_1_poweroftwo_8800_0e218820() {
    // Encoding: 0x0E218820
    // Test aarch64_vector_arithmetic_unary_float_round field Rn = 1 (PowerOfTwo)
    // Fields: U=0, sz=0, Q=0, Rn=1, Rd=0, o2=0, o1=0
    let encoding: u32 = 0x0E218820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rn_30_poweroftwominusone_8800_0e218bc0() {
    // Encoding: 0x0E218BC0
    // Test aarch64_vector_arithmetic_unary_float_round field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, o2=0, U=0, sz=0, o1=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E218BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rn_31_max_8800_0e218be0() {
    // Encoding: 0x0E218BE0
    // Test aarch64_vector_arithmetic_unary_float_round field Rn = 31 (Max)
    // Fields: Rd=0, o2=0, U=0, Q=0, sz=0, Rn=31, o1=0
    let encoding: u32 = 0x0E218BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rd_0_min_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field Rd = 0 (Min)
    // Fields: o1=0, U=0, Q=0, Rd=0, Rn=0, sz=0, o2=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rd_1_poweroftwo_8800_0e218801() {
    // Encoding: 0x0E218801
    // Test aarch64_vector_arithmetic_unary_float_round field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, o2=0, o1=0, Rn=0, Rd=1, U=0, sz=0
    let encoding: u32 = 0x0E218801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rd_30_poweroftwominusone_8800_0e21881e() {
    // Encoding: 0x0E21881E
    // Test aarch64_vector_arithmetic_unary_float_round field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, sz=0, o1=0, U=0, Rn=0, o2=0
    let encoding: u32 = 0x0E21881E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_field_rd_31_max_8800_0e21881f() {
    // Encoding: 0x0E21881F
    // Test aarch64_vector_arithmetic_unary_float_round field Rd = 31 (Max)
    // Fields: U=0, sz=0, Rd=31, Q=0, o1=0, o2=0, Rn=0
    let encoding: u32 = 0x0E21881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_0_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Q=0, sz=0, o2=0, o1=0, Rd=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_1_8800_4e218800() {
    // Encoding: 0x4E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=1, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, o1=0, Rd=0, Rn=0, Q=1, U=0, sz=0
    let encoding: u32 = 0x4E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_2_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, o2=0, sz=0, Rn=0, o1=0, Q=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_3_8800_2e218800() {
    // Encoding: 0x2E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=1, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, Q=0, U=1, o1=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_4_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, o1=0, o2=0, Q=0, sz=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_5_8800_0ea18800() {
    // Encoding: 0x0EA18800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=1, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, o2=1, U=0, sz=0, o1=0, Rn=0
    let encoding: u32 = 0x0EA18800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_6_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, o1=0, Rn=0, Q=0, Rd=0, o2=0, sz=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_7_8800_0e618800() {
    // Encoding: 0x0E618800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=1, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, sz=1, U=0, o2=0, o1=0
    let encoding: u32 = 0x0E618800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_8_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, sz=0, o1=0, Q=0, Rn=0, o2=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_9_8800_0e219800() {
    // Encoding: 0x0E219800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0, U=0, Q=0, o2=0, o1=1
    let encoding: u32 = 0x0E219800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_10_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, o2=0, sz=0, Q=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_11_8800_0e218820() {
    // Encoding: 0x0E218820
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=1, Rd=0
    // Fields: o2=0, U=0, o1=0, Rn=1, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x0E218820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_12_8800_0e218bc0() {
    // Encoding: 0x0E218BC0
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=30, Rd=0
    // Fields: o1=0, Rd=0, o2=0, sz=0, U=0, Rn=30, Q=0
    let encoding: u32 = 0x0E218BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_13_8800_0e218be0() {
    // Encoding: 0x0E218BE0
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=31, Rd=0
    // Fields: o1=0, Rn=31, o2=0, U=0, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x0E218BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_14_8800_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, Rd=0, U=0, sz=0, Q=0, o1=0, Rn=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_15_8800_0e218801() {
    // Encoding: 0x0E218801
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=1
    // Fields: Q=0, sz=0, U=0, Rn=0, Rd=1, o2=0, o1=0
    let encoding: u32 = 0x0E218801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_16_8800_0e21881e() {
    // Encoding: 0x0E21881E
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=30
    // Fields: Rd=30, o1=0, o2=0, U=0, sz=0, Rn=0, Q=0
    let encoding: u32 = 0x0E21881E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_17_8800_0e21881f() {
    // Encoding: 0x0E21881F
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=31
    // Fields: Rd=31, sz=0, o1=0, Rn=0, Q=0, o2=0, U=0
    let encoding: u32 = 0x0E21881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_18_8800_0e218821() {
    // Encoding: 0x0E218821
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=1, Rd=1
    // Fields: Rd=1, o1=0, Rn=1, U=0, Q=0, o2=0, sz=0
    let encoding: u32 = 0x0E218821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_combo_19_8800_0e218bff() {
    // Encoding: 0x0E218BFF
    // Test aarch64_vector_arithmetic_unary_float_round field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=31, Rd=31
    // Fields: o1=0, o2=0, sz=0, Rn=31, Rd=31, U=0, Q=0
    let encoding: u32 = 0x0E218BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_q_0_size_variant_0_34816_0e618800() {
    // Encoding: 0x0E618800
    // Test aarch64_vector_arithmetic_unary_float_round special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, U=0, Q=0, sz=1, o1=0, o2=0
    let encoding: u32 = 0x0E618800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_q_1_size_variant_1_34816_4e618800() {
    // Encoding: 0x4E618800
    // Test aarch64_vector_arithmetic_unary_float_round special value Q = 1 (Size variant 1)
    // Fields: U=0, Q=1, o2=0, sz=1, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E618800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_sz_0_size_variant_0_34816_0e218800() {
    // Encoding: 0x0E218800
    // Test aarch64_vector_arithmetic_unary_float_round special value sz = 0 (Size variant 0)
    // Fields: U=0, o1=0, Rn=0, Rd=0, Q=0, sz=0, o2=0
    let encoding: u32 = 0x0E218800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_sz_1_size_variant_1_34816_0e618800() {
    // Encoding: 0x0E618800
    // Test aarch64_vector_arithmetic_unary_float_round special value sz = 1 (Size variant 1)
    // Fields: Q=0, o1=0, Rn=0, Rd=0, U=0, o2=0, sz=1
    let encoding: u32 = 0x0E618800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_rn_31_stack_pointer_sp_may_require_alignment_34816_0e618be0() {
    // Encoding: 0x0E618BE0
    // Test aarch64_vector_arithmetic_unary_float_round special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: o1=0, o2=0, U=0, Q=0, sz=1, Rn=31, Rd=0
    let encoding: u32 = 0x0E618BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_34816_0e61881f() {
    // Encoding: 0x0E61881F
    // Test aarch64_vector_arithmetic_unary_float_round special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, sz=1, o2=0, Rn=0, Rd=31, o1=0, Q=0
    let encoding: u32 = 0x0E61881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_reg_write_0_0e798800() {
    // Test aarch64_vector_arithmetic_unary_fp16_round register write: SimdFromField("d")
    // Encoding: 0x0E798800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E798800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_sp_rn_0e798be0() {
    // Test aarch64_vector_arithmetic_unary_fp16_round with Rn = SP (31)
    // Encoding: 0x0E798BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E798BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_round
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_round_zr_rd_0e79881f() {
    // Test aarch64_vector_arithmetic_unary_fp16_round with Rd = ZR (31)
    // Encoding: 0x0E79881F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79881F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_reg_write_0_0e218800() {
    // Test aarch64_vector_arithmetic_unary_float_round register write: SimdFromField("d")
    // Encoding: 0x0E218800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E218800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_sp_rn_0e218be0() {
    // Test aarch64_vector_arithmetic_unary_float_round with Rn = SP (31)
    // Encoding: 0x0E218BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E218BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_zr_rd_0e21881f() {
    // Test aarch64_vector_arithmetic_unary_float_round with Rd = ZR (31)
    // Encoding: 0x0E21881F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21881F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_dotp Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_q_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Q = 0 (Min)
    // Fields: H=0, Rd=0, Rn=0, U=0, Q=0, L=0, Rm=0, M=0, size=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_q_1_max_e000_4f00e000() {
    // Encoding: 0x4F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Q = 1 (Max)
    // Fields: U=0, Rd=0, Rm=0, H=0, Rn=0, Q=1, L=0, size=0, M=0
    let encoding: u32 = 0x4F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_u_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field U = 0 (Min)
    // Fields: U=0, Rm=0, Q=0, L=0, H=0, M=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_u_1_max_e000_2f00e000() {
    // Encoding: 0x2F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field U = 1 (Max)
    // Fields: Q=0, size=0, Rd=0, U=1, Rn=0, Rm=0, L=0, H=0, M=0
    let encoding: u32 = 0x2F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_size_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field size = 0 (Min)
    // Fields: size=0, H=0, U=0, L=0, M=0, Rn=0, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_size_1_poweroftwo_e000_0f40e000() {
    // Encoding: 0x0F40E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field size = 1 (PowerOfTwo)
    // Fields: size=1, U=0, Rd=0, Rm=0, L=0, Rn=0, Q=0, H=0, M=0
    let encoding: u32 = 0x0F40E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_size_2_poweroftwo_e000_0f80e000() {
    // Encoding: 0x0F80E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field size = 2 (PowerOfTwo)
    // Fields: U=0, Rd=0, L=0, Q=0, H=0, size=2, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x0F80E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_size_3_max_e000_0fc0e000() {
    // Encoding: 0x0FC0E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field size = 3 (Max)
    // Fields: Q=0, U=0, L=0, H=0, size=3, M=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0FC0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_l_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field L = 0 (Min)
    // Fields: U=0, Rd=0, size=0, Rm=0, Q=0, M=0, L=0, Rn=0, H=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_l_1_max_e000_0f20e000() {
    // Encoding: 0x0F20E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field L = 1 (Max)
    // Fields: M=0, Rm=0, Rd=0, L=1, Rn=0, Q=0, size=0, U=0, H=0
    let encoding: u32 = 0x0F20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_m_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field M = 0 (Min)
    // Fields: Rd=0, L=0, U=0, Rm=0, size=0, M=0, Q=0, Rn=0, H=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_m_1_max_e000_0f10e000() {
    // Encoding: 0x0F10E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field M = 1 (Max)
    // Fields: Q=0, H=0, U=0, size=0, Rm=0, L=0, M=1, Rd=0, Rn=0
    let encoding: u32 = 0x0F10E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rm_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rm = 0 (Min)
    // Fields: Rm=0, Q=0, Rd=0, H=0, U=0, L=0, size=0, M=0, Rn=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rm_1_poweroftwo_e000_0f01e000() {
    // Encoding: 0x0F01E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, L=0, H=0, U=0, size=0, Rm=1, Q=0, M=0
    let encoding: u32 = 0x0F01E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_h_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field H = 0 (Min)
    // Fields: Rm=0, size=0, Q=0, H=0, U=0, L=0, M=0, Rd=0, Rn=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_h_1_max_e000_0f00e800() {
    // Encoding: 0x0F00E800
    // Test aarch64_vector_arithmetic_binary_element_dotp field H = 1 (Max)
    // Fields: Q=0, H=1, M=0, size=0, Rn=0, Rm=0, Rd=0, U=0, L=0
    let encoding: u32 = 0x0F00E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rn_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rn = 0 (Min)
    // Fields: H=0, size=0, L=0, M=0, Rn=0, Rm=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rn_1_poweroftwo_e000_0f00e020() {
    // Encoding: 0x0F00E020
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, L=0, Q=0, M=0, size=0, H=0, U=0, Rm=0
    let encoding: u32 = 0x0F00E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rn_30_poweroftwominusone_e000_0f00e3c0() {
    // Encoding: 0x0F00E3C0
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, M=0, H=0, size=0, Q=0, L=0, U=0, Rd=0, Rn=30
    let encoding: u32 = 0x0F00E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rn_31_max_e000_0f00e3e0() {
    // Encoding: 0x0F00E3E0
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rn = 31 (Max)
    // Fields: Q=0, U=0, L=0, M=0, H=0, Rm=0, Rn=31, Rd=0, size=0
    let encoding: u32 = 0x0F00E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rd_0_min_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rd = 0 (Min)
    // Fields: U=0, H=0, size=0, Q=0, M=0, Rn=0, Rd=0, Rm=0, L=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rd_1_poweroftwo_e000_0f00e001() {
    // Encoding: 0x0F00E001
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rd = 1 (PowerOfTwo)
    // Fields: M=0, size=0, Rm=0, H=0, Rd=1, U=0, Q=0, L=0, Rn=0
    let encoding: u32 = 0x0F00E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rd_30_poweroftwominusone_e000_0f00e01e() {
    // Encoding: 0x0F00E01E
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: L=0, Rm=0, M=0, Rn=0, H=0, Rd=30, Q=0, size=0, U=0
    let encoding: u32 = 0x0F00E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_field_rd_31_max_e000_0f00e01f() {
    // Encoding: 0x0F00E01F
    // Test aarch64_vector_arithmetic_binary_element_dotp field Rd = 31 (Max)
    // Fields: M=0, Rm=0, H=0, L=0, Rn=0, Rd=31, Q=0, U=0, size=0
    let encoding: u32 = 0x0F00E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_0_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, L=0, U=0, size=0, M=0, Rm=0, H=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_1_e000_4f00e000() {
    // Encoding: 0x4F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=1, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, Rm=0, H=0, Rd=0, L=0, Rn=0, U=0, M=0, Q=1
    let encoding: u32 = 0x4F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_2_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: U=0, Q=0, size=0, H=0, M=0, Rd=0, Rm=0, L=0, Rn=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_3_e000_2f00e000() {
    // Encoding: 0x2F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=1, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, U=1, H=0, L=0, M=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x2F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_4_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, U=0, H=0, Rd=0, Q=0, size=0, L=0, Rn=0, M=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_5_e000_0f40e000() {
    // Encoding: 0x0F40E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=1, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rn=0, size=1, L=0, Q=0, U=0, H=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x0F40E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_6_e000_0f80e000() {
    // Encoding: 0x0F80E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=2, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: U=0, size=2, Rm=0, L=0, Rd=0, Rn=0, Q=0, H=0, M=0
    let encoding: u32 = 0x0F80E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_7_e000_0fc0e000() {
    // Encoding: 0x0FC0E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=3, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, H=0, L=0, size=3, M=0, Rd=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0FC0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// L=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_8_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, size=0, Q=0, H=0, U=0, L=0, M=0, Rd=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// L=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_9_e000_0f20e000() {
    // Encoding: 0x0F20E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=1, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: U=0, size=0, Q=0, Rn=0, L=1, M=0, H=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_10_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: H=0, Rn=0, Rd=0, U=0, L=0, Rm=0, size=0, M=0, Q=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// M=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_11_e000_0f10e000() {
    // Encoding: 0x0F10E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=1, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, U=0, Q=0, M=1, L=0, Rm=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F10E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_12_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Rn=0, H=0, Q=0, size=0, U=0, M=0, Rm=0, Rd=0, L=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_13_e000_0f01e000() {
    // Encoding: 0x0F01E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=1, H=0, Rn=0, Rd=0
    // Fields: U=0, Q=0, Rm=1, M=0, L=0, Rn=0, H=0, size=0, Rd=0
    let encoding: u32 = 0x0F01E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// H=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_14_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, Rm=0, Rn=0, U=0, M=0, Rd=0, H=0, L=0, Q=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// H=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_15_e000_0f00e800() {
    // Encoding: 0x0F00E800
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=1, Rn=0, Rd=0
    // Fields: Rm=0, U=0, M=0, size=0, H=1, Rn=0, L=0, Rd=0, Q=0
    let encoding: u32 = 0x0F00E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_16_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, L=0, Rm=0, Q=0, Rn=0, M=0, H=0, U=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_17_e000_0f00e020() {
    // Encoding: 0x0F00E020
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=1, Rd=0
    // Fields: size=0, H=0, L=0, U=0, Q=0, Rn=1, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x0F00E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_18_e000_0f00e3c0() {
    // Encoding: 0x0F00E3C0
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=30, Rd=0
    // Fields: U=0, Rd=0, H=0, Rn=30, L=0, M=0, Q=0, size=0, Rm=0
    let encoding: u32 = 0x0F00E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_19_e000_0f00e3e0() {
    // Encoding: 0x0F00E3E0
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=31, Rd=0
    // Fields: Rd=0, H=0, M=0, U=0, Q=0, Rn=31, L=0, Rm=0, size=0
    let encoding: u32 = 0x0F00E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_20_e000_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Q=0, L=0, U=0, M=0, Rm=0, H=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_21_e000_0f00e001() {
    // Encoding: 0x0F00E001
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, Rd=1, size=0, L=0, H=0, Q=0, M=0, Rm=0
    let encoding: u32 = 0x0F00E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_22_e000_0f00e01e() {
    // Encoding: 0x0F00E01E
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=30
    // Fields: L=0, size=0, Rd=30, M=0, H=0, Rm=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0F00E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_23_e000_0f00e01f() {
    // Encoding: 0x0F00E01F
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=31
    // Fields: M=0, Rm=0, H=0, Rn=0, Q=0, size=0, Rd=31, U=0, L=0
    let encoding: u32 = 0x0F00E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_24_e000_0f01e020() {
    // Encoding: 0x0F01E020
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=1, H=0, Rn=1, Rd=0
    // Fields: H=0, Rd=0, L=0, M=0, Rn=1, Rm=1, U=0, Q=0, size=0
    let encoding: u32 = 0x0F01E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_25_e000_0f0fe3e0() {
    // Encoding: 0x0F0FE3E0
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=31, H=0, Rn=31, Rd=0
    // Fields: Rd=0, H=0, M=0, L=0, Rm=31, Q=0, U=0, Rn=31, size=0
    let encoding: u32 = 0x0F0FE3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_26_e000_0f01e001() {
    // Encoding: 0x0F01E001
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=1, H=0, Rn=0, Rd=1
    // Fields: Rn=0, U=0, H=0, M=0, L=0, size=0, Rd=1, Rm=1, Q=0
    let encoding: u32 = 0x0F01E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_27_e000_0f0fe01f() {
    // Encoding: 0x0F0FE01F
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=31, H=0, Rn=0, Rd=31
    // Fields: Rm=31, Rd=31, M=0, L=0, U=0, H=0, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0F0FE01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 28`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_28_e000_0f00e021() {
    // Encoding: 0x0F00E021
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=1, Rd=1
    // Fields: U=0, L=0, H=0, Q=0, Rd=1, M=0, size=0, Rm=0, Rn=1
    let encoding: u32 = 0x0F00E021;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field combination 29`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_combo_29_e000_0f00e3ff() {
    // Encoding: 0x0F00E3FF
    // Test aarch64_vector_arithmetic_binary_element_dotp field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=31, Rd=31
    // Fields: Rm=0, H=0, Q=0, M=0, Rn=31, Rd=31, L=0, U=0, size=0
    let encoding: u32 = 0x0F00E3FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_q_0_size_variant_0_57344_0f40e000() {
    // Encoding: 0x0F40E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value Q = 0 (Size variant 0)
    // Fields: L=0, Rn=0, size=1, Rd=0, Rm=0, Q=0, H=0, M=0, U=0
    let encoding: u32 = 0x0F40E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_q_1_size_variant_1_57344_4f40e000() {
    // Encoding: 0x4F40E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, U=0, Rm=0, Q=1, L=0, H=0, M=0, size=1
    let encoding: u32 = 0x4F40E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_size_0_size_variant_0_57344_0f00e000() {
    // Encoding: 0x0F00E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value size = 0 (Size variant 0)
    // Fields: H=0, size=0, Rn=0, U=0, Rm=0, Rd=0, L=0, Q=0, M=0
    let encoding: u32 = 0x0F00E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_size_1_size_variant_1_57344_0f40e000() {
    // Encoding: 0x0F40E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value size = 1 (Size variant 1)
    // Fields: Rd=0, Q=0, U=0, M=0, H=0, L=0, size=1, Rm=0, Rn=0
    let encoding: u32 = 0x0F40E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_size_2_size_variant_2_57344_0f80e000() {
    // Encoding: 0x0F80E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value size = 2 (Size variant 2)
    // Fields: U=0, Q=0, Rn=0, Rm=0, L=0, Rd=0, M=0, H=0, size=2
    let encoding: u32 = 0x0F80E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_size_3_size_variant_3_57344_0fc0e000() {
    // Encoding: 0x0FC0E000
    // Test aarch64_vector_arithmetic_binary_element_dotp special value size = 3 (Size variant 3)
    // Fields: M=0, U=0, size=3, Q=0, H=0, L=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0FC0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_rn_31_stack_pointer_sp_may_require_alignment_57344_0f40e3e0() {
    // Encoding: 0x0F40E3E0
    // Test aarch64_vector_arithmetic_binary_element_dotp special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rd=0, size=1, M=0, Rm=0, Q=0, L=0, H=0, Rn=31
    let encoding: u32 = 0x0F40E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_0f40e01f() {
    // Encoding: 0x0F40E01F
    // Test aarch64_vector_arithmetic_binary_element_dotp special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, Rn=0, size=1, Rm=0, Q=0, Rd=31, H=0, L=0, M=0
    let encoding: u32 = 0x0F40E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_reg_write_0_0f00e000() {
    // Test aarch64_vector_arithmetic_binary_element_dotp register write: SimdFromField("d")
    // Encoding: 0x0F00E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_sp_rn_0f00e3e0() {
    // Test aarch64_vector_arithmetic_binary_element_dotp with Rn = SP (31)
    // Encoding: 0x0F00E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_dotp
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_dotp_zr_rd_0f00e01f() {
    // Test aarch64_vector_arithmetic_binary_element_dotp with Rd = ZR (31)
    // Encoding: 0x0F00E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rn_0_min_d800_7ef9d800() {
    // Encoding: 0x7EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x7EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rn_1_poweroftwo_d800_7ef9d820() {
    // Encoding: 0x7EF9D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1
    let encoding: u32 = 0x7EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rn_30_poweroftwominusone_d800_7ef9dbc0() {
    // Encoding: 0x7EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=30
    let encoding: u32 = 0x7EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rn_31_max_d800_7ef9dbe0() {
    // Encoding: 0x7EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rn = 31 (Max)
    // Fields: Rd=0, Rn=31
    let encoding: u32 = 0x7EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rd_0_min_d800_7ef9d800() {
    // Encoding: 0x7EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rd = 0 (Min)
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x7EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rd_1_poweroftwo_d800_7ef9d801() {
    // Encoding: 0x7EF9D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1
    let encoding: u32 = 0x7EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rd_30_poweroftwominusone_d800_7ef9d81e() {
    // Encoding: 0x7EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30
    let encoding: u32 = 0x7EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_field_rd_31_max_d800_7ef9d81f() {
    // Encoding: 0x7EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field Rd = 31 (Max)
    // Fields: Rd=31, Rn=0
    let encoding: u32 = 0x7EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_0_d800_7ef9d800() {
    // Encoding: 0x7EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=0, Rd=0
    // Fields: Rn=0, Rd=0
    let encoding: u32 = 0x7EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_1_d800_7ef9d820() {
    // Encoding: 0x7EF9D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=1, Rd=0
    // Fields: Rn=1, Rd=0
    let encoding: u32 = 0x7EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_2_d800_7ef9dbc0() {
    // Encoding: 0x7EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=30, Rd=0
    // Fields: Rd=0, Rn=30
    let encoding: u32 = 0x7EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_3_d800_7ef9dbe0() {
    // Encoding: 0x7EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=31, Rd=0
    // Fields: Rd=0, Rn=31
    let encoding: u32 = 0x7EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_4_d800_7ef9d800() {
    // Encoding: 0x7EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=0, Rd=0
    // Fields: Rn=0, Rd=0
    let encoding: u32 = 0x7EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_5_d800_7ef9d801() {
    // Encoding: 0x7EF9D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=0, Rd=1
    // Fields: Rn=0, Rd=1
    let encoding: u32 = 0x7EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_6_d800_7ef9d81e() {
    // Encoding: 0x7EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=0, Rd=30
    // Fields: Rn=0, Rd=30
    let encoding: u32 = 0x7EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_7_d800_7ef9d81f() {
    // Encoding: 0x7EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=0, Rd=31
    // Fields: Rd=31, Rn=0
    let encoding: u32 = 0x7EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_8_d800_7ef9d821() {
    // Encoding: 0x7EF9D821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=1, Rd=1
    // Fields: Rn=1, Rd=1
    let encoding: u32 = 0x7EF9D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_combo_9_d800_7ef9dbff() {
    // Encoding: 0x7EF9DBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd field combination: Rn=31, Rd=31
    // Fields: Rd=31, Rn=31
    let encoding: u32 = 0x7EF9DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_7ef9dbe0() {
    // Encoding: 0x7EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0
    let encoding: u32 = 0x7EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_7ef9d81f() {
    // Encoding: 0x7EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31
    let encoding: u32 = 0x7EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_sz_0_min_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field sz = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_sz_1_max_d800_7ee1d800() {
    // Encoding: 0x7EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, sz=1
    let encoding: u32 = 0x7EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rn_0_min_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rn = 0 (Min)
    // Fields: sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rn_1_poweroftwo_d800_7ea1d820() {
    // Encoding: 0x7EA1D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x7EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rn_30_poweroftwominusone_d800_7ea1dbc0() {
    // Encoding: 0x7EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x7EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rn_31_max_d800_7ea1dbe0() {
    // Encoding: 0x7EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rn = 31 (Max)
    // Fields: Rn=31, sz=0, Rd=0
    let encoding: u32 = 0x7EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rd_0_min_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rd = 0 (Min)
    // Fields: sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rd_1_poweroftwo_d800_7ea1d801() {
    // Encoding: 0x7EA1D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x7EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rd_30_poweroftwominusone_d800_7ea1d81e() {
    // Encoding: 0x7EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=30, Rn=0
    let encoding: u32 = 0x7EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_field_rd_31_max_d800_7ea1d81f() {
    // Encoding: 0x7EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field Rd = 31 (Max)
    // Fields: Rd=31, sz=0, Rn=0
    let encoding: u32 = 0x7EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_0_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_1_d800_7ee1d800() {
    // Encoding: 0x7EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=1, Rn=0, Rd=0
    // Fields: sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x7EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_2_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_3_d800_7ea1d820() {
    // Encoding: 0x7EA1D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x7EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_4_d800_7ea1dbc0() {
    // Encoding: 0x7EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, sz=0
    let encoding: u32 = 0x7EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_5_d800_7ea1dbe0() {
    // Encoding: 0x7EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=31, Rd=0
    // Fields: sz=0, Rd=0, Rn=31
    let encoding: u32 = 0x7EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_6_d800_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_7_d800_7ea1d801() {
    // Encoding: 0x7EA1D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=1
    // Fields: Rd=1, sz=0, Rn=0
    let encoding: u32 = 0x7EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_8_d800_7ea1d81e() {
    // Encoding: 0x7EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rn=0, Rd=30
    let encoding: u32 = 0x7EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_9_d800_7ea1d81f() {
    // Encoding: 0x7EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=0, Rd=31
    // Fields: sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x7EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_10_d800_7ea1d821() {
    // Encoding: 0x7EA1D821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rn=1, Rd=1
    let encoding: u32 = 0x7EA1D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_combo_11_d800_7ea1dbff() {
    // Encoding: 0x7EA1DBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd field combination: sz=0, Rn=31, Rd=31
    // Fields: sz=0, Rd=31, Rn=31
    let encoding: u32 = 0x7EA1DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_special_sz_0_size_variant_0_55296_7ea1d800() {
    // Encoding: 0x7EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd special value sz = 0 (Size variant 0)
    // Fields: Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x7EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_special_sz_1_size_variant_1_55296_7ee1d800() {
    // Encoding: 0x7EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x7EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_7ee1dbe0() {
    // Encoding: 0x7EE1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, Rn=31, Rd=0
    let encoding: u32 = 0x7EE1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_7ee1d81f() {
    // Encoding: 0x7EE1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rn=0, sz=1
    let encoding: u32 = 0x7EE1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_q_0_min_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_q_1_max_d800_6ef9d800() {
    // Encoding: 0x6EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Q = 1 (Max)
    // Fields: Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x6EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rn_0_min_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rn = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rn_1_poweroftwo_d800_2ef9d820() {
    // Encoding: 0x2EF9D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Q=0
    let encoding: u32 = 0x2EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rn_30_poweroftwominusone_d800_2ef9dbc0() {
    // Encoding: 0x2EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rn_31_max_d800_2ef9dbe0() {
    // Encoding: 0x2EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x2EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rd_0_min_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rd_1_poweroftwo_d800_2ef9d801() {
    // Encoding: 0x2EF9D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rd=1
    let encoding: u32 = 0x2EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rd_30_poweroftwominusone_d800_2ef9d81e() {
    // Encoding: 0x2EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_field_rd_31_max_d800_2ef9d81f() {
    // Encoding: 0x2EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x2EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_0_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_1_d800_6ef9d800() {
    // Encoding: 0x6EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x6EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_2_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_3_d800_2ef9d820() {
    // Encoding: 0x2EF9D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=1, Rd=0
    // Fields: Rn=1, Rd=0, Q=0
    let encoding: u32 = 0x2EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_4_d800_2ef9dbc0() {
    // Encoding: 0x2EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_5_d800_2ef9dbe0() {
    // Encoding: 0x2EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x2EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_6_d800_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_7_d800_2ef9d801() {
    // Encoding: 0x2EF9D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x2EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_8_d800_2ef9d81e() {
    // Encoding: 0x2EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=30
    // Fields: Q=0, Rd=30, Rn=0
    let encoding: u32 = 0x2EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_9_d800_2ef9d81f() {
    // Encoding: 0x2EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x2EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_10_d800_2ef9d821() {
    // Encoding: 0x2EF9D821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=1, Rd=1
    // Fields: Rn=1, Rd=1, Q=0
    let encoding: u32 = 0x2EF9D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_combo_11_d800_2ef9dbff() {
    // Encoding: 0x2EF9DBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd field combination: Q=0, Rn=31, Rd=31
    // Fields: Rn=31, Q=0, Rd=31
    let encoding: u32 = 0x2EF9DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_special_q_0_size_variant_0_55296_2ef9d800() {
    // Encoding: 0x2EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_special_q_1_size_variant_1_55296_6ef9d800() {
    // Encoding: 0x6EF9D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x6EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_2ef9dbe0() {
    // Encoding: 0x2EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, Rn=31
    let encoding: u32 = 0x2EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_2ef9d81f() {
    // Encoding: 0x2EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x2EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_q_0_min_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Q = 0 (Min)
    // Fields: Rn=0, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_q_1_max_d800_6ea1d800() {
    // Encoding: 0x6EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Q = 1 (Max)
    // Fields: sz=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x6EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_sz_0_min_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field sz = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_sz_1_max_d800_2ee1d800() {
    // Encoding: 0x2EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field sz = 1 (Max)
    // Fields: sz=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rn_0_min_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rn = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rn_1_poweroftwo_d800_2ea1d820() {
    // Encoding: 0x2EA1D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rn_30_poweroftwominusone_d800_2ea1dbc0() {
    // Encoding: 0x2EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x2EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rn_31_max_d800_2ea1dbe0() {
    // Encoding: 0x2EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rn = 31 (Max)
    // Fields: Q=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x2EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rd_0_min_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rd = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0, sz=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rd_1_poweroftwo_d800_2ea1d801() {
    // Encoding: 0x2EA1D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x2EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rd_30_poweroftwominusone_d800_2ea1d81e() {
    // Encoding: 0x2EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, sz=0, Rd=30
    let encoding: u32 = 0x2EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_field_rd_31_max_d800_2ea1d81f() {
    // Encoding: 0x2EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field Rd = 31 (Max)
    // Fields: Q=0, sz=0, Rd=31, Rn=0
    let encoding: u32 = 0x2EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_0_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_1_d800_6ea1d800() {
    // Encoding: 0x6EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Q=1, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x6EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_2_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_3_d800_2ee1d800() {
    // Encoding: 0x2EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Q=0, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x2EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_4_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_5_d800_2ea1d820() {
    // Encoding: 0x2EA1D820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Rn=1, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x2EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_6_d800_2ea1dbc0() {
    // Encoding: 0x2EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=30
    let encoding: u32 = 0x2EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_7_d800_2ea1dbe0() {
    // Encoding: 0x2EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Q=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x2EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_8_d800_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_9_d800_2ea1d801() {
    // Encoding: 0x2EA1D801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: sz=0, Q=0, Rd=1, Rn=0
    let encoding: u32 = 0x2EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_10_d800_2ea1d81e() {
    // Encoding: 0x2EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: Rn=0, Q=0, sz=0, Rd=30
    let encoding: u32 = 0x2EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_11_d800_2ea1d81f() {
    // Encoding: 0x2EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: sz=0, Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x2EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_12_d800_2ea1d821() {
    // Encoding: 0x2EA1D821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rd=1, Q=0, Rn=1
    let encoding: u32 = 0x2EA1D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_combo_13_d800_2ea1dbff() {
    // Encoding: 0x2EA1DBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Q=0, Rd=31, sz=0, Rn=31
    let encoding: u32 = 0x2EA1DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_q_0_size_variant_0_55296_2ee1d800() {
    // Encoding: 0x2EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0, sz=1
    let encoding: u32 = 0x2EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_q_1_size_variant_1_55296_6ee1d800() {
    // Encoding: 0x6EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Q=1, sz=1, Rn=0
    let encoding: u32 = 0x6EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_sz_0_size_variant_0_55296_2ea1d800() {
    // Encoding: 0x2EA1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value sz = 0 (Size variant 0)
    // Fields: Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_sz_1_size_variant_1_55296_2ee1d800() {
    // Encoding: 0x2EE1D800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x2EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_2ee1dbe0() {
    // Encoding: 0x2EE1DBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, sz=1, Rn=31, Rd=0
    let encoding: u32 = 0x2EE1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_2ee1d81f() {
    // Encoding: 0x2EE1D81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x2EE1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_reg_write_0_7ef9d800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x7EF9D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EF9D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_sp_rn_7ef9dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd with Rn = SP (31)
    // Encoding: 0x7EF9DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EF9DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd_zr_rd_7ef9d81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x7EF9D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EF9D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_reg_write_0_7ea1d800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd register write: SimdFromField("d")
    // Encoding: 0x7EA1D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EA1D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_sp_rn_7ea1dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd with Rn = SP (31)
    // Encoding: 0x7EA1DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EA1DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd_zr_rd_7ea1d81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_sisd with Rd = ZR (31)
    // Encoding: 0x7EA1D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7EA1D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_reg_write_0_2ef9d800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x2EF9D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_sp_rn_2ef9dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd with Rn = SP (31)
    // Encoding: 0x2EF9DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd_zr_rd_2ef9d81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_fp16_simd with Rd = ZR (31)
    // Encoding: 0x2EF9D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_reg_write_0_2ea1d800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd register write: SimdFromField("d")
    // Encoding: 0x2EA1D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_sp_rn_2ea1dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd with Rn = SP (31)
    // Encoding: 0x2EA1DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd_zr_rd_2ea1d81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_float_simd with Rd = ZR (31)
    // Encoding: 0x2EA1D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_clsz Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_q_0_min_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field Q = 0 (Min)
    // Fields: Rn=0, size=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_q_1_max_4800_4e204800() {
    // Encoding: 0x4E204800
    // Test aarch64_vector_arithmetic_unary_clsz field Q = 1 (Max)
    // Fields: Q=1, U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_u_0_min_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field U = 0 (Min)
    // Fields: size=0, Q=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_u_1_max_4800_2e204800() {
    // Encoding: 0x2E204800
    // Test aarch64_vector_arithmetic_unary_clsz field U = 1 (Max)
    // Fields: Q=0, Rn=0, size=0, Rd=0, U=1
    let encoding: u32 = 0x2E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_size_0_min_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field size = 0 (Min)
    // Fields: U=0, Rd=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_size_1_poweroftwo_4800_0e604800() {
    // Encoding: 0x0E604800
    // Test aarch64_vector_arithmetic_unary_clsz field size = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, size=1, Rd=0, Q=0
    let encoding: u32 = 0x0E604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_size_2_poweroftwo_4800_0ea04800() {
    // Encoding: 0x0EA04800
    // Test aarch64_vector_arithmetic_unary_clsz field size = 2 (PowerOfTwo)
    // Fields: Q=0, U=0, size=2, Rn=0, Rd=0
    let encoding: u32 = 0x0EA04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_size_3_max_4800_0ee04800() {
    // Encoding: 0x0EE04800
    // Test aarch64_vector_arithmetic_unary_clsz field size = 3 (Max)
    // Fields: Rd=0, size=3, Rn=0, U=0, Q=0
    let encoding: u32 = 0x0EE04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rn_0_min_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field Rn = 0 (Min)
    // Fields: Q=0, Rn=0, U=0, Rd=0, size=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rn_1_poweroftwo_4800_0e204820() {
    // Encoding: 0x0E204820
    // Test aarch64_vector_arithmetic_unary_clsz field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rd=0, Q=0, Rn=1, U=0
    let encoding: u32 = 0x0E204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rn_30_poweroftwominusone_4800_0e204bc0() {
    // Encoding: 0x0E204BC0
    // Test aarch64_vector_arithmetic_unary_clsz field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E204BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rn_31_max_4800_0e204be0() {
    // Encoding: 0x0E204BE0
    // Test aarch64_vector_arithmetic_unary_clsz field Rn = 31 (Max)
    // Fields: U=0, size=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E204BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rd_0_min_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field Rd = 0 (Min)
    // Fields: Q=0, U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rd_1_poweroftwo_4800_0e204801() {
    // Encoding: 0x0E204801
    // Test aarch64_vector_arithmetic_unary_clsz field Rd = 1 (PowerOfTwo)
    // Fields: U=0, size=0, Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x0E204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rd_30_poweroftwominusone_4800_0e20481e() {
    // Encoding: 0x0E20481E
    // Test aarch64_vector_arithmetic_unary_clsz field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rd=30, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E20481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_field_rd_31_max_4800_0e20481f() {
    // Encoding: 0x0E20481F
    // Test aarch64_vector_arithmetic_unary_clsz field Rd = 31 (Max)
    // Fields: Rd=31, size=0, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E20481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_0_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_1_4800_4e204800() {
    // Encoding: 0x4E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=1, U=0, size=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Rd=0, Q=1, size=0
    let encoding: u32 = 0x4E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_2_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_3_4800_2e204800() {
    // Encoding: 0x2E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=1, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Q=0, U=1, Rn=0
    let encoding: u32 = 0x2E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_4_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=0, Rn=0, U=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_5_4800_0e604800() {
    // Encoding: 0x0E604800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=1, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Q=0, Rd=0, size=1
    let encoding: u32 = 0x0E604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_6_4800_0ea04800() {
    // Encoding: 0x0EA04800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=2, Rn=0, Rd=0
    // Fields: U=0, Q=0, size=2, Rn=0, Rd=0
    let encoding: u32 = 0x0EA04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_7_4800_0ee04800() {
    // Encoding: 0x0EE04800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=3, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rn=0, Rd=0, size=3
    let encoding: u32 = 0x0EE04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_8_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: U=0, Q=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_9_4800_0e204820() {
    // Encoding: 0x0E204820
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=1, Rd=0
    // Fields: Rn=1, Q=0, Rd=0, size=0, U=0
    let encoding: u32 = 0x0E204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_10_4800_0e204bc0() {
    // Encoding: 0x0E204BC0
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=30, Rd=0
    // Fields: Q=0, U=0, Rd=0, Rn=30, size=0
    let encoding: u32 = 0x0E204BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_11_4800_0e204be0() {
    // Encoding: 0x0E204BE0
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=31, Rd=0
    // Fields: Rd=0, U=0, size=0, Q=0, Rn=31
    let encoding: u32 = 0x0E204BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_12_4800_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0, size=0, Q=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_13_4800_0e204801() {
    // Encoding: 0x0E204801
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=1
    // Fields: Q=0, Rn=0, size=0, Rd=1, U=0
    let encoding: u32 = 0x0E204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_14_4800_0e20481e() {
    // Encoding: 0x0E20481E
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=30
    // Fields: Q=0, U=0, Rn=0, Rd=30, size=0
    let encoding: u32 = 0x0E20481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_15_4800_0e20481f() {
    // Encoding: 0x0E20481F
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=0, Rd=31
    // Fields: Rn=0, Q=0, U=0, Rd=31, size=0
    let encoding: u32 = 0x0E20481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_16_4800_0e204821() {
    // Encoding: 0x0E204821
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, size=0, Rd=1, U=0, Q=0
    let encoding: u32 = 0x0E204821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_combo_17_4800_0e204bff() {
    // Encoding: 0x0E204BFF
    // Test aarch64_vector_arithmetic_unary_clsz field combination: Q=0, U=0, size=0, Rn=31, Rd=31
    // Fields: Q=0, U=0, size=0, Rn=31, Rd=31
    let encoding: u32 = 0x0E204BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_q_0_size_variant_0_18432_0e604800() {
    // Encoding: 0x0E604800
    // Test aarch64_vector_arithmetic_unary_clsz special value Q = 0 (Size variant 0)
    // Fields: U=0, size=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_q_1_size_variant_1_18432_4e604800() {
    // Encoding: 0x4E604800
    // Test aarch64_vector_arithmetic_unary_clsz special value Q = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Rd=0, Q=1, U=0
    let encoding: u32 = 0x4E604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_size_0_size_variant_0_18432_0e204800() {
    // Encoding: 0x0E204800
    // Test aarch64_vector_arithmetic_unary_clsz special value size = 0 (Size variant 0)
    // Fields: U=0, Rn=0, Rd=0, size=0, Q=0
    let encoding: u32 = 0x0E204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_size_1_size_variant_1_18432_0e604800() {
    // Encoding: 0x0E604800
    // Test aarch64_vector_arithmetic_unary_clsz special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_size_2_size_variant_2_18432_0ea04800() {
    // Encoding: 0x0EA04800
    // Test aarch64_vector_arithmetic_unary_clsz special value size = 2 (Size variant 2)
    // Fields: U=0, Rd=0, size=2, Q=0, Rn=0
    let encoding: u32 = 0x0EA04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_size_3_size_variant_3_18432_0ee04800() {
    // Encoding: 0x0EE04800
    // Test aarch64_vector_arithmetic_unary_clsz special value size = 3 (Size variant 3)
    // Fields: U=0, Q=0, size=3, Rn=0, Rd=0
    let encoding: u32 = 0x0EE04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_rn_31_stack_pointer_sp_may_require_alignment_18432_0e604be0() {
    // Encoding: 0x0E604BE0
    // Test aarch64_vector_arithmetic_unary_clsz special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rn=31, Rd=0, size=1, U=0
    let encoding: u32 = 0x0E604BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_18432_0e60481f() {
    // Encoding: 0x0E60481F
    // Test aarch64_vector_arithmetic_unary_clsz special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, Q=0, Rn=0, Rd=31, size=1
    let encoding: u32 = 0x0E60481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_reg_write_0_0e204800() {
    // Test aarch64_vector_arithmetic_unary_clsz register write: SimdFromField("d")
    // Encoding: 0x0E204800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E204800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_sp_rn_0e204be0() {
    // Test aarch64_vector_arithmetic_unary_clsz with Rn = SP (31)
    // Encoding: 0x0E204BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E204BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_clsz
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_clsz_zr_rd_0e20481f() {
    // Test aarch64_vector_arithmetic_unary_clsz with Rd = ZR (31)
    // Encoding: 0x0E20481F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20481F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_float_xtn_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_sz_0_min_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field sz = 0 (Min)
    // Fields: Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_sz_1_max_6800_7e616800() {
    // Encoding: 0x7E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, sz=1
    let encoding: u32 = 0x7E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rn_0_min_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rn = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rn_1_poweroftwo_6800_7e216820() {
    // Encoding: 0x7E216820
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, sz=0, Rn=1
    let encoding: u32 = 0x7E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rn_30_poweroftwominusone_6800_7e216bc0() {
    // Encoding: 0x7E216BC0
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x7E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rn_31_max_6800_7e216be0() {
    // Encoding: 0x7E216BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, sz=0
    let encoding: u32 = 0x7E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rd_0_min_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rd = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rd_1_poweroftwo_6800_7e216801() {
    // Encoding: 0x7E216801
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, sz=0
    let encoding: u32 = 0x7E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rd_30_poweroftwominusone_6800_7e21681e() {
    // Encoding: 0x7E21681E
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, sz=0, Rn=0
    let encoding: u32 = 0x7E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_field_rd_31_max_6800_7e21681f() {
    // Encoding: 0x7E21681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field Rd = 31 (Max)
    // Fields: Rn=0, sz=0, Rd=31
    let encoding: u32 = 0x7E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_0_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_1_6800_7e616800() {
    // Encoding: 0x7E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=1, Rn=0, Rd=0
    // Fields: sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x7E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_2_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_3_6800_7e216820() {
    // Encoding: 0x7E216820
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x7E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_4_6800_7e216bc0() {
    // Encoding: 0x7E216BC0
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=30, Rd=0
    // Fields: sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x7E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_5_6800_7e216be0() {
    // Encoding: 0x7E216BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=31, Rd=0
    // Fields: sz=0, Rd=0, Rn=31
    let encoding: u32 = 0x7E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_6_6800_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_7_6800_7e216801() {
    // Encoding: 0x7E216801
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=1
    // Fields: Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x7E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_8_6800_7e21681e() {
    // Encoding: 0x7E21681E
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rd=30, Rn=0
    let encoding: u32 = 0x7E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_9_6800_7e21681f() {
    // Encoding: 0x7E21681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=0, Rd=31
    // Fields: Rd=31, Rn=0, sz=0
    let encoding: u32 = 0x7E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_10_6800_7e216821() {
    // Encoding: 0x7E216821
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rd=1, Rn=1
    let encoding: u32 = 0x7E216821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_combo_11_6800_7e216bff() {
    // Encoding: 0x7E216BFF
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd field combination: sz=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, sz=0
    let encoding: u32 = 0x7E216BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_special_sz_0_size_variant_0_26624_7e216800() {
    // Encoding: 0x7E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd special value sz = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x7E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_special_sz_1_size_variant_1_26624_7e616800() {
    // Encoding: 0x7E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd special value sz = 1 (Size variant 1)
    // Fields: Rn=0, sz=1, Rd=0
    let encoding: u32 = 0x7E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_26624_7e616be0() {
    // Encoding: 0x7E616BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, sz=1, Rn=31
    let encoding: u32 = 0x7E616BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_26624_7e61681f() {
    // Encoding: 0x7E61681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Rn=0, Rd=31
    let encoding: u32 = 0x7E61681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_q_0_min_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Q = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_q_1_max_6800_6e216800() {
    // Encoding: 0x6E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Q = 1 (Max)
    // Fields: Rd=0, Rn=0, Q=1, sz=0
    let encoding: u32 = 0x6E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_sz_0_min_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field sz = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_sz_1_max_6800_2e616800() {
    // Encoding: 0x2E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, sz=1, Q=0
    let encoding: u32 = 0x2E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rn_0_min_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rn_1_poweroftwo_6800_2e216820() {
    // Encoding: 0x2E216820
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x2E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rn_30_poweroftwominusone_6800_2e216bc0() {
    // Encoding: 0x2E216BC0
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x2E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rn_31_max_6800_2e216be0() {
    // Encoding: 0x2E216BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rn = 31 (Max)
    // Fields: Q=0, sz=0, Rd=0, Rn=31
    let encoding: u32 = 0x2E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rd_0_min_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rd_1_poweroftwo_6800_2e216801() {
    // Encoding: 0x2E216801
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rd_30_poweroftwominusone_6800_2e21681e() {
    // Encoding: 0x2E21681E
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_field_rd_31_max_6800_2e21681f() {
    // Encoding: 0x2E21681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field Rd = 31 (Max)
    // Fields: Rn=0, Q=0, sz=0, Rd=31
    let encoding: u32 = 0x2E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_0_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_1_6800_6e216800() {
    // Encoding: 0x6E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Rd=0, Q=1
    let encoding: u32 = 0x6E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_2_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_3_6800_2e616800() {
    // Encoding: 0x2E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: sz=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_4_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_5_6800_2e216820() {
    // Encoding: 0x2E216820
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Rd=0, Q=0, sz=0, Rn=1
    let encoding: u32 = 0x2E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_6_6800_2e216bc0() {
    // Encoding: 0x2E216BC0
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_7_6800_2e216be0() {
    // Encoding: 0x2E216BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: sz=0, Rn=31, Q=0, Rd=0
    let encoding: u32 = 0x2E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_8_6800_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, sz=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_9_6800_2e216801() {
    // Encoding: 0x2E216801
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Q=0, sz=0, Rn=0, Rd=1
    let encoding: u32 = 0x2E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_10_6800_2e21681e() {
    // Encoding: 0x2E21681E
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rn=0, Q=0, Rd=30
    let encoding: u32 = 0x2E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_11_6800_2e21681f() {
    // Encoding: 0x2E21681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Q=0, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x2E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_12_6800_2e216821() {
    // Encoding: 0x2E216821
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: Rn=1, Rd=1, Q=0, sz=0
    let encoding: u32 = 0x2E216821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_combo_13_6800_2e216bff() {
    // Encoding: 0x2E216BFF
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Rn=31, sz=0, Rd=31, Q=0
    let encoding: u32 = 0x2E216BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_q_0_size_variant_0_26624_2e616800() {
    // Encoding: 0x2E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, sz=1, Rn=0
    let encoding: u32 = 0x2E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_q_1_size_variant_1_26624_6e616800() {
    // Encoding: 0x6E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value Q = 1 (Size variant 1)
    // Fields: sz=1, Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x6E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_sz_0_size_variant_0_26624_2e216800() {
    // Encoding: 0x2E216800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value sz = 0 (Size variant 0)
    // Fields: Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_sz_1_size_variant_1_26624_2e616800() {
    // Encoding: 0x2E616800
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_rn_31_stack_pointer_sp_may_require_alignment_26624_2e616be0() {
    // Encoding: 0x2E616BE0
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, sz=1, Q=0, Rd=0
    let encoding: u32 = 0x2E616BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_26624_2e61681f() {
    // Encoding: 0x2E61681F
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, sz=1, Rn=0, Rd=31
    let encoding: u32 = 0x2E61681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_sp_rn_7e216be0() {
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd with Rn = SP (31)
    // Encoding: 0x7E216BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E216BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_sisd_zr_rd_7e21681f() {
    // Test aarch64_vector_arithmetic_unary_float_xtn_sisd with Rd = ZR (31)
    // Encoding: 0x7E21681F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E21681F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_sp_rn_2e216be0() {
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd with Rn = SP (31)
    // Encoding: 0x2E216BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E216BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_xtn_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_xtn_simd_zr_rd_2e21681f() {
    // Test aarch64_vector_arithmetic_unary_float_xtn_simd with Rd = ZR (31)
    // Encoding: 0x2E21681F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E21681F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_cnt Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_q_0_min_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field Q = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, size=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_q_1_max_5800_4e205800() {
    // Encoding: 0x4E205800
    // Test aarch64_vector_arithmetic_unary_cnt field Q = 1 (Max)
    // Fields: Rn=0, size=0, Q=1, Rd=0
    let encoding: u32 = 0x4E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_size_0_min_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field size = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_size_1_poweroftwo_5800_0e605800() {
    // Encoding: 0x0E605800
    // Test aarch64_vector_arithmetic_unary_cnt field size = 1 (PowerOfTwo)
    // Fields: size=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_size_2_poweroftwo_5800_0ea05800() {
    // Encoding: 0x0EA05800
    // Test aarch64_vector_arithmetic_unary_cnt field size = 2 (PowerOfTwo)
    // Fields: Q=0, size=2, Rn=0, Rd=0
    let encoding: u32 = 0x0EA05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_size_3_max_5800_0ee05800() {
    // Encoding: 0x0EE05800
    // Test aarch64_vector_arithmetic_unary_cnt field size = 3 (Max)
    // Fields: Rn=0, Q=0, size=3, Rd=0
    let encoding: u32 = 0x0EE05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rn_0_min_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field Rn = 0 (Min)
    // Fields: size=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rn_1_poweroftwo_5800_0e205820() {
    // Encoding: 0x0E205820
    // Test aarch64_vector_arithmetic_unary_cnt field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, Rd=0, Rn=1
    let encoding: u32 = 0x0E205820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rn_30_poweroftwominusone_5800_0e205bc0() {
    // Encoding: 0x0E205BC0
    // Test aarch64_vector_arithmetic_unary_cnt field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, Rd=0, Rn=30
    let encoding: u32 = 0x0E205BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rn_31_max_5800_0e205be0() {
    // Encoding: 0x0E205BE0
    // Test aarch64_vector_arithmetic_unary_cnt field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E205BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rd_0_min_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field Rd = 0 (Min)
    // Fields: Rd=0, Rn=0, size=0, Q=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rd_1_poweroftwo_5800_0e205801() {
    // Encoding: 0x0E205801
    // Test aarch64_vector_arithmetic_unary_cnt field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Q=0, size=0
    let encoding: u32 = 0x0E205801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rd_30_poweroftwominusone_5800_0e20581e() {
    // Encoding: 0x0E20581E
    // Test aarch64_vector_arithmetic_unary_cnt field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, size=0, Rd=30, Q=0
    let encoding: u32 = 0x0E20581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_field_rd_31_max_5800_0e20581f() {
    // Encoding: 0x0E20581F
    // Test aarch64_vector_arithmetic_unary_cnt field Rd = 31 (Max)
    // Fields: size=0, Rd=31, Q=0, Rn=0
    let encoding: u32 = 0x0E20581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_0_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_1_5800_4e205800() {
    // Encoding: 0x4E205800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=1, size=0, Rn=0, Rd=0
    // Fields: Q=1, Rd=0, Rn=0, size=0
    let encoding: u32 = 0x4E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_2_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_3_5800_0e605800() {
    // Encoding: 0x0E605800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=1, Rn=0, Rd=0
    // Fields: size=1, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_4_5800_0ea05800() {
    // Encoding: 0x0EA05800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=2, Rn=0, Rd=0
    // Fields: Rn=0, size=2, Q=0, Rd=0
    let encoding: u32 = 0x0EA05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_5_5800_0ee05800() {
    // Encoding: 0x0EE05800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=3, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0, size=3
    let encoding: u32 = 0x0EE05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_6_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_7_5800_0e205820() {
    // Encoding: 0x0E205820
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=1, Rd=0
    // Fields: Rd=0, Rn=1, Q=0, size=0
    let encoding: u32 = 0x0E205820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_8_5800_0e205bc0() {
    // Encoding: 0x0E205BC0
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=30, Rd=0
    // Fields: Rn=30, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E205BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_9_5800_0e205be0() {
    // Encoding: 0x0E205BE0
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, Rn=31, size=0
    let encoding: u32 = 0x0E205BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_10_5800_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_11_5800_0e205801() {
    // Encoding: 0x0E205801
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=1
    // Fields: Rd=1, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0E205801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_12_5800_0e20581e() {
    // Encoding: 0x0E20581E
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=30
    // Fields: Q=0, size=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E20581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_13_5800_0e20581f() {
    // Encoding: 0x0E20581F
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=0, Rd=31
    // Fields: size=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E20581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_14_5800_0e205821() {
    // Encoding: 0x0E205821
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=1, Rd=1
    // Fields: Q=0, Rd=1, size=0, Rn=1
    let encoding: u32 = 0x0E205821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_combo_15_5800_0e205bff() {
    // Encoding: 0x0E205BFF
    // Test aarch64_vector_arithmetic_unary_cnt field combination: Q=0, size=0, Rn=31, Rd=31
    // Fields: Rn=31, Q=0, size=0, Rd=31
    let encoding: u32 = 0x0E205BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_q_0_size_variant_0_22528_0e605800() {
    // Encoding: 0x0E605800
    // Test aarch64_vector_arithmetic_unary_cnt special value Q = 0 (Size variant 0)
    // Fields: Rd=0, size=1, Q=0, Rn=0
    let encoding: u32 = 0x0E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_q_1_size_variant_1_22528_4e605800() {
    // Encoding: 0x4E605800
    // Test aarch64_vector_arithmetic_unary_cnt special value Q = 1 (Size variant 1)
    // Fields: Q=1, size=1, Rn=0, Rd=0
    let encoding: u32 = 0x4E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_size_0_size_variant_0_22528_0e205800() {
    // Encoding: 0x0E205800
    // Test aarch64_vector_arithmetic_unary_cnt special value size = 0 (Size variant 0)
    // Fields: size=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_size_1_size_variant_1_22528_0e605800() {
    // Encoding: 0x0E605800
    // Test aarch64_vector_arithmetic_unary_cnt special value size = 1 (Size variant 1)
    // Fields: size=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_size_2_size_variant_2_22528_0ea05800() {
    // Encoding: 0x0EA05800
    // Test aarch64_vector_arithmetic_unary_cnt special value size = 2 (Size variant 2)
    // Fields: size=2, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_size_3_size_variant_3_22528_0ee05800() {
    // Encoding: 0x0EE05800
    // Test aarch64_vector_arithmetic_unary_cnt special value size = 3 (Size variant 3)
    // Fields: Rd=0, Q=0, Rn=0, size=3
    let encoding: u32 = 0x0EE05800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_rn_31_stack_pointer_sp_may_require_alignment_22528_0e605be0() {
    // Encoding: 0x0E605BE0
    // Test aarch64_vector_arithmetic_unary_cnt special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, size=1, Rd=0, Q=0
    let encoding: u32 = 0x0E605BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_22528_0e60581f() {
    // Encoding: 0x0E60581F
    // Test aarch64_vector_arithmetic_unary_cnt special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, size=1, Rd=31, Rn=0
    let encoding: u32 = 0x0E60581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_reg_write_0_0e205800() {
    // Test aarch64_vector_arithmetic_unary_cnt register write: SimdFromField("d")
    // Encoding: 0x0E205800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E205800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_sp_rn_0e205be0() {
    // Test aarch64_vector_arithmetic_unary_cnt with Rn = SP (31)
    // Encoding: 0x0E205BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E205BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_cnt
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_cnt_zr_rd_0e20581f() {
    // Test aarch64_vector_arithmetic_unary_cnt with Rd = ZR (31)
    // Encoding: 0x0E20581F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20581F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_extract_sat_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_u_0_min_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field U = 0 (Min)
    // Fields: Rd=0, U=0, size=0, Rn=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_u_1_max_4800_7e214800() {
    // Encoding: 0x7E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field U = 1 (Max)
    // Fields: size=0, U=1, Rd=0, Rn=0
    let encoding: u32 = 0x7E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_size_0_min_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field size = 0 (Min)
    // Fields: U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_size_1_poweroftwo_4800_5e614800() {
    // Encoding: 0x5E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field size = 1 (PowerOfTwo)
    // Fields: Rn=0, U=0, Rd=0, size=1
    let encoding: u32 = 0x5E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_size_2_poweroftwo_4800_5ea14800() {
    // Encoding: 0x5EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field size = 2 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, size=2, U=0
    let encoding: u32 = 0x5EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_size_3_max_4800_5ee14800() {
    // Encoding: 0x5EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field size = 3 (Max)
    // Fields: Rd=0, U=0, size=3, Rn=0
    let encoding: u32 = 0x5EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rn_0_min_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rn = 0 (Min)
    // Fields: size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rn_1_poweroftwo_4800_5e214820() {
    // Encoding: 0x5E214820
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, size=0, U=0, Rd=0
    let encoding: u32 = 0x5E214820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rn_30_poweroftwominusone_4800_5e214bc0() {
    // Encoding: 0x5E214BC0
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rd=0, Rn=30, U=0
    let encoding: u32 = 0x5E214BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rn_31_max_4800_5e214be0() {
    // Encoding: 0x5E214BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rn = 31 (Max)
    // Fields: Rd=0, U=0, Rn=31, size=0
    let encoding: u32 = 0x5E214BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rd_0_min_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rd = 0 (Min)
    // Fields: Rn=0, U=0, size=0, Rd=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rd_1_poweroftwo_4800_5e214801() {
    // Encoding: 0x5E214801
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, U=0, size=0
    let encoding: u32 = 0x5E214801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rd_30_poweroftwominusone_4800_5e21481e() {
    // Encoding: 0x5E21481E
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=0, U=0, Rd=30
    let encoding: u32 = 0x5E21481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_field_rd_31_max_4800_5e21481f() {
    // Encoding: 0x5E21481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field Rd = 31 (Max)
    // Fields: size=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x5E21481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_0_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_1_4800_7e214800() {
    // Encoding: 0x7E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=1, size=0, Rn=0, Rd=0
    // Fields: size=0, U=1, Rn=0, Rd=0
    let encoding: u32 = 0x7E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_2_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_3_4800_5e614800() {
    // Encoding: 0x5E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=1, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, size=1, U=0
    let encoding: u32 = 0x5E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_4_4800_5ea14800() {
    // Encoding: 0x5EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=2, Rn=0, Rd=0
    // Fields: size=2, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_5_4800_5ee14800() {
    // Encoding: 0x5EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=3, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Rd=0, size=3
    let encoding: u32 = 0x5EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_6_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, size=0, U=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_7_4800_5e214820() {
    // Encoding: 0x5E214820
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=1, Rd=0
    // Fields: U=0, Rd=0, size=0, Rn=1
    let encoding: u32 = 0x5E214820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_8_4800_5e214bc0() {
    // Encoding: 0x5E214BC0
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=30, Rd=0
    // Fields: Rn=30, size=0, U=0, Rd=0
    let encoding: u32 = 0x5E214BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_9_4800_5e214be0() {
    // Encoding: 0x5E214BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=31, Rd=0
    // Fields: Rd=0, U=0, Rn=31, size=0
    let encoding: u32 = 0x5E214BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_10_4800_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_11_4800_5e214801() {
    // Encoding: 0x5E214801
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=1
    // Fields: U=0, size=0, Rd=1, Rn=0
    let encoding: u32 = 0x5E214801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_12_4800_5e21481e() {
    // Encoding: 0x5E21481E
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=30
    // Fields: Rd=30, Rn=0, U=0, size=0
    let encoding: u32 = 0x5E21481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_13_4800_5e21481f() {
    // Encoding: 0x5E21481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=0, Rd=31
    // Fields: U=0, size=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E21481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_14_4800_5e214821() {
    // Encoding: 0x5E214821
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, size=0, Rd=1, U=0
    let encoding: u32 = 0x5E214821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_combo_15_4800_5e214bff() {
    // Encoding: 0x5E214BFF
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd field combination: U=0, size=0, Rn=31, Rd=31
    // Fields: U=0, size=0, Rn=31, Rd=31
    let encoding: u32 = 0x5E214BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_size_0_size_variant_0_18432_5e214800() {
    // Encoding: 0x5E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value size = 0 (Size variant 0)
    // Fields: U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_size_1_size_variant_1_18432_5e614800() {
    // Encoding: 0x5E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value size = 1 (Size variant 1)
    // Fields: U=0, size=1, Rd=0, Rn=0
    let encoding: u32 = 0x5E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_size_2_size_variant_2_18432_5ea14800() {
    // Encoding: 0x5EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value size = 2 (Size variant 2)
    // Fields: Rn=0, Rd=0, U=0, size=2
    let encoding: u32 = 0x5EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_size_3_size_variant_3_18432_5ee14800() {
    // Encoding: 0x5EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value size = 3 (Size variant 3)
    // Fields: Rn=0, size=3, U=0, Rd=0
    let encoding: u32 = 0x5EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_18432_5e614be0() {
    // Encoding: 0x5E614BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rd=0, size=1, Rn=31
    let encoding: u32 = 0x5E614BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_18432_5e61481f() {
    // Encoding: 0x5E61481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, U=0, Rd=31, size=1
    let encoding: u32 = 0x5E61481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_q_0_min_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Q = 0 (Min)
    // Fields: Rn=0, U=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_q_1_max_4800_4e214800() {
    // Encoding: 0x4E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Q = 1 (Max)
    // Fields: size=0, Rd=0, U=0, Q=1, Rn=0
    let encoding: u32 = 0x4E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_u_0_min_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field U = 0 (Min)
    // Fields: Q=0, U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_u_1_max_4800_2e214800() {
    // Encoding: 0x2E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field U = 1 (Max)
    // Fields: Rn=0, size=0, Rd=0, Q=0, U=1
    let encoding: u32 = 0x2E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_size_0_min_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field size = 0 (Min)
    // Fields: U=0, Rn=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_size_1_poweroftwo_4800_0e614800() {
    // Encoding: 0x0E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field size = 1 (PowerOfTwo)
    // Fields: size=1, Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_size_2_poweroftwo_4800_0ea14800() {
    // Encoding: 0x0EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field size = 2 (PowerOfTwo)
    // Fields: size=2, Rd=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_size_3_max_4800_0ee14800() {
    // Encoding: 0x0EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field size = 3 (Max)
    // Fields: size=3, Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rn_0_min_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rn = 0 (Min)
    // Fields: Q=0, Rd=0, size=0, U=0, Rn=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rn_1_poweroftwo_4800_0e214820() {
    // Encoding: 0x0E214820
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, Rn=1, Rd=0, size=0
    let encoding: u32 = 0x0E214820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rn_30_poweroftwominusone_4800_0e214bc0() {
    // Encoding: 0x0E214BC0
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, Q=0, U=0, Rd=0
    let encoding: u32 = 0x0E214BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rn_31_max_4800_0e214be0() {
    // Encoding: 0x0E214BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, Q=0, U=0, size=0
    let encoding: u32 = 0x0E214BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rd_0_min_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rd = 0 (Min)
    // Fields: size=0, Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rd_1_poweroftwo_4800_0e214801() {
    // Encoding: 0x0E214801
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, U=0, size=0, Rd=1
    let encoding: u32 = 0x0E214801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rd_30_poweroftwominusone_4800_0e21481e() {
    // Encoding: 0x0E21481E
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, U=0, size=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E21481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_field_rd_31_max_4800_0e21481f() {
    // Encoding: 0x0E21481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, size=0, U=0, Rn=0
    let encoding: u32 = 0x0E21481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_0_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, U=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_1_4800_4e214800() {
    // Encoding: 0x4E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=1, U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, size=0, Q=1
    let encoding: u32 = 0x4E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_2_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=0, U=0, Rn=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_3_4800_2e214800() {
    // Encoding: 0x2E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=1, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, size=0, U=1, Rn=0
    let encoding: u32 = 0x2E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_4_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, Rn=0, U=0, Q=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_5_4800_0e614800() {
    // Encoding: 0x0E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=1, Rn=0, Rd=0
    // Fields: size=1, Rn=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_6_4800_0ea14800() {
    // Encoding: 0x0EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=2, Rn=0, Rd=0
    // Fields: Q=0, size=2, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_7_4800_0ee14800() {
    // Encoding: 0x0EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=3, Rn=0, Rd=0
    // Fields: Q=0, U=0, size=3, Rn=0, Rd=0
    let encoding: u32 = 0x0EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_8_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, U=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_9_4800_0e214820() {
    // Encoding: 0x0E214820
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=0
    // Fields: Rd=0, U=0, Q=0, Rn=1, size=0
    let encoding: u32 = 0x0E214820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_10_4800_0e214bc0() {
    // Encoding: 0x0E214BC0
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=30, Rd=0
    // Fields: Rn=30, size=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E214BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_11_4800_0e214be0() {
    // Encoding: 0x0E214BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=0
    // Fields: Rn=31, U=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E214BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_12_4800_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_13_4800_0e214801() {
    // Encoding: 0x0E214801
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=1
    // Fields: size=0, Rd=1, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E214801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_14_4800_0e21481e() {
    // Encoding: 0x0E21481E
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, Q=0, size=0, U=0
    let encoding: u32 = 0x0E21481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_15_4800_0e21481f() {
    // Encoding: 0x0E21481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=31
    // Fields: Q=0, Rd=31, size=0, Rn=0, U=0
    let encoding: u32 = 0x0E21481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_16_4800_0e214821() {
    // Encoding: 0x0E214821
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, U=0, Q=0, Rd=1, size=0
    let encoding: u32 = 0x0E214821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_combo_17_4800_0e214bff() {
    // Encoding: 0x0E214BFF
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=31
    // Fields: U=0, Q=0, Rn=31, Rd=31, size=0
    let encoding: u32 = 0x0E214BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_q_0_size_variant_0_18432_0e614800() {
    // Encoding: 0x0E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value Q = 0 (Size variant 0)
    // Fields: Rn=0, size=1, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_q_1_size_variant_1_18432_4e614800() {
    // Encoding: 0x4E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rd=0, size=1, Rn=0, U=0
    let encoding: u32 = 0x4E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_size_0_size_variant_0_18432_0e214800() {
    // Encoding: 0x0E214800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value size = 0 (Size variant 0)
    // Fields: size=0, Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_size_1_size_variant_1_18432_0e614800() {
    // Encoding: 0x0E614800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E614800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_size_2_size_variant_2_18432_0ea14800() {
    // Encoding: 0x0EA14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value size = 2 (Size variant 2)
    // Fields: U=0, Rd=0, Rn=0, Q=0, size=2
    let encoding: u32 = 0x0EA14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_size_3_size_variant_3_18432_0ee14800() {
    // Encoding: 0x0EE14800
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, Rn=0, size=3, U=0, Rd=0
    let encoding: u32 = 0x0EE14800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_rn_31_stack_pointer_sp_may_require_alignment_18432_0e614be0() {
    // Encoding: 0x0E614BE0
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, size=1, Rd=0, Rn=31, U=0
    let encoding: u32 = 0x0E614BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_18432_0e61481f() {
    // Encoding: 0x0E61481F
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: size=1, Rn=0, Q=0, Rd=31, U=0
    let encoding: u32 = 0x0E61481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_sp_rn_5e214be0() {
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd with Rn = SP (31)
    // Encoding: 0x5E214BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E214BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_sisd_zr_rd_5e21481f() {
    // Test aarch64_vector_arithmetic_unary_extract_sat_sisd with Rd = ZR (31)
    // Encoding: 0x5E21481F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21481F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_sp_rn_0e214be0() {
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd with Rn = SP (31)
    // Encoding: 0x0E214BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E214BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sat_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sat_simd_zr_rd_0e21481f() {
    // Test aarch64_vector_arithmetic_unary_extract_sat_simd with Rd = ZR (31)
    // Encoding: 0x0E21481F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21481F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_recip_int Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_q_0_min_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_q_1_max_c800_4ea1c800() {
    // Encoding: 0x4EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Q = 1 (Max)
    // Fields: Q=1, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x4EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_sz_0_min_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field sz = 0 (Min)
    // Fields: Q=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_sz_1_max_c800_0ee1c800() {
    // Encoding: 0x0EE1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field sz = 1 (Max)
    // Fields: sz=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rn_0_min_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rn = 0 (Min)
    // Fields: Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rn_1_poweroftwo_c800_0ea1c820() {
    // Encoding: 0x0EA1C820
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=1, Rd=0, Q=0
    let encoding: u32 = 0x0EA1C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rn_30_poweroftwominusone_c800_0ea1cbc0() {
    // Encoding: 0x0EA1CBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=30, Rd=0, sz=0
    let encoding: u32 = 0x0EA1CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rn_31_max_c800_0ea1cbe0() {
    // Encoding: 0x0EA1CBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, sz=0, Rn=31
    let encoding: u32 = 0x0EA1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rd_0_min_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rd = 0 (Min)
    // Fields: sz=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rd_1_poweroftwo_c800_0ea1c801() {
    // Encoding: 0x0EA1C801
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x0EA1C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rd_30_poweroftwominusone_c800_0ea1c81e() {
    // Encoding: 0x0EA1C81E
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=30, Q=0, Rn=0
    let encoding: u32 = 0x0EA1C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_field_rd_31_max_c800_0ea1c81f() {
    // Encoding: 0x0EA1C81F
    // Test aarch64_vector_arithmetic_unary_special_recip_int field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, sz=0, Q=0
    let encoding: u32 = 0x0EA1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_0_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_1_c800_4ea1c800() {
    // Encoding: 0x4EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x4EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_2_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_3_c800_0ee1c800() {
    // Encoding: 0x0EE1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, sz=1
    let encoding: u32 = 0x0EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_4_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_5_c800_0ea1c820() {
    // Encoding: 0x0EA1C820
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Q=0, sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x0EA1C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_6_c800_0ea1cbc0() {
    // Encoding: 0x0EA1CBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=30
    let encoding: u32 = 0x0EA1CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_7_c800_0ea1cbe0() {
    // Encoding: 0x0EA1CBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Rd=0, Q=0, sz=0, Rn=31
    let encoding: u32 = 0x0EA1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_8_c800_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_9_c800_0ea1c801() {
    // Encoding: 0x0EA1C801
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Q=0, Rd=1, Rn=0, sz=0
    let encoding: u32 = 0x0EA1C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_10_c800_0ea1c81e() {
    // Encoding: 0x0EA1C81E
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: Q=0, Rd=30, Rn=0, sz=0
    let encoding: u32 = 0x0EA1C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_11_c800_0ea1c81f() {
    // Encoding: 0x0EA1C81F
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Rd=31, Q=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_12_c800_0ea1c821() {
    // Encoding: 0x0EA1C821
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, Rd=1, sz=0
    let encoding: u32 = 0x0EA1C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_combo_13_c800_0ea1cbff() {
    // Encoding: 0x0EA1CBFF
    // Test aarch64_vector_arithmetic_unary_special_recip_int field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Q=0, sz=0, Rn=31, Rd=31
    let encoding: u32 = 0x0EA1CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_q_0_size_variant_0_51200_0ee1c800() {
    // Encoding: 0x0EE1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, Rn=0, sz=1
    let encoding: u32 = 0x0EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_q_1_size_variant_1_51200_4ee1c800() {
    // Encoding: 0x4EE1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value Q = 1 (Size variant 1)
    // Fields: Q=1, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x4EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_sz_0_size_variant_0_51200_0ea1c800() {
    // Encoding: 0x0EA1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value sz = 0 (Size variant 0)
    // Fields: Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_sz_1_size_variant_1_51200_0ee1c800() {
    // Encoding: 0x0EE1C800
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value sz = 1 (Size variant 1)
    // Fields: Q=0, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x0EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_rn_31_stack_pointer_sp_may_require_alignment_51200_0ee1cbe0() {
    // Encoding: 0x0EE1CBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rd=0, sz=1, Rn=31
    let encoding: u32 = 0x0EE1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_0ee1c81f() {
    // Encoding: 0x0EE1C81F
    // Test aarch64_vector_arithmetic_unary_special_recip_int special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x0EE1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_reg_write_0_0ea1c800() {
    // Test aarch64_vector_arithmetic_unary_special_recip_int register write: SimdFromField("d")
    // Encoding: 0x0EA1C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_sp_rn_0ea1cbe0() {
    // Test aarch64_vector_arithmetic_unary_special_recip_int with Rn = SP (31)
    // Encoding: 0x0EA1CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_int
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_int_zr_rd_0ea1c81f() {
    // Test aarch64_vector_arithmetic_unary_special_recip_int with Rd = ZR (31)
    // Encoding: 0x0EA1C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rm_0_min_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rm = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rm_1_poweroftwo_3c00_5ec13c00() {
    // Encoding: 0x5EC13C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Rd=0
    let encoding: u32 = 0x5EC13C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rm_30_poweroftwominusone_3c00_5ede3c00() {
    // Encoding: 0x5EDE3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rd=0, Rn=0
    let encoding: u32 = 0x5EDE3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rm_31_max_3c00_5edf3c00() {
    // Encoding: 0x5EDF3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Rd=0
    let encoding: u32 = 0x5EDF3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rn_0_min_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rn_1_poweroftwo_3c00_5ec03c20() {
    // Encoding: 0x5EC03C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, Rm=0
    let encoding: u32 = 0x5EC03C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rn_30_poweroftwominusone_3c00_5ec03fc0() {
    // Encoding: 0x5EC03FC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x5EC03FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rn_31_max_3c00_5ec03fe0() {
    // Encoding: 0x5EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Rd=0
    let encoding: u32 = 0x5EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rd_0_min_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rd_1_poweroftwo_3c00_5ec03c01() {
    // Encoding: 0x5EC03C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, Rm=0
    let encoding: u32 = 0x5EC03C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rd_30_poweroftwominusone_3c00_5ec03c1e() {
    // Encoding: 0x5EC03C1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Rm=0
    let encoding: u32 = 0x5EC03C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_field_rd_31_max_3c00_5ec03c1f() {
    // Encoding: 0x5EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field Rd = 31 (Max)
    // Fields: Rd=31, Rm=0, Rn=0
    let encoding: u32 = 0x5EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_0_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_1_3c00_5ec13c00() {
    // Encoding: 0x5EC13C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=1, Rn=0, Rd=0
    // Fields: Rm=1, Rd=0, Rn=0
    let encoding: u32 = 0x5EC13C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_2_3c00_5ede3c00() {
    // Encoding: 0x5EDE3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=30, Rn=0, Rd=0
    // Fields: Rm=30, Rn=0, Rd=0
    let encoding: u32 = 0x5EDE3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_3_3c00_5edf3c00() {
    // Encoding: 0x5EDF3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=31, Rn=0, Rd=0
    // Fields: Rn=0, Rm=31, Rd=0
    let encoding: u32 = 0x5EDF3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_4_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_5_3c00_5ec03c20() {
    // Encoding: 0x5EC03C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=1, Rd=0
    // Fields: Rn=1, Rm=0, Rd=0
    let encoding: u32 = 0x5EC03C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_6_3c00_5ec03fc0() {
    // Encoding: 0x5EC03FC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=30, Rd=0
    // Fields: Rm=0, Rd=0, Rn=30
    let encoding: u32 = 0x5EC03FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_7_3c00_5ec03fe0() {
    // Encoding: 0x5EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Rn=31, Rd=0
    let encoding: u32 = 0x5EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_8_3c00_5ec03c00() {
    // Encoding: 0x5EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_9_3c00_5ec03c01() {
    // Encoding: 0x5EC03C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=1
    // Fields: Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x5EC03C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_10_3c00_5ec03c1e() {
    // Encoding: 0x5EC03C1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, Rm=0
    let encoding: u32 = 0x5EC03C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_11_3c00_5ec03c1f() {
    // Encoding: 0x5EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, Rn=0, Rd=31
    let encoding: u32 = 0x5EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_12_3c00_5ec13c20() {
    // Encoding: 0x5EC13C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=1, Rn=1, Rd=0
    // Fields: Rd=0, Rm=1, Rn=1
    let encoding: u32 = 0x5EC13C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_13_3c00_5edf3fe0() {
    // Encoding: 0x5EDF3FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=31, Rn=31, Rd=0
    // Fields: Rd=0, Rm=31, Rn=31
    let encoding: u32 = 0x5EDF3FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_14_3c00_5ec13c01() {
    // Encoding: 0x5EC13C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, Rm=1, Rn=0
    let encoding: u32 = 0x5EC13C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_15_3c00_5edf3c1f() {
    // Encoding: 0x5EDF3C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=31, Rn=0, Rd=31
    // Fields: Rm=31, Rd=31, Rn=0
    let encoding: u32 = 0x5EDF3C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_16_3c00_5ec03c21() {
    // Encoding: 0x5EC03C21
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=1, Rd=1
    // Fields: Rn=1, Rd=1, Rm=0
    let encoding: u32 = 0x5EC03C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_combo_17_3c00_5ec03fff() {
    // Encoding: 0x5EC03FFF
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd field combination: Rm=0, Rn=31, Rd=31
    // Fields: Rn=31, Rm=0, Rd=31
    let encoding: u32 = 0x5EC03FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_15360_5ec03fe0() {
    // Encoding: 0x5EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rd=0, Rn=31
    let encoding: u32 = 0x5EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_15360_5ec03c1f() {
    // Encoding: 0x5EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Rm=0
    let encoding: u32 = 0x5EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_sz_0_min_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field sz = 0 (Min)
    // Fields: Rm=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_sz_1_max_fc00_5ee0fc00() {
    // Encoding: 0x5EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field sz = 1 (Max)
    // Fields: Rn=0, sz=1, Rd=0, Rm=0
    let encoding: u32 = 0x5EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rm_0_min_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rm_1_poweroftwo_fc00_5ea1fc00() {
    // Encoding: 0x5EA1FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=0, Rm=1, Rd=0
    let encoding: u32 = 0x5EA1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rm_30_poweroftwominusone_fc00_5ebefc00() {
    // Encoding: 0x5EBEFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=0, sz=0, Rm=30
    let encoding: u32 = 0x5EBEFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rm_31_max_fc00_5ebffc00() {
    // Encoding: 0x5EBFFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rm = 31 (Max)
    // Fields: Rd=0, Rn=0, Rm=31, sz=0
    let encoding: u32 = 0x5EBFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rn_0_min_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rn_1_poweroftwo_fc00_5ea0fc20() {
    // Encoding: 0x5EA0FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, sz=0, Rm=0, Rn=1
    let encoding: u32 = 0x5EA0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rn_30_poweroftwominusone_fc00_5ea0ffc0() {
    // Encoding: 0x5EA0FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, sz=0, Rd=0
    let encoding: u32 = 0x5EA0FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rn_31_max_fc00_5ea0ffe0() {
    // Encoding: 0x5EA0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, sz=0, Rd=0
    let encoding: u32 = 0x5EA0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rd_0_min_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rd = 0 (Min)
    // Fields: Rm=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rd_1_poweroftwo_fc00_5ea0fc01() {
    // Encoding: 0x5EA0FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x5EA0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rd_30_poweroftwominusone_fc00_5ea0fc1e() {
    // Encoding: 0x5EA0FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=0, Rd=30, Rm=0
    let encoding: u32 = 0x5EA0FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_field_rd_31_max_fc00_5ea0fc1f() {
    // Encoding: 0x5EA0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rm=0, Rd=31, sz=0
    let encoding: u32 = 0x5EA0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_0_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_1_fc00_5ee0fc00() {
    // Encoding: 0x5EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, Rn=0, sz=1
    let encoding: u32 = 0x5EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_2_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_3_fc00_5ea1fc00() {
    // Encoding: 0x5EA1FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=1, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Rn=0, Rm=1
    let encoding: u32 = 0x5EA1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_4_fc00_5ebefc00() {
    // Encoding: 0x5EBEFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=30, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rm=30, Rd=0
    let encoding: u32 = 0x5EBEFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_5_fc00_5ebffc00() {
    // Encoding: 0x5EBFFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=31, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Rn=0, Rm=31
    let encoding: u32 = 0x5EBFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_6_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_7_fc00_5ea0fc20() {
    // Encoding: 0x5EA0FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=1, Rd=0
    // Fields: Rm=0, Rn=1, Rd=0, sz=0
    let encoding: u32 = 0x5EA0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_8_fc00_5ea0ffc0() {
    // Encoding: 0x5EA0FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, sz=0, Rm=0
    let encoding: u32 = 0x5EA0FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_9_fc00_5ea0ffe0() {
    // Encoding: 0x5EA0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=31, Rd=0
    // Fields: sz=0, Rd=0, Rn=31, Rm=0
    let encoding: u32 = 0x5EA0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_10_fc00_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, sz=0, Rd=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_11_fc00_5ea0fc01() {
    // Encoding: 0x5EA0FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=1
    // Fields: sz=0, Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x5EA0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_12_fc00_5ea0fc1e() {
    // Encoding: 0x5EA0FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=30
    // Fields: Rd=30, Rn=0, sz=0, Rm=0
    let encoding: u32 = 0x5EA0FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_13_fc00_5ea0fc1f() {
    // Encoding: 0x5EA0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Rd=31, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x5EA0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_14_fc00_5ea1fc20() {
    // Encoding: 0x5EA1FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=1, Rn=1, Rd=0
    // Fields: Rd=0, Rm=1, sz=0, Rn=1
    let encoding: u32 = 0x5EA1FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_15_fc00_5ebfffe0() {
    // Encoding: 0x5EBFFFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=31, Rn=31, Rd=0
    // Fields: sz=0, Rn=31, Rd=0, Rm=31
    let encoding: u32 = 0x5EBFFFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_16_fc00_5ea1fc01() {
    // Encoding: 0x5EA1FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=1, Rn=0, Rd=1
    // Fields: sz=0, Rd=1, Rm=1, Rn=0
    let encoding: u32 = 0x5EA1FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_17_fc00_5ebffc1f() {
    // Encoding: 0x5EBFFC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, Rm=31, sz=0
    let encoding: u32 = 0x5EBFFC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_18_fc00_5ea0fc21() {
    // Encoding: 0x5EA0FC21
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Rm=0, sz=0, Rd=1, Rn=1
    let encoding: u32 = 0x5EA0FC21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_combo_19_fc00_5ea0ffff() {
    // Encoding: 0x5EA0FFFF
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd field combination: sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rn=31, sz=0, Rm=0, Rd=31
    let encoding: u32 = 0x5EA0FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_special_sz_0_size_variant_0_64512_5ea0fc00() {
    // Encoding: 0x5EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd special value sz = 0 (Size variant 0)
    // Fields: Rd=0, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x5EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_special_sz_1_size_variant_1_64512_5ee0fc00() {
    // Encoding: 0x5EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd special value sz = 1 (Size variant 1)
    // Fields: Rn=0, sz=1, Rm=0, Rd=0
    let encoding: u32 = 0x5EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_64512_5ee0ffe0() {
    // Encoding: 0x5EE0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, sz=1, Rn=31, Rd=0
    let encoding: u32 = 0x5EE0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_64512_5ee0fc1f() {
    // Encoding: 0x5EE0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rm=0, sz=1, Rn=0
    let encoding: u32 = 0x5EE0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_q_0_min_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Q = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_q_1_max_3c00_4ec03c00() {
    // Encoding: 0x4EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Q = 1 (Max)
    // Fields: Rd=0, Rn=0, Rm=0, Q=1
    let encoding: u32 = 0x4EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rm_0_min_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rm = 0 (Min)
    // Fields: Rd=0, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rm_1_poweroftwo_3c00_0ec13c00() {
    // Encoding: 0x0EC13C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0EC13C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rm_30_poweroftwominusone_3c00_0ede3c00() {
    // Encoding: 0x0EDE3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rm=30, Rd=0
    let encoding: u32 = 0x0EDE3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rm_31_max_3c00_0edf3c00() {
    // Encoding: 0x0EDF3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rm = 31 (Max)
    // Fields: Rd=0, Rn=0, Rm=31, Q=0
    let encoding: u32 = 0x0EDF3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rn_0_min_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rn = 0 (Min)
    // Fields: Rm=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rn_1_poweroftwo_3c00_0ec03c20() {
    // Encoding: 0x0EC03C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Rm=0, Q=0
    let encoding: u32 = 0x0EC03C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rn_30_poweroftwominusone_3c00_0ec03fc0() {
    // Encoding: 0x0EC03FC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=30, Rd=0, Rm=0
    let encoding: u32 = 0x0EC03FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rn_31_max_3c00_0ec03fe0() {
    // Encoding: 0x0EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Q=0, Rd=0
    let encoding: u32 = 0x0EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rd_0_min_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rd = 0 (Min)
    // Fields: Q=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rd_1_poweroftwo_3c00_0ec03c01() {
    // Encoding: 0x0EC03C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rd=1, Rm=0
    let encoding: u32 = 0x0EC03C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rd_30_poweroftwominusone_3c00_0ec03c1e() {
    // Encoding: 0x0EC03C1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30, Rm=0
    let encoding: u32 = 0x0EC03C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_field_rd_31_max_3c00_0ec03c1f() {
    // Encoding: 0x0EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field Rd = 31 (Max)
    // Fields: Rd=31, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x0EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_0_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_1_3c00_4ec03c00() {
    // Encoding: 0x4EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=1, Rm=0, Rn=0, Rd=0
    // Fields: Q=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x4EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_2_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_3_3c00_0ec13c00() {
    // Encoding: 0x0EC13C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=1, Rn=0, Rd=0
    // Fields: Rn=0, Rm=1, Rd=0, Q=0
    let encoding: u32 = 0x0EC13C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_4_3c00_0ede3c00() {
    // Encoding: 0x0EDE3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=30, Rn=0, Rd=0
    // Fields: Rd=0, Rm=30, Q=0, Rn=0
    let encoding: u32 = 0x0EDE3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_5_3c00_0edf3c00() {
    // Encoding: 0x0EDF3C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=31, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rm=31, Rn=0
    let encoding: u32 = 0x0EDF3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_6_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_7_3c00_0ec03c20() {
    // Encoding: 0x0EC03C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=1, Rd=0
    // Fields: Rd=0, Rm=0, Q=0, Rn=1
    let encoding: u32 = 0x0EC03C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_8_3c00_0ec03fc0() {
    // Encoding: 0x0EC03FC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=30, Rd=0
    // Fields: Rn=30, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EC03FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_9_3c00_0ec03fe0() {
    // Encoding: 0x0EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=31, Rd=0
    // Fields: Rd=0, Rn=31, Rm=0, Q=0
    let encoding: u32 = 0x0EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_10_3c00_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_11_3c00_0ec03c01() {
    // Encoding: 0x0EC03C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=1
    // Fields: Rd=1, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0EC03C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_12_3c00_0ec03c1e() {
    // Encoding: 0x0EC03C1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, Q=0, Rm=0
    let encoding: u32 = 0x0EC03C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_13_3c00_0ec03c1f() {
    // Encoding: 0x0EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x0EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_14_3c00_0ec13c20() {
    // Encoding: 0x0EC13C20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=1, Rn=1, Rd=0
    // Fields: Rm=1, Rn=1, Rd=0, Q=0
    let encoding: u32 = 0x0EC13C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_15_3c00_0edf3fe0() {
    // Encoding: 0x0EDF3FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=31, Rn=31, Rd=0
    // Fields: Rd=0, Rn=31, Rm=31, Q=0
    let encoding: u32 = 0x0EDF3FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_16_3c00_0ec13c01() {
    // Encoding: 0x0EC13C01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, Rm=1, Rn=0, Q=0
    let encoding: u32 = 0x0EC13C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_17_3c00_0edf3c1f() {
    // Encoding: 0x0EDF3C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=31, Rn=0, Rd=31
    // Fields: Rd=31, Rm=31, Q=0, Rn=0
    let encoding: u32 = 0x0EDF3C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_18_3c00_0ec03c21() {
    // Encoding: 0x0EC03C21
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=1, Rd=1
    // Fields: Rd=1, Rn=1, Rm=0, Q=0
    let encoding: u32 = 0x0EC03C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_combo_19_3c00_0ec03fff() {
    // Encoding: 0x0EC03FFF
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd field combination: Q=0, Rm=0, Rn=31, Rd=31
    // Fields: Q=0, Rm=0, Rn=31, Rd=31
    let encoding: u32 = 0x0EC03FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_special_q_0_size_variant_0_15360_0ec03c00() {
    // Encoding: 0x0EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_special_q_1_size_variant_1_15360_4ec03c00() {
    // Encoding: 0x4EC03C00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rn=0, Q=1, Rm=0
    let encoding: u32 = 0x4EC03C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_15360_0ec03fe0() {
    // Encoding: 0x0EC03FE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Rm=0, Rn=31, Q=0
    let encoding: u32 = 0x0EC03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_15360_0ec03c1f() {
    // Encoding: 0x0EC03C1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0EC03C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_q_0_min_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_q_1_max_fc00_4ea0fc00() {
    // Encoding: 0x4EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Q = 1 (Max)
    // Fields: sz=0, Q=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x4EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_sz_0_min_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field sz = 0 (Min)
    // Fields: Q=0, Rd=0, Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_sz_1_max_fc00_0ee0fc00() {
    // Encoding: 0x0EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, Q=0, Rm=0, sz=1
    let encoding: u32 = 0x0EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rm_0_min_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rm = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rm_1_poweroftwo_fc00_0ea1fc00() {
    // Encoding: 0x0EA1FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rm=1, Rn=0, Rd=0
    let encoding: u32 = 0x0EA1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rm_30_poweroftwominusone_fc00_0ebefc00() {
    // Encoding: 0x0EBEFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, sz=0, Rn=0, Rd=0, Rm=30
    let encoding: u32 = 0x0EBEFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rm_31_max_fc00_0ebffc00() {
    // Encoding: 0x0EBFFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rm = 31 (Max)
    // Fields: Q=0, Rm=31, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x0EBFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rn_0_min_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rn_1_poweroftwo_fc00_0ea0fc20() {
    // Encoding: 0x0EA0FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rm=0, Rn=1, Rd=0
    let encoding: u32 = 0x0EA0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rn_30_poweroftwominusone_fc00_0ea0ffc0() {
    // Encoding: 0x0EA0FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, sz=0, Rn=30, Q=0, Rm=0
    let encoding: u32 = 0x0EA0FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rn_31_max_fc00_0ea0ffe0() {
    // Encoding: 0x0EA0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rn = 31 (Max)
    // Fields: Q=0, Rd=0, sz=0, Rm=0, Rn=31
    let encoding: u32 = 0x0EA0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rd_0_min_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rd = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rd_1_poweroftwo_fc00_0ea0fc01() {
    // Encoding: 0x0EA0FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, sz=0, Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x0EA0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rd_30_poweroftwominusone_fc00_0ea0fc1e() {
    // Encoding: 0x0EA0FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, sz=0, Rn=0, Rd=30, Rm=0
    let encoding: u32 = 0x0EA0FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_field_rd_31_max_fc00_0ea0fc1f() {
    // Encoding: 0x0EA0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field Rd = 31 (Max)
    // Fields: Q=0, Rm=0, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x0EA0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_0_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_1_fc00_4ea0fc00() {
    // Encoding: 0x4EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=1, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Q=1, Rm=0, Rd=0
    let encoding: u32 = 0x4EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_2_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, sz=0, Rm=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_3_fc00_0ee0fc00() {
    // Encoding: 0x0EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, Q=0, Rn=0, sz=1
    let encoding: u32 = 0x0EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_4_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_5_fc00_0ea1fc00() {
    // Encoding: 0x0EA1FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rm=1, sz=0, Rd=0
    let encoding: u32 = 0x0EA1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_6_fc00_0ebefc00() {
    // Encoding: 0x0EBEFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=30, Rn=0, Rd=0
    // Fields: sz=0, Rm=30, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0EBEFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_7_fc00_0ebffc00() {
    // Encoding: 0x0EBFFC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=0
    // Fields: Rm=31, sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EBFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_8_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_9_fc00_0ea0fc20() {
    // Encoding: 0x0EA0FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=0
    // Fields: sz=0, Q=0, Rd=0, Rn=1, Rm=0
    let encoding: u32 = 0x0EA0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_10_fc00_0ea0ffc0() {
    // Encoding: 0x0EA0FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=30, Rd=0
    // Fields: Q=0, Rn=30, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x0EA0FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_11_fc00_0ea0ffe0() {
    // Encoding: 0x0EA0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=31, Rm=0
    let encoding: u32 = 0x0EA0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_12_fc00_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_13_fc00_0ea0fc01() {
    // Encoding: 0x0EA0FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=1
    // Fields: Rm=0, Q=0, Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x0EA0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_14_fc00_0ea0fc1e() {
    // Encoding: 0x0EA0FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=30
    // Fields: Rd=30, Rn=0, Rm=0, Q=0, sz=0
    let encoding: u32 = 0x0EA0FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_15_fc00_0ea0fc1f() {
    // Encoding: 0x0EA0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, Rn=0, Rd=31, Q=0, sz=0
    let encoding: u32 = 0x0EA0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_16_fc00_0ea1fc20() {
    // Encoding: 0x0EA1FC20
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=1, Rn=1, Rd=0
    // Fields: Rn=1, Rm=1, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x0EA1FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_17_fc00_0ebfffe0() {
    // Encoding: 0x0EBFFFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=31, Rn=31, Rd=0
    // Fields: Rn=31, Q=0, Rm=31, Rd=0, sz=0
    let encoding: u32 = 0x0EBFFFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_18_fc00_0ea1fc01() {
    // Encoding: 0x0EA1FC01
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, sz=0, Rm=1, Q=0, Rn=0
    let encoding: u32 = 0x0EA1FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_19_fc00_0ebffc1f() {
    // Encoding: 0x0EBFFC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Q=0, Rm=31, Rn=0, sz=0, Rd=31
    let encoding: u32 = 0x0EBFFC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_20_fc00_0ea0fc21() {
    // Encoding: 0x0EA0FC21
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Q=0, Rm=0, sz=0, Rn=1, Rd=1
    let encoding: u32 = 0x0EA0FC21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_combo_21_fc00_0ea0ffff() {
    // Encoding: 0x0EA0FFFF
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rn=31, Rm=0, sz=0, Q=0, Rd=31
    let encoding: u32 = 0x0EA0FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_q_0_size_variant_0_64512_0ee0fc00() {
    // Encoding: 0x0EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, Rn=0, sz=1, Rd=0
    let encoding: u32 = 0x0EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_q_1_size_variant_1_64512_4ee0fc00() {
    // Encoding: 0x4EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, sz=1, Rn=0, Q=1
    let encoding: u32 = 0x4EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_sz_0_size_variant_0_64512_0ea0fc00() {
    // Encoding: 0x0EA0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value sz = 0 (Size variant 0)
    // Fields: sz=0, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EA0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_sz_1_size_variant_1_64512_0ee0fc00() {
    // Encoding: 0x0EE0FC00
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value sz = 1 (Size variant 1)
    // Fields: Rm=0, Rn=0, sz=1, Q=0, Rd=0
    let encoding: u32 = 0x0EE0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_rn_31_stack_pointer_sp_may_require_alignment_64512_0ee0ffe0() {
    // Encoding: 0x0EE0FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Rm=0, Q=0, sz=1, Rn=31
    let encoding: u32 = 0x0EE0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_64512_0ee0fc1f() {
    // Encoding: 0x0EE0FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rm=0, Q=0, sz=1, Rd=31
    let encoding: u32 = 0x0EE0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_reg_write_0_5ec03c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x5EC03C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EC03C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_sp_rn_5ec03fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd with Rn = SP (31)
    // Encoding: 0x5EC03FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EC03FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd_zr_rd_5ec03c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x5EC03C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EC03C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_reg_write_0_5ea0fc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd register write: SimdFromField("d")
    // Encoding: 0x5EA0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_sp_rn_5ea0ffe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd with Rn = SP (31)
    // Encoding: 0x5EA0FFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA0FFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd_zr_rd_5ea0fc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_sisd with Rd = ZR (31)
    // Encoding: 0x5EA0FC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA0FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_reg_write_0_0ec03c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x0EC03C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EC03C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_sp_rn_0ec03fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd with Rn = SP (31)
    // Encoding: 0x0EC03FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EC03FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd_zr_rd_0ec03c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_fp16_simd with Rd = ZR (31)
    // Encoding: 0x0EC03C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EC03C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_reg_write_0_0ea0fc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd register write: SimdFromField("d")
    // Encoding: 0x0EA0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_sp_rn_0ea0ffe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd with Rn = SP (31)
    // Encoding: 0x0EA0FFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0FFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_rsqrts_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_rsqrts_simd_zr_rd_0ea0fc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_rsqrts_simd with Rd = ZR (31)
    // Encoding: 0x0EA0FC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA0FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_u_0_min_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field U = 0 (Min)
    // Fields: o2=0, o1=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_u_1_max_a800_7e79a800() {
    // Encoding: 0x7E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field U = 1 (Max)
    // Fields: o1=0, Rd=0, o2=0, Rn=0, U=1
    let encoding: u32 = 0x7E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_o2_0_min_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field o2 = 0 (Min)
    // Fields: o1=0, U=0, Rn=0, o2=0, Rd=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_o2_1_max_a800_5ef9a800() {
    // Encoding: 0x5EF9A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field o2 = 1 (Max)
    // Fields: Rn=0, Rd=0, o1=0, o2=1, U=0
    let encoding: u32 = 0x5EF9A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_o1_0_min_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field o1 = 0 (Min)
    // Fields: o2=0, o1=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_o1_1_max_a800_5e79b800() {
    // Encoding: 0x5E79B800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field o1 = 1 (Max)
    // Fields: o2=0, o1=1, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E79B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rn_0_min_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0, U=0, o2=0, o1=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rn_1_poweroftwo_a800_5e79a820() {
    // Encoding: 0x5E79A820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, o2=0, o1=0, Rn=1, U=0
    let encoding: u32 = 0x5E79A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rn_30_poweroftwominusone_a800_5e79abc0() {
    // Encoding: 0x5E79ABC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, o2=0, Rd=0, Rn=30, U=0
    let encoding: u32 = 0x5E79ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rn_31_max_a800_5e79abe0() {
    // Encoding: 0x5E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rn = 31 (Max)
    // Fields: U=0, o2=0, Rd=0, Rn=31, o1=0
    let encoding: u32 = 0x5E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rd_0_min_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rd = 0 (Min)
    // Fields: o2=0, U=0, Rd=0, o1=0, Rn=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rd_1_poweroftwo_a800_5e79a801() {
    // Encoding: 0x5E79A801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, U=0, o2=0, o1=0, Rn=0
    let encoding: u32 = 0x5E79A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rd_30_poweroftwominusone_a800_5e79a81e() {
    // Encoding: 0x5E79A81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o2=0, o1=0, Rn=0, Rd=30, U=0
    let encoding: u32 = 0x5E79A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_field_rd_31_max_a800_5e79a81f() {
    // Encoding: 0x5E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, U=0, o1=0, o2=0
    let encoding: u32 = 0x5E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_0_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, o1=0, Rn=0, Rd=0, o2=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_1_a800_7e79a800() {
    // Encoding: 0x7E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=1, o2=0, o1=0, Rn=0, Rd=0
    // Fields: U=1, Rd=0, o1=0, Rn=0, o2=0
    let encoding: u32 = 0x7E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_2_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, o1=0, U=0, o2=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_3_a800_5ef9a800() {
    // Encoding: 0x5EF9A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=1, o1=0, Rn=0, Rd=0
    // Fields: o2=1, Rd=0, o1=0, Rn=0, U=0
    let encoding: u32 = 0x5EF9A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_4_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, o1=0, U=0, Rn=0, o2=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_5_a800_5e79b800() {
    // Encoding: 0x5E79B800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=1, Rn=0, Rd=0
    // Fields: Rd=0, U=0, o2=0, Rn=0, o1=1
    let encoding: u32 = 0x5E79B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_6_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, Rn=0, o1=0, U=0, Rd=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_7_a800_5e79a820() {
    // Encoding: 0x5E79A820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=1, Rd=0
    // Fields: Rn=1, o2=0, Rd=0, o1=0, U=0
    let encoding: u32 = 0x5E79A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_8_a800_5e79abc0() {
    // Encoding: 0x5E79ABC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=30, Rd=0
    // Fields: Rn=30, o1=0, o2=0, Rd=0, U=0
    let encoding: u32 = 0x5E79ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_9_a800_5e79abe0() {
    // Encoding: 0x5E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, o2=0, U=0, o1=0
    let encoding: u32 = 0x5E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_10_a800_5e79a800() {
    // Encoding: 0x5E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, o2=0, Rn=0, U=0, o1=0
    let encoding: u32 = 0x5E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_11_a800_5e79a801() {
    // Encoding: 0x5E79A801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=1
    // Fields: o1=0, U=0, Rn=0, Rd=1, o2=0
    let encoding: u32 = 0x5E79A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_12_a800_5e79a81e() {
    // Encoding: 0x5E79A81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=30
    // Fields: Rn=0, o1=0, o2=0, U=0, Rd=30
    let encoding: u32 = 0x5E79A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_13_a800_5e79a81f() {
    // Encoding: 0x5E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=0, Rd=31
    // Fields: Rd=31, o1=0, Rn=0, o2=0, U=0
    let encoding: u32 = 0x5E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_14_a800_5e79a821() {
    // Encoding: 0x5E79A821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=1, Rd=1
    // Fields: U=0, Rd=1, Rn=1, o2=0, o1=0
    let encoding: u32 = 0x5E79A821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_combo_15_a800_5e79abff() {
    // Encoding: 0x5E79ABFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd field combination: U=0, o2=0, o1=0, Rn=31, Rd=31
    // Fields: U=0, Rn=31, o2=0, Rd=31, o1=0
    let encoding: u32 = 0x5E79ABFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_43008_5e79abe0() {
    // Encoding: 0x5E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, U=0, o2=0, o1=0, Rd=0
    let encoding: u32 = 0x5E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_43008_5e79a81f() {
    // Encoding: 0x5E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, o1=0, U=0, o2=0
    let encoding: u32 = 0x5E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_u_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field U = 0 (Min)
    // Fields: o2=0, Rn=0, Rd=0, sz=0, o1=0, U=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_u_1_max_a800_7e21a800() {
    // Encoding: 0x7E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field U = 1 (Max)
    // Fields: sz=0, o1=0, U=1, Rn=0, Rd=0, o2=0
    let encoding: u32 = 0x7E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_o2_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field o2 = 0 (Min)
    // Fields: o1=0, Rd=0, Rn=0, o2=0, U=0, sz=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_o2_1_max_a800_5ea1a800() {
    // Encoding: 0x5EA1A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field o2 = 1 (Max)
    // Fields: o1=0, Rn=0, Rd=0, U=0, o2=1, sz=0
    let encoding: u32 = 0x5EA1A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_sz_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field sz = 0 (Min)
    // Fields: Rd=0, sz=0, o2=0, o1=0, U=0, Rn=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_sz_1_max_a800_5e61a800() {
    // Encoding: 0x5E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field sz = 1 (Max)
    // Fields: U=0, Rn=0, sz=1, o1=0, o2=0, Rd=0
    let encoding: u32 = 0x5E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_o1_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field o1 = 0 (Min)
    // Fields: Rn=0, Rd=0, o1=0, o2=0, U=0, sz=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_o1_1_max_a800_5e21b800() {
    // Encoding: 0x5E21B800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field o1 = 1 (Max)
    // Fields: o2=0, sz=0, U=0, o1=1, Rn=0, Rd=0
    let encoding: u32 = 0x5E21B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rn_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rn = 0 (Min)
    // Fields: sz=0, Rd=0, U=0, o1=0, o2=0, Rn=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rn_1_poweroftwo_a800_5e21a820() {
    // Encoding: 0x5E21A820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rn = 1 (PowerOfTwo)
    // Fields: o2=0, sz=0, U=0, o1=0, Rn=1, Rd=0
    let encoding: u32 = 0x5E21A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rn_30_poweroftwominusone_a800_5e21abc0() {
    // Encoding: 0x5E21ABC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, o1=0, sz=0, U=0, o2=0, Rn=30
    let encoding: u32 = 0x5E21ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rn_31_max_a800_5e21abe0() {
    // Encoding: 0x5E21ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rn = 31 (Max)
    // Fields: o1=0, Rn=31, U=0, Rd=0, o2=0, sz=0
    let encoding: u32 = 0x5E21ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rd_0_min_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rd = 0 (Min)
    // Fields: o2=0, Rd=0, Rn=0, U=0, o1=0, sz=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rd_1_poweroftwo_a800_5e21a801() {
    // Encoding: 0x5E21A801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, o2=0, o1=0, Rd=1, U=0, Rn=0
    let encoding: u32 = 0x5E21A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rd_30_poweroftwominusone_a800_5e21a81e() {
    // Encoding: 0x5E21A81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, o1=0, U=0, o2=0, sz=0
    let encoding: u32 = 0x5E21A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_field_rd_31_max_a800_5e21a81f() {
    // Encoding: 0x5E21A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, o1=0, U=0, o2=0, sz=0
    let encoding: u32 = 0x5E21A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_0_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_1_a800_7e21a800() {
    // Encoding: 0x7E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=1, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, o1=0, Rd=0, U=1, o2=0
    let encoding: u32 = 0x7E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_2_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, sz=0, U=0, o2=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_3_a800_5ea1a800() {
    // Encoding: 0x5EA1A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=1, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, o2=1, Rd=0, sz=0, U=0
    let encoding: u32 = 0x5EA1A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_4_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, sz=0, U=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_5_a800_5e61a800() {
    // Encoding: 0x5E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=1, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, o2=0, sz=1, U=0, o1=0
    let encoding: u32 = 0x5E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_6_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, o1=0, Rn=0, U=0, Rd=0, sz=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_7_a800_5e21b800() {
    // Encoding: 0x5E21B800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=1, Rn=0, Rd=0
    // Fields: o1=1, Rn=0, Rd=0, o2=0, U=0, sz=0
    let encoding: u32 = 0x5E21B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_8_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, o1=0, Rd=0, Rn=0, U=0, sz=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_9_a800_5e21a820() {
    // Encoding: 0x5E21A820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=1, Rd=0
    // Fields: o2=0, U=0, Rn=1, o1=0, sz=0, Rd=0
    let encoding: u32 = 0x5E21A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_10_a800_5e21abc0() {
    // Encoding: 0x5E21ABC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=30, Rd=0
    // Fields: sz=0, U=0, o2=0, Rn=30, o1=0, Rd=0
    let encoding: u32 = 0x5E21ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_11_a800_5e21abe0() {
    // Encoding: 0x5E21ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, o2=0, o1=0, sz=0, U=0
    let encoding: u32 = 0x5E21ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_12_a800_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, o1=0, Rn=0, sz=0, o2=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_13_a800_5e21a801() {
    // Encoding: 0x5E21A801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=1
    // Fields: o1=0, Rd=1, U=0, Rn=0, o2=0, sz=0
    let encoding: u32 = 0x5E21A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_14_a800_5e21a81e() {
    // Encoding: 0x5E21A81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=30
    // Fields: o1=0, sz=0, U=0, Rd=30, o2=0, Rn=0
    let encoding: u32 = 0x5E21A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_15_a800_5e21a81f() {
    // Encoding: 0x5E21A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=0, Rd=31
    // Fields: o2=0, o1=0, Rd=31, sz=0, U=0, Rn=0
    let encoding: u32 = 0x5E21A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_16_a800_5e21a821() {
    // Encoding: 0x5E21A821
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=1, Rd=1
    // Fields: o1=0, U=0, Rd=1, Rn=1, o2=0, sz=0
    let encoding: u32 = 0x5E21A821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_combo_17_a800_5e21abff() {
    // Encoding: 0x5E21ABFF
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd field combination: U=0, o2=0, sz=0, o1=0, Rn=31, Rd=31
    // Fields: o2=0, Rd=31, sz=0, U=0, o1=0, Rn=31
    let encoding: u32 = 0x5E21ABFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_special_sz_0_size_variant_0_43008_5e21a800() {
    // Encoding: 0x5E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd special value sz = 0 (Size variant 0)
    // Fields: Rn=0, sz=0, o1=0, Rd=0, U=0, o2=0
    let encoding: u32 = 0x5E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_special_sz_1_size_variant_1_43008_5e61a800() {
    // Encoding: 0x5E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd special value sz = 1 (Size variant 1)
    // Fields: o2=0, o1=0, Rn=0, U=0, Rd=0, sz=1
    let encoding: u32 = 0x5E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_43008_5e61abe0() {
    // Encoding: 0x5E61ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, o1=0, Rd=0, Rn=31, sz=1, o2=0
    let encoding: u32 = 0x5E61ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_43008_5e61a81f() {
    // Encoding: 0x5E61A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o2=0, sz=1, U=0, Rd=31, Rn=0, o1=0
    let encoding: u32 = 0x5E61A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_q_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Q = 0 (Min)
    // Fields: Q=0, o1=0, U=0, Rd=0, Rn=0, o2=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_q_1_max_a800_4e79a800() {
    // Encoding: 0x4E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Q = 1 (Max)
    // Fields: Q=1, o1=0, Rn=0, U=0, o2=0, Rd=0
    let encoding: u32 = 0x4E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_u_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field U = 0 (Min)
    // Fields: Rd=0, o2=0, U=0, Q=0, o1=0, Rn=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_u_1_max_a800_2e79a800() {
    // Encoding: 0x2E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field U = 1 (Max)
    // Fields: o1=0, U=1, Q=0, Rd=0, o2=0, Rn=0
    let encoding: u32 = 0x2E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_o2_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field o2 = 0 (Min)
    // Fields: o1=0, Rd=0, Q=0, U=0, Rn=0, o2=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_o2_1_max_a800_0ef9a800() {
    // Encoding: 0x0EF9A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field o2 = 1 (Max)
    // Fields: Rn=0, Q=0, o1=0, U=0, Rd=0, o2=1
    let encoding: u32 = 0x0EF9A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_o1_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field o1 = 0 (Min)
    // Fields: Q=0, U=0, o1=0, o2=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_o1_1_max_a800_0e79b800() {
    // Encoding: 0x0E79B800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field o1 = 1 (Max)
    // Fields: o2=0, Rn=0, o1=1, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E79B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rn_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0, o1=0, U=0, o2=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rn_1_poweroftwo_a800_0e79a820() {
    // Encoding: 0x0E79A820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, U=0, Q=0, o2=0, o1=0, Rd=0
    let encoding: u32 = 0x0E79A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rn_30_poweroftwominusone_a800_0e79abc0() {
    // Encoding: 0x0E79ABC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, U=0, Q=0, o1=0, Rn=30, o2=0
    let encoding: u32 = 0x0E79ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rn_31_max_a800_0e79abe0() {
    // Encoding: 0x0E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rd=0, U=0, o1=0, o2=0
    let encoding: u32 = 0x0E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rd_0_min_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rd = 0 (Min)
    // Fields: o2=0, U=0, Rn=0, Q=0, o1=0, Rd=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rd_1_poweroftwo_a800_0e79a801() {
    // Encoding: 0x0E79A801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, o2=0, Q=0, o1=0, Rn=0, U=0
    let encoding: u32 = 0x0E79A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rd_30_poweroftwominusone_a800_0e79a81e() {
    // Encoding: 0x0E79A81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, Q=0, Rn=0, o1=0, o2=0
    let encoding: u32 = 0x0E79A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_field_rd_31_max_a800_0e79a81f() {
    // Encoding: 0x0E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field Rd = 31 (Max)
    // Fields: U=0, o2=0, o1=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_0_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Q=0, o2=0, o1=0, Rn=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_1_a800_4e79a800() {
    // Encoding: 0x4E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=1, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, o2=0, U=0, Q=1, o1=0, Rn=0
    let encoding: u32 = 0x4E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_2_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, o2=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_3_a800_2e79a800() {
    // Encoding: 0x2E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=1, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, o1=0, Rn=0, U=1, o2=0, Rd=0
    let encoding: u32 = 0x2E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_4_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, o2=0, Q=0, Rn=0, o1=0, Rd=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_5_a800_0ef9a800() {
    // Encoding: 0x0EF9A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=1, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, o2=1, o1=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0EF9A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_6_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, Rd=0, Q=0, U=0, o2=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_7_a800_0e79b800() {
    // Encoding: 0x0E79B800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=1, Rn=0, Rd=0
    // Fields: o2=0, o1=1, Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E79B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_8_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, Q=0, Rd=0, o1=0, o2=0, Rn=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_9_a800_0e79a820() {
    // Encoding: 0x0E79A820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=1, Rd=0
    // Fields: o1=0, U=0, Q=0, Rn=1, Rd=0, o2=0
    let encoding: u32 = 0x0E79A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_10_a800_0e79abc0() {
    // Encoding: 0x0E79ABC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=30, Rd=0
    // Fields: U=0, o1=0, Rd=0, Rn=30, Q=0, o2=0
    let encoding: u32 = 0x0E79ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_11_a800_0e79abe0() {
    // Encoding: 0x0E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, U=0, o2=0, Rn=31, o1=0
    let encoding: u32 = 0x0E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_12_a800_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, o1=0, o2=0, U=0, Rn=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_13_a800_0e79a801() {
    // Encoding: 0x0E79A801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=1
    // Fields: U=0, Q=0, o1=0, Rd=1, o2=0, Rn=0
    let encoding: u32 = 0x0E79A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_14_a800_0e79a81e() {
    // Encoding: 0x0E79A81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=30
    // Fields: o1=0, Q=0, o2=0, Rn=0, Rd=30, U=0
    let encoding: u32 = 0x0E79A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_15_a800_0e79a81f() {
    // Encoding: 0x0E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=0, Rd=31
    // Fields: U=0, Q=0, Rn=0, o1=0, o2=0, Rd=31
    let encoding: u32 = 0x0E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_16_a800_0e79a821() {
    // Encoding: 0x0E79A821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=1, Rd=1
    // Fields: Q=0, o2=0, o1=0, U=0, Rn=1, Rd=1
    let encoding: u32 = 0x0E79A821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_combo_17_a800_0e79abff() {
    // Encoding: 0x0E79ABFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, o1=0, Rn=31, Rd=31
    // Fields: Q=0, o2=0, Rn=31, Rd=31, o1=0, U=0
    let encoding: u32 = 0x0E79ABFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_special_q_0_size_variant_0_43008_0e79a800() {
    // Encoding: 0x0E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd special value Q = 0 (Size variant 0)
    // Fields: U=0, o1=0, Rn=0, Q=0, Rd=0, o2=0
    let encoding: u32 = 0x0E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_special_q_1_size_variant_1_43008_4e79a800() {
    // Encoding: 0x4E79A800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd special value Q = 1 (Size variant 1)
    // Fields: o1=0, Rn=0, Rd=0, Q=1, U=0, o2=0
    let encoding: u32 = 0x4E79A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_special_rn_31_stack_pointer_sp_may_require_alignment_43008_0e79abe0() {
    // Encoding: 0x0E79ABE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: o1=0, Rd=0, o2=0, Q=0, U=0, Rn=31
    let encoding: u32 = 0x0E79ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_43008_0e79a81f() {
    // Encoding: 0x0E79A81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o1=0, Rn=0, Q=0, Rd=31, o2=0, U=0
    let encoding: u32 = 0x0E79A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_q_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Q = 0 (Min)
    // Fields: sz=0, U=0, Rd=0, o2=0, o1=0, Q=0, Rn=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_q_1_max_a800_4e21a800() {
    // Encoding: 0x4E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Q = 1 (Max)
    // Fields: Rn=0, Rd=0, o2=0, Q=1, U=0, sz=0, o1=0
    let encoding: u32 = 0x4E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_u_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field U = 0 (Min)
    // Fields: Q=0, sz=0, U=0, o1=0, Rn=0, Rd=0, o2=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_u_1_max_a800_2e21a800() {
    // Encoding: 0x2E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field U = 1 (Max)
    // Fields: Rn=0, sz=0, o1=0, Rd=0, o2=0, Q=0, U=1
    let encoding: u32 = 0x2E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_o2_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field o2 = 0 (Min)
    // Fields: o2=0, sz=0, U=0, o1=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field o2 23 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_o2_1_max_a800_0ea1a800() {
    // Encoding: 0x0EA1A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field o2 = 1 (Max)
    // Fields: U=0, Rd=0, o2=1, sz=0, o1=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA1A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_sz_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field sz = 0 (Min)
    // Fields: o2=0, Rd=0, o1=0, Q=0, Rn=0, sz=0, U=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_sz_1_max_a800_0e61a800() {
    // Encoding: 0x0E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field sz = 1 (Max)
    // Fields: Rd=0, o2=0, sz=1, o1=0, U=0, Rn=0, Q=0
    let encoding: u32 = 0x0E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_o1_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field o1 = 0 (Min)
    // Fields: U=0, o2=0, Rn=0, Rd=0, Q=0, sz=0, o1=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field o1 12 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_o1_1_max_a800_0e21b800() {
    // Encoding: 0x0E21B800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field o1 = 1 (Max)
    // Fields: Q=0, Rd=0, o1=1, o2=0, Rn=0, U=0, sz=0
    let encoding: u32 = 0x0E21B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rn_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rn = 0 (Min)
    // Fields: Rd=0, o2=0, sz=0, o1=0, U=0, Rn=0, Q=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rn_1_poweroftwo_a800_0e21a820() {
    // Encoding: 0x0E21A820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, U=0, o2=0, Q=0, o1=0, sz=0
    let encoding: u32 = 0x0E21A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rn_30_poweroftwominusone_a800_0e21abc0() {
    // Encoding: 0x0E21ABC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Q=0, o1=0, Rd=0, o2=0, U=0
    let encoding: u32 = 0x0E21ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rn_31_max_a800_0e21abe0() {
    // Encoding: 0x0E21ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rn = 31 (Max)
    // Fields: o2=0, Rn=31, o1=0, sz=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E21ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rd_0_min_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rd = 0 (Min)
    // Fields: sz=0, U=0, o1=0, Rd=0, Rn=0, Q=0, o2=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rd_1_poweroftwo_a800_0e21a801() {
    // Encoding: 0x0E21A801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, sz=0, Rd=1, Rn=0, o1=0, Q=0, o2=0
    let encoding: u32 = 0x0E21A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rd_30_poweroftwominusone_a800_0e21a81e() {
    // Encoding: 0x0E21A81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, U=0, o2=0, o1=0, Rn=0, Rd=30, Q=0
    let encoding: u32 = 0x0E21A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_field_rd_31_max_a800_0e21a81f() {
    // Encoding: 0x0E21A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field Rd = 31 (Max)
    // Fields: Q=0, U=0, o2=0, o1=0, Rn=0, sz=0, Rd=31
    let encoding: u32 = 0x0E21A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_0_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, Rn=0, Rd=0, Q=0, U=0, sz=0, o1=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_1_a800_4e21a800() {
    // Encoding: 0x4E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=1, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, o2=0, sz=0, Rd=0, U=0, Q=1
    let encoding: u32 = 0x4E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_2_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, sz=0, Q=0, U=0, o2=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_3_a800_2e21a800() {
    // Encoding: 0x2E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=1, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, Rd=0, Q=0, sz=0, U=1, o2=0
    let encoding: u32 = 0x2E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_4_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, U=0, Q=0, sz=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o2=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_5_a800_0ea1a800() {
    // Encoding: 0x0EA1A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=1, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rd=0, sz=0, o1=0, Rn=0, o2=1
    let encoding: u32 = 0x0EA1A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_6_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, U=0, sz=0, Rd=0, o1=0, Q=0, Rn=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_7_a800_0e61a800() {
    // Encoding: 0x0E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=1, o1=0, Rn=0, Rd=0
    // Fields: Q=0, sz=1, U=0, Rn=0, Rd=0, o2=0, o1=0
    let encoding: u32 = 0x0E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_8_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: sz=0, o1=0, Rn=0, Rd=0, U=0, Q=0, o2=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_9_a800_0e21b800() {
    // Encoding: 0x0E21B800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=1, Rn=0, Rd=0
    // Fields: U=0, o2=0, Rn=0, Rd=0, sz=0, Q=0, o1=1
    let encoding: u32 = 0x0E21B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_10_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, o2=0, U=0, sz=0, o1=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_11_a800_0e21a820() {
    // Encoding: 0x0E21A820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=1, Rd=0
    // Fields: Rd=0, o2=0, o1=0, Rn=1, sz=0, Q=0, U=0
    let encoding: u32 = 0x0E21A820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_12_a800_0e21abc0() {
    // Encoding: 0x0E21ABC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=30, Rd=0
    // Fields: o1=0, sz=0, Rn=30, U=0, Rd=0, o2=0, Q=0
    let encoding: u32 = 0x0E21ABC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_13_a800_0e21abe0() {
    // Encoding: 0x0E21ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, U=0, Q=0, sz=0, o2=0, o1=0
    let encoding: u32 = 0x0E21ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_14_a800_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=0
    // Fields: o2=0, sz=0, o1=0, Rn=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_15_a800_0e21a801() {
    // Encoding: 0x0E21A801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=1
    // Fields: sz=0, Q=0, o1=0, Rd=1, Rn=0, U=0, o2=0
    let encoding: u32 = 0x0E21A801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_16_a800_0e21a81e() {
    // Encoding: 0x0E21A81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=30
    // Fields: o2=0, Q=0, o1=0, Rn=0, sz=0, U=0, Rd=30
    let encoding: u32 = 0x0E21A81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_17_a800_0e21a81f() {
    // Encoding: 0x0E21A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=0, Rd=31
    // Fields: U=0, Q=0, sz=0, o1=0, Rn=0, o2=0, Rd=31
    let encoding: u32 = 0x0E21A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_18_a800_0e21a821() {
    // Encoding: 0x0E21A821
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=1, Rd=1
    // Fields: o1=0, Rn=1, Rd=1, Q=0, o2=0, sz=0, U=0
    let encoding: u32 = 0x0E21A821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_combo_19_a800_0e21abff() {
    // Encoding: 0x0E21ABFF
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd field combination: Q=0, U=0, o2=0, sz=0, o1=0, Rn=31, Rd=31
    // Fields: o1=0, o2=0, U=0, Q=0, Rd=31, sz=0, Rn=31
    let encoding: u32 = 0x0E21ABFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_q_0_size_variant_0_43008_0e61a800() {
    // Encoding: 0x0E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, sz=1, Rd=0, o2=0, o1=0, Rn=0, U=0
    let encoding: u32 = 0x0E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_q_1_size_variant_1_43008_4e61a800() {
    // Encoding: 0x4E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, o1=0, U=0, Rd=0, Q=1, sz=1, o2=0
    let encoding: u32 = 0x4E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_sz_0_size_variant_0_43008_0e21a800() {
    // Encoding: 0x0E21A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value sz = 0 (Size variant 0)
    // Fields: o1=0, Rn=0, Q=0, sz=0, Rd=0, U=0, o2=0
    let encoding: u32 = 0x0E21A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_sz_1_size_variant_1_43008_0e61a800() {
    // Encoding: 0x0E61A800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value sz = 1 (Size variant 1)
    // Fields: Rd=0, o2=0, o1=0, sz=1, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E61A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_rn_31_stack_pointer_sp_may_require_alignment_43008_0e61abe0() {
    // Encoding: 0x0E61ABE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: o1=0, Rn=31, Q=0, Rd=0, U=0, o2=0, sz=1
    let encoding: u32 = 0x0E61ABE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_43008_0e61a81f() {
    // Encoding: 0x0E61A81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, o2=0, sz=1, Rn=0, o1=0, U=0, Rd=31
    let encoding: u32 = 0x0E61A81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_reg_write_0_5e79a800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd register write: SimdFromField("d")
    // Encoding: 0x5E79A800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79A800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_sp_rn_5e79abe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd with Rn = SP (31)
    // Encoding: 0x5E79ABE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79ABE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd_zr_rd_5e79a81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_sisd with Rd = ZR (31)
    // Encoding: 0x5E79A81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79A81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_reg_write_0_5e21a800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd register write: SimdFromField("d")
    // Encoding: 0x5E21A800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21A800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_sp_rn_5e21abe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd with Rn = SP (31)
    // Encoding: 0x5E21ABE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21ABE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd_zr_rd_5e21a81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_sisd with Rd = ZR (31)
    // Encoding: 0x5E21A81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21A81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_reg_write_0_0e79a800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd register write: SimdFromField("d")
    // Encoding: 0x0E79A800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79A800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_sp_rn_0e79abe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd with Rn = SP (31)
    // Encoding: 0x0E79ABE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79ABE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd_zr_rd_0e79a81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_bulk_simd with Rd = ZR (31)
    // Encoding: 0x0E79A81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79A81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_reg_write_0_0e21a800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd register write: SimdFromField("d")
    // Encoding: 0x0E21A800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21A800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_sp_rn_0e21abe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd with Rn = SP (31)
    // Encoding: 0x0E21ABE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21ABE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd_zr_rd_0e21a81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_bulk_simd with Rd = ZR (31)
    // Encoding: 0x0E21A81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21A81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_extract_sqxtun_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_size_0_min_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field size = 0 (Min)
    // Fields: Rn=0, size=0, Rd=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_size_1_poweroftwo_2800_7e612800() {
    // Encoding: 0x7E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field size = 1 (PowerOfTwo)
    // Fields: size=1, Rn=0, Rd=0
    let encoding: u32 = 0x7E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_size_2_poweroftwo_2800_7ea12800() {
    // Encoding: 0x7EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field size = 2 (PowerOfTwo)
    // Fields: Rd=0, size=2, Rn=0
    let encoding: u32 = 0x7EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_size_3_max_2800_7ee12800() {
    // Encoding: 0x7EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field size = 3 (Max)
    // Fields: Rn=0, size=3, Rd=0
    let encoding: u32 = 0x7EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rn_0_min_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0, size=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rn_1_poweroftwo_2800_7e212820() {
    // Encoding: 0x7E212820
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, size=0, Rn=1
    let encoding: u32 = 0x7E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rn_30_poweroftwominusone_2800_7e212bc0() {
    // Encoding: 0x7E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, size=0
    let encoding: u32 = 0x7E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rn_31_max_2800_7e212be0() {
    // Encoding: 0x7E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rn = 31 (Max)
    // Fields: size=0, Rn=31, Rd=0
    let encoding: u32 = 0x7E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rd_0_min_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rd = 0 (Min)
    // Fields: size=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rd_1_poweroftwo_2800_7e212801() {
    // Encoding: 0x7E212801
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, size=0
    let encoding: u32 = 0x7E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rd_30_poweroftwominusone_2800_7e21281e() {
    // Encoding: 0x7E21281E
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, size=0
    let encoding: u32 = 0x7E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_field_rd_31_max_2800_7e21281f() {
    // Encoding: 0x7E21281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field Rd = 31 (Max)
    // Fields: size=0, Rn=0, Rd=31
    let encoding: u32 = 0x7E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_0_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_1_2800_7e612800() {
    // Encoding: 0x7E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=1, Rn=0, Rd=0
    // Fields: Rn=0, size=1, Rd=0
    let encoding: u32 = 0x7E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_2_2800_7ea12800() {
    // Encoding: 0x7EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=2, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, size=2
    let encoding: u32 = 0x7EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_3_2800_7ee12800() {
    // Encoding: 0x7EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=3, Rn=0, Rd=0
    // Fields: Rd=0, size=3, Rn=0
    let encoding: u32 = 0x7EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_4_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_5_2800_7e212820() {
    // Encoding: 0x7E212820
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=1, Rd=0
    // Fields: size=0, Rn=1, Rd=0
    let encoding: u32 = 0x7E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_6_2800_7e212bc0() {
    // Encoding: 0x7E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=30, Rd=0
    // Fields: size=0, Rd=0, Rn=30
    let encoding: u32 = 0x7E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_7_2800_7e212be0() {
    // Encoding: 0x7E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=31, Rd=0
    // Fields: Rd=0, size=0, Rn=31
    let encoding: u32 = 0x7E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_8_2800_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, Rn=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_9_2800_7e212801() {
    // Encoding: 0x7E212801
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=1
    // Fields: size=0, Rn=0, Rd=1
    let encoding: u32 = 0x7E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_10_2800_7e21281e() {
    // Encoding: 0x7E21281E
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=30
    // Fields: size=0, Rn=0, Rd=30
    let encoding: u32 = 0x7E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_11_2800_7e21281f() {
    // Encoding: 0x7E21281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=0, Rd=31
    // Fields: Rd=31, size=0, Rn=0
    let encoding: u32 = 0x7E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_12_2800_7e212821() {
    // Encoding: 0x7E212821
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=1, Rd=1
    // Fields: Rd=1, Rn=1, size=0
    let encoding: u32 = 0x7E212821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_combo_13_2800_7e212bff() {
    // Encoding: 0x7E212BFF
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd field combination: size=0, Rn=31, Rd=31
    // Fields: Rd=31, Rn=31, size=0
    let encoding: u32 = 0x7E212BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_size_0_size_variant_0_10240_7e212800() {
    // Encoding: 0x7E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value size = 0 (Size variant 0)
    // Fields: size=0, Rd=0, Rn=0
    let encoding: u32 = 0x7E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_size_1_size_variant_1_10240_7e612800() {
    // Encoding: 0x7E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value size = 1 (Size variant 1)
    // Fields: Rn=0, size=1, Rd=0
    let encoding: u32 = 0x7E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_size_2_size_variant_2_10240_7ea12800() {
    // Encoding: 0x7EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value size = 2 (Size variant 2)
    // Fields: Rn=0, size=2, Rd=0
    let encoding: u32 = 0x7EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_size_3_size_variant_3_10240_7ee12800() {
    // Encoding: 0x7EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rd=0, size=3
    let encoding: u32 = 0x7EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_10240_7e612be0() {
    // Encoding: 0x7E612BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=1, Rn=31, Rd=0
    let encoding: u32 = 0x7E612BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_10240_7e61281f() {
    // Encoding: 0x7E61281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, size=1, Rn=0
    let encoding: u32 = 0x7E61281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_q_0_min_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Q = 0 (Min)
    // Fields: Q=0, size=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_q_1_max_2800_6e212800() {
    // Encoding: 0x6E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Q = 1 (Max)
    // Fields: size=0, Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x6E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_size_0_min_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field size = 0 (Min)
    // Fields: Q=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_size_1_poweroftwo_2800_2e612800() {
    // Encoding: 0x2E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field size = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rd=0, size=1
    let encoding: u32 = 0x2E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_size_2_poweroftwo_2800_2ea12800() {
    // Encoding: 0x2EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field size = 2 (PowerOfTwo)
    // Fields: size=2, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_size_3_max_2800_2ee12800() {
    // Encoding: 0x2EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field size = 3 (Max)
    // Fields: size=3, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rn_0_min_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rn = 0 (Min)
    // Fields: size=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rn_1_poweroftwo_2800_2e212820() {
    // Encoding: 0x2E212820
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, Rd=0, Rn=1
    let encoding: u32 = 0x2E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rn_30_poweroftwominusone_2800_2e212bc0() {
    // Encoding: 0x2E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=30, Q=0, size=0
    let encoding: u32 = 0x2E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rn_31_max_2800_2e212be0() {
    // Encoding: 0x2E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rn = 31 (Max)
    // Fields: Q=0, Rd=0, size=0, Rn=31
    let encoding: u32 = 0x2E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rd_0_min_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rd = 0 (Min)
    // Fields: Q=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rd_1_poweroftwo_2800_2e212801() {
    // Encoding: 0x2E212801
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Q=0, size=0, Rn=0
    let encoding: u32 = 0x2E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rd_30_poweroftwominusone_2800_2e21281e() {
    // Encoding: 0x2E21281E
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Q=0, Rd=30, size=0
    let encoding: u32 = 0x2E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_field_rd_31_max_2800_2e21281f() {
    // Encoding: 0x2E21281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field Rd = 31 (Max)
    // Fields: size=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x2E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_0_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_1_2800_6e212800() {
    // Encoding: 0x6E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=1, size=0, Rn=0, Rd=0
    // Fields: Q=1, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x6E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_2_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_3_2800_2e612800() {
    // Encoding: 0x2E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=1, Rn=0, Rd=0
    // Fields: Rn=0, size=1, Rd=0, Q=0
    let encoding: u32 = 0x2E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_4_2800_2ea12800() {
    // Encoding: 0x2EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=2, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, size=2, Rd=0
    let encoding: u32 = 0x2EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_5_2800_2ee12800() {
    // Encoding: 0x2EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=3, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, size=3
    let encoding: u32 = 0x2EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_6_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_7_2800_2e212820() {
    // Encoding: 0x2E212820
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=1, Rd=0
    // Fields: Q=0, Rn=1, size=0, Rd=0
    let encoding: u32 = 0x2E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_8_2800_2e212bc0() {
    // Encoding: 0x2E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=30, Rd=0
    // Fields: Q=0, size=0, Rn=30, Rd=0
    let encoding: u32 = 0x2E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_9_2800_2e212be0() {
    // Encoding: 0x2E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=31, Rd=0
    // Fields: Q=0, Rn=31, size=0, Rd=0
    let encoding: u32 = 0x2E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_10_2800_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_11_2800_2e212801() {
    // Encoding: 0x2E212801
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=1
    // Fields: Rn=0, size=0, Q=0, Rd=1
    let encoding: u32 = 0x2E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_12_2800_2e21281e() {
    // Encoding: 0x2E21281E
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=30
    // Fields: Rd=30, Q=0, Rn=0, size=0
    let encoding: u32 = 0x2E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_13_2800_2e21281f() {
    // Encoding: 0x2E21281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=0, Rd=31
    // Fields: Rd=31, Q=0, size=0, Rn=0
    let encoding: u32 = 0x2E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_14_2800_2e212821() {
    // Encoding: 0x2E212821
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, Rd=1, size=0
    let encoding: u32 = 0x2E212821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_combo_15_2800_2e212bff() {
    // Encoding: 0x2E212BFF
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd field combination: Q=0, size=0, Rn=31, Rd=31
    // Fields: Rn=31, size=0, Rd=31, Q=0
    let encoding: u32 = 0x2E212BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_q_0_size_variant_0_10240_2e612800() {
    // Encoding: 0x2E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value Q = 0 (Size variant 0)
    // Fields: size=1, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_q_1_size_variant_1_10240_6e612800() {
    // Encoding: 0x6E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value Q = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x6E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_size_0_size_variant_0_10240_2e212800() {
    // Encoding: 0x2E212800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value size = 0 (Size variant 0)
    // Fields: Q=0, Rd=0, Rn=0, size=0
    let encoding: u32 = 0x2E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_size_1_size_variant_1_10240_2e612800() {
    // Encoding: 0x2E612800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value size = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Q=0, size=1
    let encoding: u32 = 0x2E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_size_2_size_variant_2_10240_2ea12800() {
    // Encoding: 0x2EA12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value size = 2 (Size variant 2)
    // Fields: Rn=0, Q=0, Rd=0, size=2
    let encoding: u32 = 0x2EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_size_3_size_variant_3_10240_2ee12800() {
    // Encoding: 0x2EE12800
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, size=3, Rd=0, Rn=0
    let encoding: u32 = 0x2EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_rn_31_stack_pointer_sp_may_require_alignment_10240_2e612be0() {
    // Encoding: 0x2E612BE0
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, size=1, Q=0, Rn=31
    let encoding: u32 = 0x2E612BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_10240_2e61281f() {
    // Encoding: 0x2E61281F
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, size=1, Rn=0, Rd=31
    let encoding: u32 = 0x2E61281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_sp_rn_7e212be0() {
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd with Rn = SP (31)
    // Encoding: 0x7E212BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E212BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_sisd_zr_rd_7e21281f() {
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_sisd with Rd = ZR (31)
    // Encoding: 0x7E21281F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E21281F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_sp_rn_2e212be0() {
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd with Rn = SP (31)
    // Encoding: 0x2E212BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E212BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_sqxtun_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_sqxtun_simd_zr_rd_2e21281f() {
    // Test aarch64_vector_arithmetic_unary_extract_sqxtun_simd with Rd = ZR (31)
    // Encoding: 0x2E21281F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E21281F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_diff_neg_int_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_u_0_min_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field U = 0 (Min)
    // Fields: size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_u_1_max_b800_7e20b800() {
    // Encoding: 0x7E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field U = 1 (Max)
    // Fields: Rn=0, U=1, size=0, Rd=0
    let encoding: u32 = 0x7E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_size_0_min_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field size = 0 (Min)
    // Fields: Rd=0, U=0, size=0, Rn=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_size_1_poweroftwo_b800_5e60b800() {
    // Encoding: 0x5E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field size = 1 (PowerOfTwo)
    // Fields: U=0, size=1, Rd=0, Rn=0
    let encoding: u32 = 0x5E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_size_2_poweroftwo_b800_5ea0b800() {
    // Encoding: 0x5EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field size = 2 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, U=0, size=2
    let encoding: u32 = 0x5EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_size_3_max_b800_5ee0b800() {
    // Encoding: 0x5EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field size = 3 (Max)
    // Fields: U=0, size=3, Rn=0, Rd=0
    let encoding: u32 = 0x5EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rn_0_min_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rn = 0 (Min)
    // Fields: Rn=0, U=0, Rd=0, size=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rn_1_poweroftwo_b800_5e20b820() {
    // Encoding: 0x5E20B820
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rn = 1 (PowerOfTwo)
    // Fields: size=0, U=0, Rn=1, Rd=0
    let encoding: u32 = 0x5E20B820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rn_30_poweroftwominusone_b800_5e20bbc0() {
    // Encoding: 0x5E20BBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, size=0, Rn=30, U=0
    let encoding: u32 = 0x5E20BBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rn_31_max_b800_5e20bbe0() {
    // Encoding: 0x5E20BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rn = 31 (Max)
    // Fields: Rn=31, U=0, Rd=0, size=0
    let encoding: u32 = 0x5E20BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rd_0_min_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rd = 0 (Min)
    // Fields: size=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rd_1_poweroftwo_b800_5e20b801() {
    // Encoding: 0x5E20B801
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Rn=0, Rd=1, U=0
    let encoding: u32 = 0x5E20B801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rd_30_poweroftwominusone_b800_5e20b81e() {
    // Encoding: 0x5E20B81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, size=0, Rn=0
    let encoding: u32 = 0x5E20B81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_field_rd_31_max_b800_5e20b81f() {
    // Encoding: 0x5E20B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field Rd = 31 (Max)
    // Fields: size=0, U=0, Rd=31, Rn=0
    let encoding: u32 = 0x5E20B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_0_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, U=0, size=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_1_b800_7e20b800() {
    // Encoding: 0x7E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=1, size=0, Rn=0, Rd=0
    // Fields: U=1, size=0, Rd=0, Rn=0
    let encoding: u32 = 0x7E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_2_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, U=0, size=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_3_b800_5e60b800() {
    // Encoding: 0x5E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=1, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Rd=0, size=1
    let encoding: u32 = 0x5E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_4_b800_5ea0b800() {
    // Encoding: 0x5EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=2, Rn=0, Rd=0
    // Fields: size=2, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_5_b800_5ee0b800() {
    // Encoding: 0x5EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=3, Rn=0, Rd=0
    // Fields: size=3, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_6_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_7_b800_5e20b820() {
    // Encoding: 0x5E20B820
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=1, Rd=0
    // Fields: size=0, Rn=1, Rd=0, U=0
    let encoding: u32 = 0x5E20B820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_8_b800_5e20bbc0() {
    // Encoding: 0x5E20BBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, U=0, size=0
    let encoding: u32 = 0x5E20BBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_9_b800_5e20bbe0() {
    // Encoding: 0x5E20BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=31, Rd=0
    // Fields: size=0, Rd=0, U=0, Rn=31
    let encoding: u32 = 0x5E20BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_10_b800_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_11_b800_5e20b801() {
    // Encoding: 0x5E20B801
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, size=0, Rd=1
    let encoding: u32 = 0x5E20B801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_12_b800_5e20b81e() {
    // Encoding: 0x5E20B81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=30
    // Fields: U=0, size=0, Rn=0, Rd=30
    let encoding: u32 = 0x5E20B81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_13_b800_5e20b81f() {
    // Encoding: 0x5E20B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=0, Rd=31
    // Fields: Rn=0, U=0, Rd=31, size=0
    let encoding: u32 = 0x5E20B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_14_b800_5e20b821() {
    // Encoding: 0x5E20B821
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=1, Rd=1
    // Fields: U=0, size=0, Rn=1, Rd=1
    let encoding: u32 = 0x5E20B821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_combo_15_b800_5e20bbff() {
    // Encoding: 0x5E20BBFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd field combination: U=0, size=0, Rn=31, Rd=31
    // Fields: U=0, Rd=31, size=0, Rn=31
    let encoding: u32 = 0x5E20BBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_size_0_size_variant_0_47104_5e20b800() {
    // Encoding: 0x5E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value size = 0 (Size variant 0)
    // Fields: U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_size_1_size_variant_1_47104_5e60b800() {
    // Encoding: 0x5E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value size = 1 (Size variant 1)
    // Fields: Rn=0, U=0, size=1, Rd=0
    let encoding: u32 = 0x5E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_size_2_size_variant_2_47104_5ea0b800() {
    // Encoding: 0x5EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value size = 2 (Size variant 2)
    // Fields: size=2, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_size_3_size_variant_3_47104_5ee0b800() {
    // Encoding: 0x5EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value size = 3 (Size variant 3)
    // Fields: size=3, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_47104_5e60bbe0() {
    // Encoding: 0x5E60BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, U=0, size=1, Rn=31
    let encoding: u32 = 0x5E60BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_47104_5e60b81f() {
    // Encoding: 0x5E60B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, size=1, U=0, Rd=31
    let encoding: u32 = 0x5E60B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_q_0_min_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Q = 0 (Min)
    // Fields: Q=0, Rn=0, U=0, Rd=0, size=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_q_1_max_b800_4e20b800() {
    // Encoding: 0x4E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Q = 1 (Max)
    // Fields: size=0, Rd=0, Q=1, U=0, Rn=0
    let encoding: u32 = 0x4E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_u_0_min_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field U = 0 (Min)
    // Fields: Rn=0, U=0, size=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_u_1_max_b800_2e20b800() {
    // Encoding: 0x2E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field U = 1 (Max)
    // Fields: Rd=0, Q=0, U=1, size=0, Rn=0
    let encoding: u32 = 0x2E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_size_0_min_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field size = 0 (Min)
    // Fields: Rd=0, U=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_size_1_poweroftwo_b800_0e60b800() {
    // Encoding: 0x0E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field size = 1 (PowerOfTwo)
    // Fields: size=1, U=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_size_2_poweroftwo_b800_0ea0b800() {
    // Encoding: 0x0EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field size = 2 (PowerOfTwo)
    // Fields: Q=0, U=0, size=2, Rn=0, Rd=0
    let encoding: u32 = 0x0EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_size_3_max_b800_0ee0b800() {
    // Encoding: 0x0EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field size = 3 (Max)
    // Fields: Rd=0, Q=0, U=0, size=3, Rn=0
    let encoding: u32 = 0x0EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rn_0_min_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rn = 0 (Min)
    // Fields: Rd=0, U=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rn_1_poweroftwo_b800_0e20b820() {
    // Encoding: 0x0E20B820
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=1, size=0, U=0, Rd=0
    let encoding: u32 = 0x0E20B820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rn_30_poweroftwominusone_b800_0e20bbc0() {
    // Encoding: 0x0E20BBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, U=0, Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x0E20BBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rn_31_max_b800_0e20bbe0() {
    // Encoding: 0x0E20BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rn = 31 (Max)
    // Fields: Rd=0, size=0, Rn=31, Q=0, U=0
    let encoding: u32 = 0x0E20BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rd_0_min_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rd_1_poweroftwo_b800_0e20b801() {
    // Encoding: 0x0E20B801
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Q=0, size=0, U=0
    let encoding: u32 = 0x0E20B801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rd_30_poweroftwominusone_b800_0e20b81e() {
    // Encoding: 0x0E20B81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, U=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E20B81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_field_rd_31_max_b800_0e20b81f() {
    // Encoding: 0x0E20B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field Rd = 31 (Max)
    // Fields: size=0, Rd=31, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E20B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_0_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_1_b800_4e20b800() {
    // Encoding: 0x4E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=1, U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Q=1, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x4E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_2_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Q=0, U=0, Rd=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_3_b800_2e20b800() {
    // Encoding: 0x2E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=1, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, size=0, U=1
    let encoding: u32 = 0x2E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_4_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_5_b800_0e60b800() {
    // Encoding: 0x0E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=1, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, size=1, U=0
    let encoding: u32 = 0x0E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_6_b800_0ea0b800() {
    // Encoding: 0x0EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=2, Rn=0, Rd=0
    // Fields: size=2, Q=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_7_b800_0ee0b800() {
    // Encoding: 0x0EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=3, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, U=0, size=3
    let encoding: u32 = 0x0EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_8_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, size=0, U=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_9_b800_0e20b820() {
    // Encoding: 0x0E20B820
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=0
    // Fields: U=0, size=0, Q=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E20B820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_10_b800_0e20bbc0() {
    // Encoding: 0x0E20BBC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=30, Rd=0
    // Fields: Rn=30, U=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E20BBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_11_b800_0e20bbe0() {
    // Encoding: 0x0E20BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=0
    // Fields: size=0, Q=0, Rd=0, Rn=31, U=0
    let encoding: u32 = 0x0E20BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_12_b800_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, U=0, size=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_13_b800_0e20b801() {
    // Encoding: 0x0E20B801
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=1
    // Fields: Q=0, Rd=1, Rn=0, U=0, size=0
    let encoding: u32 = 0x0E20B801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_14_b800_0e20b81e() {
    // Encoding: 0x0E20B81E
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, U=0, size=0, Q=0
    let encoding: u32 = 0x0E20B81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_15_b800_0e20b81f() {
    // Encoding: 0x0E20B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=31
    // Fields: Rn=0, size=0, Q=0, Rd=31, U=0
    let encoding: u32 = 0x0E20B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_16_b800_0e20b821() {
    // Encoding: 0x0E20B821
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, size=0, Q=0, Rd=1, U=0
    let encoding: u32 = 0x0E20B821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_combo_17_b800_0e20bbff() {
    // Encoding: 0x0E20BBFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, U=0, size=0, Q=0
    let encoding: u32 = 0x0E20BBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_q_0_size_variant_0_47104_0e60b800() {
    // Encoding: 0x0E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, U=0, size=1, Rn=0
    let encoding: u32 = 0x0E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_q_1_size_variant_1_47104_4e60b800() {
    // Encoding: 0x4E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, U=0, Rd=0, Q=1, size=1
    let encoding: u32 = 0x4E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_size_0_size_variant_0_47104_0e20b800() {
    // Encoding: 0x0E20B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value size = 0 (Size variant 0)
    // Fields: Rn=0, Q=0, Rd=0, size=0, U=0
    let encoding: u32 = 0x0E20B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_size_1_size_variant_1_47104_0e60b800() {
    // Encoding: 0x0E60B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value size = 1 (Size variant 1)
    // Fields: Q=0, U=0, size=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E60B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_size_2_size_variant_2_47104_0ea0b800() {
    // Encoding: 0x0EA0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value size = 2 (Size variant 2)
    // Fields: Rd=0, U=0, size=2, Q=0, Rn=0
    let encoding: u32 = 0x0EA0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_size_3_size_variant_3_47104_0ee0b800() {
    // Encoding: 0x0EE0B800
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, size=3, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EE0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_rn_31_stack_pointer_sp_may_require_alignment_47104_0e60bbe0() {
    // Encoding: 0x0E60BBE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, size=1, U=0, Rn=31
    let encoding: u32 = 0x0E60BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_47104_0e60b81f() {
    // Encoding: 0x0E60B81F
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, U=0, size=1, Rd=31, Rn=0
    let encoding: u32 = 0x0E60B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_reg_write_0_5e20b800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd register write: SimdFromField("d")
    // Encoding: 0x5E20B800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20B800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_sp_rn_5e20bbe0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd with Rn = SP (31)
    // Encoding: 0x5E20BBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20BBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_sisd_zr_rd_5e20b81f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_sisd with Rd = ZR (31)
    // Encoding: 0x5E20B81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20B81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_reg_write_0_0e20b800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd register write: SimdFromField("d")
    // Encoding: 0x0E20B800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20B800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_sp_rn_0e20bbe0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd with Rn = SP (31)
    // Encoding: 0x0E20BBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20BBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_int_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_int_simd_zr_rd_0e20b81f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_int_simd with Rd = ZR (31)
    // Encoding: 0x0E20B81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20B81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_frecpx_fp16 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rn_0_min_f800_5ef9f800() {
    // Encoding: 0x5EF9F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rn_1_poweroftwo_f800_5ef9f820() {
    // Encoding: 0x5EF9F820
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0
    let encoding: u32 = 0x5EF9F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rn_30_poweroftwominusone_f800_5ef9fbc0() {
    // Encoding: 0x5EF9FBC0
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0
    let encoding: u32 = 0x5EF9FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rn_31_max_f800_5ef9fbe0() {
    // Encoding: 0x5EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0
    let encoding: u32 = 0x5EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rd_0_min_f800_5ef9f800() {
    // Encoding: 0x5EF9F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0
    let encoding: u32 = 0x5EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rd_1_poweroftwo_f800_5ef9f801() {
    // Encoding: 0x5EF9F801
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1
    let encoding: u32 = 0x5EF9F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rd_30_poweroftwominusone_f800_5ef9f81e() {
    // Encoding: 0x5EF9F81E
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30
    let encoding: u32 = 0x5EF9F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_field_rd_31_max_f800_5ef9f81f() {
    // Encoding: 0x5EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31
    let encoding: u32 = 0x5EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_0_f800_5ef9f800() {
    // Encoding: 0x5EF9F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=0, Rd=0
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_1_f800_5ef9f820() {
    // Encoding: 0x5EF9F820
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=1, Rd=0
    // Fields: Rn=1, Rd=0
    let encoding: u32 = 0x5EF9F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_2_f800_5ef9fbc0() {
    // Encoding: 0x5EF9FBC0
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=30, Rd=0
    // Fields: Rd=0, Rn=30
    let encoding: u32 = 0x5EF9FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_3_f800_5ef9fbe0() {
    // Encoding: 0x5EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=31, Rd=0
    // Fields: Rd=0, Rn=31
    let encoding: u32 = 0x5EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_4_f800_5ef9f800() {
    // Encoding: 0x5EF9F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=0, Rd=0
    // Fields: Rn=0, Rd=0
    let encoding: u32 = 0x5EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_5_f800_5ef9f801() {
    // Encoding: 0x5EF9F801
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=0, Rd=1
    // Fields: Rn=0, Rd=1
    let encoding: u32 = 0x5EF9F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_6_f800_5ef9f81e() {
    // Encoding: 0x5EF9F81E
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=0, Rd=30
    // Fields: Rd=30, Rn=0
    let encoding: u32 = 0x5EF9F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_7_f800_5ef9f81f() {
    // Encoding: 0x5EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=0, Rd=31
    // Fields: Rn=0, Rd=31
    let encoding: u32 = 0x5EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_8_f800_5ef9f821() {
    // Encoding: 0x5EF9F821
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=1, Rd=1
    // Fields: Rd=1, Rn=1
    let encoding: u32 = 0x5EF9F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_combo_9_f800_5ef9fbff() {
    // Encoding: 0x5EF9FBFF
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 field combination: Rn=31, Rd=31
    // Fields: Rd=31, Rn=31
    let encoding: u32 = 0x5EF9FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_special_rn_31_stack_pointer_sp_may_require_alignment_63488_5ef9fbe0() {
    // Encoding: 0x5EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0
    let encoding: u32 = 0x5EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_5ef9f81f() {
    // Encoding: 0x5EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31
    let encoding: u32 = 0x5EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_sz_0_min_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field sz = 0 (Min)
    // Fields: Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_sz_1_max_f800_5ee1f800() {
    // Encoding: 0x5EE1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field sz = 1 (Max)
    // Fields: Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x5EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rn_0_min_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rn = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rn_1_poweroftwo_f800_5ea1f820() {
    // Encoding: 0x5EA1F820
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, sz=0
    let encoding: u32 = 0x5EA1F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rn_30_poweroftwominusone_f800_5ea1fbc0() {
    // Encoding: 0x5EA1FBC0
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, sz=0, Rd=0
    let encoding: u32 = 0x5EA1FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rn_31_max_f800_5ea1fbe0() {
    // Encoding: 0x5EA1FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rn = 31 (Max)
    // Fields: Rd=0, Rn=31, sz=0
    let encoding: u32 = 0x5EA1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rd_0_min_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rd = 0 (Min)
    // Fields: sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rd_1_poweroftwo_f800_5ea1f801() {
    // Encoding: 0x5EA1F801
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, sz=0
    let encoding: u32 = 0x5EA1F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rd_30_poweroftwominusone_f800_5ea1f81e() {
    // Encoding: 0x5EA1F81E
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30, sz=0
    let encoding: u32 = 0x5EA1F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_field_rd_31_max_f800_5ea1f81f() {
    // Encoding: 0x5EA1F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx field Rd = 31 (Max)
    // Fields: Rn=0, sz=0, Rd=31
    let encoding: u32 = 0x5EA1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_0_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_1_f800_5ee1f800() {
    // Encoding: 0x5EE1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=1, Rn=0, Rd=0
    // Fields: sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x5EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_2_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_3_f800_5ea1f820() {
    // Encoding: 0x5EA1F820
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x5EA1F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_4_f800_5ea1fbc0() {
    // Encoding: 0x5EA1FBC0
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, sz=0
    let encoding: u32 = 0x5EA1FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_5_f800_5ea1fbe0() {
    // Encoding: 0x5EA1FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=31, Rd=0
    // Fields: Rd=0, sz=0, Rn=31
    let encoding: u32 = 0x5EA1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_6_f800_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_7_f800_5ea1f801() {
    // Encoding: 0x5EA1F801
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=1
    // Fields: Rd=1, sz=0, Rn=0
    let encoding: u32 = 0x5EA1F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_8_f800_5ea1f81e() {
    // Encoding: 0x5EA1F81E
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, sz=0
    let encoding: u32 = 0x5EA1F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_9_f800_5ea1f81f() {
    // Encoding: 0x5EA1F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=0, Rd=31
    // Fields: Rd=31, sz=0, Rn=0
    let encoding: u32 = 0x5EA1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_10_f800_5ea1f821() {
    // Encoding: 0x5EA1F821
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rd=1, Rn=1
    let encoding: u32 = 0x5EA1F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_combo_11_f800_5ea1fbff() {
    // Encoding: 0x5EA1FBFF
    // Test aarch64_vector_arithmetic_unary_special_frecpx field combination: sz=0, Rn=31, Rd=31
    // Fields: sz=0, Rd=31, Rn=31
    let encoding: u32 = 0x5EA1FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_special_sz_0_size_variant_0_63488_5ea1f800() {
    // Encoding: 0x5EA1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx special value sz = 0 (Size variant 0)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_special_sz_1_size_variant_1_63488_5ee1f800() {
    // Encoding: 0x5EE1F800
    // Test aarch64_vector_arithmetic_unary_special_frecpx special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x5EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_special_rn_31_stack_pointer_sp_may_require_alignment_63488_5ee1fbe0() {
    // Encoding: 0x5EE1FBE0
    // Test aarch64_vector_arithmetic_unary_special_frecpx special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, sz=1, Rn=31
    let encoding: u32 = 0x5EE1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_5ee1f81f() {
    // Encoding: 0x5EE1F81F
    // Test aarch64_vector_arithmetic_unary_special_frecpx special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Rn=0, Rd=31
    let encoding: u32 = 0x5EE1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_reg_write_0_5ef9f800() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 register write: SimdFromField("d")
    // Encoding: 0x5EF9F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_sp_rn_5ef9fbe0() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 with Rn = SP (31)
    // Encoding: 0x5EF9FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx_fp16
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_fp16_zr_rd_5ef9f81f() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx_fp16 with Rd = ZR (31)
    // Encoding: 0x5EF9F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_reg_write_0_5ea1f800() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx register write: SimdFromField("d")
    // Encoding: 0x5EA1F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_sp_rn_5ea1fbe0() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx with Rn = SP (31)
    // Encoding: 0x5EA1FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_frecpx
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_frecpx_zr_rd_5ea1f81f() {
    // Test aarch64_vector_arithmetic_unary_special_frecpx with Rd = ZR (31)
    // Encoding: 0x5EA1F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_diff Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_q_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Q = 0 (Min)
    // Fields: size=0, Rd=0, Rm=0, op=0, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_q_1_max_5000_4e205000() {
    // Encoding: 0x4E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Q = 1 (Max)
    // Fields: Rd=0, Q=1, op=0, Rn=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x4E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_u_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field U = 0 (Min)
    // Fields: op=0, U=0, Q=0, size=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_u_1_max_5000_2e205000() {
    // Encoding: 0x2E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field U = 1 (Max)
    // Fields: U=1, size=0, Rm=0, op=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_size_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field size = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, U=0, Rd=0, op=0, size=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_size_1_poweroftwo_5000_0e605000() {
    // Encoding: 0x0E605000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field size = 1 (PowerOfTwo)
    // Fields: op=0, Rn=0, Q=0, U=0, size=1, Rd=0, Rm=0
    let encoding: u32 = 0x0E605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_size_2_poweroftwo_5000_0ea05000() {
    // Encoding: 0x0EA05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field size = 2 (PowerOfTwo)
    // Fields: Q=0, Rd=0, size=2, Rn=0, U=0, Rm=0, op=0
    let encoding: u32 = 0x0EA05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_size_3_max_5000_0ee05000() {
    // Encoding: 0x0EE05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field size = 3 (Max)
    // Fields: size=3, U=0, Rm=0, op=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EE05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rm_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, op=0, Rd=0, Q=0, U=0, size=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rm_1_poweroftwo_5000_0e215000() {
    // Encoding: 0x0E215000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, Rm=1, size=0, Rn=0, Rd=0, op=0
    let encoding: u32 = 0x0E215000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rm_30_poweroftwominusone_5000_0e3e5000() {
    // Encoding: 0x0E3E5000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Q=0, op=0, Rd=0, size=0, U=0, Rm=30
    let encoding: u32 = 0x0E3E5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rm_31_max_5000_0e3f5000() {
    // Encoding: 0x0E3F5000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rm = 31 (Max)
    // Fields: U=0, size=0, Rn=0, Rd=0, op=0, Q=0, Rm=31
    let encoding: u32 = 0x0E3F5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field op 13 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_op_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field op = 0 (Min)
    // Fields: Rm=0, op=0, Rd=0, U=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field op 13 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_op_1_max_5000_0e207000() {
    // Encoding: 0x0E207000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field op = 1 (Max)
    // Fields: Rn=0, Rd=0, Q=0, U=0, op=1, size=0, Rm=0
    let encoding: u32 = 0x0E207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rn_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rn = 0 (Min)
    // Fields: op=0, size=0, U=0, Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rn_1_poweroftwo_5000_0e205020() {
    // Encoding: 0x0E205020
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, U=0, size=0, Q=0, op=0, Rn=1, Rm=0
    let encoding: u32 = 0x0E205020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rn_30_poweroftwominusone_5000_0e2053c0() {
    // Encoding: 0x0E2053C0
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, op=0, size=0, Q=0, Rm=0, Rd=0, Rn=30
    let encoding: u32 = 0x0E2053C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rn_31_max_5000_0e2053e0() {
    // Encoding: 0x0E2053E0
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rn = 31 (Max)
    // Fields: U=0, size=0, Rm=0, op=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E2053E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rd_0_min_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rd = 0 (Min)
    // Fields: size=0, Rm=0, Q=0, op=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rd_1_poweroftwo_5000_0e205001() {
    // Encoding: 0x0E205001
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rd = 1 (PowerOfTwo)
    // Fields: op=0, Rn=0, U=0, size=0, Rd=1, Rm=0, Q=0
    let encoding: u32 = 0x0E205001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rd_30_poweroftwominusone_5000_0e20501e() {
    // Encoding: 0x0E20501E
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, size=0, Q=0, op=0, Rn=0, Rm=0, U=0
    let encoding: u32 = 0x0E20501E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_field_rd_31_max_5000_0e20501f() {
    // Encoding: 0x0E20501F
    // Test aarch64_vector_arithmetic_binary_disparate_diff field Rd = 31 (Max)
    // Fields: Rn=0, Q=0, U=0, size=0, Rm=0, op=0, Rd=31
    let encoding: u32 = 0x0E20501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_0_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: op=0, Rn=0, Rd=0, size=0, Rm=0, U=0, Q=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_1_5000_4e205000() {
    // Encoding: 0x4E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=1, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0, size=0, Q=1, op=0, Rm=0
    let encoding: u32 = 0x4E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_2_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, Rm=0, op=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_3_5000_2e205000() {
    // Encoding: 0x2E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=1, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, U=1, Rm=0, op=0, Rd=0, size=0
    let encoding: u32 = 0x2E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_4_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, U=0, Rm=0, Rn=0, Q=0, op=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_5_5000_0e605000() {
    // Encoding: 0x0E605000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=1, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, size=1, op=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0E605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_6_5000_0ea05000() {
    // Encoding: 0x0EA05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=2, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rm=0, size=2, U=0, Q=0, op=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EA05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_7_5000_0ee05000() {
    // Encoding: 0x0EE05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=3, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Q=0, U=0, size=3, Rn=0, op=0
    let encoding: u32 = 0x0EE05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_8_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: op=0, size=0, Rd=0, Rn=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_9_5000_0e215000() {
    // Encoding: 0x0E215000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=1, op=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, U=0, Rn=0, op=0, Q=0, Rm=1
    let encoding: u32 = 0x0E215000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_10_5000_0e3e5000() {
    // Encoding: 0x0E3E5000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=30, op=0, Rn=0, Rd=0
    // Fields: op=0, size=0, U=0, Q=0, Rm=30, Rn=0, Rd=0
    let encoding: u32 = 0x0E3E5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_11_5000_0e3f5000() {
    // Encoding: 0x0E3F5000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=31, op=0, Rn=0, Rd=0
    // Fields: op=0, size=0, Rn=0, Q=0, Rd=0, Rm=31, U=0
    let encoding: u32 = 0x0E3F5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_12_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rm=0, size=0, U=0, Rn=0, Q=0, op=0, Rd=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_13_5000_0e207000() {
    // Encoding: 0x0E207000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=1, Rn=0, Rd=0
    // Fields: U=0, size=0, Rm=0, op=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_14_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, op=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_15_5000_0e205020() {
    // Encoding: 0x0E205020
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=1, Rd=0
    // Fields: Rm=0, Rd=0, U=0, op=0, Q=0, size=0, Rn=1
    let encoding: u32 = 0x0E205020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_16_5000_0e2053c0() {
    // Encoding: 0x0E2053C0
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=30, Rd=0
    // Fields: Q=0, size=0, U=0, Rm=0, op=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E2053C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_17_5000_0e2053e0() {
    // Encoding: 0x0E2053E0
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=31, Rd=0
    // Fields: size=0, Rn=31, Rd=0, Q=0, U=0, Rm=0, op=0
    let encoding: u32 = 0x0E2053E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_18_5000_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, size=0, U=0, op=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_19_5000_0e205001() {
    // Encoding: 0x0E205001
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=1
    // Fields: size=0, Rn=0, op=0, U=0, Q=0, Rd=1, Rm=0
    let encoding: u32 = 0x0E205001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_20_5000_0e20501e() {
    // Encoding: 0x0E20501E
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=30
    // Fields: Rd=30, U=0, Q=0, size=0, Rm=0, op=0, Rn=0
    let encoding: u32 = 0x0E20501E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_21_5000_0e20501f() {
    // Encoding: 0x0E20501F
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=0, Rd=31
    // Fields: Rm=0, op=0, Rn=0, size=0, Rd=31, Q=0, U=0
    let encoding: u32 = 0x0E20501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_22_5000_0e215020() {
    // Encoding: 0x0E215020
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=1, op=0, Rn=1, Rd=0
    // Fields: op=0, U=0, Rn=1, size=0, Rm=1, Rd=0, Q=0
    let encoding: u32 = 0x0E215020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_23_5000_0e3f53e0() {
    // Encoding: 0x0E3F53E0
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=31, op=0, Rn=31, Rd=0
    // Fields: Rd=0, op=0, Rn=31, U=0, size=0, Rm=31, Q=0
    let encoding: u32 = 0x0E3F53E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_24_5000_0e215001() {
    // Encoding: 0x0E215001
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=1, op=0, Rn=0, Rd=1
    // Fields: Rm=1, size=0, op=0, Rn=0, Rd=1, U=0, Q=0
    let encoding: u32 = 0x0E215001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_25_5000_0e3f501f() {
    // Encoding: 0x0E3F501F
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=31, op=0, Rn=0, Rd=31
    // Fields: Q=0, U=0, size=0, Rm=31, op=0, Rd=31, Rn=0
    let encoding: u32 = 0x0E3F501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_26_5000_0e205021() {
    // Encoding: 0x0E205021
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=1, Rd=1
    // Fields: Q=0, Rn=1, Rm=0, op=0, Rd=1, U=0, size=0
    let encoding: u32 = 0x0E205021;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_combo_27_5000_0e2053ff() {
    // Encoding: 0x0E2053FF
    // Test aarch64_vector_arithmetic_binary_disparate_diff field combination: Q=0, U=0, size=0, Rm=0, op=0, Rn=31, Rd=31
    // Fields: size=0, U=0, op=0, Q=0, Rd=31, Rm=0, Rn=31
    let encoding: u32 = 0x0E2053FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_q_0_size_variant_0_20480_0e605000() {
    // Encoding: 0x0E605000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value Q = 0 (Size variant 0)
    // Fields: U=0, op=0, Rd=0, size=1, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_q_1_size_variant_1_20480_4e605000() {
    // Encoding: 0x4E605000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value Q = 1 (Size variant 1)
    // Fields: Rn=0, op=0, Rd=0, size=1, U=0, Rm=0, Q=1
    let encoding: u32 = 0x4E605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_size_0_size_variant_0_20480_0e205000() {
    // Encoding: 0x0E205000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value size = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0, size=0, U=0, op=0, Rm=0
    let encoding: u32 = 0x0E205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_size_1_size_variant_1_20480_0e605000() {
    // Encoding: 0x0E605000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value size = 1 (Size variant 1)
    // Fields: U=0, op=0, Rn=0, Rm=0, Rd=0, Q=0, size=1
    let encoding: u32 = 0x0E605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_size_2_size_variant_2_20480_0ea05000() {
    // Encoding: 0x0EA05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value size = 2 (Size variant 2)
    // Fields: op=0, Rn=0, size=2, Rd=0, U=0, Q=0, Rm=0
    let encoding: u32 = 0x0EA05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_size_3_size_variant_3_20480_0ee05000() {
    // Encoding: 0x0EE05000
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value size = 3 (Size variant 3)
    // Fields: Q=0, U=0, Rm=0, op=0, size=3, Rd=0, Rn=0
    let encoding: u32 = 0x0EE05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_rn_31_stack_pointer_sp_may_require_alignment_20480_0e6053e0() {
    // Encoding: 0x0E6053E0
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: op=0, Rd=0, size=1, Q=0, Rm=0, Rn=31, U=0
    let encoding: u32 = 0x0E6053E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_20480_0e60501f() {
    // Encoding: 0x0E60501F
    // Test aarch64_vector_arithmetic_binary_disparate_diff special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, Rd=31, op=0, size=1, Rm=0, U=0
    let encoding: u32 = 0x0E60501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_reg_write_0_0e205000() {
    // Test aarch64_vector_arithmetic_binary_disparate_diff register write: SimdFromField("d")
    // Encoding: 0x0E205000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E205000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_sp_rn_0e2053e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_diff with Rn = SP (31)
    // Encoding: 0x0E2053E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2053E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_diff
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_diff_zr_rd_0e20501f() {
    // Test aarch64_vector_arithmetic_binary_disparate_diff with Rd = ZR (31)
    // Encoding: 0x0E20501F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20501F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_q_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Q = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, U=0, o1=0, Q=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_q_1_max_3400_4e403400() {
    // Encoding: 0x4E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Q = 1 (Max)
    // Fields: Rm=0, Q=1, Rn=0, U=0, Rd=0, o1=0
    let encoding: u32 = 0x4E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_u_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field U = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, U=0, Rm=0, o1=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_u_1_max_3400_2e403400() {
    // Encoding: 0x2E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field U = 1 (Max)
    // Fields: Rd=0, Q=0, o1=0, Rm=0, U=1, Rn=0
    let encoding: u32 = 0x2E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_o1_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field o1 = 0 (Min)
    // Fields: Rd=0, Rm=0, U=0, o1=0, Rn=0, Q=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_o1_1_max_3400_0ec03400() {
    // Encoding: 0x0EC03400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field o1 = 1 (Max)
    // Fields: U=0, o1=1, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EC03400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rm_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rm = 0 (Min)
    // Fields: o1=0, U=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rm_1_poweroftwo_3400_0e413400() {
    // Encoding: 0x0E413400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, o1=0, Q=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E413400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rm_30_poweroftwominusone_3400_0e5e3400() {
    // Encoding: 0x0E5E3400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, Rm=30, U=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E5E3400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rm_31_max_3400_0e5f3400() {
    // Encoding: 0x0E5F3400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rm = 31 (Max)
    // Fields: Rm=31, Q=0, U=0, Rn=0, o1=0, Rd=0
    let encoding: u32 = 0x0E5F3400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rn_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rn = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, o1=0, U=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rn_1_poweroftwo_3400_0e403420() {
    // Encoding: 0x0E403420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Q=0, Rn=1, Rd=0, Rm=0, o1=0
    let encoding: u32 = 0x0E403420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rn_30_poweroftwominusone_3400_0e4037c0() {
    // Encoding: 0x0E4037C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, o1=0, U=0, Rn=30, Rm=0, Rd=0
    let encoding: u32 = 0x0E4037C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rn_31_max_3400_0e4037e0() {
    // Encoding: 0x0E4037E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rn = 31 (Max)
    // Fields: Rm=0, Q=0, o1=0, U=0, Rd=0, Rn=31
    let encoding: u32 = 0x0E4037E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rd_0_min_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, Q=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rd_1_poweroftwo_3400_0e403401() {
    // Encoding: 0x0E403401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, U=0, o1=0, Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x0E403401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rd_30_poweroftwominusone_3400_0e40341e() {
    // Encoding: 0x0E40341E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, o1=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x0E40341E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_field_rd_31_max_3400_0e40341f() {
    // Encoding: 0x0E40341F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field Rd = 31 (Max)
    // Fields: Rd=31, o1=0, Rn=0, U=0, Rm=0, Q=0
    let encoding: u32 = 0x0E40341F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_0_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: o1=0, Rm=0, Rd=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_1_3400_4e403400() {
    // Encoding: 0x4E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=1, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Q=1, Rn=0, Rd=0, o1=0, U=0
    let encoding: u32 = 0x4E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_2_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Q=0, o1=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_3_3400_2e403400() {
    // Encoding: 0x2E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=1, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, o1=0, Rn=0, Rd=0, Q=0, U=1
    let encoding: u32 = 0x2E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_4_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_5_3400_0ec03400() {
    // Encoding: 0x0EC03400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=1, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, U=0, Rn=0, o1=1, Rd=0, Q=0
    let encoding: u32 = 0x0EC03400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_6_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: o1=0, U=0, Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_7_3400_0e413400() {
    // Encoding: 0x0E413400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=1, Rn=0, Rd=0
    // Fields: o1=0, Rd=0, Rm=1, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E413400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_8_3400_0e5e3400() {
    // Encoding: 0x0E5E3400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=30, Rn=0, Rd=0
    // Fields: Rm=30, Q=0, Rn=0, U=0, Rd=0, o1=0
    let encoding: u32 = 0x0E5E3400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_9_3400_0e5f3400() {
    // Encoding: 0x0E5F3400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=31, Rn=0, Rd=0
    // Fields: Rm=31, Q=0, U=0, o1=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E5F3400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_10_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, Q=0, U=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_11_3400_0e403420() {
    // Encoding: 0x0E403420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=1, Rd=0
    // Fields: Rn=1, U=0, o1=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E403420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_12_3400_0e4037c0() {
    // Encoding: 0x0E4037C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, Rm=0, Q=0, U=0, o1=0
    let encoding: u32 = 0x0E4037C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_13_3400_0e4037e0() {
    // Encoding: 0x0E4037E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=31, Rd=0
    // Fields: Q=0, U=0, Rm=0, Rd=0, o1=0, Rn=31
    let encoding: u32 = 0x0E4037E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_14_3400_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o1=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_15_3400_0e403401() {
    // Encoding: 0x0E403401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, U=0, Q=0, o1=0, Rm=0
    let encoding: u32 = 0x0E403401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_16_3400_0e40341e() {
    // Encoding: 0x0E40341E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=30
    // Fields: Rm=0, Q=0, Rd=30, Rn=0, o1=0, U=0
    let encoding: u32 = 0x0E40341E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_17_3400_0e40341f() {
    // Encoding: 0x0E40341F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=0, Rd=31
    // Fields: Rd=31, Rn=0, o1=0, Q=0, Rm=0, U=0
    let encoding: u32 = 0x0E40341F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_18_3400_0e413420() {
    // Encoding: 0x0E413420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=1, Rn=1, Rd=0
    // Fields: U=0, o1=0, Rd=0, Q=0, Rn=1, Rm=1
    let encoding: u32 = 0x0E413420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_19_3400_0e5f37e0() {
    // Encoding: 0x0E5F37E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=31, Rn=31, Rd=0
    // Fields: o1=0, Q=0, Rm=31, U=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E5F37E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_20_3400_0e413401() {
    // Encoding: 0x0E413401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=1, Rn=0, Rd=1
    // Fields: o1=0, Rm=1, Q=0, Rn=0, Rd=1, U=0
    let encoding: u32 = 0x0E413401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_21_3400_0e5f341f() {
    // Encoding: 0x0E5F341F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=31, Rn=0, Rd=31
    // Fields: o1=0, Rm=31, Rd=31, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E5F341F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_22_3400_0e403421() {
    // Encoding: 0x0E403421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=1, Rd=1
    // Fields: U=0, Rm=0, Rn=1, Q=0, Rd=1, o1=0
    let encoding: u32 = 0x0E403421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_combo_23_3400_0e4037ff() {
    // Encoding: 0x0E4037FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 field combination: Q=0, U=0, o1=0, Rm=0, Rn=31, Rd=31
    // Fields: Q=0, U=0, Rm=0, Rn=31, o1=0, Rd=31
    let encoding: u32 = 0x0E4037FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_special_q_0_size_variant_0_13312_0e403400() {
    // Encoding: 0x0E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Q=0, Rm=0, U=0, o1=0
    let encoding: u32 = 0x0E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_special_q_1_size_variant_1_13312_4e403400() {
    // Encoding: 0x4E403400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rn=0, Rm=0, o1=0, Q=1, U=0
    let encoding: u32 = 0x4E403400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_special_rn_31_stack_pointer_sp_may_require_alignment_13312_0e4037e0() {
    // Encoding: 0x0E4037E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rn=31, o1=0, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E4037E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_13312_0e40341f() {
    // Encoding: 0x0E40341F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, o1=0, Rm=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E40341F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_q_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Q = 0 (Min)
    // Fields: sz=0, o1=0, Q=0, Rd=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_q_1_max_f400_4e20f400() {
    // Encoding: 0x4E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Q = 1 (Max)
    // Fields: sz=0, Rm=0, U=0, Rd=0, Rn=0, Q=1, o1=0
    let encoding: u32 = 0x4E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_u_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field U = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, U=0, Rm=0, o1=0, sz=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_u_1_max_f400_2e20f400() {
    // Encoding: 0x2E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field U = 1 (Max)
    // Fields: Q=0, U=1, sz=0, Rn=0, Rd=0, o1=0, Rm=0
    let encoding: u32 = 0x2E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_o1_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field o1 = 0 (Min)
    // Fields: Rn=0, U=0, Rd=0, Rm=0, Q=0, sz=0, o1=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_o1_1_max_f400_0ea0f400() {
    // Encoding: 0x0EA0F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field o1 = 1 (Max)
    // Fields: U=0, o1=1, Rm=0, Q=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x0EA0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_sz_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field sz = 0 (Min)
    // Fields: sz=0, Q=0, o1=0, Rm=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_sz_1_max_f400_0e60f400() {
    // Encoding: 0x0E60F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field sz = 1 (Max)
    // Fields: Rd=0, Rm=0, sz=1, Q=0, o1=0, U=0, Rn=0
    let encoding: u32 = 0x0E60F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rm_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rm = 0 (Min)
    // Fields: Rd=0, o1=0, U=0, Q=0, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rm_1_poweroftwo_f400_0e21f400() {
    // Encoding: 0x0E21F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rd=0, o1=0, Rn=0, U=0, Q=0, sz=0
    let encoding: u32 = 0x0E21F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rm_30_poweroftwominusone_f400_0e3ef400() {
    // Encoding: 0x0E3EF400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, o1=0, Rn=0, sz=0, Rd=0, U=0, Rm=30
    let encoding: u32 = 0x0E3EF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rm_31_max_f400_0e3ff400() {
    // Encoding: 0x0E3FF400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rm = 31 (Max)
    // Fields: Rn=0, Q=0, U=0, o1=0, sz=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E3FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rn_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rn = 0 (Min)
    // Fields: Rd=0, o1=0, Rm=0, sz=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rn_1_poweroftwo_f400_0e20f420() {
    // Encoding: 0x0E20F420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, U=0, Q=0, o1=0, Rn=1, sz=0, Rm=0
    let encoding: u32 = 0x0E20F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rn_30_poweroftwominusone_f400_0e20f7c0() {
    // Encoding: 0x0E20F7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, U=0, sz=0, Q=0, o1=0, Rm=0, Rn=30
    let encoding: u32 = 0x0E20F7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rn_31_max_f400_0e20f7e0() {
    // Encoding: 0x0E20F7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rn = 31 (Max)
    // Fields: Rm=0, o1=0, Rn=31, Rd=0, Q=0, U=0, sz=0
    let encoding: u32 = 0x0E20F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rd_0_min_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rd = 0 (Min)
    // Fields: Rd=0, Q=0, Rm=0, U=0, o1=0, sz=0, Rn=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rd_1_poweroftwo_f400_0e20f401() {
    // Encoding: 0x0E20F401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, U=0, Rd=1, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0E20F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rd_30_poweroftwominusone_f400_0e20f41e() {
    // Encoding: 0x0E20F41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, o1=0, Rm=0, Rd=30, sz=0, U=0
    let encoding: u32 = 0x0E20F41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_field_rd_31_max_f400_0e20f41f() {
    // Encoding: 0x0E20F41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field Rd = 31 (Max)
    // Fields: o1=0, Q=0, Rm=0, U=0, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E20F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_0_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, Rd=0, o1=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_1_f400_4e20f400() {
    // Encoding: 0x4E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=1, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Q=1, U=0, sz=0, Rn=0, Rd=0, o1=0
    let encoding: u32 = 0x4E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_2_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Q=0, U=0, Rm=0, o1=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_3_f400_2e20f400() {
    // Encoding: 0x2E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=1, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, o1=0, Rn=0, Q=0, U=1, sz=0, Rm=0
    let encoding: u32 = 0x2E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_4_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, o1=0, sz=0, Rm=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_5_f400_0ea0f400() {
    // Encoding: 0x0EA0F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=1, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, o1=1, sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0EA0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_6_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, o1=0, sz=0, Rm=0, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_7_f400_0e60f400() {
    // Encoding: 0x0E60F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=1, Rd=0, Q=0, o1=0, Rm=0, U=0
    let encoding: u32 = 0x0E60F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_8_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, o1=0, U=0, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_9_f400_0e21f400() {
    // Encoding: 0x0E21F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, sz=0, Rd=0, o1=0, Rm=1, U=0
    let encoding: u32 = 0x0E21F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_10_f400_0e3ef400() {
    // Encoding: 0x0E3EF400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=30, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Q=0, Rm=30, Rn=0, U=0, o1=0
    let encoding: u32 = 0x0E3EF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_11_f400_0e3ff400() {
    // Encoding: 0x0E3FF400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Rm=31, Rn=0, o1=0, Q=0, U=0
    let encoding: u32 = 0x0E3FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_12_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, o1=0, Rm=0, Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_13_f400_0e20f420() {
    // Encoding: 0x0E20F420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=1, Rd=0
    // Fields: Q=0, o1=0, Rd=0, sz=0, Rm=0, U=0, Rn=1
    let encoding: u32 = 0x0E20F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_14_f400_0e20f7c0() {
    // Encoding: 0x0E20F7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=30, Rd=0
    // Fields: sz=0, Q=0, Rm=0, Rd=0, o1=0, Rn=30, U=0
    let encoding: u32 = 0x0E20F7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_15_f400_0e20f7e0() {
    // Encoding: 0x0E20F7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=31, Rd=0
    // Fields: Q=0, sz=0, U=0, Rn=31, Rm=0, o1=0, Rd=0
    let encoding: u32 = 0x0E20F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_16_f400_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, o1=0, Rd=0, Rn=0, U=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_17_f400_0e20f401() {
    // Encoding: 0x0E20F401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=1
    // Fields: Q=0, Rm=0, Rn=0, U=0, Rd=1, o1=0, sz=0
    let encoding: u32 = 0x0E20F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_18_f400_0e20f41e() {
    // Encoding: 0x0E20F41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=30
    // Fields: sz=0, Q=0, Rn=0, Rd=30, U=0, Rm=0, o1=0
    let encoding: u32 = 0x0E20F41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_19_f400_0e20f41f() {
    // Encoding: 0x0E20F41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=31
    // Fields: o1=0, sz=0, Rm=0, Q=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x0E20F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_20_f400_0e21f420() {
    // Encoding: 0x0E21F420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=1, Rd=0
    // Fields: U=0, Q=0, o1=0, Rn=1, sz=0, Rm=1, Rd=0
    let encoding: u32 = 0x0E21F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_21_f400_0e3ff7e0() {
    // Encoding: 0x0E3FF7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=31, Rd=0
    // Fields: Rd=0, U=0, Q=0, Rm=31, sz=0, o1=0, Rn=31
    let encoding: u32 = 0x0E3FF7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_22_f400_0e21f401() {
    // Encoding: 0x0E21F401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, Rm=1, Q=0, U=0, o1=0, sz=0, Rn=0
    let encoding: u32 = 0x0E21F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_23_f400_0e3ff41f() {
    // Encoding: 0x0E3FF41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Rm=31, Rd=31, U=0, o1=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E3FF41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_24_f400_0e20f421() {
    // Encoding: 0x0E20F421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=1, Rd=1
    // Fields: sz=0, U=0, Rd=1, Rn=1, Rm=0, Q=0, o1=0
    let encoding: u32 = 0x0E20F421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_combo_25_f400_0e20f7ff() {
    // Encoding: 0x0E20F7FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rd=31, U=0, o1=0, Rm=0, Rn=31, Q=0, sz=0
    let encoding: u32 = 0x0E20F7FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_q_0_size_variant_0_62464_0e60f400() {
    // Encoding: 0x0E60F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value Q = 0 (Size variant 0)
    // Fields: U=0, o1=0, Rd=0, sz=1, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E60F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_q_1_size_variant_1_62464_4e60f400() {
    // Encoding: 0x4E60F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value Q = 1 (Size variant 1)
    // Fields: Rd=0, o1=0, Q=1, Rm=0, Rn=0, sz=1, U=0
    let encoding: u32 = 0x4E60F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_sz_0_size_variant_0_62464_0e20f400() {
    // Encoding: 0x0E20F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value sz = 0 (Size variant 0)
    // Fields: o1=0, Rd=0, U=0, sz=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_sz_1_size_variant_1_62464_0e60f400() {
    // Encoding: 0x0E60F400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rm=0, Rd=0, Rn=0, Q=0, U=0, o1=0
    let encoding: u32 = 0x0E60F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_rn_31_stack_pointer_sp_may_require_alignment_62464_0e60f7e0() {
    // Encoding: 0x0E60F7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, U=0, o1=0, Rm=0, Rd=0, sz=1, Rn=31
    let encoding: u32 = 0x0E60F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_62464_0e60f41f() {
    // Encoding: 0x0E60F41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o1=0, U=0, Rm=0, Rn=0, sz=1, Rd=31, Q=0
    let encoding: u32 = 0x0E60F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_reg_write_0_0e403400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 register write: SimdFromField("d")
    // Encoding: 0x0E403400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E403400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_sp_rn_0e4037e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 with Rn = SP (31)
    // Encoding: 0x0E4037E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E4037E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985_zr_rd_0e40341f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_1985 with Rd = ZR (31)
    // Encoding: 0x0E40341F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E40341F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_reg_write_0_0e20f400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 register write: SimdFromField("d")
    // Encoding: 0x0E20F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_sp_rn_0e20f7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 with Rn = SP (31)
    // Encoding: 0x0E20F7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20F7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985_zr_rd_0e20f41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_1985 with Rd = ZR (31)
    // Encoding: 0x0E20F41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20F41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_float_widen Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_q_0_min_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field Q = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_q_1_max_7800_4e217800() {
    // Encoding: 0x4E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field Q = 1 (Max)
    // Fields: Rd=0, Rn=0, sz=0, Q=1
    let encoding: u32 = 0x4E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_sz_0_min_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field sz = 0 (Min)
    // Fields: Rd=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_sz_1_max_7800_0e617800() {
    // Encoding: 0x0E617800
    // Test aarch64_vector_arithmetic_unary_float_widen field sz = 1 (Max)
    // Fields: Q=0, sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E617800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rn_0_min_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field Rn = 0 (Min)
    // Fields: sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rn_1_poweroftwo_7800_0e217820() {
    // Encoding: 0x0E217820
    // Test aarch64_vector_arithmetic_unary_float_widen field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E217820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rn_30_poweroftwominusone_7800_0e217bc0() {
    // Encoding: 0x0E217BC0
    // Test aarch64_vector_arithmetic_unary_float_widen field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=0, Rn=30, Q=0
    let encoding: u32 = 0x0E217BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rn_31_max_7800_0e217be0() {
    // Encoding: 0x0E217BE0
    // Test aarch64_vector_arithmetic_unary_float_widen field Rn = 31 (Max)
    // Fields: Q=0, sz=0, Rd=0, Rn=31
    let encoding: u32 = 0x0E217BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rd_0_min_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field Rd = 0 (Min)
    // Fields: Rn=0, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rd_1_poweroftwo_7800_0e217801() {
    // Encoding: 0x0E217801
    // Test aarch64_vector_arithmetic_unary_float_widen field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rd=1, Rn=0
    let encoding: u32 = 0x0E217801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rd_30_poweroftwominusone_7800_0e21781e() {
    // Encoding: 0x0E21781E
    // Test aarch64_vector_arithmetic_unary_float_widen field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30, Q=0, sz=0
    let encoding: u32 = 0x0E21781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_field_rd_31_max_7800_0e21781f() {
    // Encoding: 0x0E21781F
    // Test aarch64_vector_arithmetic_unary_float_widen field Rd = 31 (Max)
    // Fields: sz=0, Rd=31, Q=0, Rn=0
    let encoding: u32 = 0x0E21781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_0_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_1_7800_4e217800() {
    // Encoding: 0x4E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Q=1, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x4E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_2_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_3_7800_0e617800() {
    // Encoding: 0x0E617800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Rd=0, sz=1, Q=0, Rn=0
    let encoding: u32 = 0x0E617800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_4_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_5_7800_0e217820() {
    // Encoding: 0x0E217820
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rd=0, Rn=1, Q=0
    let encoding: u32 = 0x0E217820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_6_7800_0e217bc0() {
    // Encoding: 0x0E217BC0
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0E217BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_7_7800_0e217be0() {
    // Encoding: 0x0E217BE0
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Rd=0, Rn=31, Q=0, sz=0
    let encoding: u32 = 0x0E217BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_8_7800_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_9_7800_0e217801() {
    // Encoding: 0x0E217801
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Rn=0, sz=0, Rd=1, Q=0
    let encoding: u32 = 0x0E217801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_10_7800_0e21781e() {
    // Encoding: 0x0E21781E
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: Q=0, Rn=0, sz=0, Rd=30
    let encoding: u32 = 0x0E21781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_11_7800_0e21781f() {
    // Encoding: 0x0E21781F
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, sz=0, Q=0
    let encoding: u32 = 0x0E21781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_12_7800_0e217821() {
    // Encoding: 0x0E217821
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rn=1, Q=0, Rd=1
    let encoding: u32 = 0x0E217821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_combo_13_7800_0e217bff() {
    // Encoding: 0x0E217BFF
    // Test aarch64_vector_arithmetic_unary_float_widen field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Rd=31, Q=0, Rn=31, sz=0
    let encoding: u32 = 0x0E217BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_q_0_size_variant_0_30720_0e617800() {
    // Encoding: 0x0E617800
    // Test aarch64_vector_arithmetic_unary_float_widen special value Q = 0 (Size variant 0)
    // Fields: Q=0, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x0E617800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_q_1_size_variant_1_30720_4e617800() {
    // Encoding: 0x4E617800
    // Test aarch64_vector_arithmetic_unary_float_widen special value Q = 1 (Size variant 1)
    // Fields: Rn=0, sz=1, Q=1, Rd=0
    let encoding: u32 = 0x4E617800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_sz_0_size_variant_0_30720_0e217800() {
    // Encoding: 0x0E217800
    // Test aarch64_vector_arithmetic_unary_float_widen special value sz = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x0E217800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_sz_1_size_variant_1_30720_0e617800() {
    // Encoding: 0x0E617800
    // Test aarch64_vector_arithmetic_unary_float_widen special value sz = 1 (Size variant 1)
    // Fields: Q=0, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x0E617800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_rn_31_stack_pointer_sp_may_require_alignment_30720_0e617be0() {
    // Encoding: 0x0E617BE0
    // Test aarch64_vector_arithmetic_unary_float_widen special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, sz=1, Rn=31, Q=0
    let encoding: u32 = 0x0E617BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_30720_0e61781f() {
    // Encoding: 0x0E61781F
    // Test aarch64_vector_arithmetic_unary_float_widen special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, sz=1, Q=0, Rn=0
    let encoding: u32 = 0x0E61781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_reg_write_0_0e217800() {
    // Test aarch64_vector_arithmetic_unary_float_widen register write: SimdFromField("d")
    // Encoding: 0x0E217800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E217800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_sp_rn_0e217be0() {
    // Test aarch64_vector_arithmetic_unary_float_widen with Rn = SP (31)
    // Encoding: 0x0E217BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E217BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_widen
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_widen_zr_rd_0e21781f() {
    // Test aarch64_vector_arithmetic_unary_float_widen with Rd = ZR (31)
    // Encoding: 0x0E21781F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21781F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_logical_and_orr Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_q_0_min_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Q = 0 (Min)
    // Fields: Rn=0, Q=0, Rm=0, size=0, Rd=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_q_1_max_1c00_4e201c00() {
    // Encoding: 0x4E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Q = 1 (Max)
    // Fields: size=0, Q=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_size_0_min_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field size = 0 (Min)
    // Fields: Rm=0, size=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_size_1_poweroftwo_1c00_0e601c00() {
    // Encoding: 0x0E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Q=0, Rd=0, size=1, Rm=0
    let encoding: u32 = 0x0E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_size_2_poweroftwo_1c00_0ea01c00() {
    // Encoding: 0x0EA01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Q=0, Rd=0, Rn=0, size=2
    let encoding: u32 = 0x0EA01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_size_3_max_1c00_0ee01c00() {
    // Encoding: 0x0EE01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field size = 3 (Max)
    // Fields: Rm=0, Q=0, Rd=0, Rn=0, size=3
    let encoding: u32 = 0x0EE01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rm_0_min_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rm = 0 (Min)
    // Fields: Rd=0, Q=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rm_1_poweroftwo_1c00_0e211c00() {
    // Encoding: 0x0E211C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rd=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x0E211C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rm_30_poweroftwominusone_1c00_0e3e1c00() {
    // Encoding: 0x0E3E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, size=0, Rn=0, Q=0, Rm=30
    let encoding: u32 = 0x0E3E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rm_31_max_1c00_0e3f1c00() {
    // Encoding: 0x0E3F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rm = 31 (Max)
    // Fields: size=0, Rm=31, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E3F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rn_0_min_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0, Rm=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rn_1_poweroftwo_1c00_0e201c20() {
    // Encoding: 0x0E201C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, Rd=0, Rm=0, Rn=1
    let encoding: u32 = 0x0E201C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rn_30_poweroftwominusone_1c00_0e201fc0() {
    // Encoding: 0x0E201FC0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, Rn=30, Rd=0, Rm=0
    let encoding: u32 = 0x0E201FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rn_31_max_1c00_0e201fe0() {
    // Encoding: 0x0E201FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rn = 31 (Max)
    // Fields: Rm=0, size=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rd_0_min_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rd = 0 (Min)
    // Fields: Q=0, size=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rd_1_poweroftwo_1c00_0e201c01() {
    // Encoding: 0x0E201C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Rd=1, Q=0, size=0
    let encoding: u32 = 0x0E201C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rd_30_poweroftwominusone_1c00_0e201c1e() {
    // Encoding: 0x0E201C1E
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Q=0, size=0, Rd=30, Rn=0
    let encoding: u32 = 0x0E201C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_field_rd_31_max_1c00_0e201c1f() {
    // Encoding: 0x0E201C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, Rm=0, size=0, Rn=0
    let encoding: u32 = 0x0E201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_0_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, size=0, Q=0, Rm=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_1_1c00_4e201c00() {
    // Encoding: 0x4E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=1, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Q=1, size=0, Rd=0
    let encoding: u32 = 0x4E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_2_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, size=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_3_1c00_0e601c00() {
    // Encoding: 0x0E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=1, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, size=1, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_4_1c00_0ea01c00() {
    // Encoding: 0x0EA01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=2, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Rm=0, size=2, Q=0
    let encoding: u32 = 0x0EA01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_5_1c00_0ee01c00() {
    // Encoding: 0x0EE01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=3, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, Rd=0, Rn=0, size=3
    let encoding: u32 = 0x0EE01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_6_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_7_1c00_0e211c00() {
    // Encoding: 0x0E211C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=1, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rm=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E211C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_8_1c00_0e3e1c00() {
    // Encoding: 0x0E3E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=30, Rn=0, Rd=0
    // Fields: Q=0, size=0, Rm=30, Rn=0, Rd=0
    let encoding: u32 = 0x0E3E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_9_1c00_0e3f1c00() {
    // Encoding: 0x0E3F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=31, Rn=0, Rd=0
    // Fields: Rn=0, size=0, Rm=31, Rd=0, Q=0
    let encoding: u32 = 0x0E3F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_10_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_11_1c00_0e201c20() {
    // Encoding: 0x0E201C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=1, Rd=0
    // Fields: Q=0, size=0, Rm=0, Rd=0, Rn=1
    let encoding: u32 = 0x0E201C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_12_1c00_0e201fc0() {
    // Encoding: 0x0E201FC0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=30, Rd=0
    // Fields: size=0, Q=0, Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E201FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_13_1c00_0e201fe0() {
    // Encoding: 0x0E201FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=31, Rd=0
    // Fields: Rn=31, Q=0, size=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_14_1c00_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_15_1c00_0e201c01() {
    // Encoding: 0x0E201C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=1
    // Fields: Q=0, Rn=0, size=0, Rm=0, Rd=1
    let encoding: u32 = 0x0E201C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_16_1c00_0e201c1e() {
    // Encoding: 0x0E201C1E
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=30
    // Fields: Rn=0, Rm=0, Q=0, Rd=30, size=0
    let encoding: u32 = 0x0E201C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_17_1c00_0e201c1f() {
    // Encoding: 0x0E201C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=0, Rd=31
    // Fields: Rd=31, Rm=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_18_1c00_0e211c20() {
    // Encoding: 0x0E211C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=1, Rn=1, Rd=0
    // Fields: Q=0, Rm=1, size=0, Rd=0, Rn=1
    let encoding: u32 = 0x0E211C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_19_1c00_0e3f1fe0() {
    // Encoding: 0x0E3F1FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=31, Rn=31, Rd=0
    // Fields: size=0, Rd=0, Rm=31, Q=0, Rn=31
    let encoding: u32 = 0x0E3F1FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_20_1c00_0e211c01() {
    // Encoding: 0x0E211C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=1, Rn=0, Rd=1
    // Fields: Q=0, Rm=1, Rd=1, size=0, Rn=0
    let encoding: u32 = 0x0E211C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_21_1c00_0e3f1c1f() {
    // Encoding: 0x0E3F1C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=31, Rn=0, Rd=31
    // Fields: Rm=31, Rn=0, size=0, Q=0, Rd=31
    let encoding: u32 = 0x0E3F1C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_22_1c00_0e201c21() {
    // Encoding: 0x0E201C21
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=1, Rd=1
    // Fields: Rm=0, Q=0, Rd=1, size=0, Rn=1
    let encoding: u32 = 0x0E201C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_combo_23_1c00_0e201fff() {
    // Encoding: 0x0E201FFF
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr field combination: Q=0, size=0, Rm=0, Rn=31, Rd=31
    // Fields: Rd=31, Rn=31, Rm=0, Q=0, size=0
    let encoding: u32 = 0x0E201FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_q_0_size_variant_0_7168_0e601c00() {
    // Encoding: 0x0E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value Q = 0 (Size variant 0)
    // Fields: Rm=0, size=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_q_1_size_variant_1_7168_4e601c00() {
    // Encoding: 0x4E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value Q = 1 (Size variant 1)
    // Fields: Rm=0, size=1, Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x4E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_size_0_size_variant_0_7168_0e201c00() {
    // Encoding: 0x0E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value size = 0 (Size variant 0)
    // Fields: size=0, Rm=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_size_1_size_variant_1_7168_0e601c00() {
    // Encoding: 0x0E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value size = 1 (Size variant 1)
    // Fields: size=1, Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_size_2_size_variant_2_7168_0ea01c00() {
    // Encoding: 0x0EA01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value size = 2 (Size variant 2)
    // Fields: size=2, Q=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x0EA01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_size_3_size_variant_3_7168_0ee01c00() {
    // Encoding: 0x0EE01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value size = 3 (Size variant 3)
    // Fields: size=3, Rn=0, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0EE01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_rn_31_stack_pointer_sp_may_require_alignment_7168_0e601fe0() {
    // Encoding: 0x0E601FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=1, Rm=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E601FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_7168_0e601c1f() {
    // Encoding: 0x0E601C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Rm=0, Q=0, size=1
    let encoding: u32 = 0x0E601C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_reg_write_0_0e201c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr register write: SimdFromField("d")
    // Encoding: 0x0E201C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E201C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_sp_rn_0e201fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr with Rn = SP (31)
    // Encoding: 0x0E201FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E201FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_and_orr
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_and_orr_zr_rd_0e201c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_and_orr with Rd = ZR (31)
    // Encoding: 0x0E201C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E201C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_shift Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_q_0_min_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field Q = 0 (Min)
    // Fields: Rn=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_q_1_max_3800_6e213800() {
    // Encoding: 0x6E213800
    // Test aarch64_vector_arithmetic_unary_shift field Q = 1 (Max)
    // Fields: Rn=0, size=0, Rd=0, Q=1
    let encoding: u32 = 0x6E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_size_0_min_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field size = 0 (Min)
    // Fields: Rd=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_size_1_poweroftwo_3800_2e613800() {
    // Encoding: 0x2E613800
    // Test aarch64_vector_arithmetic_unary_shift field size = 1 (PowerOfTwo)
    // Fields: size=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2E613800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_size_2_poweroftwo_3800_2ea13800() {
    // Encoding: 0x2EA13800
    // Test aarch64_vector_arithmetic_unary_shift field size = 2 (PowerOfTwo)
    // Fields: Q=0, Rn=0, size=2, Rd=0
    let encoding: u32 = 0x2EA13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_size_3_max_3800_2ee13800() {
    // Encoding: 0x2EE13800
    // Test aarch64_vector_arithmetic_unary_shift field size = 3 (Max)
    // Fields: Rn=0, Q=0, size=3, Rd=0
    let encoding: u32 = 0x2EE13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rn_0_min_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rn_1_poweroftwo_3800_2e213820() {
    // Encoding: 0x2E213820
    // Test aarch64_vector_arithmetic_unary_shift field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, Rn=1, Rd=0
    let encoding: u32 = 0x2E213820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rn_30_poweroftwominusone_3800_2e213bc0() {
    // Encoding: 0x2E213BC0
    // Test aarch64_vector_arithmetic_unary_shift field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2E213BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rn_31_max_3800_2e213be0() {
    // Encoding: 0x2E213BE0
    // Test aarch64_vector_arithmetic_unary_shift field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, size=0, Rn=31
    let encoding: u32 = 0x2E213BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rd_0_min_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rd_1_poweroftwo_3800_2e213801() {
    // Encoding: 0x2E213801
    // Test aarch64_vector_arithmetic_unary_shift field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rn=0, Rd=1
    let encoding: u32 = 0x2E213801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rd_30_poweroftwominusone_3800_2e21381e() {
    // Encoding: 0x2E21381E
    // Test aarch64_vector_arithmetic_unary_shift field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Q=0, size=0, Rd=30
    let encoding: u32 = 0x2E21381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_field_rd_31_max_3800_2e21381f() {
    // Encoding: 0x2E21381F
    // Test aarch64_vector_arithmetic_unary_shift field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, Rd=31, size=0
    let encoding: u32 = 0x2E21381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_0_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, size=0, Q=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_1_3800_6e213800() {
    // Encoding: 0x6E213800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=1, size=0, Rn=0, Rd=0
    // Fields: size=0, Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x6E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_2_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_3_3800_2e613800() {
    // Encoding: 0x2E613800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=1, Rn=0, Rd=0
    // Fields: size=1, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E613800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_4_3800_2ea13800() {
    // Encoding: 0x2EA13800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=2, Rn=0, Rd=0
    // Fields: size=2, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2EA13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_5_3800_2ee13800() {
    // Encoding: 0x2EE13800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=3, Rn=0, Rd=0
    // Fields: Q=0, size=3, Rd=0, Rn=0
    let encoding: u32 = 0x2EE13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_6_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_7_3800_2e213820() {
    // Encoding: 0x2E213820
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=1, Rd=0
    // Fields: size=0, Rd=0, Q=0, Rn=1
    let encoding: u32 = 0x2E213820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_8_3800_2e213bc0() {
    // Encoding: 0x2E213BC0
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=30, Rd=0
    // Fields: size=0, Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2E213BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_9_3800_2e213be0() {
    // Encoding: 0x2E213BE0
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=31, Rd=0
    // Fields: Rd=0, size=0, Rn=31, Q=0
    let encoding: u32 = 0x2E213BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_10_3800_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_11_3800_2e213801() {
    // Encoding: 0x2E213801
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=1
    // Fields: Q=0, size=0, Rd=1, Rn=0
    let encoding: u32 = 0x2E213801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_12_3800_2e21381e() {
    // Encoding: 0x2E21381E
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=30
    // Fields: Rd=30, Rn=0, size=0, Q=0
    let encoding: u32 = 0x2E21381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_13_3800_2e21381f() {
    // Encoding: 0x2E21381F
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=0, Rd=31
    // Fields: Rd=31, size=0, Q=0, Rn=0
    let encoding: u32 = 0x2E21381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_14_3800_2e213821() {
    // Encoding: 0x2E213821
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=1, Rd=1
    // Fields: size=0, Q=0, Rn=1, Rd=1
    let encoding: u32 = 0x2E213821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_combo_15_3800_2e213bff() {
    // Encoding: 0x2E213BFF
    // Test aarch64_vector_arithmetic_unary_shift field combination: Q=0, size=0, Rn=31, Rd=31
    // Fields: Q=0, size=0, Rd=31, Rn=31
    let encoding: u32 = 0x2E213BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_q_0_size_variant_0_14336_2e613800() {
    // Encoding: 0x2E613800
    // Test aarch64_vector_arithmetic_unary_shift special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Q=0, size=1
    let encoding: u32 = 0x2E613800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_q_1_size_variant_1_14336_6e613800() {
    // Encoding: 0x6E613800
    // Test aarch64_vector_arithmetic_unary_shift special value Q = 1 (Size variant 1)
    // Fields: Rd=0, size=1, Rn=0, Q=1
    let encoding: u32 = 0x6E613800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_size_0_size_variant_0_14336_2e213800() {
    // Encoding: 0x2E213800
    // Test aarch64_vector_arithmetic_unary_shift special value size = 0 (Size variant 0)
    // Fields: Rd=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x2E213800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_size_1_size_variant_1_14336_2e613800() {
    // Encoding: 0x2E613800
    // Test aarch64_vector_arithmetic_unary_shift special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E613800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_size_2_size_variant_2_14336_2ea13800() {
    // Encoding: 0x2EA13800
    // Test aarch64_vector_arithmetic_unary_shift special value size = 2 (Size variant 2)
    // Fields: Rd=0, size=2, Rn=0, Q=0
    let encoding: u32 = 0x2EA13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_size_3_size_variant_3_14336_2ee13800() {
    // Encoding: 0x2EE13800
    // Test aarch64_vector_arithmetic_unary_shift special value size = 3 (Size variant 3)
    // Fields: Rd=0, Q=0, Rn=0, size=3
    let encoding: u32 = 0x2EE13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_rn_31_stack_pointer_sp_may_require_alignment_14336_2e613be0() {
    // Encoding: 0x2E613BE0
    // Test aarch64_vector_arithmetic_unary_shift special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Q=0, size=1, Rd=0
    let encoding: u32 = 0x2E613BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_14336_2e61381f() {
    // Encoding: 0x2E61381F
    // Test aarch64_vector_arithmetic_unary_shift special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, size=1, Q=0
    let encoding: u32 = 0x2E61381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_reg_write_0_2e213800() {
    // Test aarch64_vector_arithmetic_unary_shift register write: SimdFromField("d")
    // Encoding: 0x2E213800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E213800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_sp_rn_2e213be0() {
    // Test aarch64_vector_arithmetic_unary_shift with Rn = SP (31)
    // Encoding: 0x2E213BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E213BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_shift
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_shift_zr_rd_2e21381f() {
    // Test aarch64_vector_arithmetic_unary_shift with Rd = ZR (31)
    // Encoding: 0x2E21381F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E21381F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_diff Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_q_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Q = 0 (Min)
    // Fields: ac=0, Rn=0, U=0, Q=0, Rd=0, Rm=0, size=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_q_1_max_7400_4e207400() {
    // Encoding: 0x4E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Q = 1 (Max)
    // Fields: U=0, size=0, Q=1, Rm=0, Rn=0, ac=0, Rd=0
    let encoding: u32 = 0x4E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_u_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field U = 0 (Min)
    // Fields: Q=0, U=0, size=0, ac=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_u_1_max_7400_2e207400() {
    // Encoding: 0x2E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field U = 1 (Max)
    // Fields: size=0, Q=0, Rm=0, ac=0, Rn=0, U=1, Rd=0
    let encoding: u32 = 0x2E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_size_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field size = 0 (Min)
    // Fields: Rn=0, Q=0, Rm=0, size=0, ac=0, Rd=0, U=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_size_1_poweroftwo_7400_0e607400() {
    // Encoding: 0x0E607400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, U=0, Q=0, size=1, Rm=0, ac=0
    let encoding: u32 = 0x0E607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_size_2_poweroftwo_7400_0ea07400() {
    // Encoding: 0x0EA07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field size = 2 (PowerOfTwo)
    // Fields: Q=0, U=0, size=2, Rm=0, ac=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_size_3_max_7400_0ee07400() {
    // Encoding: 0x0EE07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field size = 3 (Max)
    // Fields: ac=0, Rn=0, size=3, Rd=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0EE07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rm_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rm = 0 (Min)
    // Fields: U=0, Rm=0, Rn=0, Rd=0, Q=0, ac=0, size=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rm_1_poweroftwo_7400_0e217400() {
    // Encoding: 0x0E217400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, size=0, ac=0, Rn=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E217400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rm_30_poweroftwominusone_7400_0e3e7400() {
    // Encoding: 0x0E3E7400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, U=0, Rn=0, Rd=0, ac=0, Rm=30
    let encoding: u32 = 0x0E3E7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rm_31_max_7400_0e3f7400() {
    // Encoding: 0x0E3F7400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rm = 31 (Max)
    // Fields: Q=0, U=0, Rn=0, ac=0, Rd=0, size=0, Rm=31
    let encoding: u32 = 0x0E3F7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field ac 11 +: 1`
/// Requirement: FieldBoundary { field: "ac", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_ac_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field ac = 0 (Min)
    // Fields: Q=0, size=0, U=0, ac=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field ac 11 +: 1`
/// Requirement: FieldBoundary { field: "ac", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_ac_1_max_7400_0e207c00() {
    // Encoding: 0x0E207C00
    // Test aarch64_vector_arithmetic_binary_uniform_diff field ac = 1 (Max)
    // Fields: size=0, Q=0, Rm=0, Rn=0, U=0, ac=1, Rd=0
    let encoding: u32 = 0x0E207C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rn_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rn = 0 (Min)
    // Fields: size=0, U=0, Rm=0, ac=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rn_1_poweroftwo_7400_0e207420() {
    // Encoding: 0x0E207420
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, Q=0, U=0, ac=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E207420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rn_30_poweroftwominusone_7400_0e2077c0() {
    // Encoding: 0x0E2077C0
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, ac=0, Rn=30, Rd=0, U=0, Q=0, size=0
    let encoding: u32 = 0x0E2077C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rn_31_max_7400_0e2077e0() {
    // Encoding: 0x0E2077E0
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rn = 31 (Max)
    // Fields: U=0, ac=0, size=0, Rm=0, Rd=0, Rn=31, Q=0
    let encoding: u32 = 0x0E2077E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rd_0_min_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rd = 0 (Min)
    // Fields: Rd=0, ac=0, U=0, Rm=0, Q=0, Rn=0, size=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rd_1_poweroftwo_7400_0e207401() {
    // Encoding: 0x0E207401
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, size=0, Q=0, U=0, Rm=0, ac=0
    let encoding: u32 = 0x0E207401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rd_30_poweroftwominusone_7400_0e20741e() {
    // Encoding: 0x0E20741E
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: ac=0, Rm=0, Rn=0, U=0, Rd=30, Q=0, size=0
    let encoding: u32 = 0x0E20741E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_field_rd_31_max_7400_0e20741f() {
    // Encoding: 0x0E20741F
    // Test aarch64_vector_arithmetic_binary_uniform_diff field Rd = 31 (Max)
    // Fields: Rd=31, Q=0, ac=0, Rm=0, U=0, Rn=0, size=0
    let encoding: u32 = 0x0E20741F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_0_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, ac=0, size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_1_7400_4e207400() {
    // Encoding: 0x4E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=1, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Rm=0, ac=0, U=0, Rd=0, Rn=0, size=0, Q=1
    let encoding: u32 = 0x4E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_2_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Rn=0, Q=0, Rm=0, size=0, ac=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_3_7400_2e207400() {
    // Encoding: 0x2E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=1, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: size=0, ac=0, U=1, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x2E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_4_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, size=0, Rm=0, U=0, ac=0, Q=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_5_7400_0e607400() {
    // Encoding: 0x0E607400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=1, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: size=1, ac=0, Rd=0, Q=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_6_7400_0ea07400() {
    // Encoding: 0x0EA07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=2, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: U=0, size=2, Rm=0, ac=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EA07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_7_7400_0ee07400() {
    // Encoding: 0x0EE07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=3, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: U=0, size=3, ac=0, Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EE07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_8_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: ac=0, Q=0, U=0, Rn=0, Rd=0, size=0, Rm=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_9_7400_0e217400() {
    // Encoding: 0x0E217400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=1, ac=0, Rn=0, Rd=0
    // Fields: Rm=1, ac=0, U=0, Rn=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E217400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_10_7400_0e3e7400() {
    // Encoding: 0x0E3E7400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=30, ac=0, Rn=0, Rd=0
    // Fields: Rm=30, U=0, ac=0, Rd=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E3E7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_11_7400_0e3f7400() {
    // Encoding: 0x0E3F7400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=31, ac=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Q=0, Rm=31, ac=0, Rn=0, size=0
    let encoding: u32 = 0x0E3F7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// ac=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_12_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: size=0, ac=0, Rn=0, Rd=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// ac=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_13_7400_0e207c00() {
    // Encoding: 0x0E207C00
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, U=0, Rm=0, ac=1, size=0
    let encoding: u32 = 0x0E207C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_14_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, size=0, U=0, Rm=0, ac=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_15_7400_0e207420() {
    // Encoding: 0x0E207420
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=1, Rd=0
    // Fields: ac=0, Rn=1, Rd=0, Rm=0, U=0, size=0, Q=0
    let encoding: u32 = 0x0E207420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_16_7400_0e2077c0() {
    // Encoding: 0x0E2077C0
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=30, Rd=0
    // Fields: ac=0, Rn=30, Rd=0, Q=0, Rm=0, U=0, size=0
    let encoding: u32 = 0x0E2077C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_17_7400_0e2077e0() {
    // Encoding: 0x0E2077E0
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=31, Rd=0
    // Fields: Rd=0, Q=0, Rm=0, U=0, ac=0, size=0, Rn=31
    let encoding: u32 = 0x0E2077E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_18_7400_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, ac=0, Rn=0, U=0, size=0, Rd=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_19_7400_0e207401() {
    // Encoding: 0x0E207401
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=1
    // Fields: Rd=1, ac=0, U=0, Rn=0, Q=0, Rm=0, size=0
    let encoding: u32 = 0x0E207401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_20_7400_0e20741e() {
    // Encoding: 0x0E20741E
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=30
    // Fields: Rm=0, Q=0, ac=0, Rn=0, Rd=30, U=0, size=0
    let encoding: u32 = 0x0E20741E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_21_7400_0e20741f() {
    // Encoding: 0x0E20741F
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=0, Rd=31
    // Fields: U=0, ac=0, Rn=0, Rd=31, size=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20741F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_22_7400_0e217420() {
    // Encoding: 0x0E217420
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=1, ac=0, Rn=1, Rd=0
    // Fields: size=0, Q=0, Rn=1, Rd=0, ac=0, Rm=1, U=0
    let encoding: u32 = 0x0E217420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_23_7400_0e3f77e0() {
    // Encoding: 0x0E3F77E0
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=31, ac=0, Rn=31, Rd=0
    // Fields: Rm=31, U=0, Rd=0, Rn=31, Q=0, ac=0, size=0
    let encoding: u32 = 0x0E3F77E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_24_7400_0e217401() {
    // Encoding: 0x0E217401
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=1, ac=0, Rn=0, Rd=1
    // Fields: ac=0, U=0, Rm=1, Rn=0, Q=0, Rd=1, size=0
    let encoding: u32 = 0x0E217401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_25_7400_0e3f741f() {
    // Encoding: 0x0E3F741F
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=31, ac=0, Rn=0, Rd=31
    // Fields: size=0, Q=0, U=0, ac=0, Rn=0, Rm=31, Rd=31
    let encoding: u32 = 0x0E3F741F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_26_7400_0e207421() {
    // Encoding: 0x0E207421
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=1, Rd=1
    // Fields: size=0, Rm=0, Rd=1, Rn=1, ac=0, Q=0, U=0
    let encoding: u32 = 0x0E207421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_combo_27_7400_0e2077ff() {
    // Encoding: 0x0E2077FF
    // Test aarch64_vector_arithmetic_binary_uniform_diff field combination: Q=0, U=0, size=0, Rm=0, ac=0, Rn=31, Rd=31
    // Fields: size=0, ac=0, Q=0, Rm=0, U=0, Rn=31, Rd=31
    let encoding: u32 = 0x0E2077FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_q_0_size_variant_0_29696_0e607400() {
    // Encoding: 0x0E607400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value Q = 0 (Size variant 0)
    // Fields: U=0, ac=0, size=1, Q=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_q_1_size_variant_1_29696_4e607400() {
    // Encoding: 0x4E607400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value Q = 1 (Size variant 1)
    // Fields: Rd=0, size=1, Rm=0, ac=0, Q=1, U=0, Rn=0
    let encoding: u32 = 0x4E607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_size_0_size_variant_0_29696_0e207400() {
    // Encoding: 0x0E207400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value size = 0 (Size variant 0)
    // Fields: Rm=0, size=0, U=0, Q=0, Rd=0, ac=0, Rn=0
    let encoding: u32 = 0x0E207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_size_1_size_variant_1_29696_0e607400() {
    // Encoding: 0x0E607400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value size = 1 (Size variant 1)
    // Fields: U=0, Q=0, ac=0, size=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_size_2_size_variant_2_29696_0ea07400() {
    // Encoding: 0x0EA07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value size = 2 (Size variant 2)
    // Fields: U=0, Rd=0, size=2, ac=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0EA07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_size_3_size_variant_3_29696_0ee07400() {
    // Encoding: 0x0EE07400
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value size = 3 (Size variant 3)
    // Fields: size=3, Q=0, U=0, Rm=0, ac=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EE07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_rn_31_stack_pointer_sp_may_require_alignment_29696_0e6077e0() {
    // Encoding: 0x0E6077E0
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rm=0, Q=0, Rd=0, Rn=31, ac=0, size=1
    let encoding: u32 = 0x0E6077E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_29696_0e60741f() {
    // Encoding: 0x0E60741F
    // Test aarch64_vector_arithmetic_binary_uniform_diff special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, Rd=31, U=0, size=1, ac=0, Q=0
    let encoding: u32 = 0x0E60741F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_reg_write_0_0e207400() {
    // Test aarch64_vector_arithmetic_binary_uniform_diff register write: SimdFromField("d")
    // Encoding: 0x0E207400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E207400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_sp_rn_0e2077e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_diff with Rn = SP (31)
    // Encoding: 0x0E2077E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2077E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_diff
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_diff_zr_rd_0e20741f() {
    // Test aarch64_vector_arithmetic_binary_uniform_diff with Rd = ZR (31)
    // Encoding: 0x0E20741F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20741F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_q_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Q = 0 (Min)
    // Fields: Rn=0, Rm=0, Q=0, U=0, a=0, Rd=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_q_1_max_400_4e400400() {
    // Encoding: 0x4E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Q = 1 (Max)
    // Fields: Rm=0, Rn=0, Rd=0, Q=1, U=0, a=0
    let encoding: u32 = 0x4E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_u_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field U = 0 (Min)
    // Fields: Q=0, U=0, Rd=0, Rn=0, Rm=0, a=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_u_1_max_400_2e400400() {
    // Encoding: 0x2E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field U = 1 (Max)
    // Fields: Rn=0, Rd=0, Rm=0, a=0, Q=0, U=1
    let encoding: u32 = 0x2E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field a 23 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_a_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field a = 0 (Min)
    // Fields: Rn=0, Rd=0, U=0, Q=0, a=0, Rm=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field a 23 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_a_1_max_400_0ec00400() {
    // Encoding: 0x0EC00400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field a = 1 (Max)
    // Fields: Rn=0, Rd=0, Q=0, a=1, Rm=0, U=0
    let encoding: u32 = 0x0EC00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rm_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rm = 0 (Min)
    // Fields: Q=0, a=0, U=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rm_1_poweroftwo_400_0e410400() {
    // Encoding: 0x0E410400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, a=0, Rd=0, U=0, Rn=0, Rm=1
    let encoding: u32 = 0x0E410400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rm_30_poweroftwominusone_400_0e5e0400() {
    // Encoding: 0x0E5E0400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, a=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E5E0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rm_31_max_400_0e5f0400() {
    // Encoding: 0x0E5F0400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rm = 31 (Max)
    // Fields: Q=0, U=0, Rm=31, Rd=0, Rn=0, a=0
    let encoding: u32 = 0x0E5F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rn_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, U=0, Rm=0, Q=0, a=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rn_1_poweroftwo_400_0e400420() {
    // Encoding: 0x0E400420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rn=1, a=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E400420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rn_30_poweroftwominusone_400_0e4007c0() {
    // Encoding: 0x0E4007C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0, U=0, a=0, Rm=0
    let encoding: u32 = 0x0E4007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rn_31_max_400_0e4007e0() {
    // Encoding: 0x0E4007E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rn = 31 (Max)
    // Fields: Q=0, a=0, Rn=31, Rd=0, U=0, Rm=0
    let encoding: u32 = 0x0E4007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rd_0_min_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rd = 0 (Min)
    // Fields: Rm=0, U=0, Q=0, a=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rd_1_poweroftwo_400_0e400401() {
    // Encoding: 0x0E400401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, U=0, Q=0, a=0, Rm=0
    let encoding: u32 = 0x0E400401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rd_30_poweroftwominusone_400_0e40041e() {
    // Encoding: 0x0E40041E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Q=0, U=0, a=0, Rd=30
    let encoding: u32 = 0x0E40041E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_field_rd_31_max_400_0e40041f() {
    // Encoding: 0x0E40041F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field Rd = 31 (Max)
    // Fields: Q=0, U=0, Rm=0, Rn=0, Rd=31, a=0
    let encoding: u32 = 0x0E40041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_0_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Rn=0, Rm=0, a=0, Q=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_1_400_4e400400() {
    // Encoding: 0x4E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=1, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, a=0, Rm=0, Rn=0, Q=1
    let encoding: u32 = 0x4E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_2_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, a=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_3_400_2e400400() {
    // Encoding: 0x2E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=1, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, a=0, Rm=0, Rn=0, Rd=0, U=1
    let encoding: u32 = 0x2E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_4_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rd=0, Rm=0, a=0, Rn=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// a=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_5_400_0ec00400() {
    // Encoding: 0x0EC00400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=1, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, a=1, U=0, Rm=0
    let encoding: u32 = 0x0EC00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_6_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, a=0, Rd=0, Rm=0, Q=0, U=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_7_400_0e410400() {
    // Encoding: 0x0E410400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=1, Rn=0, Rd=0
    // Fields: a=0, Rm=1, Rn=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E410400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_8_400_0e5e0400() {
    // Encoding: 0x0E5E0400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=30, Rn=0, Rd=0
    // Fields: Rd=0, a=0, Q=0, U=0, Rm=30, Rn=0
    let encoding: u32 = 0x0E5E0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_9_400_0e5f0400() {
    // Encoding: 0x0E5F0400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=31, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, a=0, Rm=31, Rn=0, U=0
    let encoding: u32 = 0x0E5F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_10_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, U=0, a=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_11_400_0e400420() {
    // Encoding: 0x0E400420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=1, Rd=0
    // Fields: Q=0, Rm=0, Rn=1, U=0, Rd=0, a=0
    let encoding: u32 = 0x0E400420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_12_400_0e4007c0() {
    // Encoding: 0x0E4007C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=30, Rd=0
    // Fields: U=0, Rm=0, Rn=30, Rd=0, a=0, Q=0
    let encoding: u32 = 0x0E4007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_13_400_0e4007e0() {
    // Encoding: 0x0E4007E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=31, Rd=0
    // Fields: Rd=0, Q=0, Rm=0, a=0, Rn=31, U=0
    let encoding: u32 = 0x0E4007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_14_400_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, a=0, Rd=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_15_400_0e400401() {
    // Encoding: 0x0E400401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=1
    // Fields: a=0, U=0, Rm=0, Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x0E400401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_16_400_0e40041e() {
    // Encoding: 0x0E40041E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=30
    // Fields: a=0, Rn=0, Rd=30, Q=0, Rm=0, U=0
    let encoding: u32 = 0x0E40041E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_17_400_0e40041f() {
    // Encoding: 0x0E40041F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, a=0, U=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E40041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_18_400_0e410420() {
    // Encoding: 0x0E410420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=1, Rn=1, Rd=0
    // Fields: Rm=1, Rn=1, Rd=0, Q=0, U=0, a=0
    let encoding: u32 = 0x0E410420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_19_400_0e5f07e0() {
    // Encoding: 0x0E5F07E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=31, Rn=31, Rd=0
    // Fields: a=0, U=0, Rm=31, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E5F07E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_20_400_0e410401() {
    // Encoding: 0x0E410401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=1, Rn=0, Rd=1
    // Fields: Rm=1, Q=0, U=0, a=0, Rn=0, Rd=1
    let encoding: u32 = 0x0E410401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_21_400_0e5f041f() {
    // Encoding: 0x0E5F041F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=31, Rn=0, Rd=31
    // Fields: Rn=0, Q=0, U=0, Rm=31, a=0, Rd=31
    let encoding: u32 = 0x0E5F041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_22_400_0e400421() {
    // Encoding: 0x0E400421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=1, Rd=1
    // Fields: Q=0, U=0, a=0, Rm=0, Rd=1, Rn=1
    let encoding: u32 = 0x0E400421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_combo_23_400_0e4007ff() {
    // Encoding: 0x0E4007FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 field combination: Q=0, U=0, a=0, Rm=0, Rn=31, Rd=31
    // Fields: Rd=31, Q=0, U=0, Rm=0, a=0, Rn=31
    let encoding: u32 = 0x0E4007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_special_q_0_size_variant_0_1024_0e400400() {
    // Encoding: 0x0E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 special value Q = 0 (Size variant 0)
    // Fields: U=0, Rm=0, Q=0, Rd=0, a=0, Rn=0
    let encoding: u32 = 0x0E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_special_q_1_size_variant_1_1024_4e400400() {
    // Encoding: 0x4E400400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rm=0, Rn=0, U=0, Rd=0, a=0
    let encoding: u32 = 0x4E400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_special_rn_31_stack_pointer_sp_may_require_alignment_1024_0e4007e0() {
    // Encoding: 0x0E4007E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Q=0, U=0, a=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E4007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_1024_0e40041f() {
    // Encoding: 0x0E40041F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rm=0, Rn=0, Rd=31, U=0, a=0
    let encoding: u32 = 0x0E40041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_q_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Q = 0 (Min)
    // Fields: Rd=0, Rm=0, o1=0, U=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_q_1_max_c400_4e20c400() {
    // Encoding: 0x4E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Q = 1 (Max)
    // Fields: o1=0, Rm=0, Q=1, U=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x4E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_u_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field U = 0 (Min)
    // Fields: sz=0, Rm=0, Rd=0, o1=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_u_1_max_c400_2e20c400() {
    // Encoding: 0x2E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field U = 1 (Max)
    // Fields: Rm=0, Q=0, Rd=0, U=1, Rn=0, o1=0, sz=0
    let encoding: u32 = 0x2E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_o1_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field o1 = 0 (Min)
    // Fields: Rn=0, Rm=0, Q=0, U=0, o1=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field o1 23 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_o1_1_max_c400_0ea0c400() {
    // Encoding: 0x0EA0C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field o1 = 1 (Max)
    // Fields: Rm=0, U=0, sz=0, Q=0, Rn=0, Rd=0, o1=1
    let encoding: u32 = 0x0EA0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_sz_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field sz = 0 (Min)
    // Fields: U=0, sz=0, Rm=0, o1=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_sz_1_max_c400_0e60c400() {
    // Encoding: 0x0E60C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field sz = 1 (Max)
    // Fields: Rn=0, Rd=0, U=0, o1=0, Q=0, sz=1, Rm=0
    let encoding: u32 = 0x0E60C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rm_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rm = 0 (Min)
    // Fields: Q=0, o1=0, U=0, Rm=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rm_1_poweroftwo_c400_0e21c400() {
    // Encoding: 0x0E21C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, sz=0, U=0, o1=0, Rn=0, Rd=0, Rm=1
    let encoding: u32 = 0x0E21C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rm_30_poweroftwominusone_c400_0e3ec400() {
    // Encoding: 0x0E3EC400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rd=0, Rm=30, o1=0, sz=0, Rn=0, U=0
    let encoding: u32 = 0x0E3EC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rm_31_max_c400_0e3fc400() {
    // Encoding: 0x0E3FC400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rm = 31 (Max)
    // Fields: o1=0, Rd=0, Q=0, Rm=31, sz=0, Rn=0, U=0
    let encoding: u32 = 0x0E3FC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rn_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rn = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0, o1=0, sz=0, Rm=0, U=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rn_1_poweroftwo_c400_0e20c420() {
    // Encoding: 0x0E20C420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, o1=0, Rd=0, U=0, sz=0, Q=0
    let encoding: u32 = 0x0E20C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rn_30_poweroftwominusone_c400_0e20c7c0() {
    // Encoding: 0x0E20C7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, U=0, Q=0, o1=0, sz=0, Rm=0, Rn=30
    let encoding: u32 = 0x0E20C7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rn_31_max_c400_0e20c7e0() {
    // Encoding: 0x0E20C7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rn = 31 (Max)
    // Fields: Rn=31, o1=0, sz=0, Rd=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E20C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rd_0_min_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rd = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0, Rd=0, Q=0, o1=0, U=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rd_1_poweroftwo_c400_0e20c401() {
    // Encoding: 0x0E20C401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, o1=0, sz=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E20C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rd_30_poweroftwominusone_c400_0e20c41e() {
    // Encoding: 0x0E20C41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, Rm=0, sz=0, Q=0, U=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E20C41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_field_rd_31_max_c400_0e20c41f() {
    // Encoding: 0x0E20C41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field Rd = 31 (Max)
    // Fields: Rm=0, Rd=31, Rn=0, sz=0, Q=0, U=0, o1=0
    let encoding: u32 = 0x0E20C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_0_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_1_c400_4e20c400() {
    // Encoding: 0x4E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=1, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, U=0, o1=0, Q=1, Rd=0, sz=0
    let encoding: u32 = 0x4E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_2_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, sz=0, Rd=0, Q=0, o1=0, U=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_3_c400_2e20c400() {
    // Encoding: 0x2E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=1, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: U=1, o1=0, sz=0, Rm=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_4_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, o1=0, Q=0, sz=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_5_c400_0ea0c400() {
    // Encoding: 0x0EA0C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=1, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, Rn=0, Q=0, U=0, o1=1, sz=0
    let encoding: u32 = 0x0EA0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_6_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Rd=0, o1=0, Rm=0, Q=0, U=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_7_c400_0e60c400() {
    // Encoding: 0x0E60C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rm=0, Rd=0, o1=0, sz=1, Rn=0
    let encoding: u32 = 0x0E60C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_8_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: o1=0, Q=0, U=0, sz=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_9_c400_0e21c400() {
    // Encoding: 0x0E21C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=0, Rd=0
    // Fields: sz=0, o1=0, Rm=1, Rd=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E21C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_10_c400_0e3ec400() {
    // Encoding: 0x0E3EC400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=30, Rn=0, Rd=0
    // Fields: U=0, o1=0, Rd=0, sz=0, Q=0, Rm=30, Rn=0
    let encoding: u32 = 0x0E3EC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_11_c400_0e3fc400() {
    // Encoding: 0x0E3FC400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=0, Rd=0
    // Fields: Q=0, o1=0, Rm=31, U=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x0E3FC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_12_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: o1=0, Rd=0, sz=0, U=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_13_c400_0e20c420() {
    // Encoding: 0x0E20C420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=1, Rd=0
    // Fields: Rm=0, Rn=1, Rd=0, Q=0, o1=0, U=0, sz=0
    let encoding: u32 = 0x0E20C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_14_c400_0e20c7c0() {
    // Encoding: 0x0E20C7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=30, Rd=0
    // Fields: o1=0, Rm=0, U=0, Q=0, sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E20C7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_15_c400_0e20c7e0() {
    // Encoding: 0x0E20C7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=31, Rd=0
    // Fields: o1=0, sz=0, U=0, Rm=0, Rn=31, Rd=0, Q=0
    let encoding: u32 = 0x0E20C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_16_c400_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, U=0, o1=0, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_17_c400_0e20c401() {
    // Encoding: 0x0E20C401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=1
    // Fields: Q=0, sz=0, Rm=0, o1=0, Rn=0, Rd=1, U=0
    let encoding: u32 = 0x0E20C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_18_c400_0e20c41e() {
    // Encoding: 0x0E20C41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=30
    // Fields: Rm=0, sz=0, Rn=0, o1=0, Rd=30, U=0, Q=0
    let encoding: u32 = 0x0E20C41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_19_c400_0e20c41f() {
    // Encoding: 0x0E20C41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Q=0, U=0, o1=0, Rn=0, Rd=31, sz=0, Rm=0
    let encoding: u32 = 0x0E20C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_20_c400_0e21c420() {
    // Encoding: 0x0E21C420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=1, Rd=0
    // Fields: U=0, Rn=1, Rm=1, Rd=0, o1=0, sz=0, Q=0
    let encoding: u32 = 0x0E21C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_21_c400_0e3fc7e0() {
    // Encoding: 0x0E3FC7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=31, Rd=0
    // Fields: Rm=31, Rd=0, Q=0, sz=0, U=0, o1=0, Rn=31
    let encoding: u32 = 0x0E3FC7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_22_c400_0e21c401() {
    // Encoding: 0x0E21C401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=1, Rn=0, Rd=1
    // Fields: Q=0, U=0, Rd=1, sz=0, o1=0, Rm=1, Rn=0
    let encoding: u32 = 0x0E21C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_23_c400_0e3fc41f() {
    // Encoding: 0x0E3FC41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=31, Rn=0, Rd=31
    // Fields: U=0, sz=0, Rn=0, Rd=31, Q=0, o1=0, Rm=31
    let encoding: u32 = 0x0E3FC41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_24_c400_0e20c421() {
    // Encoding: 0x0E20C421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Rd=1, U=0, o1=0, Q=0, sz=0, Rm=0, Rn=1
    let encoding: u32 = 0x0E20C421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_combo_25_c400_0e20c7ff() {
    // Encoding: 0x0E20C7FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 field combination: Q=0, U=0, o1=0, sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rm=0, U=0, Rn=31, Rd=31, sz=0, o1=0, Q=0
    let encoding: u32 = 0x0E20C7FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_q_0_size_variant_0_50176_0e60c400() {
    // Encoding: 0x0E60C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value Q = 0 (Size variant 0)
    // Fields: U=0, Rd=0, Rm=0, Q=0, o1=0, sz=1, Rn=0
    let encoding: u32 = 0x0E60C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_q_1_size_variant_1_50176_4e60c400() {
    // Encoding: 0x4E60C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value Q = 1 (Size variant 1)
    // Fields: U=0, o1=0, Rm=0, Rn=0, Q=1, Rd=0, sz=1
    let encoding: u32 = 0x4E60C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_sz_0_size_variant_0_50176_0e20c400() {
    // Encoding: 0x0E20C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value sz = 0 (Size variant 0)
    // Fields: Rm=0, Q=0, U=0, sz=0, Rd=0, Rn=0, o1=0
    let encoding: u32 = 0x0E20C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_sz_1_size_variant_1_50176_0e60c400() {
    // Encoding: 0x0E60C400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Q=0, o1=0, U=0, Rd=0, sz=1, Rm=0
    let encoding: u32 = 0x0E60C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_rn_31_stack_pointer_sp_may_require_alignment_50176_0e60c7e0() {
    // Encoding: 0x0E60C7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: o1=0, Rn=31, Rd=0, Rm=0, Q=0, U=0, sz=1
    let encoding: u32 = 0x0E60C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_50176_0e60c41f() {
    // Encoding: 0x0E60C41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, o1=0, U=0, sz=1, Rm=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E60C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_reg_write_0_0e400400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 register write: SimdFromField("d")
    // Encoding: 0x0E400400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E400400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_sp_rn_0e4007e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 with Rn = SP (31)
    // Encoding: 0x0E4007E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E4007E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008_zr_rd_0e40041f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp16_2008 with Rd = ZR (31)
    // Encoding: 0x0E40041F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E40041F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_reg_write_0_0e20c400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 register write: SimdFromField("d")
    // Encoding: 0x0E20C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_sp_rn_0e20c7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 with Rn = SP (31)
    // Encoding: 0x0E20C7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008_zr_rd_0e20c41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_fp_2008 with Rd = ZR (31)
    // Encoding: 0x0E20C41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_max_min_single Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_q_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Q = 0 (Min)
    // Fields: o1=0, U=0, size=0, Q=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_q_1_max_6400_4e206400() {
    // Encoding: 0x4E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Q = 1 (Max)
    // Fields: U=0, Q=1, Rm=0, Rd=0, o1=0, size=0, Rn=0
    let encoding: u32 = 0x4E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_u_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field U = 0 (Min)
    // Fields: Rn=0, Rd=0, size=0, U=0, Q=0, Rm=0, o1=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_u_1_max_6400_2e206400() {
    // Encoding: 0x2E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field U = 1 (Max)
    // Fields: Rd=0, Rn=0, size=0, U=1, Rm=0, o1=0, Q=0
    let encoding: u32 = 0x2E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_size_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field size = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, Rd=0, Q=0, o1=0, U=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_size_1_poweroftwo_6400_0e606400() {
    // Encoding: 0x0E606400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field size = 1 (PowerOfTwo)
    // Fields: U=0, size=1, Rn=0, Q=0, Rd=0, o1=0, Rm=0
    let encoding: u32 = 0x0E606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_size_2_poweroftwo_6400_0ea06400() {
    // Encoding: 0x0EA06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field size = 2 (PowerOfTwo)
    // Fields: o1=0, Rm=0, U=0, Rd=0, size=2, Q=0, Rn=0
    let encoding: u32 = 0x0EA06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_size_3_max_6400_0ee06400() {
    // Encoding: 0x0EE06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field size = 3 (Max)
    // Fields: Rm=0, o1=0, Rd=0, Q=0, size=3, Rn=0, U=0
    let encoding: u32 = 0x0EE06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rm_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rm = 0 (Min)
    // Fields: Rm=0, U=0, size=0, o1=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rm_1_poweroftwo_6400_0e216400() {
    // Encoding: 0x0E216400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rm = 1 (PowerOfTwo)
    // Fields: size=0, U=0, Rm=1, Rn=0, Q=0, Rd=0, o1=0
    let encoding: u32 = 0x0E216400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rm_30_poweroftwominusone_6400_0e3e6400() {
    // Encoding: 0x0E3E6400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, U=0, Rm=30, size=0, Q=0, o1=0, Rd=0
    let encoding: u32 = 0x0E3E6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rm_31_max_6400_0e3f6400() {
    // Encoding: 0x0E3F6400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rm = 31 (Max)
    // Fields: Q=0, size=0, Rm=31, Rn=0, U=0, Rd=0, o1=0
    let encoding: u32 = 0x0E3F6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field o1 11 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_o1_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field o1 = 0 (Min)
    // Fields: Rn=0, U=0, Rm=0, Rd=0, Q=0, o1=0, size=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field o1 11 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_o1_1_max_6400_0e206c00() {
    // Encoding: 0x0E206C00
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field o1 = 1 (Max)
    // Fields: size=0, Rm=0, Q=0, o1=1, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rn_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rn = 0 (Min)
    // Fields: Q=0, size=0, o1=0, Rm=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rn_1_poweroftwo_6400_0e206420() {
    // Encoding: 0x0E206420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, o1=0, Q=0, size=0, Rn=1, Rd=0, U=0
    let encoding: u32 = 0x0E206420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rn_30_poweroftwominusone_6400_0e2067c0() {
    // Encoding: 0x0E2067C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, size=0, U=0, Rm=0, Rn=30, Q=0, Rd=0
    let encoding: u32 = 0x0E2067C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rn_31_max_6400_0e2067e0() {
    // Encoding: 0x0E2067E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rn = 31 (Max)
    // Fields: U=0, Rm=0, Rd=0, Rn=31, o1=0, Q=0, size=0
    let encoding: u32 = 0x0E2067E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rd_0_min_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rd = 0 (Min)
    // Fields: Rd=0, U=0, o1=0, size=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rd_1_poweroftwo_6400_0e206401() {
    // Encoding: 0x0E206401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rd=1, o1=0, size=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E206401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rd_30_poweroftwominusone_6400_0e20641e() {
    // Encoding: 0x0E20641E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, o1=0, Rd=30, Rm=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E20641E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_field_rd_31_max_6400_0e20641f() {
    // Encoding: 0x0E20641F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field Rd = 31 (Max)
    // Fields: U=0, size=0, Rm=0, o1=0, Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0E20641F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_0_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, Rn=0, Q=0, size=0, o1=0, Rd=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_1_6400_4e206400() {
    // Encoding: 0x4E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=1, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Rm=0, U=0, Q=1, size=0, o1=0
    let encoding: u32 = 0x4E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_2_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: size=0, o1=0, Rn=0, Rd=0, U=0, Rm=0, Q=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_3_6400_2e206400() {
    // Encoding: 0x2E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=1, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, Rm=0, Rn=0, U=1, o1=0, Rd=0
    let encoding: u32 = 0x2E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_4_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, o1=0, Q=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_5_6400_0e606400() {
    // Encoding: 0x0E606400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=1, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: size=1, Rd=0, o1=0, Rm=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_6_6400_0ea06400() {
    // Encoding: 0x0EA06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=2, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rd=0, Rn=0, U=0, Rm=0, Q=0, size=2
    let encoding: u32 = 0x0EA06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_7_6400_0ee06400() {
    // Encoding: 0x0EE06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=3, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, Rm=0, o1=0, size=3, Q=0
    let encoding: u32 = 0x0EE06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_8_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=0, U=0, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_9_6400_0e216400() {
    // Encoding: 0x0E216400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Rm=1, size=0, U=0, Q=0, o1=0
    let encoding: u32 = 0x0E216400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_10_6400_0e3e6400() {
    // Encoding: 0x0E3E6400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=30, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, o1=0, size=0, Rm=30, Q=0, Rd=0
    let encoding: u32 = 0x0E3E6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_11_6400_0e3f6400() {
    // Encoding: 0x0E3F6400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Q=0, Rm=31, Rn=0, Rd=0, size=0, U=0
    let encoding: u32 = 0x0E3F6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_12_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Q=0, Rm=0, o1=0, U=0, Rn=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_13_6400_0e206c00() {
    // Encoding: 0x0E206C00
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, size=0, Rm=0, U=0, o1=1
    let encoding: u32 = 0x0E206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_14_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, o1=0, Q=0, U=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_15_6400_0e206420() {
    // Encoding: 0x0E206420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=1, Rd=0
    // Fields: o1=0, size=0, Rd=0, U=0, Rm=0, Q=0, Rn=1
    let encoding: u32 = 0x0E206420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_16_6400_0e2067c0() {
    // Encoding: 0x0E2067C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=30, Rd=0
    // Fields: Rn=30, Q=0, size=0, Rm=0, U=0, o1=0, Rd=0
    let encoding: u32 = 0x0E2067C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_17_6400_0e2067e0() {
    // Encoding: 0x0E2067E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=31, Rd=0
    // Fields: size=0, Q=0, o1=0, Rd=0, Rm=0, Rn=31, U=0
    let encoding: u32 = 0x0E2067E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_18_6400_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, Rn=0, U=0, size=0, o1=0, Rd=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_19_6400_0e206401() {
    // Encoding: 0x0E206401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=1
    // Fields: o1=0, Rm=0, Rn=0, size=0, Rd=1, U=0, Q=0
    let encoding: u32 = 0x0E206401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_20_6400_0e20641e() {
    // Encoding: 0x0E20641E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=30
    // Fields: o1=0, Q=0, Rd=30, size=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20641E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_21_6400_0e20641f() {
    // Encoding: 0x0E20641F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=31
    // Fields: Rd=31, Rm=0, Q=0, o1=0, Rn=0, U=0, size=0
    let encoding: u32 = 0x0E20641F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_22_6400_0e216420() {
    // Encoding: 0x0E216420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=1, Rd=0
    // Fields: U=0, size=0, Rm=1, Rn=1, Rd=0, o1=0, Q=0
    let encoding: u32 = 0x0E216420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_23_6400_0e3f67e0() {
    // Encoding: 0x0E3F67E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=31, Rd=0
    // Fields: Rm=31, Q=0, o1=0, size=0, Rn=31, Rd=0, U=0
    let encoding: u32 = 0x0E3F67E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_24_6400_0e216401() {
    // Encoding: 0x0E216401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=0, Rd=1
    // Fields: Rm=1, Q=0, o1=0, size=0, Rd=1, Rn=0, U=0
    let encoding: u32 = 0x0E216401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_25_6400_0e3f641f() {
    // Encoding: 0x0E3F641F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=0, Rd=31
    // Fields: Q=0, U=0, Rm=31, size=0, o1=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E3F641F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_26_6400_0e206421() {
    // Encoding: 0x0E206421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=1, Rd=1
    // Fields: Rm=0, o1=0, Rn=1, U=0, Rd=1, Q=0, size=0
    let encoding: u32 = 0x0E206421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_combo_27_6400_0e2067ff() {
    // Encoding: 0x0E2067FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=31, Rd=31
    // Fields: Rn=31, U=0, size=0, Rd=31, Rm=0, Q=0, o1=0
    let encoding: u32 = 0x0E2067FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_q_0_size_variant_0_25600_0e606400() {
    // Encoding: 0x0E606400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value Q = 0 (Size variant 0)
    // Fields: size=1, U=0, Rn=0, Q=0, Rd=0, Rm=0, o1=0
    let encoding: u32 = 0x0E606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_q_1_size_variant_1_25600_4e606400() {
    // Encoding: 0x4E606400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Rn=0, size=1, U=0, o1=0, Rd=0, Q=1
    let encoding: u32 = 0x4E606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_size_0_size_variant_0_25600_0e206400() {
    // Encoding: 0x0E206400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Rd=0, Q=0, U=0, Rm=0, o1=0
    let encoding: u32 = 0x0E206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_size_1_size_variant_1_25600_0e606400() {
    // Encoding: 0x0E606400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value size = 1 (Size variant 1)
    // Fields: U=0, Rd=0, size=1, Rm=0, o1=0, Rn=0, Q=0
    let encoding: u32 = 0x0E606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_size_2_size_variant_2_25600_0ea06400() {
    // Encoding: 0x0EA06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value size = 2 (Size variant 2)
    // Fields: Rn=0, Rd=0, size=2, Rm=0, Q=0, U=0, o1=0
    let encoding: u32 = 0x0EA06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_size_3_size_variant_3_25600_0ee06400() {
    // Encoding: 0x0EE06400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value size = 3 (Size variant 3)
    // Fields: Rd=0, U=0, Q=0, size=3, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0EE06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_rn_31_stack_pointer_sp_may_require_alignment_25600_0e6067e0() {
    // Encoding: 0x0E6067E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rm=0, o1=0, Rn=31, Rd=0, U=0, size=1
    let encoding: u32 = 0x0E6067E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_25600_0e60641f() {
    // Encoding: 0x0E60641F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o1=0, Rd=31, size=1, Q=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E60641F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_reg_write_0_0e206400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single register write: SimdFromField("d")
    // Encoding: 0x0E206400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E206400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_sp_rn_0e2067e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single with Rn = SP (31)
    // Encoding: 0x0E2067E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2067E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_single
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_single_zr_rd_0e20641f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_single with Rd = ZR (31)
    // Encoding: 0x0E20641F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20641F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_shift_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_u_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field U = 0 (Min)
    // Fields: U=0, Rn=0, Rd=0, size=0, Rm=0, R=0, S=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_u_1_max_4400_7e204400() {
    // Encoding: 0x7E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field U = 1 (Max)
    // Fields: U=1, Rn=0, Rd=0, Rm=0, R=0, size=0, S=0
    let encoding: u32 = 0x7E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_size_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field size = 0 (Min)
    // Fields: R=0, S=0, size=0, Rd=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_size_1_poweroftwo_4400_5e604400() {
    // Encoding: 0x5E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field size = 1 (PowerOfTwo)
    // Fields: U=0, S=0, Rn=0, Rd=0, R=0, size=1, Rm=0
    let encoding: u32 = 0x5E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_size_2_poweroftwo_4400_5ea04400() {
    // Encoding: 0x5EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field size = 2 (PowerOfTwo)
    // Fields: Rm=0, R=0, size=2, S=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_size_3_max_4400_5ee04400() {
    // Encoding: 0x5EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field size = 3 (Max)
    // Fields: Rd=0, U=0, Rm=0, S=0, R=0, size=3, Rn=0
    let encoding: u32 = 0x5EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rm_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rm = 0 (Min)
    // Fields: U=0, S=0, size=0, Rm=0, R=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rm_1_poweroftwo_4400_5e214400() {
    // Encoding: 0x5E214400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rm = 1 (PowerOfTwo)
    // Fields: U=0, R=0, S=0, Rn=0, Rd=0, Rm=1, size=0
    let encoding: u32 = 0x5E214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rm_30_poweroftwominusone_4400_5e3e4400() {
    // Encoding: 0x5E3E4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, S=0, U=0, R=0, Rm=30, Rd=0, size=0
    let encoding: u32 = 0x5E3E4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rm_31_max_4400_5e3f4400() {
    // Encoding: 0x5E3F4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rm = 31 (Max)
    // Fields: U=0, size=0, Rm=31, S=0, R=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E3F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field R 12 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_r_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field R = 0 (Min)
    // Fields: size=0, Rm=0, S=0, Rn=0, U=0, Rd=0, R=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field R 12 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_r_1_max_4400_5e205400() {
    // Encoding: 0x5E205400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field R = 1 (Max)
    // Fields: size=0, Rd=0, Rm=0, U=0, R=1, S=0, Rn=0
    let encoding: u32 = 0x5E205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_s_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field S = 0 (Min)
    // Fields: Rn=0, U=0, R=0, size=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_s_1_max_4400_5e204c00() {
    // Encoding: 0x5E204C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field S = 1 (Max)
    // Fields: U=0, S=1, Rd=0, Rm=0, size=0, R=0, Rn=0
    let encoding: u32 = 0x5E204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rn_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rn = 0 (Min)
    // Fields: U=0, Rm=0, Rn=0, S=0, size=0, Rd=0, R=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rn_1_poweroftwo_4400_5e204420() {
    // Encoding: 0x5E204420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rn = 1 (PowerOfTwo)
    // Fields: R=0, S=0, Rd=0, Rn=1, U=0, Rm=0, size=0
    let encoding: u32 = 0x5E204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rn_30_poweroftwominusone_4400_5e2047c0() {
    // Encoding: 0x5E2047C0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, size=0, Rm=0, R=0, U=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E2047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rn_31_max_4400_5e2047e0() {
    // Encoding: 0x5E2047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rn = 31 (Max)
    // Fields: U=0, Rd=0, Rn=31, R=0, S=0, Rm=0, size=0
    let encoding: u32 = 0x5E2047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rd_0_min_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rd = 0 (Min)
    // Fields: Rm=0, Rn=0, size=0, S=0, U=0, R=0, Rd=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rd_1_poweroftwo_4400_5e204401() {
    // Encoding: 0x5E204401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, S=0, R=0, size=0, U=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rd_30_poweroftwominusone_4400_5e20441e() {
    // Encoding: 0x5E20441E
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rn=0, Rd=30, U=0, Rm=0, R=0, size=0
    let encoding: u32 = 0x5E20441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_field_rd_31_max_4400_5e20441f() {
    // Encoding: 0x5E20441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field Rd = 31 (Max)
    // Fields: S=0, U=0, Rn=0, Rd=31, size=0, Rm=0, R=0
    let encoding: u32 = 0x5E20441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_0_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, R=0, Rd=0, U=0, Rm=0, S=0, size=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_1_4400_7e204400() {
    // Encoding: 0x7E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=1, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: R=0, Rd=0, Rm=0, U=1, size=0, S=0, Rn=0
    let encoding: u32 = 0x7E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_2_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: R=0, S=0, Rm=0, size=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_3_4400_5e604400() {
    // Encoding: 0x5E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=1, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: S=0, U=0, R=0, Rd=0, Rm=0, Rn=0, size=1
    let encoding: u32 = 0x5E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_4_4400_5ea04400() {
    // Encoding: 0x5EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=2, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, size=2, S=0, R=0, Rd=0, U=0, Rm=0
    let encoding: u32 = 0x5EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_5_4400_5ee04400() {
    // Encoding: 0x5EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=3, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rm=0, U=0, size=3, R=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x5EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_6_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, R=0, Rm=0, size=0, Rn=0, S=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_7_4400_5e214400() {
    // Encoding: 0x5E214400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=1, R=0, S=0, Rn=0, Rd=0
    // Fields: Rm=1, U=0, S=0, R=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_8_4400_5e3e4400() {
    // Encoding: 0x5E3E4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=30, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, S=0, Rn=0, Rm=30, Rd=0, size=0, R=0
    let encoding: u32 = 0x5E3E4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_9_4400_5e3f4400() {
    // Encoding: 0x5E3F4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=31, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, R=0, S=0, Rm=31, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x5E3F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_10_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Rm=0, R=0, size=0, U=0, S=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_11_4400_5e205400() {
    // Encoding: 0x5E205400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=1, S=0, Rn=0, Rd=0
    // Fields: Rm=0, R=1, size=0, S=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_12_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: size=0, Rm=0, R=0, S=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_13_4400_5e204c00() {
    // Encoding: 0x5E204C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=1, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, U=0, size=0, R=0, S=1, Rm=0
    let encoding: u32 = 0x5E204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_14_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, S=0, Rn=0, Rm=0, size=0, U=0, R=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_15_4400_5e204420() {
    // Encoding: 0x5E204420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=1, Rd=0
    // Fields: Rd=0, U=0, S=0, Rm=0, R=0, size=0, Rn=1
    let encoding: u32 = 0x5E204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_16_4400_5e2047c0() {
    // Encoding: 0x5E2047C0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, size=0, R=0, S=0, U=0, Rm=0
    let encoding: u32 = 0x5E2047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_17_4400_5e2047e0() {
    // Encoding: 0x5E2047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=31, Rd=0
    // Fields: Rn=31, size=0, Rm=0, R=0, Rd=0, U=0, S=0
    let encoding: u32 = 0x5E2047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_18_4400_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: size=0, R=0, U=0, S=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_19_4400_5e204401() {
    // Encoding: 0x5E204401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=1
    // Fields: Rn=0, Rm=0, U=0, Rd=1, size=0, S=0, R=0
    let encoding: u32 = 0x5E204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_20_4400_5e20441e() {
    // Encoding: 0x5E20441E
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=30
    // Fields: size=0, S=0, Rn=0, Rd=30, R=0, U=0, Rm=0
    let encoding: u32 = 0x5E20441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_21_4400_5e20441f() {
    // Encoding: 0x5E20441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=31
    // Fields: size=0, Rm=0, S=0, U=0, R=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E20441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_22_4400_5e214420() {
    // Encoding: 0x5E214420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=1, R=0, S=0, Rn=1, Rd=0
    // Fields: Rm=1, Rd=0, size=0, S=0, R=0, Rn=1, U=0
    let encoding: u32 = 0x5E214420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_23_4400_5e3f47e0() {
    // Encoding: 0x5E3F47E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=31, R=0, S=0, Rn=31, Rd=0
    // Fields: S=0, Rn=31, Rd=0, size=0, R=0, U=0, Rm=31
    let encoding: u32 = 0x5E3F47E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_24_4400_5e214401() {
    // Encoding: 0x5E214401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=1, R=0, S=0, Rn=0, Rd=1
    // Fields: R=0, S=0, Rn=0, size=0, U=0, Rd=1, Rm=1
    let encoding: u32 = 0x5E214401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_25_4400_5e3f441f() {
    // Encoding: 0x5E3F441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=31, R=0, S=0, Rn=0, Rd=31
    // Fields: R=0, S=0, U=0, Rn=0, Rd=31, Rm=31, size=0
    let encoding: u32 = 0x5E3F441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_26_4400_5e204421() {
    // Encoding: 0x5E204421
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=1, Rd=1
    // Fields: S=0, R=0, U=0, Rd=1, Rm=0, size=0, Rn=1
    let encoding: u32 = 0x5E204421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_combo_27_4400_5e2047ff() {
    // Encoding: 0x5E2047FF
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd field combination: U=0, size=0, Rm=0, R=0, S=0, Rn=31, Rd=31
    // Fields: size=0, U=0, Rn=31, Rd=31, S=0, R=0, Rm=0
    let encoding: u32 = 0x5E2047FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_size_0_size_variant_0_17408_5e204400() {
    // Encoding: 0x5E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Rm=0, U=0, S=0, R=0, Rd=0
    let encoding: u32 = 0x5E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_size_1_size_variant_1_17408_5e604400() {
    // Encoding: 0x5E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value size = 1 (Size variant 1)
    // Fields: U=0, Rn=0, R=0, size=1, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x5E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_size_2_size_variant_2_17408_5ea04400() {
    // Encoding: 0x5EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value size = 2 (Size variant 2)
    // Fields: U=0, size=2, Rm=0, R=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x5EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_size_3_size_variant_3_17408_5ee04400() {
    // Encoding: 0x5EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value size = 3 (Size variant 3)
    // Fields: size=3, R=0, S=0, Rn=0, Rd=0, Rm=0, U=0
    let encoding: u32 = 0x5EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_s_0_size_variant_0_17408_5e604400() {
    // Encoding: 0x5E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value S = 0 (Size variant 0)
    // Fields: R=0, S=0, Rm=0, Rn=0, size=1, Rd=0, U=0
    let encoding: u32 = 0x5E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_s_1_size_variant_1_17408_5e604c00() {
    // Encoding: 0x5E604C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value S = 1 (Size variant 1)
    // Fields: Rn=0, size=1, Rd=0, S=1, R=0, U=0, Rm=0
    let encoding: u32 = 0x5E604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_17408_5e6047e0() {
    // Encoding: 0x5E6047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: S=0, Rn=31, Rd=0, Rm=0, U=0, R=0, size=1
    let encoding: u32 = 0x5E6047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_17408_5e60441f() {
    // Encoding: 0x5E60441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, size=1, Rm=0, S=0, U=0, Rn=0, R=0
    let encoding: u32 = 0x5E60441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_q_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Q = 0 (Min)
    // Fields: Rn=0, U=0, size=0, R=0, Q=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_q_1_max_4400_4e204400() {
    // Encoding: 0x4E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Q = 1 (Max)
    // Fields: S=0, Rm=0, R=0, U=0, Q=1, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x4E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_u_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field U = 0 (Min)
    // Fields: Q=0, S=0, R=0, U=0, Rd=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_u_1_max_4400_2e204400() {
    // Encoding: 0x2E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field U = 1 (Max)
    // Fields: size=0, U=1, R=0, S=0, Rn=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x2E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_size_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field size = 0 (Min)
    // Fields: Rd=0, U=0, Rn=0, Rm=0, Q=0, S=0, R=0, size=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_size_1_poweroftwo_4400_0e604400() {
    // Encoding: 0x0E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field size = 1 (PowerOfTwo)
    // Fields: R=0, S=0, Rn=0, U=0, size=1, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_size_2_poweroftwo_4400_0ea04400() {
    // Encoding: 0x0EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field size = 2 (PowerOfTwo)
    // Fields: S=0, Rm=0, Rd=0, size=2, R=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_size_3_max_4400_0ee04400() {
    // Encoding: 0x0EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field size = 3 (Max)
    // Fields: S=0, Rm=0, Rn=0, Q=0, R=0, Rd=0, U=0, size=3
    let encoding: u32 = 0x0EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rm_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rm = 0 (Min)
    // Fields: U=0, S=0, Q=0, Rm=0, R=0, Rd=0, Rn=0, size=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rm_1_poweroftwo_4400_0e214400() {
    // Encoding: 0x0E214400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, R=0, size=0, Q=0, Rm=1, Rn=0, U=0, S=0
    let encoding: u32 = 0x0E214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rm_30_poweroftwominusone_4400_0e3e4400() {
    // Encoding: 0x0E3E4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Q=0, Rm=30, Rd=0, S=0, U=0, Rn=0, R=0
    let encoding: u32 = 0x0E3E4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rm_31_max_4400_0e3f4400() {
    // Encoding: 0x0E3F4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rm = 31 (Max)
    // Fields: Rm=31, S=0, size=0, Q=0, Rn=0, R=0, Rd=0, U=0
    let encoding: u32 = 0x0E3F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field R 12 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_r_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field R = 0 (Min)
    // Fields: Rn=0, U=0, Q=0, Rm=0, S=0, size=0, Rd=0, R=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field R 12 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_r_1_max_4400_0e205400() {
    // Encoding: 0x0E205400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field R = 1 (Max)
    // Fields: U=0, size=0, S=0, Q=0, R=1, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_s_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field S = 0 (Min)
    // Fields: size=0, Q=0, R=0, S=0, Rm=0, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_s_1_max_4400_0e204c00() {
    // Encoding: 0x0E204C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field S = 1 (Max)
    // Fields: size=0, U=0, Rm=0, R=0, Rd=0, S=1, Rn=0, Q=0
    let encoding: u32 = 0x0E204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rn_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rn = 0 (Min)
    // Fields: R=0, Q=0, U=0, S=0, size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rn_1_poweroftwo_4400_0e204420() {
    // Encoding: 0x0E204420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, S=0, R=0, size=0, Rm=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rn_30_poweroftwominusone_4400_0e2047c0() {
    // Encoding: 0x0E2047C0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rd=0, U=0, Rm=0, R=0, Q=0, size=0, Rn=30
    let encoding: u32 = 0x0E2047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rn_31_max_4400_0e2047e0() {
    // Encoding: 0x0E2047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rn = 31 (Max)
    // Fields: Rn=31, size=0, Q=0, R=0, S=0, U=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E2047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rd_0_min_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, U=0, Q=0, R=0, Rn=0, size=0, S=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rd_1_poweroftwo_4400_0e204401() {
    // Encoding: 0x0E204401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, R=0, Rd=1, S=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rd_30_poweroftwominusone_4400_0e20441e() {
    // Encoding: 0x0E20441E
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, S=0, U=0, Rm=0, Q=0, R=0, size=0, Rn=0
    let encoding: u32 = 0x0E20441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_field_rd_31_max_4400_0e20441f() {
    // Encoding: 0x0E20441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field Rd = 31 (Max)
    // Fields: Rm=0, S=0, Q=0, Rd=31, U=0, Rn=0, R=0, size=0
    let encoding: u32 = 0x0E20441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_0_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, size=0, R=0, U=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_1_4400_4e204400() {
    // Encoding: 0x4E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=1, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=1, Rn=0, size=0, U=0, Rm=0, R=0, S=0
    let encoding: u32 = 0x4E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_2_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, S=0, Q=0, Rm=0, size=0, Rd=0, R=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_3_4400_2e204400() {
    // Encoding: 0x2E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=1, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: S=0, Q=0, U=1, Rn=0, Rd=0, Rm=0, size=0, R=0
    let encoding: u32 = 0x2E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_4_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Q=0, R=0, size=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_5_4400_0e604400() {
    // Encoding: 0x0E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=1, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, S=0, Rn=0, size=1, Rd=0, R=0, Q=0, Rm=0
    let encoding: u32 = 0x0E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_6_4400_0ea04400() {
    // Encoding: 0x0EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=2, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: R=0, Rm=0, Rn=0, size=2, Rd=0, Q=0, S=0, U=0
    let encoding: u32 = 0x0EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_7_4400_0ee04400() {
    // Encoding: 0x0EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=3, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, R=0, Rn=0, S=0, Rd=0, size=3, Q=0
    let encoding: u32 = 0x0EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_8_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, R=0, Q=0, Rm=0, size=0, Rd=0, U=0, S=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_9_4400_0e214400() {
    // Encoding: 0x0E214400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=1, R=0, S=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, R=0, U=0, Rm=1, size=0, Q=0, S=0
    let encoding: u32 = 0x0E214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_10_4400_0e3e4400() {
    // Encoding: 0x0E3E4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=30, R=0, S=0, Rn=0, Rd=0
    // Fields: size=0, S=0, Rn=0, Rm=30, Q=0, Rd=0, R=0, U=0
    let encoding: u32 = 0x0E3E4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_11_4400_0e3f4400() {
    // Encoding: 0x0E3F4400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=31, R=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, S=0, Rn=0, size=0, U=0, Rm=31, R=0
    let encoding: u32 = 0x0E3F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_12_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: size=0, R=0, Rd=0, Rn=0, Rm=0, S=0, U=0, Q=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// R=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_13_4400_0e205400() {
    // Encoding: 0x0E205400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=1, S=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Q=0, R=1, size=0, U=0, Rd=0, S=0
    let encoding: u32 = 0x0E205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_14_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, R=0, Rd=0, U=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_15_4400_0e204c00() {
    // Encoding: 0x0E204C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=1, Rn=0, Rd=0
    // Fields: size=0, U=0, Rd=0, R=0, Rm=0, S=1, Q=0, Rn=0
    let encoding: u32 = 0x0E204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_16_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, R=0, Rn=0, U=0, Rm=0, S=0, Q=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_17_4400_0e204420() {
    // Encoding: 0x0E204420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=1, Rd=0
    // Fields: Rm=0, Rn=1, R=0, Q=0, Rd=0, size=0, S=0, U=0
    let encoding: u32 = 0x0E204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_18_4400_0e2047c0() {
    // Encoding: 0x0E2047C0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=30, Rd=0
    // Fields: Rd=0, size=0, Q=0, Rm=0, Rn=30, R=0, U=0, S=0
    let encoding: u32 = 0x0E2047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_19_4400_0e2047e0() {
    // Encoding: 0x0E2047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=31, Rd=0
    // Fields: Rd=0, Rm=0, U=0, Rn=31, size=0, Q=0, R=0, S=0
    let encoding: u32 = 0x0E2047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_20_4400_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=0
    // Fields: Rm=0, U=0, Rn=0, Rd=0, Q=0, S=0, R=0, size=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_21_4400_0e204401() {
    // Encoding: 0x0E204401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=1
    // Fields: Q=0, Rn=0, Rm=0, size=0, R=0, S=0, U=0, Rd=1
    let encoding: u32 = 0x0E204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_22_4400_0e20441e() {
    // Encoding: 0x0E20441E
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=30
    // Fields: Rd=30, R=0, U=0, Rm=0, Rn=0, Q=0, size=0, S=0
    let encoding: u32 = 0x0E20441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_23_4400_0e20441f() {
    // Encoding: 0x0E20441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=0, Rd=31
    // Fields: size=0, U=0, Rm=0, Rd=31, S=0, Q=0, Rn=0, R=0
    let encoding: u32 = 0x0E20441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_24_4400_0e214420() {
    // Encoding: 0x0E214420
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=1, R=0, S=0, Rn=1, Rd=0
    // Fields: U=0, Rm=1, R=0, Rd=0, size=0, Rn=1, S=0, Q=0
    let encoding: u32 = 0x0E214420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_25_4400_0e3f47e0() {
    // Encoding: 0x0E3F47E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=31, R=0, S=0, Rn=31, Rd=0
    // Fields: U=0, Rm=31, S=0, Rn=31, Rd=0, R=0, size=0, Q=0
    let encoding: u32 = 0x0E3F47E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_26_4400_0e214401() {
    // Encoding: 0x0E214401
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=1, R=0, S=0, Rn=0, Rd=1
    // Fields: Rm=1, S=0, Q=0, U=0, Rd=1, size=0, R=0, Rn=0
    let encoding: u32 = 0x0E214401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_27_4400_0e3f441f() {
    // Encoding: 0x0E3F441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=31, R=0, S=0, Rn=0, Rd=31
    // Fields: size=0, Rn=0, Rd=31, U=0, Rm=31, Q=0, R=0, S=0
    let encoding: u32 = 0x0E3F441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 28`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_28_4400_0e204421() {
    // Encoding: 0x0E204421
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=1, Rd=1
    // Fields: Rd=1, Rm=0, Q=0, S=0, U=0, R=0, size=0, Rn=1
    let encoding: u32 = 0x0E204421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field combination 29`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_combo_29_4400_0e2047ff() {
    // Encoding: 0x0E2047FF
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd field combination: Q=0, U=0, size=0, Rm=0, R=0, S=0, Rn=31, Rd=31
    // Fields: size=0, Rm=0, S=0, R=0, Rn=31, Rd=31, Q=0, U=0
    let encoding: u32 = 0x0E2047FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_q_0_size_variant_0_17408_0e604400() {
    // Encoding: 0x0E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value Q = 0 (Size variant 0)
    // Fields: Rn=0, size=1, Rm=0, Q=0, U=0, R=0, S=0, Rd=0
    let encoding: u32 = 0x0E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_q_1_size_variant_1_17408_4e604400() {
    // Encoding: 0x4E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Rm=0, U=0, Q=1, size=1, S=0, R=0
    let encoding: u32 = 0x4E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_size_0_size_variant_0_17408_0e204400() {
    // Encoding: 0x0E204400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value size = 0 (Size variant 0)
    // Fields: size=0, R=0, U=0, Q=0, Rn=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_size_1_size_variant_1_17408_0e604400() {
    // Encoding: 0x0E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value size = 1 (Size variant 1)
    // Fields: S=0, Q=0, Rn=0, size=1, Rm=0, U=0, R=0, Rd=0
    let encoding: u32 = 0x0E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_size_2_size_variant_2_17408_0ea04400() {
    // Encoding: 0x0EA04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value size = 2 (Size variant 2)
    // Fields: S=0, Q=0, U=0, size=2, Rd=0, Rn=0, Rm=0, R=0
    let encoding: u32 = 0x0EA04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_size_3_size_variant_3_17408_0ee04400() {
    // Encoding: 0x0EE04400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, Rd=0, R=0, S=0, Rn=0, U=0, Rm=0, size=3
    let encoding: u32 = 0x0EE04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_s_0_size_variant_0_17408_0e604400() {
    // Encoding: 0x0E604400
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value S = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, Rn=0, R=0, S=0, U=0, size=1, Rd=0
    let encoding: u32 = 0x0E604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_s_1_size_variant_1_17408_0e604c00() {
    // Encoding: 0x0E604C00
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value S = 1 (Size variant 1)
    // Fields: Q=0, R=0, U=0, Rd=0, Rm=0, size=1, S=1, Rn=0
    let encoding: u32 = 0x0E604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_rn_31_stack_pointer_sp_may_require_alignment_17408_0e6047e0() {
    // Encoding: 0x0E6047E0
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=1, R=0, Rn=31, S=0, Rm=0, Q=0, U=0, Rd=0
    let encoding: u32 = 0x0E6047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_17408_0e60441f() {
    // Encoding: 0x0E60441F
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, size=1, S=0, U=0, Rn=0, Rd=31, R=0, Rm=0
    let encoding: u32 = 0x0E60441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_reg_write_0_5e204400() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd register write: SimdFromField("d")
    // Encoding: 0x5E204400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E204400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_sp_rn_5e2047e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd with Rn = SP (31)
    // Encoding: 0x5E2047E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E2047E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_sisd_zr_rd_5e20441f() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_sisd with Rd = ZR (31)
    // Encoding: 0x5E20441F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20441F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_reg_write_0_0e204400() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd register write: SimdFromField("d")
    // Encoding: 0x0E204400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E204400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_sp_rn_0e2047e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd with Rn = SP (31)
    // Encoding: 0x0E2047E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2047E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_shift_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_shift_simd_zr_rd_0e20441f() {
    // Test aarch64_vector_arithmetic_binary_uniform_shift_simd with Rd = ZR (31)
    // Encoding: 0x0E20441F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20441F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_rbit Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_q_0_min_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field Q = 0 (Min)
    // Fields: Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_q_1_max_5800_6e605800() {
    // Encoding: 0x6E605800
    // Test aarch64_vector_arithmetic_unary_rbit field Q = 1 (Max)
    // Fields: Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x6E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rn_0_min_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rn_1_poweroftwo_5800_2e605820() {
    // Encoding: 0x2E605820
    // Test aarch64_vector_arithmetic_unary_rbit field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, Q=0
    let encoding: u32 = 0x2E605820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rn_30_poweroftwominusone_5800_2e605bc0() {
    // Encoding: 0x2E605BC0
    // Test aarch64_vector_arithmetic_unary_rbit field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x2E605BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rn_31_max_5800_2e605be0() {
    // Encoding: 0x2E605BE0
    // Test aarch64_vector_arithmetic_unary_rbit field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, Q=0
    let encoding: u32 = 0x2E605BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rd_0_min_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rd_1_poweroftwo_5800_2e605801() {
    // Encoding: 0x2E605801
    // Test aarch64_vector_arithmetic_unary_rbit field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Q=0, Rd=1
    let encoding: u32 = 0x2E605801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rd_30_poweroftwominusone_5800_2e60581e() {
    // Encoding: 0x2E60581E
    // Test aarch64_vector_arithmetic_unary_rbit field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2E60581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_field_rd_31_max_5800_2e60581f() {
    // Encoding: 0x2E60581F
    // Test aarch64_vector_arithmetic_unary_rbit field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x2E60581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_0_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_1_5800_6e605800() {
    // Encoding: 0x6E605800
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x6E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_2_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_3_5800_2e605820() {
    // Encoding: 0x2E605820
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=1, Rd=0
    // Fields: Rd=0, Rn=1, Q=0
    let encoding: u32 = 0x2E605820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_4_5800_2e605bc0() {
    // Encoding: 0x2E605BC0
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=30, Rd=0
    // Fields: Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x2E605BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_5_5800_2e605be0() {
    // Encoding: 0x2E605BE0
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x2E605BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_6_5800_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_7_5800_2e605801() {
    // Encoding: 0x2E605801
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x2E605801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_8_5800_2e60581e() {
    // Encoding: 0x2E60581E
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=30
    // Fields: Rd=30, Rn=0, Q=0
    let encoding: u32 = 0x2E60581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_9_5800_2e60581f() {
    // Encoding: 0x2E60581F
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=0, Rd=31
    // Fields: Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x2E60581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_10_5800_2e605821() {
    // Encoding: 0x2E605821
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=1, Rd=1
    // Fields: Q=0, Rn=1, Rd=1
    let encoding: u32 = 0x2E605821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_combo_11_5800_2e605bff() {
    // Encoding: 0x2E605BFF
    // Test aarch64_vector_arithmetic_unary_rbit field combination: Q=0, Rn=31, Rd=31
    // Fields: Rd=31, Q=0, Rn=31
    let encoding: u32 = 0x2E605BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_special_q_0_size_variant_0_22528_2e605800() {
    // Encoding: 0x2E605800
    // Test aarch64_vector_arithmetic_unary_rbit special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_special_q_1_size_variant_1_22528_6e605800() {
    // Encoding: 0x6E605800
    // Test aarch64_vector_arithmetic_unary_rbit special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x6E605800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_special_rn_31_stack_pointer_sp_may_require_alignment_22528_2e605be0() {
    // Encoding: 0x2E605BE0
    // Test aarch64_vector_arithmetic_unary_rbit special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, Rn=31
    let encoding: u32 = 0x2E605BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_22528_2e60581f() {
    // Encoding: 0x2E60581F
    // Test aarch64_vector_arithmetic_unary_rbit special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x2E60581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_reg_write_0_2e605800() {
    // Test aarch64_vector_arithmetic_unary_rbit register write: SimdFromField("d")
    // Encoding: 0x2E605800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E605800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_sp_rn_2e605be0() {
    // Test aarch64_vector_arithmetic_unary_rbit with Rn = SP (31)
    // Encoding: 0x2E605BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E605BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_rbit
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_rbit_zr_rd_2e60581f() {
    // Test aarch64_vector_arithmetic_unary_rbit with Rd = ZR (31)
    // Encoding: 0x2E60581F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E60581F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_not Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_q_0_min_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field Q = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_q_1_max_5800_6e205800() {
    // Encoding: 0x6E205800
    // Test aarch64_vector_arithmetic_unary_not field Q = 1 (Max)
    // Fields: Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x6E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rn_0_min_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rn_1_poweroftwo_5800_2e205820() {
    // Encoding: 0x2E205820
    // Test aarch64_vector_arithmetic_unary_not field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Q=0, Rn=1
    let encoding: u32 = 0x2E205820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rn_30_poweroftwominusone_5800_2e205bc0() {
    // Encoding: 0x2E205BC0
    // Test aarch64_vector_arithmetic_unary_not field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2E205BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rn_31_max_5800_2e205be0() {
    // Encoding: 0x2E205BE0
    // Test aarch64_vector_arithmetic_unary_not field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x2E205BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rd_0_min_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rd_1_poweroftwo_5800_2e205801() {
    // Encoding: 0x2E205801
    // Test aarch64_vector_arithmetic_unary_not field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x2E205801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rd_30_poweroftwominusone_5800_2e20581e() {
    // Encoding: 0x2E20581E
    // Test aarch64_vector_arithmetic_unary_not field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rd=30, Rn=0
    let encoding: u32 = 0x2E20581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_field_rd_31_max_5800_2e20581f() {
    // Encoding: 0x2E20581F
    // Test aarch64_vector_arithmetic_unary_not field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x2E20581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_0_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_1_5800_6e205800() {
    // Encoding: 0x6E205800
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x6E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_2_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_3_5800_2e205820() {
    // Encoding: 0x2E205820
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=1, Rd=0
    // Fields: Rn=1, Q=0, Rd=0
    let encoding: u32 = 0x2E205820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_4_5800_2e205bc0() {
    // Encoding: 0x2E205BC0
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=30, Rd=0
    // Fields: Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x2E205BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_5_5800_2e205be0() {
    // Encoding: 0x2E205BE0
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=31, Rd=0
    // Fields: Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x2E205BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_6_5800_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_7_5800_2e205801() {
    // Encoding: 0x2E205801
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=1
    // Fields: Q=0, Rd=1, Rn=0
    let encoding: u32 = 0x2E205801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_8_5800_2e20581e() {
    // Encoding: 0x2E20581E
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=30
    // Fields: Q=0, Rd=30, Rn=0
    let encoding: u32 = 0x2E20581E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_9_5800_2e20581f() {
    // Encoding: 0x2E20581F
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=0, Rd=31
    // Fields: Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x2E20581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_10_5800_2e205821() {
    // Encoding: 0x2E205821
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=1, Rd=1
    // Fields: Q=0, Rn=1, Rd=1
    let encoding: u32 = 0x2E205821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_not_combo_11_5800_2e205bff() {
    // Encoding: 0x2E205BFF
    // Test aarch64_vector_arithmetic_unary_not field combination: Q=0, Rn=31, Rd=31
    // Fields: Rn=31, Q=0, Rd=31
    let encoding: u32 = 0x2E205BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_not_special_q_0_size_variant_0_22528_2e205800() {
    // Encoding: 0x2E205800
    // Test aarch64_vector_arithmetic_unary_not special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_not_special_q_1_size_variant_1_22528_6e205800() {
    // Encoding: 0x6E205800
    // Test aarch64_vector_arithmetic_unary_not special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rn=0, Q=1
    let encoding: u32 = 0x6E205800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_not_special_rn_31_stack_pointer_sp_may_require_alignment_22528_2e205be0() {
    // Encoding: 0x2E205BE0
    // Test aarch64_vector_arithmetic_unary_not special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x2E205BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_not_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_22528_2e20581f() {
    // Encoding: 0x2E20581F
    // Test aarch64_vector_arithmetic_unary_not special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x2E20581F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_not_reg_write_0_2e205800() {
    // Test aarch64_vector_arithmetic_unary_not register write: SimdFromField("d")
    // Encoding: 0x2E205800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E205800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_sp_rn_2e205be0() {
    // Test aarch64_vector_arithmetic_unary_not with Rn = SP (31)
    // Encoding: 0x2E205BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E205BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_not
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_not_zr_rd_2e20581f() {
    // Test aarch64_vector_arithmetic_unary_not with Rd = ZR (31)
    // Encoding: 0x2E20581F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20581F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_rev Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_q_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field Q = 0 (Min)
    // Fields: o0=0, size=0, Q=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_q_1_max_800_4e200800() {
    // Encoding: 0x4E200800
    // Test aarch64_vector_arithmetic_unary_rev field Q = 1 (Max)
    // Fields: Q=1, U=0, o0=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x4E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_u_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field U = 0 (Min)
    // Fields: size=0, U=0, Rn=0, o0=0, Rd=0, Q=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_u_1_max_800_2e200800() {
    // Encoding: 0x2E200800
    // Test aarch64_vector_arithmetic_unary_rev field U = 1 (Max)
    // Fields: Rd=0, Q=0, Rn=0, o0=0, U=1, size=0
    let encoding: u32 = 0x2E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_size_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field size = 0 (Min)
    // Fields: Q=0, size=0, Rn=0, o0=0, Rd=0, U=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_size_1_poweroftwo_800_0e600800() {
    // Encoding: 0x0E600800
    // Test aarch64_vector_arithmetic_unary_rev field size = 1 (PowerOfTwo)
    // Fields: Rd=0, U=0, o0=0, Q=0, size=1, Rn=0
    let encoding: u32 = 0x0E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_size_2_poweroftwo_800_0ea00800() {
    // Encoding: 0x0EA00800
    // Test aarch64_vector_arithmetic_unary_rev field size = 2 (PowerOfTwo)
    // Fields: Rd=0, size=2, o0=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0EA00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_size_3_max_800_0ee00800() {
    // Encoding: 0x0EE00800
    // Test aarch64_vector_arithmetic_unary_rev field size = 3 (Max)
    // Fields: U=0, Rn=0, size=3, o0=0, Q=0, Rd=0
    let encoding: u32 = 0x0EE00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field o0 12 +: 1`
/// Requirement: FieldBoundary { field: "o0", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_o0_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field o0 = 0 (Min)
    // Fields: U=0, o0=0, Rn=0, size=0, Rd=0, Q=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field o0 12 +: 1`
/// Requirement: FieldBoundary { field: "o0", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_o0_1_max_800_0e201800() {
    // Encoding: 0x0E201800
    // Test aarch64_vector_arithmetic_unary_rev field o0 = 1 (Max)
    // Fields: U=0, o0=1, Q=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x0E201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rn_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field Rn = 0 (Min)
    // Fields: Rn=0, o0=0, Rd=0, Q=0, U=0, size=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rn_1_poweroftwo_800_0e200820() {
    // Encoding: 0x0E200820
    // Test aarch64_vector_arithmetic_unary_rev field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, U=0, size=0, Rd=0, o0=0, Q=0
    let encoding: u32 = 0x0E200820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rn_30_poweroftwominusone_800_0e200bc0() {
    // Encoding: 0x0E200BC0
    // Test aarch64_vector_arithmetic_unary_rev field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, U=0, o0=0, Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E200BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rn_31_max_800_0e200be0() {
    // Encoding: 0x0E200BE0
    // Test aarch64_vector_arithmetic_unary_rev field Rn = 31 (Max)
    // Fields: Rn=31, U=0, Rd=0, o0=0, size=0, Q=0
    let encoding: u32 = 0x0E200BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rd_0_min_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field Rd = 0 (Min)
    // Fields: size=0, Rd=0, U=0, o0=0, Rn=0, Q=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rd_1_poweroftwo_800_0e200801() {
    // Encoding: 0x0E200801
    // Test aarch64_vector_arithmetic_unary_rev field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, size=0, o0=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E200801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rd_30_poweroftwominusone_800_0e20081e() {
    // Encoding: 0x0E20081E
    // Test aarch64_vector_arithmetic_unary_rev field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Q=0, U=0, o0=0, size=0
    let encoding: u32 = 0x0E20081E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_field_rd_31_max_800_0e20081f() {
    // Encoding: 0x0E20081F
    // Test aarch64_vector_arithmetic_unary_rev field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, Q=0, U=0, o0=0, size=0
    let encoding: u32 = 0x0E20081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_0_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Q=0, o0=0, size=0, Rn=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_1_800_4e200800() {
    // Encoding: 0x4E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=1, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: o0=0, Q=1, Rd=0, size=0, Rn=0, U=0
    let encoding: u32 = 0x4E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_2_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: size=0, U=0, Q=0, o0=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_3_800_2e200800() {
    // Encoding: 0x2E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=1, size=0, o0=0, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rn=0, U=1, Rd=0, o0=0
    let encoding: u32 = 0x2E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_4_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, o0=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_5_800_0e600800() {
    // Encoding: 0x0E600800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=1, o0=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, U=0, size=1, Rd=0, o0=0
    let encoding: u32 = 0x0E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_6_800_0ea00800() {
    // Encoding: 0x0EA00800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=2, o0=0, Rn=0, Rd=0
    // Fields: size=2, o0=0, Q=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0EA00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_7_800_0ee00800() {
    // Encoding: 0x0EE00800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=3, o0=0, Rn=0, Rd=0
    // Fields: o0=0, Q=0, U=0, size=3, Rn=0, Rd=0
    let encoding: u32 = 0x0EE00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o0=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_8_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, o0=0, U=0, Rn=0, Q=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o0=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_9_800_0e201800() {
    // Encoding: 0x0E201800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=1, Rn=0, Rd=0
    // Fields: U=0, o0=1, Q=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x0E201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_10_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0, Q=0, size=0, o0=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_11_800_0e200820() {
    // Encoding: 0x0E200820
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=1, Rd=0
    // Fields: size=0, Q=0, o0=0, Rn=1, U=0, Rd=0
    let encoding: u32 = 0x0E200820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_12_800_0e200bc0() {
    // Encoding: 0x0E200BC0
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=30, Rd=0
    // Fields: Rn=30, Q=0, size=0, o0=0, Rd=0, U=0
    let encoding: u32 = 0x0E200BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_13_800_0e200be0() {
    // Encoding: 0x0E200BE0
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=31, Rd=0
    // Fields: Q=0, U=0, Rn=31, Rd=0, size=0, o0=0
    let encoding: u32 = 0x0E200BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_14_800_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=0
    // Fields: o0=0, Rn=0, Q=0, size=0, U=0, Rd=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_15_800_0e200801() {
    // Encoding: 0x0E200801
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, size=0, U=0, Q=0, o0=0
    let encoding: u32 = 0x0E200801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_16_800_0e20081e() {
    // Encoding: 0x0E20081E
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=30
    // Fields: Q=0, Rd=30, U=0, Rn=0, o0=0, size=0
    let encoding: u32 = 0x0E20081E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_17_800_0e20081f() {
    // Encoding: 0x0E20081F
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=0, Rd=31
    // Fields: o0=0, U=0, Q=0, Rd=31, Rn=0, size=0
    let encoding: u32 = 0x0E20081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_18_800_0e200821() {
    // Encoding: 0x0E200821
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=1, Rd=1
    // Fields: size=0, U=0, Q=0, Rn=1, o0=0, Rd=1
    let encoding: u32 = 0x0E200821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_combo_19_800_0e200bff() {
    // Encoding: 0x0E200BFF
    // Test aarch64_vector_arithmetic_unary_rev field combination: Q=0, U=0, size=0, o0=0, Rn=31, Rd=31
    // Fields: Rn=31, U=0, size=0, o0=0, Rd=31, Q=0
    let encoding: u32 = 0x0E200BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_q_0_size_variant_0_2048_0e600800() {
    // Encoding: 0x0E600800
    // Test aarch64_vector_arithmetic_unary_rev special value Q = 0 (Size variant 0)
    // Fields: U=0, Rn=0, Q=0, Rd=0, o0=0, size=1
    let encoding: u32 = 0x0E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_q_1_size_variant_1_2048_4e600800() {
    // Encoding: 0x4E600800
    // Test aarch64_vector_arithmetic_unary_rev special value Q = 1 (Size variant 1)
    // Fields: Rn=0, o0=0, U=0, Q=1, Rd=0, size=1
    let encoding: u32 = 0x4E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_size_0_size_variant_0_2048_0e200800() {
    // Encoding: 0x0E200800
    // Test aarch64_vector_arithmetic_unary_rev special value size = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, U=0, size=0, Q=0, o0=0
    let encoding: u32 = 0x0E200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_size_1_size_variant_1_2048_0e600800() {
    // Encoding: 0x0E600800
    // Test aarch64_vector_arithmetic_unary_rev special value size = 1 (Size variant 1)
    // Fields: o0=0, Q=0, Rn=0, U=0, Rd=0, size=1
    let encoding: u32 = 0x0E600800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_size_2_size_variant_2_2048_0ea00800() {
    // Encoding: 0x0EA00800
    // Test aarch64_vector_arithmetic_unary_rev special value size = 2 (Size variant 2)
    // Fields: U=0, Rn=0, Q=0, size=2, Rd=0, o0=0
    let encoding: u32 = 0x0EA00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_size_3_size_variant_3_2048_0ee00800() {
    // Encoding: 0x0EE00800
    // Test aarch64_vector_arithmetic_unary_rev special value size = 3 (Size variant 3)
    // Fields: U=0, o0=0, Rn=0, Rd=0, size=3, Q=0
    let encoding: u32 = 0x0EE00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_rn_31_stack_pointer_sp_may_require_alignment_2048_0e600be0() {
    // Encoding: 0x0E600BE0
    // Test aarch64_vector_arithmetic_unary_rev special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=1, U=0, Rn=31, Rd=0, Q=0, o0=0
    let encoding: u32 = 0x0E600BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_2048_0e60081f() {
    // Encoding: 0x0E60081F
    // Test aarch64_vector_arithmetic_unary_rev special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, o0=0, size=1, Rd=31, Rn=0, U=0
    let encoding: u32 = 0x0E60081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_reg_write_0_0e200800() {
    // Test aarch64_vector_arithmetic_unary_rev register write: SimdFromField("d")
    // Encoding: 0x0E200800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E200800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_sp_rn_0e200be0() {
    // Test aarch64_vector_arithmetic_unary_rev with Rn = SP (31)
    // Encoding: 0x0E200BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E200BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_rev
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_rev_zr_rd_0e20081f() {
    // Test aarch64_vector_arithmetic_unary_rev with Rd = ZR (31)
    // Encoding: 0x0E20081F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20081F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_float_round_frint_32_64 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_q_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Q = 0 (Min)
    // Fields: op=0, sz=0, Rd=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_q_1_max_e800_4e21e800() {
    // Encoding: 0x4E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Q = 1 (Max)
    // Fields: Rn=0, Rd=0, U=0, sz=0, op=0, Q=1
    let encoding: u32 = 0x4E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_u_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field U = 0 (Min)
    // Fields: U=0, sz=0, Q=0, Rn=0, op=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_u_1_max_e800_2e21e800() {
    // Encoding: 0x2E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field U = 1 (Max)
    // Fields: Rn=0, Q=0, Rd=0, sz=0, U=1, op=0
    let encoding: u32 = 0x2E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_sz_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field sz = 0 (Min)
    // Fields: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_sz_1_max_e800_0e61e800() {
    // Encoding: 0x0E61E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field sz = 1 (Max)
    // Fields: Q=0, op=0, Rn=0, Rd=0, U=0, sz=1
    let encoding: u32 = 0x0E61E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_op_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field op = 0 (Min)
    // Fields: Q=0, Rn=0, U=0, Rd=0, op=0, sz=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_op_1_max_e800_0e21f800() {
    // Encoding: 0x0E21F800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field op = 1 (Max)
    // Fields: Rn=0, Rd=0, U=0, op=1, Q=0, sz=0
    let encoding: u32 = 0x0E21F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rn_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, op=0, U=0, sz=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rn_1_poweroftwo_e800_0e21e820() {
    // Encoding: 0x0E21E820
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, U=0, Q=0, sz=0, op=0
    let encoding: u32 = 0x0E21E820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rn_30_poweroftwominusone_e800_0e21ebc0() {
    // Encoding: 0x0E21EBC0
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rn=30, sz=0, Q=0, op=0, Rd=0
    let encoding: u32 = 0x0E21EBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rn_31_max_e800_0e21ebe0() {
    // Encoding: 0x0E21EBE0
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rn = 31 (Max)
    // Fields: sz=0, op=0, Rn=31, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E21EBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rd_0_min_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rd = 0 (Min)
    // Fields: op=0, Q=0, U=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rd_1_poweroftwo_e800_0e21e801() {
    // Encoding: 0x0E21E801
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, op=0, U=0, Rd=1, sz=0, Rn=0
    let encoding: u32 = 0x0E21E801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rd_30_poweroftwominusone_e800_0e21e81e() {
    // Encoding: 0x0E21E81E
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=0, U=0, Q=0, Rd=30, op=0
    let encoding: u32 = 0x0E21E81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_field_rd_31_max_e800_0e21e81f() {
    // Encoding: 0x0E21E81F
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field Rd = 31 (Max)
    // Fields: Rn=0, Q=0, op=0, Rd=31, sz=0, U=0
    let encoding: u32 = 0x0E21E81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_0_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Rn=0, op=0, sz=0, Q=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_1_e800_4e21e800() {
    // Encoding: 0x4E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=1, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: sz=0, Q=1, op=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x4E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_2_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, op=0, U=0, Q=0, sz=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_3_e800_2e21e800() {
    // Encoding: 0x2E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=1, sz=0, op=0, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=0, op=0, U=1
    let encoding: u32 = 0x2E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_4_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, op=0, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_5_e800_0e61e800() {
    // Encoding: 0x0E61E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=1, op=0, Rn=0, Rd=0
    // Fields: op=0, Rn=0, Rd=0, Q=0, sz=1, U=0
    let encoding: u32 = 0x0E61E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_6_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Q=0, Rd=0, U=0, op=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// op=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_7_e800_0e21f800() {
    // Encoding: 0x0E21F800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=1, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, sz=0, Q=0, U=0, op=1
    let encoding: u32 = 0x0E21F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_8_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, op=0, Q=0, U=0, sz=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_9_e800_0e21e820() {
    // Encoding: 0x0E21E820
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=1, Rd=0
    // Fields: op=0, Rn=1, Rd=0, Q=0, U=0, sz=0
    let encoding: u32 = 0x0E21E820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_10_e800_0e21ebc0() {
    // Encoding: 0x0E21EBC0
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=30, Rd=0
    // Fields: Q=0, sz=0, op=0, Rd=0, U=0, Rn=30
    let encoding: u32 = 0x0E21EBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_11_e800_0e21ebe0() {
    // Encoding: 0x0E21EBE0
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=31, Rd=0
    // Fields: U=0, Rn=31, sz=0, Q=0, Rd=0, op=0
    let encoding: u32 = 0x0E21EBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_12_e800_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=0
    // Fields: Q=0, op=0, Rn=0, sz=0, U=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_13_e800_0e21e801() {
    // Encoding: 0x0E21E801
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, sz=0, Q=0, op=0, Rd=1
    let encoding: u32 = 0x0E21E801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_14_e800_0e21e81e() {
    // Encoding: 0x0E21E81E
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=30
    // Fields: Q=0, Rn=0, sz=0, U=0, op=0, Rd=30
    let encoding: u32 = 0x0E21E81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_15_e800_0e21e81f() {
    // Encoding: 0x0E21E81F
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=0, Rd=31
    // Fields: U=0, sz=0, Q=0, Rd=31, op=0, Rn=0
    let encoding: u32 = 0x0E21E81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_16_e800_0e21e821() {
    // Encoding: 0x0E21E821
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=1, Rd=1
    // Fields: Rd=1, Rn=1, Q=0, sz=0, U=0, op=0
    let encoding: u32 = 0x0E21E821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_combo_17_e800_0e21ebff() {
    // Encoding: 0x0E21EBFF
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 field combination: Q=0, U=0, sz=0, op=0, Rn=31, Rd=31
    // Fields: Rd=31, op=0, U=0, sz=0, Q=0, Rn=31
    let encoding: u32 = 0x0E21EBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_q_0_size_variant_0_59392_0e61e800() {
    // Encoding: 0x0E61E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value Q = 0 (Size variant 0)
    // Fields: U=0, sz=1, op=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E61E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_q_1_size_variant_1_59392_4e61e800() {
    // Encoding: 0x4E61E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value Q = 1 (Size variant 1)
    // Fields: sz=1, Rn=0, Rd=0, op=0, Q=1, U=0
    let encoding: u32 = 0x4E61E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_sz_0_size_variant_0_59392_0e21e800() {
    // Encoding: 0x0E21E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value sz = 0 (Size variant 0)
    // Fields: Q=0, sz=0, op=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_sz_1_size_variant_1_59392_0e61e800() {
    // Encoding: 0x0E61E800
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Q=0, op=0, sz=1, U=0
    let encoding: u32 = 0x0E61E800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_rn_31_stack_pointer_sp_may_require_alignment_59392_0e61ebe0() {
    // Encoding: 0x0E61EBE0
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: op=0, Rn=31, U=0, Rd=0, sz=1, Q=0
    let encoding: u32 = 0x0E61EBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_59392_0e61e81f() {
    // Encoding: 0x0E61E81F
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, op=0, Rd=31, U=0, sz=1, Rn=0
    let encoding: u32 = 0x0E61E81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_reg_write_0_0e21e800() {
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 register write: SimdFromField("d")
    // Encoding: 0x0E21E800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21E800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_sp_rn_0e21ebe0() {
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 with Rn = SP (31)
    // Encoding: 0x0E21EBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21EBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_round_frint_32_64
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_round_frint_32_64_zr_rd_0e21e81f() {
    // Test aarch64_vector_arithmetic_unary_float_round_frint_32_64 with Rd = ZR (31)
    // Encoding: 0x0E21E81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21E81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_sqrt_fp16 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_q_0_min_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_q_1_max_f800_6ef9f800() {
    // Encoding: 0x6EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Q = 1 (Max)
    // Fields: Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x6EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rn_0_min_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rn_1_poweroftwo_f800_2ef9f820() {
    // Encoding: 0x2EF9F820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=1, Rd=0
    let encoding: u32 = 0x2EF9F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rn_30_poweroftwominusone_f800_2ef9fbc0() {
    // Encoding: 0x2EF9FBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x2EF9FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rn_31_max_f800_2ef9fbe0() {
    // Encoding: 0x2EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, Q=0
    let encoding: u32 = 0x2EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rd_0_min_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rd_1_poweroftwo_f800_2ef9f801() {
    // Encoding: 0x2EF9F801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Q=0, Rd=1
    let encoding: u32 = 0x2EF9F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rd_30_poweroftwominusone_f800_2ef9f81e() {
    // Encoding: 0x2EF9F81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2EF9F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_field_rd_31_max_f800_2ef9f81f() {
    // Encoding: 0x2EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x2EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_0_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_1_f800_6ef9f800() {
    // Encoding: 0x6EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=1, Rn=0, Rd=0
    // Fields: Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x6EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_2_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_3_f800_2ef9f820() {
    // Encoding: 0x2EF9F820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=1, Rd=0
    // Fields: Q=0, Rn=1, Rd=0
    let encoding: u32 = 0x2EF9F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_4_f800_2ef9fbc0() {
    // Encoding: 0x2EF9FBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2EF9FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_5_f800_2ef9fbe0() {
    // Encoding: 0x2EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x2EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_6_f800_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_7_f800_2ef9f801() {
    // Encoding: 0x2EF9F801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, Q=0
    let encoding: u32 = 0x2EF9F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_8_f800_2ef9f81e() {
    // Encoding: 0x2EF9F81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=30
    // Fields: Rn=0, Q=0, Rd=30
    let encoding: u32 = 0x2EF9F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_9_f800_2ef9f81f() {
    // Encoding: 0x2EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=0, Rd=31
    // Fields: Rd=31, Q=0, Rn=0
    let encoding: u32 = 0x2EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_10_f800_2ef9f821() {
    // Encoding: 0x2EF9F821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=1, Rd=1
    // Fields: Rn=1, Rd=1, Q=0
    let encoding: u32 = 0x2EF9F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_combo_11_f800_2ef9fbff() {
    // Encoding: 0x2EF9FBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 field combination: Q=0, Rn=31, Rd=31
    // Fields: Q=0, Rn=31, Rd=31
    let encoding: u32 = 0x2EF9FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_special_q_0_size_variant_0_63488_2ef9f800() {
    // Encoding: 0x2EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_special_q_1_size_variant_1_63488_6ef9f800() {
    // Encoding: 0x6EF9F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Q=1, Rn=0
    let encoding: u32 = 0x6EF9F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_special_rn_31_stack_pointer_sp_may_require_alignment_63488_2ef9fbe0() {
    // Encoding: 0x2EF9FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x2EF9FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_2ef9f81f() {
    // Encoding: 0x2EF9F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x2EF9F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_q_0_min_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Q = 0 (Min)
    // Fields: Rn=0, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_q_1_max_f800_6ea1f800() {
    // Encoding: 0x6EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Q = 1 (Max)
    // Fields: Q=1, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x6EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_sz_0_min_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field sz = 0 (Min)
    // Fields: Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_sz_1_max_f800_2ee1f800() {
    // Encoding: 0x2EE1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, Q=0, sz=1
    let encoding: u32 = 0x2EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rn_0_min_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rn = 0 (Min)
    // Fields: sz=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rn_1_poweroftwo_f800_2ea1f820() {
    // Encoding: 0x2EA1F820
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rn_30_poweroftwominusone_f800_2ea1fbc0() {
    // Encoding: 0x2EA1FBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x2EA1FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rn_31_max_f800_2ea1fbe0() {
    // Encoding: 0x2EA1FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rn = 31 (Max)
    // Fields: Rn=31, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x2EA1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rd_0_min_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rd = 0 (Min)
    // Fields: sz=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rd_1_poweroftwo_f800_2ea1f801() {
    // Encoding: 0x2EA1F801
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2EA1F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rd_30_poweroftwominusone_f800_2ea1f81e() {
    // Encoding: 0x2EA1F81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, sz=0, Rn=0, Rd=30
    let encoding: u32 = 0x2EA1F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_field_rd_31_max_f800_2ea1f81f() {
    // Encoding: 0x2EA1F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt field Rd = 31 (Max)
    // Fields: Rn=0, sz=0, Q=0, Rd=31
    let encoding: u32 = 0x2EA1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_0_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_1_f800_6ea1f800() {
    // Encoding: 0x6EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Q=1, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x6EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_2_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_3_f800_2ee1f800() {
    // Encoding: 0x2EE1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: sz=1, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_4_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_5_f800_2ea1f820() {
    // Encoding: 0x2EA1F820
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Q=0, sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x2EA1F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_6_f800_2ea1fbc0() {
    // Encoding: 0x2EA1FBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x2EA1FBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_7_f800_2ea1fbe0() {
    // Encoding: 0x2EA1FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=31
    let encoding: u32 = 0x2EA1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_8_f800_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_9_f800_2ea1f801() {
    // Encoding: 0x2EA1F801
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Rn=0, sz=0, Rd=1, Q=0
    let encoding: u32 = 0x2EA1F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_10_f800_2ea1f81e() {
    // Encoding: 0x2EA1F81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: Rd=30, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1F81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_11_f800_2ea1f81f() {
    // Encoding: 0x2EA1F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Rd=31, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x2EA1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_12_f800_2ea1f821() {
    // Encoding: 0x2EA1F821
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, Rd=1, sz=0
    let encoding: u32 = 0x2EA1F821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_combo_13_f800_2ea1fbff() {
    // Encoding: 0x2EA1FBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Rn=31, Q=0, Rd=31, sz=0
    let encoding: u32 = 0x2EA1FBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_q_0_size_variant_0_63488_2ee1f800() {
    // Encoding: 0x2EE1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value Q = 0 (Size variant 0)
    // Fields: sz=1, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_q_1_size_variant_1_63488_6ee1f800() {
    // Encoding: 0x6EE1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value Q = 1 (Size variant 1)
    // Fields: Rd=0, sz=1, Q=1, Rn=0
    let encoding: u32 = 0x6EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_sz_0_size_variant_0_63488_2ea1f800() {
    // Encoding: 0x2EA1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value sz = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x2EA1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_sz_1_size_variant_1_63488_2ee1f800() {
    // Encoding: 0x2EE1F800
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value sz = 1 (Size variant 1)
    // Fields: Q=0, Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x2EE1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_rn_31_stack_pointer_sp_may_require_alignment_63488_2ee1fbe0() {
    // Encoding: 0x2EE1FBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, Rd=0, Rn=31, Q=0
    let encoding: u32 = 0x2EE1FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_63488_2ee1f81f() {
    // Encoding: 0x2EE1F81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, Rd=31, sz=1
    let encoding: u32 = 0x2EE1F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_reg_write_0_2ef9f800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 register write: SimdFromField("d")
    // Encoding: 0x2EF9F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_sp_rn_2ef9fbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 with Rn = SP (31)
    // Encoding: 0x2EF9FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_fp16
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_fp16_zr_rd_2ef9f81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_fp16 with Rd = ZR (31)
    // Encoding: 0x2EF9F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EF9F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_reg_write_0_2ea1f800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt register write: SimdFromField("d")
    // Encoding: 0x2EA1F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_sp_rn_2ea1fbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt with Rn = SP (31)
    // Encoding: 0x2EA1FBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1FBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_zr_rd_2ea1f81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt with Rd = ZR (31)
    // Encoding: 0x2EA1F81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1F81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_q_0_min_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Q = 0 (Min)
    // Fields: Rm=0, Q=0, Rd=0, Rn=0, opc2=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_q_1_max_1c00_6e201c00() {
    // Encoding: 0x6E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Q = 1 (Max)
    // Fields: Rm=0, opc2=0, Rd=0, Rn=0, Q=1
    let encoding: u32 = 0x6E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field opc2 22 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_opc2_0_min_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field opc2 = 0 (Min)
    // Fields: opc2=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field opc2 22 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_opc2_1_poweroftwo_1c00_2e601c00() {
    // Encoding: 0x2E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field opc2 = 1 (PowerOfTwo)
    // Fields: Q=0, opc2=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field opc2 22 +: 2`
/// Requirement: FieldBoundary { field: "opc2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_opc2_3_max_1c00_2ee01c00() {
    // Encoding: 0x2EE01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field opc2 = 3 (Max)
    // Fields: opc2=3, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EE01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rm_0_min_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rm = 0 (Min)
    // Fields: opc2=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rm_1_poweroftwo_1c00_2e211c00() {
    // Encoding: 0x2E211C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Q=0, Rd=0, opc2=0
    let encoding: u32 = 0x2E211C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rm_30_poweroftwominusone_1c00_2e3e1c00() {
    // Encoding: 0x2E3E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: opc2=0, Rn=0, Rm=30, Rd=0, Q=0
    let encoding: u32 = 0x2E3E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rm_31_max_1c00_2e3f1c00() {
    // Encoding: 0x2E3F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rm = 31 (Max)
    // Fields: Q=0, Rm=31, Rn=0, opc2=0, Rd=0
    let encoding: u32 = 0x2E3F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rn_0_min_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0, Q=0, opc2=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rn_1_poweroftwo_1c00_2e201c20() {
    // Encoding: 0x2E201C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Q=0, Rd=0, Rn=1, opc2=0
    let encoding: u32 = 0x2E201C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rn_30_poweroftwominusone_1c00_2e201fc0() {
    // Encoding: 0x2E201FC0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rm=0, Rn=30, opc2=0, Rd=0
    let encoding: u32 = 0x2E201FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rn_31_max_1c00_2e201fe0() {
    // Encoding: 0x2E201FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rn = 31 (Max)
    // Fields: opc2=0, Rn=31, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x2E201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rd_0_min_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rd = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, opc2=0, Q=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rd_1_poweroftwo_1c00_2e201c01() {
    // Encoding: 0x2E201C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, opc2=0, Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x2E201C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rd_30_poweroftwominusone_1c00_2e201c1e() {
    // Encoding: 0x2E201C1E
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, opc2=0, Rd=30, Rm=0, Q=0
    let encoding: u32 = 0x2E201C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_field_rd_31_max_1c00_2e201c1f() {
    // Encoding: 0x2E201C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field Rd = 31 (Max)
    // Fields: Rm=0, opc2=0, Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x2E201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_0_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Q=0, Rn=0, Rd=0, opc2=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_1_1c00_6e201c00() {
    // Encoding: 0x6E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=1, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=1, opc2=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x6E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_2_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=1 (value 1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_3_1c00_2e601c00() {
    // Encoding: 0x2E601C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=1, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, opc2=1, Rm=0
    let encoding: u32 = 0x2E601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// opc2=3 (maximum value (3))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_4_1c00_2ee01c00() {
    // Encoding: 0x2EE01C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=3, Rm=0, Rn=0, Rd=0
    // Fields: opc2=3, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EE01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_5_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, opc2=0, Rd=0, Q=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_6_1c00_2e211c00() {
    // Encoding: 0x2E211C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=1, Rn=0, Rd=0
    // Fields: Q=0, Rm=1, opc2=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E211C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_7_1c00_2e3e1c00() {
    // Encoding: 0x2E3E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=30, Rn=0, Rd=0
    // Fields: opc2=0, Rd=0, Rn=0, Rm=30, Q=0
    let encoding: u32 = 0x2E3E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_8_1c00_2e3f1c00() {
    // Encoding: 0x2E3F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=31, Rn=0, Rd=0
    // Fields: Rd=0, opc2=0, Rm=31, Rn=0, Q=0
    let encoding: u32 = 0x2E3F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_9_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, opc2=0, Rm=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_10_1c00_2e201c20() {
    // Encoding: 0x2E201C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=1, Rd=0
    // Fields: opc2=0, Rn=1, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x2E201C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_11_1c00_2e201fc0() {
    // Encoding: 0x2E201FC0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=30, Rd=0
    // Fields: Rn=30, Rm=0, opc2=0, Q=0, Rd=0
    let encoding: u32 = 0x2E201FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_12_1c00_2e201fe0() {
    // Encoding: 0x2E201FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, Q=0, opc2=0, Rm=0
    let encoding: u32 = 0x2E201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_13_1c00_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=0
    // Fields: opc2=0, Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_14_1c00_2e201c01() {
    // Encoding: 0x2E201C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=1
    // Fields: Rd=1, Rm=0, Q=0, Rn=0, opc2=0
    let encoding: u32 = 0x2E201C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_15_1c00_2e201c1e() {
    // Encoding: 0x2E201C1E
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=30
    // Fields: Rm=0, Q=0, Rn=0, Rd=30, opc2=0
    let encoding: u32 = 0x2E201C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_16_1c00_2e201c1f() {
    // Encoding: 0x2E201C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=0, Rd=31
    // Fields: Q=0, Rd=31, Rn=0, Rm=0, opc2=0
    let encoding: u32 = 0x2E201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_17_1c00_2e211c20() {
    // Encoding: 0x2E211C20
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=1, Rn=1, Rd=0
    // Fields: opc2=0, Rm=1, Rd=0, Q=0, Rn=1
    let encoding: u32 = 0x2E211C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_18_1c00_2e3f1fe0() {
    // Encoding: 0x2E3F1FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=31, Rn=31, Rd=0
    // Fields: Rd=0, opc2=0, Q=0, Rm=31, Rn=31
    let encoding: u32 = 0x2E3F1FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_19_1c00_2e211c01() {
    // Encoding: 0x2E211C01
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, opc2=0, Rm=1, Q=0, Rn=0
    let encoding: u32 = 0x2E211C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_20_1c00_2e3f1c1f() {
    // Encoding: 0x2E3F1C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=31, Rn=0, Rd=31
    // Fields: Q=0, Rm=31, opc2=0, Rn=0, Rd=31
    let encoding: u32 = 0x2E3F1C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_21_1c00_2e201c21() {
    // Encoding: 0x2E201C21
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=1, Rd=1
    // Fields: Rm=0, Q=0, Rd=1, Rn=1, opc2=0
    let encoding: u32 = 0x2E201C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_combo_22_1c00_2e201fff() {
    // Encoding: 0x2E201FFF
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor field combination: Q=0, opc2=0, Rm=0, Rn=31, Rd=31
    // Fields: Q=0, opc2=0, Rm=0, Rd=31, Rn=31
    let encoding: u32 = 0x2E201FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_special_q_0_size_variant_0_7168_2e201c00() {
    // Encoding: 0x2E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, Rn=0, opc2=0, Rd=0
    let encoding: u32 = 0x2E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_special_q_1_size_variant_1_7168_6e201c00() {
    // Encoding: 0x6E201C00
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rn=0, Rd=0, Rm=0, opc2=0
    let encoding: u32 = 0x6E201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_special_rn_31_stack_pointer_sp_may_require_alignment_7168_2e201fe0() {
    // Encoding: 0x2E201FE0
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: opc2=0, Q=0, Rn=31, Rd=0, Rm=0
    let encoding: u32 = 0x2E201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_7168_2e201c1f() {
    // Encoding: 0x2E201C1F
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, Rm=0, Rd=31, opc2=0
    let encoding: u32 = 0x2E201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_reg_write_0_2e201c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor register write: SimdFromField("d")
    // Encoding: 0x2E201C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E201C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_sp_rn_2e201fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor with Rn = SP (31)
    // Encoding: 0x2E201FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E201FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor_zr_rd_2e201c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_logical_bsl_eor with Rd = ZR (31)
    // Encoding: 0x2E201C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E201C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_div_fp16 Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_q_0_min_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Q = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_q_1_max_3c00_6e403c00() {
    // Encoding: 0x6E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Q = 1 (Max)
    // Fields: Rd=0, Rn=0, Q=1, Rm=0
    let encoding: u32 = 0x6E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rm_0_min_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rm = 0 (Min)
    // Fields: Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rm_1_poweroftwo_3c00_2e413c00() {
    // Encoding: 0x2E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=0, Q=0, Rm=1
    let encoding: u32 = 0x2E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rm_30_poweroftwominusone_3c00_2e5e3c00() {
    // Encoding: 0x2E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rm=30, Rd=0, Rn=0
    let encoding: u32 = 0x2E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rm_31_max_3c00_2e5f3c00() {
    // Encoding: 0x2E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Q=0, Rd=0
    let encoding: u32 = 0x2E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rn_0_min_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rn = 0 (Min)
    // Fields: Rd=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rn_1_poweroftwo_3c00_2e403c20() {
    // Encoding: 0x2E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rn_30_poweroftwominusone_3c00_2e403fc0() {
    // Encoding: 0x2E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x2E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rn_31_max_3c00_2e403fe0() {
    // Encoding: 0x2E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rn = 31 (Max)
    // Fields: Q=0, Rd=0, Rm=0, Rn=31
    let encoding: u32 = 0x2E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rd_0_min_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rd = 0 (Min)
    // Fields: Q=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rd_1_poweroftwo_3c00_2e403c01() {
    // Encoding: 0x2E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, Rn=0, Rd=1
    let encoding: u32 = 0x2E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rd_30_poweroftwominusone_3c00_2e403c1e() {
    // Encoding: 0x2E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_field_rd_31_max_3c00_2e403c1f() {
    // Encoding: 0x2E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field Rd = 31 (Max)
    // Fields: Rm=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x2E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_0_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_1_3c00_6e403c00() {
    // Encoding: 0x6E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=1, Rm=0, Rn=0, Rd=0
    // Fields: Q=1, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x6E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_2_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_3_3c00_2e413c00() {
    // Encoding: 0x2E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=1, Rn=0, Rd=0
    // Fields: Q=0, Rm=1, Rd=0, Rn=0
    let encoding: u32 = 0x2E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_4_3c00_2e5e3c00() {
    // Encoding: 0x2E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=30, Rn=0, Rd=0
    // Fields: Rn=0, Rm=30, Q=0, Rd=0
    let encoding: u32 = 0x2E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_5_3c00_2e5f3c00() {
    // Encoding: 0x2E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=31, Rn=0, Rd=0
    // Fields: Rm=31, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x2E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_6_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_7_3c00_2e403c20() {
    // Encoding: 0x2E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=1, Rd=0
    // Fields: Q=0, Rn=1, Rd=0, Rm=0
    let encoding: u32 = 0x2E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_8_3c00_2e403fc0() {
    // Encoding: 0x2E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=30, Rd=0
    // Fields: Rm=0, Rn=30, Rd=0, Q=0
    let encoding: u32 = 0x2E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_9_3c00_2e403fe0() {
    // Encoding: 0x2E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Rn=31, Rd=0, Q=0
    let encoding: u32 = 0x2E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_10_3c00_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_11_3c00_2e403c01() {
    // Encoding: 0x2E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=1
    // Fields: Rm=0, Rd=1, Rn=0, Q=0
    let encoding: u32 = 0x2E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_12_3c00_2e403c1e() {
    // Encoding: 0x2E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, Q=0, Rm=0
    let encoding: u32 = 0x2E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_13_3c00_2e403c1f() {
    // Encoding: 0x2E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x2E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_14_3c00_2e413c20() {
    // Encoding: 0x2E413C20
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=1, Rn=1, Rd=0
    // Fields: Q=0, Rm=1, Rd=0, Rn=1
    let encoding: u32 = 0x2E413C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_15_3c00_2e5f3fe0() {
    // Encoding: 0x2E5F3FE0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=31, Rn=31, Rd=0
    // Fields: Rm=31, Rd=0, Rn=31, Q=0
    let encoding: u32 = 0x2E5F3FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_16_3c00_2e413c01() {
    // Encoding: 0x2E413C01
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, Rn=0, Q=0, Rm=1
    let encoding: u32 = 0x2E413C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_17_3c00_2e5f3c1f() {
    // Encoding: 0x2E5F3C1F
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=31, Rn=0, Rd=31
    // Fields: Rm=31, Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x2E5F3C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_18_3c00_2e403c21() {
    // Encoding: 0x2E403C21
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=1, Rd=1
    // Fields: Rn=1, Rm=0, Q=0, Rd=1
    let encoding: u32 = 0x2E403C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_combo_19_3c00_2e403fff() {
    // Encoding: 0x2E403FFF
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 field combination: Q=0, Rm=0, Rn=31, Rd=31
    // Fields: Rn=31, Rm=0, Q=0, Rd=31
    let encoding: u32 = 0x2E403FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_special_q_0_size_variant_0_15360_2e403c00() {
    // Encoding: 0x2E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x2E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_special_q_1_size_variant_1_15360_6e403c00() {
    // Encoding: 0x6E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x6E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_special_rn_31_stack_pointer_sp_may_require_alignment_15360_2e403fe0() {
    // Encoding: 0x2E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, Rm=0, Rn=31
    let encoding: u32 = 0x2E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_15360_2e403c1f() {
    // Encoding: 0x2E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, Rm=0, Rd=31
    let encoding: u32 = 0x2E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_q_0_min_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Q = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_q_1_max_fc00_6e20fc00() {
    // Encoding: 0x6E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Q = 1 (Max)
    // Fields: Rn=0, Rd=0, Q=1, sz=0, Rm=0
    let encoding: u32 = 0x6E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_sz_0_min_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field sz = 0 (Min)
    // Fields: Q=0, Rd=0, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_sz_1_max_fc00_2e60fc00() {
    // Encoding: 0x2E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field sz = 1 (Max)
    // Fields: Rn=0, sz=1, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x2E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rm_0_min_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rm_1_poweroftwo_fc00_2e21fc00() {
    // Encoding: 0x2E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, Rm=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rm_30_poweroftwominusone_fc00_2e3efc00() {
    // Encoding: 0x2E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rd=0, Rn=0, Rm=30, sz=0
    let encoding: u32 = 0x2E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rm_31_max_fc00_2e3ffc00() {
    // Encoding: 0x2E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rm = 31 (Max)
    // Fields: Rd=0, Rm=31, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x2E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rn_0_min_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rn = 0 (Min)
    // Fields: sz=0, Rn=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rn_1_poweroftwo_fc00_2e20fc20() {
    // Encoding: 0x2E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rd=0, Rm=0, Q=0, Rn=1
    let encoding: u32 = 0x2E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rn_30_poweroftwominusone_fc00_2e20ffc0() {
    // Encoding: 0x2E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Q=0, Rm=0, Rd=0, Rn=30
    let encoding: u32 = 0x2E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rn_31_max_fc00_2e20ffe0() {
    // Encoding: 0x2E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rn = 31 (Max)
    // Fields: sz=0, Q=0, Rm=0, Rd=0, Rn=31
    let encoding: u32 = 0x2E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rd_0_min_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rd = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rd_1_poweroftwo_fc00_2e20fc01() {
    // Encoding: 0x2E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, sz=0, Rn=0, Rd=1
    let encoding: u32 = 0x2E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rd_30_poweroftwominusone_fc00_2e20fc1e() {
    // Encoding: 0x2E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rm=0, Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_field_rd_31_max_fc00_2e20fc1f() {
    // Encoding: 0x2E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_div field Rd = 31 (Max)
    // Fields: Q=0, sz=0, Rm=0, Rd=31, Rn=0
    let encoding: u32 = 0x2E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_0_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0, Q=0, Rm=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_1_fc00_6e20fc00() {
    // Encoding: 0x6E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=1, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Rm=0, Q=1, sz=0
    let encoding: u32 = 0x6E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_2_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, sz=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_3_fc00_2e60fc00() {
    // Encoding: 0x2E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=1, Rm=0, Rn=0, Rd=0
    // Fields: sz=1, Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_4_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_5_fc00_2e21fc00() {
    // Encoding: 0x2E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rm=1, Q=0, Rd=0
    let encoding: u32 = 0x2E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_6_fc00_2e3efc00() {
    // Encoding: 0x2E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=30, Rn=0, Rd=0
    // Fields: Q=0, Rm=30, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x2E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_7_fc00_2e3ffc00() {
    // Encoding: 0x2E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Q=0, Rm=31, Rd=0
    let encoding: u32 = 0x2E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_8_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rm=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_9_fc00_2e20fc20() {
    // Encoding: 0x2E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=0
    // Fields: Q=0, sz=0, Rd=0, Rn=1, Rm=0
    let encoding: u32 = 0x2E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_10_fc00_2e20ffc0() {
    // Encoding: 0x2E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, Rm=0, Q=0, sz=0
    let encoding: u32 = 0x2E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_11_fc00_2e20ffe0() {
    // Encoding: 0x2E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=0
    // Fields: Rd=0, sz=0, Rn=31, Q=0, Rm=0
    let encoding: u32 = 0x2E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_12_fc00_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_13_fc00_2e20fc01() {
    // Encoding: 0x2E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=1
    // Fields: sz=0, Rd=1, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_14_fc00_2e20fc1e() {
    // Encoding: 0x2E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=30
    // Fields: Rm=0, sz=0, Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x2E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_15_fc00_2e20fc1f() {
    // Encoding: 0x2E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, Rm=0, Q=0, sz=0
    let encoding: u32 = 0x2E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_16_fc00_2e21fc20() {
    // Encoding: 0x2E21FC20
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=1, Rn=1, Rd=0
    // Fields: Rn=1, Rm=1, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2E21FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_17_fc00_2e3fffe0() {
    // Encoding: 0x2E3FFFE0
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=31, Rn=31, Rd=0
    // Fields: Rm=31, Q=0, Rn=31, sz=0, Rd=0
    let encoding: u32 = 0x2E3FFFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_18_fc00_2e21fc01() {
    // Encoding: 0x2E21FC01
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=1
    // Fields: sz=0, Rd=1, Rm=1, Rn=0, Q=0
    let encoding: u32 = 0x2E21FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_19_fc00_2e3ffc1f() {
    // Encoding: 0x2E3FFC1F
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, sz=0, Q=0, Rm=31
    let encoding: u32 = 0x2E3FFC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_20_fc00_2e20fc21() {
    // Encoding: 0x2E20FC21
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, Rd=1, Rm=0, sz=0
    let encoding: u32 = 0x2E20FC21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_combo_21_fc00_2e20ffff() {
    // Encoding: 0x2E20FFFF
    // Test aarch64_vector_arithmetic_binary_uniform_div field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rm=0, sz=0, Rn=31, Q=0, Rd=31
    let encoding: u32 = 0x2E20FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_q_0_size_variant_0_64512_2e60fc00() {
    // Encoding: 0x2E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, Rm=0, sz=1, Rn=0
    let encoding: u32 = 0x2E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_q_1_size_variant_1_64512_6e60fc00() {
    // Encoding: 0x6E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Rn=0, Q=1, sz=1, Rd=0
    let encoding: u32 = 0x6E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_sz_0_size_variant_0_64512_2e20fc00() {
    // Encoding: 0x2E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div special value sz = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, sz=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_sz_1_size_variant_1_64512_2e60fc00() {
    // Encoding: 0x2E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_div special value sz = 1 (Size variant 1)
    // Fields: Rm=0, Q=0, sz=1, Rd=0, Rn=0
    let encoding: u32 = 0x2E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_rn_31_stack_pointer_sp_may_require_alignment_64512_2e60ffe0() {
    // Encoding: 0x2E60FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_div special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rn=31, Rm=0, sz=1, Rd=0
    let encoding: u32 = 0x2E60FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_64512_2e60fc1f() {
    // Encoding: 0x2E60FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_div special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rm=0, Rn=0, sz=1, Q=0
    let encoding: u32 = 0x2E60FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_reg_write_0_2e403c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 register write: SimdFromField("d")
    // Encoding: 0x2E403C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E403C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_sp_rn_2e403fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 with Rn = SP (31)
    // Encoding: 0x2E403FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E403FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div_fp16
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_fp16_zr_rd_2e403c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_div_fp16 with Rd = ZR (31)
    // Encoding: 0x2E403C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E403C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_reg_write_0_2e20fc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_div register write: SimdFromField("d")
    // Encoding: 0x2E20FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_sp_rn_2e20ffe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_div with Rn = SP (31)
    // Encoding: 0x2E20FFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20FFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_div
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_div_zr_rd_2e20fc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_div with Rd = ZR (31)
    // Encoding: 0x2E20FC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_diff_neg_sat_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_u_0_min_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field U = 0 (Min)
    // Fields: Rd=0, size=0, U=0, Rn=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_u_1_max_7800_7e207800() {
    // Encoding: 0x7E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field U = 1 (Max)
    // Fields: size=0, Rd=0, Rn=0, U=1
    let encoding: u32 = 0x7E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_size_0_min_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field size = 0 (Min)
    // Fields: Rn=0, size=0, Rd=0, U=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_size_1_poweroftwo_7800_5e607800() {
    // Encoding: 0x5E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field size = 1 (PowerOfTwo)
    // Fields: Rd=0, size=1, Rn=0, U=0
    let encoding: u32 = 0x5E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_size_2_poweroftwo_7800_5ea07800() {
    // Encoding: 0x5EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field size = 2 (PowerOfTwo)
    // Fields: size=2, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_size_3_max_7800_5ee07800() {
    // Encoding: 0x5EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field size = 3 (Max)
    // Fields: size=3, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rn_0_min_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rn = 0 (Min)
    // Fields: size=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rn_1_poweroftwo_7800_5e207820() {
    // Encoding: 0x5E207820
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, size=0, Rn=1, U=0
    let encoding: u32 = 0x5E207820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rn_30_poweroftwominusone_7800_5e207bc0() {
    // Encoding: 0x5E207BC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, U=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E207BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rn_31_max_7800_5e207be0() {
    // Encoding: 0x5E207BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rn = 31 (Max)
    // Fields: Rn=31, size=0, Rd=0, U=0
    let encoding: u32 = 0x5E207BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rd_0_min_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rd = 0 (Min)
    // Fields: U=0, size=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rd_1_poweroftwo_7800_5e207801() {
    // Encoding: 0x5E207801
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rd=1, size=0, Rn=0
    let encoding: u32 = 0x5E207801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rd_30_poweroftwominusone_7800_5e20781e() {
    // Encoding: 0x5E20781E
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, size=0, U=0, Rn=0
    let encoding: u32 = 0x5E20781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_field_rd_31_max_7800_5e20781f() {
    // Encoding: 0x5E20781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field Rd = 31 (Max)
    // Fields: Rd=31, U=0, size=0, Rn=0
    let encoding: u32 = 0x5E20781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_0_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_1_7800_7e207800() {
    // Encoding: 0x7E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=1, size=0, Rn=0, Rd=0
    // Fields: Rd=0, U=1, Rn=0, size=0
    let encoding: u32 = 0x7E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_2_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: U=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_3_7800_5e607800() {
    // Encoding: 0x5E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=1, Rn=0, Rd=0
    // Fields: U=0, Rd=0, Rn=0, size=1
    let encoding: u32 = 0x5E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_4_7800_5ea07800() {
    // Encoding: 0x5EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=2, Rn=0, Rd=0
    // Fields: Rd=0, size=2, U=0, Rn=0
    let encoding: u32 = 0x5EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_5_7800_5ee07800() {
    // Encoding: 0x5EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=3, Rn=0, Rd=0
    // Fields: size=3, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_6_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_7_7800_5e207820() {
    // Encoding: 0x5E207820
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=1, Rd=0
    // Fields: Rn=1, U=0, size=0, Rd=0
    let encoding: u32 = 0x5E207820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_8_7800_5e207bc0() {
    // Encoding: 0x5E207BC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=30, Rd=0
    // Fields: U=0, Rn=30, size=0, Rd=0
    let encoding: u32 = 0x5E207BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_9_7800_5e207be0() {
    // Encoding: 0x5E207BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=31, Rd=0
    // Fields: U=0, size=0, Rn=31, Rd=0
    let encoding: u32 = 0x5E207BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_10_7800_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=0
    // Fields: size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_11_7800_5e207801() {
    // Encoding: 0x5E207801
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=1
    // Fields: size=0, U=0, Rd=1, Rn=0
    let encoding: u32 = 0x5E207801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_12_7800_5e20781e() {
    // Encoding: 0x5E20781E
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=30
    // Fields: Rd=30, size=0, U=0, Rn=0
    let encoding: u32 = 0x5E20781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_13_7800_5e20781f() {
    // Encoding: 0x5E20781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=0, Rd=31
    // Fields: Rd=31, size=0, Rn=0, U=0
    let encoding: u32 = 0x5E20781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_14_7800_5e207821() {
    // Encoding: 0x5E207821
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=1, Rd=1
    // Fields: Rd=1, U=0, Rn=1, size=0
    let encoding: u32 = 0x5E207821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_combo_15_7800_5e207bff() {
    // Encoding: 0x5E207BFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd field combination: U=0, size=0, Rn=31, Rd=31
    // Fields: Rd=31, U=0, size=0, Rn=31
    let encoding: u32 = 0x5E207BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_size_0_size_variant_0_30720_5e207800() {
    // Encoding: 0x5E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value size = 0 (Size variant 0)
    // Fields: size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_size_1_size_variant_1_30720_5e607800() {
    // Encoding: 0x5E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value size = 1 (Size variant 1)
    // Fields: size=1, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_size_2_size_variant_2_30720_5ea07800() {
    // Encoding: 0x5EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value size = 2 (Size variant 2)
    // Fields: U=0, size=2, Rd=0, Rn=0
    let encoding: u32 = 0x5EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_size_3_size_variant_3_30720_5ee07800() {
    // Encoding: 0x5EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value size = 3 (Size variant 3)
    // Fields: U=0, size=3, Rd=0, Rn=0
    let encoding: u32 = 0x5EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_30720_5e607be0() {
    // Encoding: 0x5E607BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, U=0, Rd=0, size=1
    let encoding: u32 = 0x5E607BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_30720_5e60781f() {
    // Encoding: 0x5E60781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, size=1, U=0
    let encoding: u32 = 0x5E60781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_q_0_min_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Q = 0 (Min)
    // Fields: Q=0, size=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_q_1_max_7800_4e207800() {
    // Encoding: 0x4E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Q = 1 (Max)
    // Fields: Q=1, size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_u_0_min_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field U = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_u_1_max_7800_2e207800() {
    // Encoding: 0x2E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field U = 1 (Max)
    // Fields: Q=0, size=0, Rd=0, Rn=0, U=1
    let encoding: u32 = 0x2E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_size_0_min_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field size = 0 (Min)
    // Fields: size=0, U=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_size_1_poweroftwo_7800_0e607800() {
    // Encoding: 0x0E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field size = 1 (PowerOfTwo)
    // Fields: Rn=0, U=0, size=1, Q=0, Rd=0
    let encoding: u32 = 0x0E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_size_2_poweroftwo_7800_0ea07800() {
    // Encoding: 0x0EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field size = 2 (PowerOfTwo)
    // Fields: Rn=0, size=2, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_size_3_max_7800_0ee07800() {
    // Encoding: 0x0EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field size = 3 (Max)
    // Fields: size=3, Rd=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rn_0_min_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rn = 0 (Min)
    // Fields: size=0, Rd=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rn_1_poweroftwo_7800_0e207820() {
    // Encoding: 0x0E207820
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, size=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E207820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rn_30_poweroftwominusone_7800_0e207bc0() {
    // Encoding: 0x0E207BC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, size=0, U=0, Q=0, Rn=30
    let encoding: u32 = 0x0E207BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rn_31_max_7800_0e207be0() {
    // Encoding: 0x0E207BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rn = 31 (Max)
    // Fields: size=0, Rn=31, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E207BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rd_0_min_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rd = 0 (Min)
    // Fields: Q=0, size=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rd_1_poweroftwo_7800_0e207801() {
    // Encoding: 0x0E207801
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, size=0, U=0, Rd=1, Q=0
    let encoding: u32 = 0x0E207801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rd_30_poweroftwominusone_7800_0e20781e() {
    // Encoding: 0x0E20781E
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E20781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_field_rd_31_max_7800_0e20781f() {
    // Encoding: 0x0E20781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field Rd = 31 (Max)
    // Fields: U=0, size=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E20781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_0_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_1_7800_4e207800() {
    // Encoding: 0x4E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=1, U=0, size=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Q=1, size=0, Rd=0
    let encoding: u32 = 0x4E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_2_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_3_7800_2e207800() {
    // Encoding: 0x2E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=1, size=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, Rn=0, Q=0, U=1
    let encoding: u32 = 0x2E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_4_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_5_7800_0e607800() {
    // Encoding: 0x0E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=1, Rn=0, Rd=0
    // Fields: Q=0, U=0, size=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_6_7800_0ea07800() {
    // Encoding: 0x0EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=2, Rn=0, Rd=0
    // Fields: Q=0, size=2, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_7_7800_0ee07800() {
    // Encoding: 0x0EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=3, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0, size=3, Q=0
    let encoding: u32 = 0x0EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_8_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_9_7800_0e207820() {
    // Encoding: 0x0E207820
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=0
    // Fields: size=0, Rn=1, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E207820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_10_7800_0e207bc0() {
    // Encoding: 0x0E207BC0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=30, Rd=0
    // Fields: Rd=0, Q=0, U=0, Rn=30, size=0
    let encoding: u32 = 0x0E207BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_11_7800_0e207be0() {
    // Encoding: 0x0E207BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=0
    // Fields: Q=0, size=0, Rn=31, U=0, Rd=0
    let encoding: u32 = 0x0E207BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_12_7800_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, size=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_13_7800_0e207801() {
    // Encoding: 0x0E207801
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=1
    // Fields: U=0, size=0, Q=0, Rd=1, Rn=0
    let encoding: u32 = 0x0E207801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_14_7800_0e20781e() {
    // Encoding: 0x0E20781E
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=30
    // Fields: U=0, Q=0, size=0, Rd=30, Rn=0
    let encoding: u32 = 0x0E20781E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_15_7800_0e20781f() {
    // Encoding: 0x0E20781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=0, Rd=31
    // Fields: size=0, Q=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x0E20781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_16_7800_0e207821() {
    // Encoding: 0x0E207821
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=1, Rd=1
    // Fields: size=0, Q=0, Rd=1, U=0, Rn=1
    let encoding: u32 = 0x0E207821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_combo_17_7800_0e207bff() {
    // Encoding: 0x0E207BFF
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd field combination: Q=0, U=0, size=0, Rn=31, Rd=31
    // Fields: Rd=31, U=0, Q=0, size=0, Rn=31
    let encoding: u32 = 0x0E207BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_q_0_size_variant_0_30720_0e607800() {
    // Encoding: 0x0E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, U=0, Rn=0, Rd=0, size=1
    let encoding: u32 = 0x0E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_q_1_size_variant_1_30720_4e607800() {
    // Encoding: 0x4E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, U=0, Q=1, size=1, Rn=0
    let encoding: u32 = 0x4E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_size_0_size_variant_0_30720_0e207800() {
    // Encoding: 0x0E207800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value size = 0 (Size variant 0)
    // Fields: Q=0, Rd=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x0E207800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_size_1_size_variant_1_30720_0e607800() {
    // Encoding: 0x0E607800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value size = 1 (Size variant 1)
    // Fields: size=1, Rd=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E607800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_size_2_size_variant_2_30720_0ea07800() {
    // Encoding: 0x0EA07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value size = 2 (Size variant 2)
    // Fields: Rn=0, U=0, Rd=0, size=2, Q=0
    let encoding: u32 = 0x0EA07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_size_3_size_variant_3_30720_0ee07800() {
    // Encoding: 0x0EE07800
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value size = 3 (Size variant 3)
    // Fields: Rd=0, Q=0, size=3, Rn=0, U=0
    let encoding: u32 = 0x0EE07800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_rn_31_stack_pointer_sp_may_require_alignment_30720_0e607be0() {
    // Encoding: 0x0E607BE0
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, size=1, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E607BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_30720_0e60781f() {
    // Encoding: 0x0E60781F
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, U=0, size=1, Rd=31
    let encoding: u32 = 0x0E60781F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_reg_write_0_5e207800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd register write: SimdFromField("d")
    // Encoding: 0x5E207800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E207800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_sp_rn_5e207be0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd with Rn = SP (31)
    // Encoding: 0x5E207BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E207BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_sisd_zr_rd_5e20781f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_sisd with Rd = ZR (31)
    // Encoding: 0x5E20781F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20781F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_reg_write_0_0e207800() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd register write: SimdFromField("d")
    // Encoding: 0x0E207800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E207800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_sp_rn_0e207be0() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd with Rn = SP (31)
    // Encoding: 0x0E207BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E207BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_diff_neg_sat_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_diff_neg_sat_simd_zr_rd_0e20781f() {
    // Test aarch64_vector_arithmetic_unary_diff_neg_sat_simd with Rd = ZR (31)
    // Encoding: 0x0E20781F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20781F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_max_min_pair Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_q_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Q = 0 (Min)
    // Fields: U=0, Q=0, Rm=0, o1=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_q_1_max_a400_4e20a400() {
    // Encoding: 0x4E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Q = 1 (Max)
    // Fields: Q=1, size=0, Rn=0, U=0, Rd=0, Rm=0, o1=0
    let encoding: u32 = 0x4E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_u_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field U = 0 (Min)
    // Fields: Q=0, Rm=0, o1=0, Rn=0, size=0, Rd=0, U=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_u_1_max_a400_2e20a400() {
    // Encoding: 0x2E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field U = 1 (Max)
    // Fields: U=1, Q=0, o1=0, size=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_size_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field size = 0 (Min)
    // Fields: Rm=0, o1=0, Rn=0, Rd=0, Q=0, U=0, size=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_size_1_poweroftwo_a400_0e60a400() {
    // Encoding: 0x0E60A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field size = 1 (PowerOfTwo)
    // Fields: size=1, Rm=0, o1=0, Rd=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E60A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_size_2_poweroftwo_a400_0ea0a400() {
    // Encoding: 0x0EA0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Rd=0, Rn=0, o1=0, Q=0, U=0, size=2
    let encoding: u32 = 0x0EA0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_size_3_max_a400_0ee0a400() {
    // Encoding: 0x0EE0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field size = 3 (Max)
    // Fields: U=0, o1=0, Rm=0, Rn=0, Rd=0, size=3, Q=0
    let encoding: u32 = 0x0EE0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rm_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rm = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, o1=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rm_1_poweroftwo_a400_0e21a400() {
    // Encoding: 0x0E21A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, o1=0, size=0, Q=0, U=0, Rm=1, Rn=0
    let encoding: u32 = 0x0E21A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rm_30_poweroftwominusone_a400_0e3ea400() {
    // Encoding: 0x0E3EA400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, o1=0, U=0, Rn=0, Rm=30, Rd=0, size=0
    let encoding: u32 = 0x0E3EA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rm_31_max_a400_0e3fa400() {
    // Encoding: 0x0E3FA400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rm = 31 (Max)
    // Fields: Q=0, o1=0, Rn=0, size=0, Rd=0, U=0, Rm=31
    let encoding: u32 = 0x0E3FA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field o1 11 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_o1_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field o1 = 0 (Min)
    // Fields: Rd=0, size=0, Q=0, Rm=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field o1 11 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_o1_1_max_a400_0e20ac00() {
    // Encoding: 0x0E20AC00
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field o1 = 1 (Max)
    // Fields: Rn=0, U=0, size=0, Q=0, Rm=0, o1=1, Rd=0
    let encoding: u32 = 0x0E20AC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rn_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rn = 0 (Min)
    // Fields: Q=0, Rd=0, Rn=0, size=0, Rm=0, o1=0, U=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rn_1_poweroftwo_a400_0e20a420() {
    // Encoding: 0x0E20A420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, U=0, Rm=0, o1=0, Rd=0, Rn=1
    let encoding: u32 = 0x0E20A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rn_30_poweroftwominusone_a400_0e20a7c0() {
    // Encoding: 0x0E20A7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, Rn=30, Rd=0, size=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E20A7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rn_31_max_a400_0e20a7e0() {
    // Encoding: 0x0E20A7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rn = 31 (Max)
    // Fields: U=0, size=0, Q=0, o1=0, Rn=31, Rd=0, Rm=0
    let encoding: u32 = 0x0E20A7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rd_0_min_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rd = 0 (Min)
    // Fields: U=0, Q=0, Rm=0, Rd=0, size=0, o1=0, Rn=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rd_1_poweroftwo_a400_0e20a401() {
    // Encoding: 0x0E20A401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rd = 1 (PowerOfTwo)
    // Fields: o1=0, U=0, size=0, Rn=0, Q=0, Rd=1, Rm=0
    let encoding: u32 = 0x0E20A401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rd_30_poweroftwominusone_a400_0e20a41e() {
    // Encoding: 0x0E20A41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, o1=0, Rd=30, U=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20A41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_field_rd_31_max_a400_0e20a41f() {
    // Encoding: 0x0E20A41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field Rd = 31 (Max)
    // Fields: Rn=0, o1=0, Rd=31, size=0, U=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20A41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_0_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, o1=0, size=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_1_a400_4e20a400() {
    // Encoding: 0x4E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=1, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, size=0, U=0, Q=1, o1=0, Rm=0, Rd=0
    let encoding: u32 = 0x4E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_2_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, Rd=0, o1=0, U=0, size=0, Rn=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_3_a400_2e20a400() {
    // Encoding: 0x2E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=1, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rm=0, size=0, Rn=0, Rd=0, Q=0, o1=0, U=1
    let encoding: u32 = 0x2E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_4_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rm=0, o1=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_5_a400_0e60a400() {
    // Encoding: 0x0E60A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=1, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, size=1, Rm=0, Rd=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E60A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_6_a400_0ea0a400() {
    // Encoding: 0x0EA0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=2, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: U=0, o1=0, Q=0, size=2, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_7_a400_0ee0a400() {
    // Encoding: 0x0EE0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=3, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=3, Rm=0, o1=0, Rn=0, U=0
    let encoding: u32 = 0x0EE0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_8_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, Rn=0, Rd=0, Q=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_9_a400_0e21a400() {
    // Encoding: 0x0E21A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=0, o1=0, Rn=0, U=0, Rm=1
    let encoding: u32 = 0x0E21A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_10_a400_0e3ea400() {
    // Encoding: 0x0E3EA400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=30, o1=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rm=30, o1=0, Rd=0, U=0, size=0
    let encoding: u32 = 0x0E3EA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_11_a400_0e3fa400() {
    // Encoding: 0x0E3FA400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=0, Rd=0
    // Fields: o1=0, U=0, size=0, Q=0, Rn=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E3FA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_12_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, U=0, Rm=0, Rd=0, size=0, o1=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// o1=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_13_a400_0e20ac00() {
    // Encoding: 0x0E20AC00
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=1, Rn=0, Rd=0
    // Fields: o1=1, Rm=0, U=0, size=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E20AC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_14_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, U=0, Rm=0, Rn=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_15_a400_0e20a420() {
    // Encoding: 0x0E20A420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=1, Rd=0
    // Fields: Rn=1, Rd=0, U=0, Q=0, size=0, Rm=0, o1=0
    let encoding: u32 = 0x0E20A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_16_a400_0e20a7c0() {
    // Encoding: 0x0E20A7C0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, o1=0, Q=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x0E20A7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_17_a400_0e20a7e0() {
    // Encoding: 0x0E20A7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=31, Rd=0
    // Fields: Q=0, Rn=31, U=0, Rm=0, o1=0, size=0, Rd=0
    let encoding: u32 = 0x0E20A7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_18_a400_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, o1=0, Rm=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_19_a400_0e20a401() {
    // Encoding: 0x0E20A401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, Rm=0, Rd=1, size=0, o1=0, Q=0
    let encoding: u32 = 0x0E20A401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_20_a400_0e20a41e() {
    // Encoding: 0x0E20A41E
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=30
    // Fields: Rn=0, U=0, Q=0, size=0, Rm=0, Rd=30, o1=0
    let encoding: u32 = 0x0E20A41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_21_a400_0e20a41f() {
    // Encoding: 0x0E20A41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=31
    // Fields: Rd=31, U=0, Q=0, o1=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0x0E20A41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 22`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_22_a400_0e21a420() {
    // Encoding: 0x0E21A420
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=1, Rd=0
    // Fields: Rd=0, size=0, Q=0, Rm=1, o1=0, U=0, Rn=1
    let encoding: u32 = 0x0E21A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 23`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_23_a400_0e3fa7e0() {
    // Encoding: 0x0E3FA7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=31, Rd=0
    // Fields: Rm=31, Q=0, U=0, o1=0, Rn=31, Rd=0, size=0
    let encoding: u32 = 0x0E3FA7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 24`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_24_a400_0e21a401() {
    // Encoding: 0x0E21A401
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=1, o1=0, Rn=0, Rd=1
    // Fields: o1=0, Rn=0, Rd=1, U=0, Rm=1, size=0, Q=0
    let encoding: u32 = 0x0E21A401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 25`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_25_a400_0e3fa41f() {
    // Encoding: 0x0E3FA41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=31, o1=0, Rn=0, Rd=31
    // Fields: U=0, Rm=31, Q=0, o1=0, Rn=0, Rd=31, size=0
    let encoding: u32 = 0x0E3FA41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 26`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_26_a400_0e20a421() {
    // Encoding: 0x0E20A421
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=1, Rd=1
    // Fields: size=0, Rm=0, Rd=1, Rn=1, o1=0, U=0, Q=0
    let encoding: u32 = 0x0E20A421;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field combination 27`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_combo_27_a400_0e20a7ff() {
    // Encoding: 0x0E20A7FF
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=31, Rd=31
    // Fields: size=0, Q=0, U=0, o1=0, Rn=31, Rd=31, Rm=0
    let encoding: u32 = 0x0E20A7FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_q_0_size_variant_0_41984_0e60a400() {
    // Encoding: 0x0E60A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value Q = 0 (Size variant 0)
    // Fields: U=0, Rm=0, Rn=0, size=1, o1=0, Rd=0, Q=0
    let encoding: u32 = 0x0E60A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_q_1_size_variant_1_41984_4e60a400() {
    // Encoding: 0x4E60A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value Q = 1 (Size variant 1)
    // Fields: U=0, size=1, Rn=0, Rm=0, Q=1, o1=0, Rd=0
    let encoding: u32 = 0x4E60A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_size_0_size_variant_0_41984_0e20a400() {
    // Encoding: 0x0E20A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value size = 0 (Size variant 0)
    // Fields: Q=0, o1=0, Rn=0, Rd=0, size=0, Rm=0, U=0
    let encoding: u32 = 0x0E20A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_size_1_size_variant_1_41984_0e60a400() {
    // Encoding: 0x0E60A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value size = 1 (Size variant 1)
    // Fields: size=1, o1=0, Rm=0, Rn=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E60A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_size_2_size_variant_2_41984_0ea0a400() {
    // Encoding: 0x0EA0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value size = 2 (Size variant 2)
    // Fields: U=0, Rm=0, o1=0, size=2, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EA0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_size_3_size_variant_3_41984_0ee0a400() {
    // Encoding: 0x0EE0A400
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value size = 3 (Size variant 3)
    // Fields: U=0, size=3, Rm=0, o1=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EE0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_rn_31_stack_pointer_sp_may_require_alignment_41984_0e60a7e0() {
    // Encoding: 0x0E60A7E0
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=1, Rn=31, Rd=0, Q=0, o1=0, U=0, Rm=0
    let encoding: u32 = 0x0E60A7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_41984_0e60a41f() {
    // Encoding: 0x0E60A41F
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rn=0, Rd=31, Rm=0, size=1, o1=0, U=0
    let encoding: u32 = 0x0E60A41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_reg_write_0_0e20a400() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair register write: SimdFromField("d")
    // Encoding: 0x0E20A400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20A400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_sp_rn_0e20a7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair with Rn = SP (31)
    // Encoding: 0x0E20A7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20A7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_max_min_pair
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_max_min_pair_zr_rd_0e20a41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_max_min_pair with Rd = ZR (31)
    // Encoding: 0x0E20A41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20A41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_extract_nosat Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_q_0_min_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Q = 0 (Min)
    // Fields: Q=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_q_1_max_2800_4e212800() {
    // Encoding: 0x4E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Q = 1 (Max)
    // Fields: Rd=0, Q=1, Rn=0, size=0
    let encoding: u32 = 0x4E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_size_0_min_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field size = 0 (Min)
    // Fields: Rn=0, Rd=0, size=0, Q=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_size_1_poweroftwo_2800_0e612800() {
    // Encoding: 0x0E612800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field size = 1 (PowerOfTwo)
    // Fields: Q=0, size=1, Rd=0, Rn=0
    let encoding: u32 = 0x0E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_size_2_poweroftwo_2800_0ea12800() {
    // Encoding: 0x0EA12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field size = 2 (PowerOfTwo)
    // Fields: Rn=0, size=2, Q=0, Rd=0
    let encoding: u32 = 0x0EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_size_3_max_2800_0ee12800() {
    // Encoding: 0x0EE12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field size = 3 (Max)
    // Fields: Rd=0, Rn=0, size=3, Q=0
    let encoding: u32 = 0x0EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rn_0_min_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rn = 0 (Min)
    // Fields: Rd=0, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rn_1_poweroftwo_2800_0e212820() {
    // Encoding: 0x0E212820
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Q=0, size=0
    let encoding: u32 = 0x0E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rn_30_poweroftwominusone_2800_0e212bc0() {
    // Encoding: 0x0E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rn_31_max_2800_0e212be0() {
    // Encoding: 0x0E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rd=0, size=0
    let encoding: u32 = 0x0E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rd_0_min_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rd = 0 (Min)
    // Fields: size=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rd_1_poweroftwo_2800_0e212801() {
    // Encoding: 0x0E212801
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=1, size=0, Rn=0
    let encoding: u32 = 0x0E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rd_30_poweroftwominusone_2800_0e21281e() {
    // Encoding: 0x0E21281E
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30, size=0, Q=0
    let encoding: u32 = 0x0E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_field_rd_31_max_2800_0e21281f() {
    // Encoding: 0x0E21281F
    // Test aarch64_vector_arithmetic_unary_extract_nosat field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, size=0, Rn=0
    let encoding: u32 = 0x0E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_0_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_1_2800_4e212800() {
    // Encoding: 0x4E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=1, size=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Q=1, Rn=0
    let encoding: u32 = 0x4E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_2_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: size=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_3_2800_0e612800() {
    // Encoding: 0x0E612800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=1, Rn=0, Rd=0
    // Fields: Rn=0, size=1, Rd=0, Q=0
    let encoding: u32 = 0x0E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_4_2800_0ea12800() {
    // Encoding: 0x0EA12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=2, Rn=0, Rd=0
    // Fields: Rd=0, size=2, Q=0, Rn=0
    let encoding: u32 = 0x0EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_5_2800_0ee12800() {
    // Encoding: 0x0EE12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=3, Rn=0, Rd=0
    // Fields: Q=0, size=3, Rd=0, Rn=0
    let encoding: u32 = 0x0EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_6_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_7_2800_0e212820() {
    // Encoding: 0x0E212820
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=1, Rd=0
    // Fields: size=0, Rd=0, Q=0, Rn=1
    let encoding: u32 = 0x0E212820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_8_2800_0e212bc0() {
    // Encoding: 0x0E212BC0
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=30, Rd=0
    // Fields: Rd=0, size=0, Q=0, Rn=30
    let encoding: u32 = 0x0E212BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_9_2800_0e212be0() {
    // Encoding: 0x0E212BE0
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=31, Rd=0
    // Fields: Rn=31, size=0, Rd=0, Q=0
    let encoding: u32 = 0x0E212BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_10_2800_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=0
    // Fields: Rn=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_11_2800_0e212801() {
    // Encoding: 0x0E212801
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=1
    // Fields: Q=0, Rn=0, size=0, Rd=1
    let encoding: u32 = 0x0E212801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_12_2800_0e21281e() {
    // Encoding: 0x0E21281E
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=30
    // Fields: Q=0, Rn=0, size=0, Rd=30
    let encoding: u32 = 0x0E21281E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_13_2800_0e21281f() {
    // Encoding: 0x0E21281F
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=0, Rd=31
    // Fields: size=0, Q=0, Rd=31, Rn=0
    let encoding: u32 = 0x0E21281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_14_2800_0e212821() {
    // Encoding: 0x0E212821
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=1, Rd=1
    // Fields: Rn=1, Rd=1, size=0, Q=0
    let encoding: u32 = 0x0E212821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_combo_15_2800_0e212bff() {
    // Encoding: 0x0E212BFF
    // Test aarch64_vector_arithmetic_unary_extract_nosat field combination: Q=0, size=0, Rn=31, Rd=31
    // Fields: Rn=31, Q=0, Rd=31, size=0
    let encoding: u32 = 0x0E212BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_q_0_size_variant_0_10240_0e612800() {
    // Encoding: 0x0E612800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value Q = 0 (Size variant 0)
    // Fields: size=1, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_q_1_size_variant_1_10240_4e612800() {
    // Encoding: 0x4E612800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value Q = 1 (Size variant 1)
    // Fields: Q=1, size=1, Rd=0, Rn=0
    let encoding: u32 = 0x4E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_size_0_size_variant_0_10240_0e212800() {
    // Encoding: 0x0E212800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x0E212800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_size_1_size_variant_1_10240_0e612800() {
    // Encoding: 0x0E612800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value size = 1 (Size variant 1)
    // Fields: Q=0, Rd=0, size=1, Rn=0
    let encoding: u32 = 0x0E612800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_size_2_size_variant_2_10240_0ea12800() {
    // Encoding: 0x0EA12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value size = 2 (Size variant 2)
    // Fields: Rn=0, Rd=0, size=2, Q=0
    let encoding: u32 = 0x0EA12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_size_3_size_variant_3_10240_0ee12800() {
    // Encoding: 0x0EE12800
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value size = 3 (Size variant 3)
    // Fields: size=3, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EE12800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_rn_31_stack_pointer_sp_may_require_alignment_10240_0e612be0() {
    // Encoding: 0x0E612BE0
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rd=0, size=1, Rn=31
    let encoding: u32 = 0x0E612BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_10240_0e61281f() {
    // Encoding: 0x0E61281F
    // Test aarch64_vector_arithmetic_unary_extract_nosat special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Q=0, Rd=31, size=1
    let encoding: u32 = 0x0E61281F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_sp_rn_0e212be0() {
    // Test aarch64_vector_arithmetic_unary_extract_nosat with Rn = SP (31)
    // Encoding: 0x0E212BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E212BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_extract_nosat
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_extract_nosat_zr_rd_0e21281f() {
    // Test aarch64_vector_arithmetic_unary_extract_nosat with Rd = ZR (31)
    // Encoding: 0x0E21281F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21281F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_u_0_min_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field U = 0 (Min)
    // Fields: U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_u_1_max_c800_7e79c800() {
    // Encoding: 0x7E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field U = 1 (Max)
    // Fields: U=1, Rn=0, Rd=0
    let encoding: u32 = 0x7E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rn_0_min_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rn = 0 (Min)
    // Fields: U=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rn_1_poweroftwo_c800_5e79c820() {
    // Encoding: 0x5E79C820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rn=1, Rd=0
    let encoding: u32 = 0x5E79C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rn_30_poweroftwominusone_c800_5e79cbc0() {
    // Encoding: 0x5E79CBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E79CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rn_31_max_c800_5e79cbe0() {
    // Encoding: 0x5E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rn = 31 (Max)
    // Fields: Rd=0, Rn=31, U=0
    let encoding: u32 = 0x5E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rd_0_min_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rd = 0 (Min)
    // Fields: Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rd_1_poweroftwo_c800_5e79c801() {
    // Encoding: 0x5E79C801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E79C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rd_30_poweroftwominusone_c800_5e79c81e() {
    // Encoding: 0x5E79C81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rd=30, Rn=0
    let encoding: u32 = 0x5E79C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_field_rd_31_max_c800_5e79c81f() {
    // Encoding: 0x5E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field Rd = 31 (Max)
    // Fields: Rn=0, U=0, Rd=31
    let encoding: u32 = 0x5E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_0_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_1_c800_7e79c800() {
    // Encoding: 0x7E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=1, Rn=0, Rd=0
    // Fields: U=1, Rn=0, Rd=0
    let encoding: u32 = 0x7E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_2_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_3_c800_5e79c820() {
    // Encoding: 0x5E79C820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=1, Rd=0
    // Fields: U=0, Rn=1, Rd=0
    let encoding: u32 = 0x5E79C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_4_c800_5e79cbc0() {
    // Encoding: 0x5E79CBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, U=0
    let encoding: u32 = 0x5E79CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_5_c800_5e79cbe0() {
    // Encoding: 0x5E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=31, Rd=0
    // Fields: Rd=0, U=0, Rn=31
    let encoding: u32 = 0x5E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_6_c800_5e79c800() {
    // Encoding: 0x5E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_7_c800_5e79c801() {
    // Encoding: 0x5E79C801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E79C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_8_c800_5e79c81e() {
    // Encoding: 0x5E79C81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, U=0
    let encoding: u32 = 0x5E79C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_9_c800_5e79c81f() {
    // Encoding: 0x5E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, U=0
    let encoding: u32 = 0x5E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_10_c800_5e79c821() {
    // Encoding: 0x5E79C821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=1, Rd=1
    // Fields: U=0, Rn=1, Rd=1
    let encoding: u32 = 0x5E79C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_combo_11_c800_5e79cbff() {
    // Encoding: 0x5E79CBFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd field combination: U=0, Rn=31, Rd=31
    // Fields: Rd=31, U=0, Rn=31
    let encoding: u32 = 0x5E79CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_51200_5e79cbe0() {
    // Encoding: 0x5E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rn=31, Rd=0
    let encoding: u32 = 0x5E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_5e79c81f() {
    // Encoding: 0x5E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, U=0
    let encoding: u32 = 0x5E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_u_0_min_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field U = 0 (Min)
    // Fields: sz=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_u_1_max_c800_7e21c800() {
    // Encoding: 0x7E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field U = 1 (Max)
    // Fields: Rn=0, Rd=0, U=1, sz=0
    let encoding: u32 = 0x7E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_sz_0_min_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field sz = 0 (Min)
    // Fields: Rd=0, U=0, sz=0, Rn=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_sz_1_max_c800_5e61c800() {
    // Encoding: 0x5E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field sz = 1 (Max)
    // Fields: Rn=0, sz=1, U=0, Rd=0
    let encoding: u32 = 0x5E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rn_0_min_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, sz=0, U=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rn_1_poweroftwo_c800_5e21c820() {
    // Encoding: 0x5E21C820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, U=0, Rn=1, sz=0
    let encoding: u32 = 0x5E21C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rn_30_poweroftwominusone_c800_5e21cbc0() {
    // Encoding: 0x5E21CBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, sz=0, Rd=0, U=0
    let encoding: u32 = 0x5E21CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rn_31_max_c800_5e21cbe0() {
    // Encoding: 0x5E21CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rn = 31 (Max)
    // Fields: U=0, Rn=31, sz=0, Rd=0
    let encoding: u32 = 0x5E21CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rd_0_min_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rd = 0 (Min)
    // Fields: U=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rd_1_poweroftwo_c800_5e21c801() {
    // Encoding: 0x5E21C801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, sz=0, U=0
    let encoding: u32 = 0x5E21C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rd_30_poweroftwominusone_c800_5e21c81e() {
    // Encoding: 0x5E21C81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, U=0, sz=0, Rd=30
    let encoding: u32 = 0x5E21C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_field_rd_31_max_c800_5e21c81f() {
    // Encoding: 0x5E21C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field Rd = 31 (Max)
    // Fields: sz=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x5E21C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_0_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_1_c800_7e21c800() {
    // Encoding: 0x7E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=1, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, U=1, Rn=0
    let encoding: u32 = 0x7E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_2_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: U=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_3_c800_5e61c800() {
    // Encoding: 0x5E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=1, Rn=0, Rd=0
    // Fields: Rn=0, sz=1, U=0, Rd=0
    let encoding: u32 = 0x5E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_4_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_5_c800_5e21c820() {
    // Encoding: 0x5E21C820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=1, Rd=0
    // Fields: U=0, Rn=1, Rd=0, sz=0
    let encoding: u32 = 0x5E21C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_6_c800_5e21cbc0() {
    // Encoding: 0x5E21CBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, U=0, sz=0, Rd=0
    let encoding: u32 = 0x5E21CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_7_c800_5e21cbe0() {
    // Encoding: 0x5E21CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=31, Rd=0
    // Fields: Rn=31, U=0, Rd=0, sz=0
    let encoding: u32 = 0x5E21CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_8_c800_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, sz=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_9_c800_5e21c801() {
    // Encoding: 0x5E21C801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=1
    // Fields: U=0, sz=0, Rd=1, Rn=0
    let encoding: u32 = 0x5E21C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_10_c800_5e21c81e() {
    // Encoding: 0x5E21C81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=30
    // Fields: Rd=30, U=0, Rn=0, sz=0
    let encoding: u32 = 0x5E21C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_11_c800_5e21c81f() {
    // Encoding: 0x5E21C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=0, Rd=31
    // Fields: sz=0, Rn=0, U=0, Rd=31
    let encoding: u32 = 0x5E21C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_12_c800_5e21c821() {
    // Encoding: 0x5E21C821
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=1, Rd=1
    // Fields: sz=0, U=0, Rn=1, Rd=1
    let encoding: u32 = 0x5E21C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_combo_13_c800_5e21cbff() {
    // Encoding: 0x5E21CBFF
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd field combination: U=0, sz=0, Rn=31, Rd=31
    // Fields: U=0, sz=0, Rn=31, Rd=31
    let encoding: u32 = 0x5E21CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_special_sz_0_size_variant_0_51200_5e21c800() {
    // Encoding: 0x5E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd special value sz = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, U=0, sz=0
    let encoding: u32 = 0x5E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_special_sz_1_size_variant_1_51200_5e61c800() {
    // Encoding: 0x5E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_51200_5e61cbe0() {
    // Encoding: 0x5E61CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, Rn=31, Rd=0, U=0
    let encoding: u32 = 0x5E61CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_5e61c81f() {
    // Encoding: 0x5E61C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, U=0, sz=1, Rn=0
    let encoding: u32 = 0x5E61C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_q_0_min_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Q = 0 (Min)
    // Fields: Rn=0, Q=0, U=0, Rd=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_q_1_max_c800_4e79c800() {
    // Encoding: 0x4E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Q = 1 (Max)
    // Fields: Rn=0, U=0, Rd=0, Q=1
    let encoding: u32 = 0x4E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_u_0_min_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field U = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_u_1_max_c800_2e79c800() {
    // Encoding: 0x2E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field U = 1 (Max)
    // Fields: Q=0, Rd=0, U=1, Rn=0
    let encoding: u32 = 0x2E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rn_0_min_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rn = 0 (Min)
    // Fields: Q=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rn_1_poweroftwo_c800_0e79c820() {
    // Encoding: 0x0E79C820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E79C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rn_30_poweroftwominusone_c800_0e79cbc0() {
    // Encoding: 0x0E79CBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=30, Rd=0, U=0
    let encoding: u32 = 0x0E79CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rn_31_max_c800_0e79cbe0() {
    // Encoding: 0x0E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rn = 31 (Max)
    // Fields: Q=0, Rd=0, U=0, Rn=31
    let encoding: u32 = 0x0E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rd_0_min_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rd = 0 (Min)
    // Fields: U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rd_1_poweroftwo_c800_0e79c801() {
    // Encoding: 0x0E79C801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, Q=0, Rd=1
    let encoding: u32 = 0x0E79C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rd_30_poweroftwominusone_c800_0e79c81e() {
    // Encoding: 0x0E79C81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E79C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_field_rd_31_max_c800_0e79c81f() {
    // Encoding: 0x0E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x0E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_0_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_1_c800_4e79c800() {
    // Encoding: 0x4E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=1, U=0, Rn=0, Rd=0
    // Fields: Q=1, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x4E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_2_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_3_c800_2e79c800() {
    // Encoding: 0x2E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=1, Rn=0, Rd=0
    // Fields: U=1, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x2E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_4_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_5_c800_0e79c820() {
    // Encoding: 0x0E79C820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=1, Rd=0
    // Fields: Rd=0, Q=0, U=0, Rn=1
    let encoding: u32 = 0x0E79C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_6_c800_0e79cbc0() {
    // Encoding: 0x0E79CBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, U=0, Q=0
    let encoding: u32 = 0x0E79CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_7_c800_0e79cbe0() {
    // Encoding: 0x0E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=31, Rd=0
    // Fields: Q=0, Rd=0, Rn=31, U=0
    let encoding: u32 = 0x0E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_8_c800_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_9_c800_0e79c801() {
    // Encoding: 0x0E79C801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=1
    // Fields: Q=0, U=0, Rn=0, Rd=1
    let encoding: u32 = 0x0E79C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_10_c800_0e79c81e() {
    // Encoding: 0x0E79C81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=30
    // Fields: U=0, Rd=30, Rn=0, Q=0
    let encoding: u32 = 0x0E79C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_11_c800_0e79c81f() {
    // Encoding: 0x0E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=0, Rd=31
    // Fields: Q=0, U=0, Rd=31, Rn=0
    let encoding: u32 = 0x0E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_12_c800_0e79c821() {
    // Encoding: 0x0E79C821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=1, Rd=1
    // Fields: Rd=1, Rn=1, U=0, Q=0
    let encoding: u32 = 0x0E79C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_combo_13_c800_0e79cbff() {
    // Encoding: 0x0E79CBFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd field combination: Q=0, U=0, Rn=31, Rd=31
    // Fields: U=0, Rn=31, Rd=31, Q=0
    let encoding: u32 = 0x0E79CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_special_q_0_size_variant_0_51200_0e79c800() {
    // Encoding: 0x0E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd special value Q = 0 (Size variant 0)
    // Fields: U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_special_q_1_size_variant_1_51200_4e79c800() {
    // Encoding: 0x4E79C800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd special value Q = 1 (Size variant 1)
    // Fields: U=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x4E79C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_special_rn_31_stack_pointer_sp_may_require_alignment_51200_0e79cbe0() {
    // Encoding: 0x0E79CBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rn=31, Rd=0, U=0
    let encoding: u32 = 0x0E79CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_0e79c81f() {
    // Encoding: 0x0E79C81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Q=0, U=0
    let encoding: u32 = 0x0E79C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_q_0_min_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Q = 0 (Min)
    // Fields: Q=0, Rd=0, U=0, Rn=0, sz=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_q_1_max_c800_4e21c800() {
    // Encoding: 0x4E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Q = 1 (Max)
    // Fields: Q=1, U=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x4E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_u_0_min_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field U = 0 (Min)
    // Fields: Q=0, U=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_u_1_max_c800_2e21c800() {
    // Encoding: 0x2E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field U = 1 (Max)
    // Fields: Q=0, Rd=0, U=1, sz=0, Rn=0
    let encoding: u32 = 0x2E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_sz_0_min_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field sz = 0 (Min)
    // Fields: Q=0, U=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_sz_1_max_c800_0e61c800() {
    // Encoding: 0x0E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field sz = 1 (Max)
    // Fields: Rn=0, Rd=0, U=0, sz=1, Q=0
    let encoding: u32 = 0x0E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rn_0_min_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rn = 0 (Min)
    // Fields: sz=0, Rd=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rn_1_poweroftwo_c800_0e21c820() {
    // Encoding: 0x0E21C820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rn = 1 (PowerOfTwo)
    // Fields: U=0, sz=0, Rd=0, Rn=1, Q=0
    let encoding: u32 = 0x0E21C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rn_30_poweroftwominusone_c800_0e21cbc0() {
    // Encoding: 0x0E21CBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E21CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rn_31_max_c800_0e21cbe0() {
    // Encoding: 0x0E21CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rn = 31 (Max)
    // Fields: U=0, sz=0, Rn=31, Rd=0, Q=0
    let encoding: u32 = 0x0E21CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rd_0_min_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rd = 0 (Min)
    // Fields: Q=0, Rd=0, sz=0, Rn=0, U=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rd_1_poweroftwo_c800_0e21c801() {
    // Encoding: 0x0E21C801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Q=0, U=0, sz=0, Rd=1
    let encoding: u32 = 0x0E21C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rd_30_poweroftwominusone_c800_0e21c81e() {
    // Encoding: 0x0E21C81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0E21C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_field_rd_31_max_c800_0e21c81f() {
    // Encoding: 0x0E21C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field Rd = 31 (Max)
    // Fields: Rd=31, U=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0E21C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_0_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_1_c800_4e21c800() {
    // Encoding: 0x4E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=1, U=0, sz=0, Rn=0, Rd=0
    // Fields: Q=1, U=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x4E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_2_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_3_c800_2e21c800() {
    // Encoding: 0x2E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=1, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, U=1, Q=0, Rd=0
    let encoding: u32 = 0x2E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_4_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Q=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_5_c800_0e61c800() {
    // Encoding: 0x0E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=1, Rn=0, Rd=0
    // Fields: U=0, Q=0, sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_6_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, U=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_7_c800_0e21c820() {
    // Encoding: 0x0E21C820
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rn=1, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_8_c800_0e21cbc0() {
    // Encoding: 0x0E21CBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=30, Rd=0
    // Fields: U=0, Q=0, Rd=0, Rn=30, sz=0
    let encoding: u32 = 0x0E21CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_9_c800_0e21cbe0() {
    // Encoding: 0x0E21CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, Q=0, sz=0, U=0
    let encoding: u32 = 0x0E21CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_10_c800_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, sz=0, Q=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_11_c800_0e21c801() {
    // Encoding: 0x0E21C801
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=1
    // Fields: Q=0, sz=0, U=0, Rd=1, Rn=0
    let encoding: u32 = 0x0E21C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_12_c800_0e21c81e() {
    // Encoding: 0x0E21C81E
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=30
    // Fields: U=0, sz=0, Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E21C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_13_c800_0e21c81f() {
    // Encoding: 0x0E21C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=31
    // Fields: Q=0, Rn=0, Rd=31, sz=0, U=0
    let encoding: u32 = 0x0E21C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_14_c800_0e21c821() {
    // Encoding: 0x0E21C821
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=1, Rd=1
    // Fields: Rn=1, U=0, Q=0, sz=0, Rd=1
    let encoding: u32 = 0x0E21C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_combo_15_c800_0e21cbff() {
    // Encoding: 0x0E21CBFF
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd field combination: Q=0, U=0, sz=0, Rn=31, Rd=31
    // Fields: sz=0, Rd=31, Rn=31, Q=0, U=0
    let encoding: u32 = 0x0E21CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_q_0_size_variant_0_51200_0e61c800() {
    // Encoding: 0x0E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, sz=1, Rd=0, U=0
    let encoding: u32 = 0x0E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_q_1_size_variant_1_51200_4e61c800() {
    // Encoding: 0x4E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value Q = 1 (Size variant 1)
    // Fields: sz=1, Q=1, Rd=0, Rn=0, U=0
    let encoding: u32 = 0x4E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_sz_0_size_variant_0_51200_0e21c800() {
    // Encoding: 0x0E21C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value sz = 0 (Size variant 0)
    // Fields: Q=0, U=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_sz_1_size_variant_1_51200_0e61c800() {
    // Encoding: 0x0E61C800
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value sz = 1 (Size variant 1)
    // Fields: Q=0, Rd=0, sz=1, Rn=0, U=0
    let encoding: u32 = 0x0E61C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_rn_31_stack_pointer_sp_may_require_alignment_51200_0e61cbe0() {
    // Encoding: 0x0E61CBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, sz=1, U=0, Rd=0, Rn=31
    let encoding: u32 = 0x0E61CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_0e61c81f() {
    // Encoding: 0x0E61C81F
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Q=0, U=0, sz=1, Rn=0
    let encoding: u32 = 0x0E61C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_reg_write_0_5e79c800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd register write: SimdFromField("d")
    // Encoding: 0x5E79C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_sp_rn_5e79cbe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd with Rn = SP (31)
    // Encoding: 0x5E79CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd_zr_rd_5e79c81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd with Rd = ZR (31)
    // Encoding: 0x5E79C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_reg_write_0_5e21c800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd register write: SimdFromField("d")
    // Encoding: 0x5E21C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_sp_rn_5e21cbe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd with Rn = SP (31)
    // Encoding: 0x5E21CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd_zr_rd_5e21c81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_sisd with Rd = ZR (31)
    // Encoding: 0x5E21C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_reg_write_0_0e79c800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd register write: SimdFromField("d")
    // Encoding: 0x0E79C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_sp_rn_0e79cbe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd with Rn = SP (31)
    // Encoding: 0x0E79CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd_zr_rd_0e79c81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_float_tieaway_simd with Rd = ZR (31)
    // Encoding: 0x0E79C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_reg_write_0_0e21c800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd register write: SimdFromField("d")
    // Encoding: 0x0E21C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_sp_rn_0e21cbe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd with Rn = SP (31)
    // Encoding: 0x0E21CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd_zr_rd_0e21c81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_float_tieaway_simd with Rd = ZR (31)
    // Encoding: 0x0E21C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_sqrt_est_int Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_q_0_min_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Q = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_q_1_max_c800_6ea1c800() {
    // Encoding: 0x6EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Q = 1 (Max)
    // Fields: Q=1, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x6EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_sz_0_min_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field sz = 0 (Min)
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_sz_1_max_c800_2ee1c800() {
    // Encoding: 0x2EE1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, Q=0, sz=1
    let encoding: u32 = 0x2EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rn_0_min_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rn_1_poweroftwo_c800_2ea1c820() {
    // Encoding: 0x2EA1C820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, sz=0, Rn=1, Q=0
    let encoding: u32 = 0x2EA1C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rn_30_poweroftwominusone_c800_2ea1cbc0() {
    // Encoding: 0x2EA1CBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x2EA1CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rn_31_max_c800_2ea1cbe0() {
    // Encoding: 0x2EA1CBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rn = 31 (Max)
    // Fields: sz=0, Rd=0, Q=0, Rn=31
    let encoding: u32 = 0x2EA1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rd_0_min_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rd = 0 (Min)
    // Fields: Rn=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rd_1_poweroftwo_c800_2ea1c801() {
    // Encoding: 0x2EA1C801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, sz=0, Rn=0, Q=0
    let encoding: u32 = 0x2EA1C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rd_30_poweroftwominusone_c800_2ea1c81e() {
    // Encoding: 0x2EA1C81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=30, Q=0, Rn=0
    let encoding: u32 = 0x2EA1C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_field_rd_31_max_c800_2ea1c81f() {
    // Encoding: 0x2EA1C81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field Rd = 31 (Max)
    // Fields: Q=0, sz=0, Rd=31, Rn=0
    let encoding: u32 = 0x2EA1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_0_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_1_c800_6ea1c800() {
    // Encoding: 0x6EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, Rd=0, Q=1
    let encoding: u32 = 0x6EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_2_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_3_c800_2ee1c800() {
    // Encoding: 0x2EE1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, sz=1
    let encoding: u32 = 0x2EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_4_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_5_c800_2ea1c820() {
    // Encoding: 0x2EA1C820
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Rd=0, sz=0, Rn=1, Q=0
    let encoding: u32 = 0x2EA1C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_6_c800_2ea1cbc0() {
    // Encoding: 0x2EA1CBC0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Q=0, Rd=0, sz=0, Rn=30
    let encoding: u32 = 0x2EA1CBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_7_c800_2ea1cbe0() {
    // Encoding: 0x2EA1CBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Rn=31, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_8_c800_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_9_c800_2ea1c801() {
    // Encoding: 0x2EA1C801
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Q=0, sz=0, Rn=0, Rd=1
    let encoding: u32 = 0x2EA1C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_10_c800_2ea1c81e() {
    // Encoding: 0x2EA1C81E
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rn=0, Q=0, Rd=30
    let encoding: u32 = 0x2EA1C81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_11_c800_2ea1c81f() {
    // Encoding: 0x2EA1C81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Q=0, Rn=0, Rd=31, sz=0
    let encoding: u32 = 0x2EA1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_12_c800_2ea1c821() {
    // Encoding: 0x2EA1C821
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, sz=0, Rd=1
    let encoding: u32 = 0x2EA1C821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_combo_13_c800_2ea1cbff() {
    // Encoding: 0x2EA1CBFF
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Q=0, Rd=31, sz=0, Rn=31
    let encoding: u32 = 0x2EA1CBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_q_0_size_variant_0_51200_2ee1c800() {
    // Encoding: 0x2EE1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Q=0, Rd=0, sz=1
    let encoding: u32 = 0x2EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_q_1_size_variant_1_51200_6ee1c800() {
    // Encoding: 0x6EE1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Q=1, sz=1
    let encoding: u32 = 0x6EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_sz_0_size_variant_0_51200_2ea1c800() {
    // Encoding: 0x2EA1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value sz = 0 (Size variant 0)
    // Fields: Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x2EA1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_sz_1_size_variant_1_51200_2ee1c800() {
    // Encoding: 0x2EE1C800
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value sz = 1 (Size variant 1)
    // Fields: Rd=0, sz=1, Q=0, Rn=0
    let encoding: u32 = 0x2EE1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_rn_31_stack_pointer_sp_may_require_alignment_51200_2ee1cbe0() {
    // Encoding: 0x2EE1CBE0
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rn=31, sz=1, Rd=0
    let encoding: u32 = 0x2EE1CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_51200_2ee1c81f() {
    // Encoding: 0x2EE1C81F
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x2EE1C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_reg_write_0_2ea1c800() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int register write: SimdFromField("d")
    // Encoding: 0x2EA1C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_sp_rn_2ea1cbe0() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int with Rn = SP (31)
    // Encoding: 0x2EA1CBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1CBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_sqrt_est_int
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_sqrt_est_int_zr_rd_2ea1c81f() {
    // Test aarch64_vector_arithmetic_unary_special_sqrt_est_int with Rd = ZR (31)
    // Encoding: 0x2EA1C81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2EA1C81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_fp16_conv_int_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_u_0_min_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field U = 0 (Min)
    // Fields: Rd=0, Rn=0, U=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_u_1_max_d800_7e79d800() {
    // Encoding: 0x7E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field U = 1 (Max)
    // Fields: U=1, Rd=0, Rn=0
    let encoding: u32 = 0x7E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rn_0_min_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rn = 0 (Min)
    // Fields: Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rn_1_poweroftwo_d800_5e79d820() {
    // Encoding: 0x5E79D820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, U=0, Rd=0
    let encoding: u32 = 0x5E79D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rn_30_poweroftwominusone_d800_5e79dbc0() {
    // Encoding: 0x5E79DBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rd=0, Rn=30
    let encoding: u32 = 0x5E79DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rn_31_max_d800_5e79dbe0() {
    // Encoding: 0x5E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, U=0
    let encoding: u32 = 0x5E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rd_0_min_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rd = 0 (Min)
    // Fields: U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rd_1_poweroftwo_d800_5e79d801() {
    // Encoding: 0x5E79D801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E79D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rd_30_poweroftwominusone_d800_5e79d81e() {
    // Encoding: 0x5E79D81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, Rn=0
    let encoding: u32 = 0x5E79D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_field_rd_31_max_d800_5e79d81f() {
    // Encoding: 0x5E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field Rd = 31 (Max)
    // Fields: U=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_0_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_1_d800_7e79d800() {
    // Encoding: 0x7E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=1, Rn=0, Rd=0
    // Fields: U=1, Rd=0, Rn=0
    let encoding: u32 = 0x7E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_2_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_3_d800_5e79d820() {
    // Encoding: 0x5E79D820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=1, Rd=0
    // Fields: Rd=0, U=0, Rn=1
    let encoding: u32 = 0x5E79D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_4_d800_5e79dbc0() {
    // Encoding: 0x5E79DBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, U=0
    let encoding: u32 = 0x5E79DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_5_d800_5e79dbe0() {
    // Encoding: 0x5E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=31, Rd=0
    // Fields: U=0, Rd=0, Rn=31
    let encoding: u32 = 0x5E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_6_d800_5e79d800() {
    // Encoding: 0x5E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=0
    // Fields: Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_7_d800_5e79d801() {
    // Encoding: 0x5E79D801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=1
    // Fields: U=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E79D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_8_d800_5e79d81e() {
    // Encoding: 0x5E79D81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, U=0
    let encoding: u32 = 0x5E79D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_9_d800_5e79d81f() {
    // Encoding: 0x5E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, U=0
    let encoding: u32 = 0x5E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_10_d800_5e79d821() {
    // Encoding: 0x5E79D821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=1, Rd=1
    // Fields: U=0, Rn=1, Rd=1
    let encoding: u32 = 0x5E79D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_combo_11_d800_5e79dbff() {
    // Encoding: 0x5E79DBFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd field combination: U=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, U=0
    let encoding: u32 = 0x5E79DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_5e79dbe0() {
    // Encoding: 0x5E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Rn=31, U=0
    let encoding: u32 = 0x5E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_5e79d81f() {
    // Encoding: 0x5E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, U=0, Rd=31
    let encoding: u32 = 0x5E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_u_0_min_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field U = 0 (Min)
    // Fields: Rd=0, sz=0, U=0, Rn=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_u_1_max_d800_7e21d800() {
    // Encoding: 0x7E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field U = 1 (Max)
    // Fields: Rn=0, U=1, sz=0, Rd=0
    let encoding: u32 = 0x7E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_sz_0_min_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field sz = 0 (Min)
    // Fields: sz=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_sz_1_max_d800_5e61d800() {
    // Encoding: 0x5E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field sz = 1 (Max)
    // Fields: sz=1, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rn_0_min_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rn = 0 (Min)
    // Fields: Rn=0, sz=0, U=0, Rd=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rn_1_poweroftwo_d800_5e21d820() {
    // Encoding: 0x5E21D820
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rn=1, sz=0, Rd=0
    let encoding: u32 = 0x5E21D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rn_30_poweroftwominusone_d800_5e21dbc0() {
    // Encoding: 0x5E21DBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=30, U=0, sz=0
    let encoding: u32 = 0x5E21DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rn_31_max_d800_5e21dbe0() {
    // Encoding: 0x5E21DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rn = 31 (Max)
    // Fields: sz=0, U=0, Rn=31, Rd=0
    let encoding: u32 = 0x5E21DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rd_0_min_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, U=0, sz=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rd_1_poweroftwo_d800_5e21d801() {
    // Encoding: 0x5E21D801
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, U=0, sz=0, Rn=0
    let encoding: u32 = 0x5E21D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rd_30_poweroftwominusone_d800_5e21d81e() {
    // Encoding: 0x5E21D81E
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, sz=0, Rn=0, Rd=30
    let encoding: u32 = 0x5E21D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_field_rd_31_max_d800_5e21d81f() {
    // Encoding: 0x5E21D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field Rd = 31 (Max)
    // Fields: U=0, Rn=0, Rd=31, sz=0
    let encoding: u32 = 0x5E21D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_0_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: U=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_1_d800_7e21d800() {
    // Encoding: 0x7E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=1, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=1, sz=0
    let encoding: u32 = 0x7E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_2_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_3_d800_5e61d800() {
    // Encoding: 0x5E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=1, Rn=0, Rd=0
    // Fields: U=0, Rn=0, sz=1, Rd=0
    let encoding: u32 = 0x5E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_4_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_5_d800_5e21d820() {
    // Encoding: 0x5E21D820
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=1, Rd=0
    // Fields: Rn=1, sz=0, U=0, Rd=0
    let encoding: u32 = 0x5E21D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_6_d800_5e21dbc0() {
    // Encoding: 0x5E21DBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=30, Rd=0
    // Fields: U=0, Rn=30, Rd=0, sz=0
    let encoding: u32 = 0x5E21DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_7_d800_5e21dbe0() {
    // Encoding: 0x5E21DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=31, Rd=0
    // Fields: U=0, Rn=31, Rd=0, sz=0
    let encoding: u32 = 0x5E21DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_8_d800_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, sz=0, U=0, Rd=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_9_d800_5e21d801() {
    // Encoding: 0x5E21D801
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=1
    // Fields: Rn=0, U=0, Rd=1, sz=0
    let encoding: u32 = 0x5E21D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_10_d800_5e21d81e() {
    // Encoding: 0x5E21D81E
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=30
    // Fields: Rn=0, Rd=30, U=0, sz=0
    let encoding: u32 = 0x5E21D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_11_d800_5e21d81f() {
    // Encoding: 0x5E21D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=0, Rd=31
    // Fields: Rn=0, sz=0, Rd=31, U=0
    let encoding: u32 = 0x5E21D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_12_d800_5e21d821() {
    // Encoding: 0x5E21D821
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=1, Rd=1
    // Fields: U=0, sz=0, Rn=1, Rd=1
    let encoding: u32 = 0x5E21D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_combo_13_d800_5e21dbff() {
    // Encoding: 0x5E21DBFF
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd field combination: U=0, sz=0, Rn=31, Rd=31
    // Fields: Rn=31, sz=0, Rd=31, U=0
    let encoding: u32 = 0x5E21DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_special_sz_0_size_variant_0_55296_5e21d800() {
    // Encoding: 0x5E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd special value sz = 0 (Size variant 0)
    // Fields: Rn=0, U=0, Rd=0, sz=0
    let encoding: u32 = 0x5E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_special_sz_1_size_variant_1_55296_5e61d800() {
    // Encoding: 0x5E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x5E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_5e61dbe0() {
    // Encoding: 0x5E61DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, U=0, Rn=31, Rd=0
    let encoding: u32 = 0x5E61DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_5e61d81f() {
    // Encoding: 0x5E61D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, Rn=0, sz=1, Rd=31
    let encoding: u32 = 0x5E61D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_q_0_min_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Q = 0 (Min)
    // Fields: Rn=0, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_q_1_max_d800_4e79d800() {
    // Encoding: 0x4E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Q = 1 (Max)
    // Fields: Rn=0, Q=1, U=0, Rd=0
    let encoding: u32 = 0x4E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_u_0_min_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field U = 0 (Min)
    // Fields: Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_u_1_max_d800_2e79d800() {
    // Encoding: 0x2E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field U = 1 (Max)
    // Fields: U=1, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rn_0_min_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rn = 0 (Min)
    // Fields: Rn=0, Q=0, Rd=0, U=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rn_1_poweroftwo_d800_0e79d820() {
    // Encoding: 0x0E79D820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, U=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E79D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rn_30_poweroftwominusone_d800_0e79dbc0() {
    // Encoding: 0x0E79DBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, U=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E79DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rn_31_max_d800_0e79dbe0() {
    // Encoding: 0x0E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rd=0, U=0
    let encoding: u32 = 0x0E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rd_0_min_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rd = 0 (Min)
    // Fields: U=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rd_1_poweroftwo_d800_0e79d801() {
    // Encoding: 0x0E79D801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rd=1, U=0
    let encoding: u32 = 0x0E79D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rd_30_poweroftwominusone_d800_0e79d81e() {
    // Encoding: 0x0E79D81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E79D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_field_rd_31_max_d800_0e79d81f() {
    // Encoding: 0x0E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field Rd = 31 (Max)
    // Fields: Q=0, Rd=31, Rn=0, U=0
    let encoding: u32 = 0x0E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_0_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_1_d800_4e79d800() {
    // Encoding: 0x4E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=1, U=0, Rn=0, Rd=0
    // Fields: U=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x4E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_2_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: U=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_3_d800_2e79d800() {
    // Encoding: 0x2E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, U=1
    let encoding: u32 = 0x2E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_4_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_5_d800_0e79d820() {
    // Encoding: 0x0E79D820
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=1, Rd=0
    // Fields: Q=0, Rd=0, Rn=1, U=0
    let encoding: u32 = 0x0E79D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_6_d800_0e79dbc0() {
    // Encoding: 0x0E79DBC0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=30, Rd=0
    // Fields: Rd=0, Q=0, Rn=30, U=0
    let encoding: u32 = 0x0E79DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_7_d800_0e79dbe0() {
    // Encoding: 0x0E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=31, Rd=0
    // Fields: Rd=0, Rn=31, U=0, Q=0
    let encoding: u32 = 0x0E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_8_d800_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_9_d800_0e79d801() {
    // Encoding: 0x0E79D801
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=1
    // Fields: Q=0, Rn=0, U=0, Rd=1
    let encoding: u32 = 0x0E79D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_10_d800_0e79d81e() {
    // Encoding: 0x0E79D81E
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=30
    // Fields: U=0, Q=0, Rd=30, Rn=0
    let encoding: u32 = 0x0E79D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_11_d800_0e79d81f() {
    // Encoding: 0x0E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=0, Rd=31
    // Fields: U=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_12_d800_0e79d821() {
    // Encoding: 0x0E79D821
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=1, Rd=1
    // Fields: Q=0, U=0, Rn=1, Rd=1
    let encoding: u32 = 0x0E79D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_combo_13_d800_0e79dbff() {
    // Encoding: 0x0E79DBFF
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd field combination: Q=0, U=0, Rn=31, Rd=31
    // Fields: Rn=31, Rd=31, Q=0, U=0
    let encoding: u32 = 0x0E79DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_special_q_0_size_variant_0_55296_0e79d800() {
    // Encoding: 0x0E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_special_q_1_size_variant_1_55296_4e79d800() {
    // Encoding: 0x4E79D800
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x4E79D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_0e79dbe0() {
    // Encoding: 0x0E79DBE0
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E79DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_0e79d81f() {
    // Encoding: 0x0E79D81F
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E79D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_q_0_min_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Q = 0 (Min)
    // Fields: U=0, Q=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_q_1_max_d800_4e21d800() {
    // Encoding: 0x4E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Q = 1 (Max)
    // Fields: sz=0, U=0, Q=1, Rn=0, Rd=0
    let encoding: u32 = 0x4E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_u_0_min_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field U = 0 (Min)
    // Fields: U=0, Rn=0, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_u_1_max_d800_2e21d800() {
    // Encoding: 0x2E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field U = 1 (Max)
    // Fields: Q=0, sz=0, Rn=0, U=1, Rd=0
    let encoding: u32 = 0x2E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_sz_0_min_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field sz = 0 (Min)
    // Fields: sz=0, U=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_sz_1_max_d800_0e61d800() {
    // Encoding: 0x0E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field sz = 1 (Max)
    // Fields: Rd=0, Q=0, U=0, sz=1, Rn=0
    let encoding: u32 = 0x0E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rn_0_min_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rn = 0 (Min)
    // Fields: Rd=0, Q=0, sz=0, U=0, Rn=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rn_1_poweroftwo_d800_0e21d820() {
    // Encoding: 0x0E21D820
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, U=0, Q=0, sz=0
    let encoding: u32 = 0x0E21D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rn_30_poweroftwominusone_d800_0e21dbc0() {
    // Encoding: 0x0E21DBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Q=0, U=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E21DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rn_31_max_d800_0e21dbe0() {
    // Encoding: 0x0E21DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rn = 31 (Max)
    // Fields: Q=0, U=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E21DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rd_0_min_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rd = 0 (Min)
    // Fields: U=0, Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rd_1_poweroftwo_d800_0e21d801() {
    // Encoding: 0x0E21D801
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=1, sz=0, Rn=0, U=0
    let encoding: u32 = 0x0E21D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rd_30_poweroftwominusone_d800_0e21d81e() {
    // Encoding: 0x0E21D81E
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, U=0, sz=0, Rn=0
    let encoding: u32 = 0x0E21D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_field_rd_31_max_d800_0e21d81f() {
    // Encoding: 0x0E21D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field Rd = 31 (Max)
    // Fields: Rn=0, U=0, sz=0, Q=0, Rd=31
    let encoding: u32 = 0x0E21D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_0_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_1_d800_4e21d800() {
    // Encoding: 0x4E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=1, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, U=0, Rd=0, Q=1, sz=0
    let encoding: u32 = 0x4E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_2_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=1 (maximum value (1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_3_d800_2e21d800() {
    // Encoding: 0x2E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=1, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Q=0, U=1
    let encoding: u32 = 0x2E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_4_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, U=0, Q=0, sz=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_5_d800_0e61d800() {
    // Encoding: 0x0E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=1, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0, sz=1, U=0
    let encoding: u32 = 0x0E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_6_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: U=0, sz=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_7_d800_0e21d820() {
    // Encoding: 0x0E21D820
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=1, Rd=0
    // Fields: U=0, Rn=1, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x0E21D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_8_d800_0e21dbc0() {
    // Encoding: 0x0E21DBC0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=30, Rd=0
    // Fields: U=0, Q=0, sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E21DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_9_d800_0e21dbe0() {
    // Encoding: 0x0E21DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, Q=0, sz=0, U=0
    let encoding: u32 = 0x0E21DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_10_d800_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=0
    // Fields: U=0, sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_11_d800_0e21d801() {
    // Encoding: 0x0E21D801
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=1
    // Fields: Rd=1, Rn=0, Q=0, sz=0, U=0
    let encoding: u32 = 0x0E21D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_12_d800_0e21d81e() {
    // Encoding: 0x0E21D81E
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rd=30, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E21D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_13_d800_0e21d81f() {
    // Encoding: 0x0E21D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=0, Rd=31
    // Fields: Q=0, Rd=31, Rn=0, U=0, sz=0
    let encoding: u32 = 0x0E21D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_14_d800_0e21d821() {
    // Encoding: 0x0E21D821
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=1, Rd=1
    // Fields: Rd=1, Rn=1, sz=0, Q=0, U=0
    let encoding: u32 = 0x0E21D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_combo_15_d800_0e21dbff() {
    // Encoding: 0x0E21DBFF
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd field combination: Q=0, U=0, sz=0, Rn=31, Rd=31
    // Fields: Rd=31, Q=0, sz=0, Rn=31, U=0
    let encoding: u32 = 0x0E21DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_q_0_size_variant_0_55296_0e61d800() {
    // Encoding: 0x0E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, U=0, Q=0, sz=1
    let encoding: u32 = 0x0E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_q_1_size_variant_1_55296_4e61d800() {
    // Encoding: 0x4E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rd=0, sz=1, Rn=0, U=0
    let encoding: u32 = 0x4E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_sz_0_size_variant_0_55296_0e21d800() {
    // Encoding: 0x0E21D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value sz = 0 (Size variant 0)
    // Fields: U=0, sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_sz_1_size_variant_1_55296_0e61d800() {
    // Encoding: 0x0E61D800
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E61D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_0e61dbe0() {
    // Encoding: 0x0E61DBE0
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, Q=0, U=0, sz=1
    let encoding: u32 = 0x0E61DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_0e61d81f() {
    // Encoding: 0x0E61D81F
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, sz=1, Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0E61D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_reg_write_0_5e79d800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd register write: SimdFromField("d")
    // Encoding: 0x5E79D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_sp_rn_5e79dbe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd with Rn = SP (31)
    // Encoding: 0x5E79DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_sisd_zr_rd_5e79d81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_sisd with Rd = ZR (31)
    // Encoding: 0x5E79D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E79D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_reg_write_0_5e21d800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd register write: SimdFromField("d")
    // Encoding: 0x5E21D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_sp_rn_5e21dbe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd with Rn = SP (31)
    // Encoding: 0x5E21DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_sisd_zr_rd_5e21d81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_sisd with Rd = ZR (31)
    // Encoding: 0x5E21D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E21D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_reg_write_0_0e79d800() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd register write: SimdFromField("d")
    // Encoding: 0x0E79D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_sp_rn_0e79dbe0() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd with Rn = SP (31)
    // Encoding: 0x0E79DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_fp16_conv_int_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_fp16_conv_int_simd_zr_rd_0e79d81f() {
    // Test aarch64_vector_arithmetic_unary_fp16_conv_int_simd with Rd = ZR (31)
    // Encoding: 0x0E79D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E79D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_reg_write_0_0e21d800() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd register write: SimdFromField("d")
    // Encoding: 0x0E21D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_sp_rn_0e21dbe0() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd with Rn = SP (31)
    // Encoding: 0x0E21DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_conv_int_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_conv_int_simd_zr_rd_0e21d81f() {
    // Test aarch64_vector_arithmetic_unary_float_conv_int_simd with Rd = ZR (31)
    // Encoding: 0x0E21D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rm_0_min_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rm = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rm_1_poweroftwo_3c00_5e413c00() {
    // Encoding: 0x5E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Rd=0
    let encoding: u32 = 0x5E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rm_30_poweroftwominusone_3c00_5e5e3c00() {
    // Encoding: 0x5E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Rd=0
    let encoding: u32 = 0x5E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rm_31_max_3c00_5e5f3c00() {
    // Encoding: 0x5E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Rd=0
    let encoding: u32 = 0x5E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rn_0_min_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rn_1_poweroftwo_3c00_5e403c20() {
    // Encoding: 0x5E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Rm=0
    let encoding: u32 = 0x5E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rn_30_poweroftwominusone_3c00_5e403fc0() {
    // Encoding: 0x5E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rn_31_max_3c00_5e403fe0() {
    // Encoding: 0x5E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rn = 31 (Max)
    // Fields: Rd=0, Rm=0, Rn=31
    let encoding: u32 = 0x5E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rd_0_min_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rd_1_poweroftwo_3c00_5e403c01() {
    // Encoding: 0x5E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rm=0, Rn=0
    let encoding: u32 = 0x5E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rd_30_poweroftwominusone_3c00_5e403c1e() {
    // Encoding: 0x5E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rm=0, Rn=0
    let encoding: u32 = 0x5E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_field_rd_31_max_3c00_5e403c1f() {
    // Encoding: 0x5E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rm=0, Rd=31
    let encoding: u32 = 0x5E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_0_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_1_3c00_5e413c00() {
    // Encoding: 0x5E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=1, Rn=0, Rd=0
    // Fields: Rm=1, Rn=0, Rd=0
    let encoding: u32 = 0x5E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_2_3c00_5e5e3c00() {
    // Encoding: 0x5E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=30, Rn=0, Rd=0
    // Fields: Rd=0, Rm=30, Rn=0
    let encoding: u32 = 0x5E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_3_3c00_5e5f3c00() {
    // Encoding: 0x5E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=31, Rn=0, Rd=0
    // Fields: Rm=31, Rn=0, Rd=0
    let encoding: u32 = 0x5E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_4_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_5_3c00_5e403c20() {
    // Encoding: 0x5E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=1, Rd=0
    // Fields: Rm=0, Rn=1, Rd=0
    let encoding: u32 = 0x5E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_6_3c00_5e403fc0() {
    // Encoding: 0x5E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=30, Rd=0
    // Fields: Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_7_3c00_5e403fe0() {
    // Encoding: 0x5E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Rd=0, Rn=31
    let encoding: u32 = 0x5E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_8_3c00_5e403c00() {
    // Encoding: 0x5E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_9_3c00_5e403c01() {
    // Encoding: 0x5E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, Rm=0
    let encoding: u32 = 0x5E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_10_3c00_5e403c1e() {
    // Encoding: 0x5E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=30
    // Fields: Rd=30, Rm=0, Rn=0
    let encoding: u32 = 0x5E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_11_3c00_5e403c1f() {
    // Encoding: 0x5E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_12_3c00_5e413c20() {
    // Encoding: 0x5E413C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=1, Rn=1, Rd=0
    // Fields: Rn=1, Rm=1, Rd=0
    let encoding: u32 = 0x5E413C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_13_3c00_5e5f3fe0() {
    // Encoding: 0x5E5F3FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=31, Rn=31, Rd=0
    // Fields: Rm=31, Rn=31, Rd=0
    let encoding: u32 = 0x5E5F3FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_14_3c00_5e413c01() {
    // Encoding: 0x5E413C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=1, Rn=0, Rd=1
    // Fields: Rd=1, Rm=1, Rn=0
    let encoding: u32 = 0x5E413C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_15_3c00_5e5f3c1f() {
    // Encoding: 0x5E5F3C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=31, Rn=0, Rd=31
    // Fields: Rm=31, Rn=0, Rd=31
    let encoding: u32 = 0x5E5F3C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_16_3c00_5e403c21() {
    // Encoding: 0x5E403C21
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=1, Rd=1
    // Fields: Rd=1, Rm=0, Rn=1
    let encoding: u32 = 0x5E403C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_combo_17_3c00_5e403fff() {
    // Encoding: 0x5E403FFF
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd field combination: Rm=0, Rn=31, Rd=31
    // Fields: Rd=31, Rn=31, Rm=0
    let encoding: u32 = 0x5E403FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_15360_5e403fe0() {
    // Encoding: 0x5E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, Rm=0
    let encoding: u32 = 0x5E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_15360_5e403c1f() {
    // Encoding: 0x5E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rn=0, Rm=0
    let encoding: u32 = 0x5E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_sz_0_min_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field sz = 0 (Min)
    // Fields: Rn=0, sz=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_sz_1_max_fc00_5e60fc00() {
    // Encoding: 0x5E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field sz = 1 (Max)
    // Fields: Rd=0, Rm=0, Rn=0, sz=1
    let encoding: u32 = 0x5E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rm_0_min_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rm = 0 (Min)
    // Fields: sz=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rm_1_poweroftwo_fc00_5e21fc00() {
    // Encoding: 0x5E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rm_30_poweroftwominusone_fc00_5e3efc00() {
    // Encoding: 0x5E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, sz=0, Rd=0
    let encoding: u32 = 0x5E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rm_31_max_fc00_5e3ffc00() {
    // Encoding: 0x5E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x5E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rn_0_min_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rn = 0 (Min)
    // Fields: Rd=0, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rn_1_poweroftwo_fc00_5e20fc20() {
    // Encoding: 0x5E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rm=0, Rd=0, Rn=1
    let encoding: u32 = 0x5E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rn_30_poweroftwominusone_fc00_5e20ffc0() {
    // Encoding: 0x5E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Rd=0, Rm=0
    let encoding: u32 = 0x5E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rn_31_max_fc00_5e20ffe0() {
    // Encoding: 0x5E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rn = 31 (Max)
    // Fields: Rn=31, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rd_0_min_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rd = 0 (Min)
    // Fields: Rd=0, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rd_1_poweroftwo_fc00_5e20fc01() {
    // Encoding: 0x5E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, sz=0, Rm=0
    let encoding: u32 = 0x5E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rd_30_poweroftwominusone_fc00_5e20fc1e() {
    // Encoding: 0x5E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, sz=0, Rm=0, Rd=30
    let encoding: u32 = 0x5E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_field_rd_31_max_fc00_5e20fc1f() {
    // Encoding: 0x5E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rm=0, Rd=31, sz=0
    let encoding: u32 = 0x5E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_0_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_1_fc00_5e60fc00() {
    // Encoding: 0x5E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x5E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_2_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_3_fc00_5e21fc00() {
    // Encoding: 0x5E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=1, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Rm=1, Rn=0
    let encoding: u32 = 0x5E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_4_fc00_5e3efc00() {
    // Encoding: 0x5E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=30, Rn=0, Rd=0
    // Fields: Rd=0, sz=0, Rm=30, Rn=0
    let encoding: u32 = 0x5E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_5_fc00_5e3ffc00() {
    // Encoding: 0x5E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=31, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Rm=31
    let encoding: u32 = 0x5E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_6_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_7_fc00_5e20fc20() {
    // Encoding: 0x5E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=1, Rd=0
    // Fields: Rn=1, Rd=0, Rm=0, sz=0
    let encoding: u32 = 0x5E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_8_fc00_5e20ffc0() {
    // Encoding: 0x5E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=30, Rd=0
    // Fields: Rn=30, Rm=0, Rd=0, sz=0
    let encoding: u32 = 0x5E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_9_fc00_5e20ffe0() {
    // Encoding: 0x5E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Rd=0, Rn=31, sz=0
    let encoding: u32 = 0x5E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_10_fc00_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_11_fc00_5e20fc01() {
    // Encoding: 0x5E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=1
    // Fields: Rm=0, Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x5E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_12_fc00_5e20fc1e() {
    // Encoding: 0x5E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=30
    // Fields: sz=0, Rd=30, Rm=0, Rn=0
    let encoding: u32 = 0x5E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_13_fc00_5e20fc1f() {
    // Encoding: 0x5E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Rn=0, sz=0, Rm=0, Rd=31
    let encoding: u32 = 0x5E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_14_fc00_5e21fc20() {
    // Encoding: 0x5E21FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=1, Rn=1, Rd=0
    // Fields: sz=0, Rm=1, Rd=0, Rn=1
    let encoding: u32 = 0x5E21FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_15_fc00_5e3fffe0() {
    // Encoding: 0x5E3FFFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=31, Rn=31, Rd=0
    // Fields: sz=0, Rd=0, Rn=31, Rm=31
    let encoding: u32 = 0x5E3FFFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_16_fc00_5e21fc01() {
    // Encoding: 0x5E21FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=1, Rn=0, Rd=1
    // Fields: Rm=1, Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x5E21FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_17_fc00_5e3ffc1f() {
    // Encoding: 0x5E3FFC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Rd=31, sz=0, Rn=0, Rm=31
    let encoding: u32 = 0x5E3FFC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_18_fc00_5e20fc21() {
    // Encoding: 0x5E20FC21
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Rn=1, sz=0, Rd=1, Rm=0
    let encoding: u32 = 0x5E20FC21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_combo_19_fc00_5e20ffff() {
    // Encoding: 0x5E20FFFF
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd field combination: sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Rm=0, Rn=31, Rd=31, sz=0
    let encoding: u32 = 0x5E20FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_special_sz_0_size_variant_0_64512_5e20fc00() {
    // Encoding: 0x5E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd special value sz = 0 (Size variant 0)
    // Fields: sz=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_special_sz_1_size_variant_1_64512_5e60fc00() {
    // Encoding: 0x5E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd special value sz = 1 (Size variant 1)
    // Fields: Rn=0, sz=1, Rd=0, Rm=0
    let encoding: u32 = 0x5E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_64512_5e60ffe0() {
    // Encoding: 0x5E60FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Rd=0, sz=1
    let encoding: u32 = 0x5E60FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_64512_5e60fc1f() {
    // Encoding: 0x5E60FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, sz=1, Rn=0, Rd=31
    let encoding: u32 = 0x5E60FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_q_0_min_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Q = 0 (Min)
    // Fields: Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_q_1_max_3c00_4e403c00() {
    // Encoding: 0x4E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Q = 1 (Max)
    // Fields: Rm=0, Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x4E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rm_0_min_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rm = 0 (Min)
    // Fields: Rm=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rm_1_poweroftwo_3c00_0e413c00() {
    // Encoding: 0x0E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=1, Rn=0, Q=0
    let encoding: u32 = 0x0E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rm_30_poweroftwominusone_3c00_0e5e3c00() {
    // Encoding: 0x0E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=0, Rm=30, Q=0
    let encoding: u32 = 0x0E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rm_31_max_3c00_0e5f3c00() {
    // Encoding: 0x0E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rm = 31 (Max)
    // Fields: Rm=31, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rn_0_min_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rn = 0 (Min)
    // Fields: Rd=0, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rn_1_poweroftwo_3c00_0e403c20() {
    // Encoding: 0x0E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Q=0, Rd=0, Rn=1
    let encoding: u32 = 0x0E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rn_30_poweroftwominusone_3c00_0e403fc0() {
    // Encoding: 0x0E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rn_31_max_3c00_0e403fe0() {
    // Encoding: 0x0E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rd_0_min_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rd = 0 (Min)
    // Fields: Rn=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rd_1_poweroftwo_3c00_0e403c01() {
    // Encoding: 0x0E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=1, Rm=0, Rn=0
    let encoding: u32 = 0x0E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rd_30_poweroftwominusone_3c00_0e403c1e() {
    // Encoding: 0x0E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Q=0, Rm=0, Rd=30
    let encoding: u32 = 0x0E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_field_rd_31_max_3c00_0e403c1f() {
    // Encoding: 0x0E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, Rd=31, Rm=0
    let encoding: u32 = 0x0E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_0_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_1_3c00_4e403c00() {
    // Encoding: 0x4E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=1, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x4E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_2_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_3_3c00_0e413c00() {
    // Encoding: 0x0E413C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=1, Rn=0, Rd=0
    // Fields: Q=0, Rm=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E413C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_4_3c00_0e5e3c00() {
    // Encoding: 0x0E5E3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=30, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rn=0, Rm=30
    let encoding: u32 = 0x0E5E3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_5_3c00_0e5f3c00() {
    // Encoding: 0x0E5F3C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=31, Rn=0, Rd=0
    // Fields: Rn=0, Rm=31, Q=0, Rd=0
    let encoding: u32 = 0x0E5F3C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_6_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_7_3c00_0e403c20() {
    // Encoding: 0x0E403C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=1, Rd=0
    // Fields: Rn=1, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0E403C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_8_3c00_0e403fc0() {
    // Encoding: 0x0E403FC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=30, Rd=0
    // Fields: Rn=30, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E403FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_9_3c00_0e403fe0() {
    // Encoding: 0x0E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_10_3c00_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_11_3c00_0e403c01() {
    // Encoding: 0x0E403C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=1
    // Fields: Rd=1, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0E403C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_12_3c00_0e403c1e() {
    // Encoding: 0x0E403C1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=30
    // Fields: Rd=30, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E403C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_13_3c00_0e403c1f() {
    // Encoding: 0x0E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, Q=0, Rm=0
    let encoding: u32 = 0x0E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_14_3c00_0e413c20() {
    // Encoding: 0x0E413C20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=1, Rn=1, Rd=0
    // Fields: Rd=0, Rm=1, Rn=1, Q=0
    let encoding: u32 = 0x0E413C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_15_3c00_0e5f3fe0() {
    // Encoding: 0x0E5F3FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=31, Rn=31, Rd=0
    // Fields: Rn=31, Q=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E5F3FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_16_3c00_0e413c01() {
    // Encoding: 0x0E413C01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=1, Rn=0, Rd=1
    // Fields: Rn=0, Rd=1, Q=0, Rm=1
    let encoding: u32 = 0x0E413C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_17_3c00_0e5f3c1f() {
    // Encoding: 0x0E5F3C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=31, Rn=0, Rd=31
    // Fields: Q=0, Rd=31, Rn=0, Rm=31
    let encoding: u32 = 0x0E5F3C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_18_3c00_0e403c21() {
    // Encoding: 0x0E403C21
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=1, Rd=1
    // Fields: Rn=1, Q=0, Rm=0, Rd=1
    let encoding: u32 = 0x0E403C21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_combo_19_3c00_0e403fff() {
    // Encoding: 0x0E403FFF
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd field combination: Q=0, Rm=0, Rn=31, Rd=31
    // Fields: Rm=0, Rn=31, Q=0, Rd=31
    let encoding: u32 = 0x0E403FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_special_q_0_size_variant_0_15360_0e403c00() {
    // Encoding: 0x0E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_special_q_1_size_variant_1_15360_4e403c00() {
    // Encoding: 0x4E403C00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Q=1, Rd=0, Rn=0
    let encoding: u32 = 0x4E403C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_15360_0e403fe0() {
    // Encoding: 0x0E403FE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_15360_0e403c1f() {
    // Encoding: 0x0E403C1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E403C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_q_0_min_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Q = 0 (Min)
    // Fields: sz=0, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_q_1_max_fc00_4e20fc00() {
    // Encoding: 0x4E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Q = 1 (Max)
    // Fields: Q=1, Rd=0, Rn=0, sz=0, Rm=0
    let encoding: u32 = 0x4E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_sz_0_min_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field sz = 0 (Min)
    // Fields: Rn=0, Rm=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_sz_1_max_fc00_0e60fc00() {
    // Encoding: 0x0E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field sz = 1 (Max)
    // Fields: Rd=0, sz=1, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rm_0_min_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rm = 0 (Min)
    // Fields: Rm=0, Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rm_1_poweroftwo_fc00_0e21fc00() {
    // Encoding: 0x0E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x0E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rm_30_poweroftwominusone_fc00_0e3efc00() {
    // Encoding: 0x0E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rm=30, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rm_31_max_fc00_0e3ffc00() {
    // Encoding: 0x0E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rm = 31 (Max)
    // Fields: Rn=0, Q=0, sz=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rn_0_min_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rn = 0 (Min)
    // Fields: Rd=0, Q=0, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rn_1_poweroftwo_fc00_0e20fc20() {
    // Encoding: 0x0E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=1, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rn_30_poweroftwominusone_fc00_0e20ffc0() {
    // Encoding: 0x0E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rn=30, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rn_31_max_fc00_0e20ffe0() {
    // Encoding: 0x0E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rn = 31 (Max)
    // Fields: Rn=31, Q=0, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rd_0_min_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rd = 0 (Min)
    // Fields: Q=0, Rd=0, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rd_1_poweroftwo_fc00_0e20fc01() {
    // Encoding: 0x0E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, sz=0, Rd=1, Q=0, Rn=0
    let encoding: u32 = 0x0E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rd_30_poweroftwominusone_fc00_0e20fc1e() {
    // Encoding: 0x0E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, sz=0, Rm=0, Rn=0, Rd=30
    let encoding: u32 = 0x0E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_field_rd_31_max_fc00_0e20fc1f() {
    // Encoding: 0x0E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field Rd = 31 (Max)
    // Fields: sz=0, Rm=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_0_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, Rm=0, sz=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_1_fc00_4e20fc00() {
    // Encoding: 0x4E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=1, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Q=1, sz=0, Rd=0
    let encoding: u32 = 0x4E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_2_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Q=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_3_fc00_0e60fc00() {
    // Encoding: 0x0E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=1, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, sz=1, Q=0, Rd=0
    let encoding: u32 = 0x0E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_4_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, Rm=0, sz=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_5_fc00_0e21fc00() {
    // Encoding: 0x0E21FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=0
    // Fields: Q=0, sz=0, Rn=0, Rm=1, Rd=0
    let encoding: u32 = 0x0E21FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_6_fc00_0e3efc00() {
    // Encoding: 0x0E3EFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=30, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, sz=0, Rm=30, Rn=0
    let encoding: u32 = 0x0E3EFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_7_fc00_0e3ffc00() {
    // Encoding: 0x0E3FFC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E3FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_8_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_9_fc00_0e20fc20() {
    // Encoding: 0x0E20FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=0
    // Fields: sz=0, Rm=0, Rn=1, Rd=0, Q=0
    let encoding: u32 = 0x0E20FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_10_fc00_0e20ffc0() {
    // Encoding: 0x0E20FFC0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=30, Rd=0
    // Fields: Q=0, sz=0, Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E20FFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_11_fc00_0e20ffe0() {
    // Encoding: 0x0E20FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=0
    // Fields: Rm=0, Q=0, Rn=31, sz=0, Rd=0
    let encoding: u32 = 0x0E20FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_12_fc00_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_13_fc00_0e20fc01() {
    // Encoding: 0x0E20FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=1
    // Fields: Rd=1, Q=0, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_14_fc00_0e20fc1e() {
    // Encoding: 0x0E20FC1E
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=30
    // Fields: sz=0, Rn=0, Rd=30, Q=0, Rm=0
    let encoding: u32 = 0x0E20FC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_15_fc00_0e20fc1f() {
    // Encoding: 0x0E20FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=31
    // Fields: Rm=0, sz=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x0E20FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_16_fc00_0e21fc20() {
    // Encoding: 0x0E21FC20
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=1, Rn=1, Rd=0
    // Fields: sz=0, Q=0, Rm=1, Rn=1, Rd=0
    let encoding: u32 = 0x0E21FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_17_fc00_0e3fffe0() {
    // Encoding: 0x0E3FFFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=31, Rn=31, Rd=0
    // Fields: Rm=31, Rd=0, Rn=31, Q=0, sz=0
    let encoding: u32 = 0x0E3FFFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_18_fc00_0e21fc01() {
    // Encoding: 0x0E21FC01
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=1, Rn=0, Rd=1
    // Fields: Rn=0, sz=0, Rm=1, Q=0, Rd=1
    let encoding: u32 = 0x0E21FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_19_fc00_0e3ffc1f() {
    // Encoding: 0x0E3FFC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=31, Rn=0, Rd=31
    // Fields: Q=0, Rm=31, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E3FFC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 20`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_20_fc00_0e20fc21() {
    // Encoding: 0x0E20FC21
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=1, Rd=1
    // Fields: Rd=1, Rm=0, Q=0, sz=0, Rn=1
    let encoding: u32 = 0x0E20FC21;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field combination 21`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_combo_21_fc00_0e20ffff() {
    // Encoding: 0x0E20FFFF
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd field combination: Q=0, sz=0, Rm=0, Rn=31, Rd=31
    // Fields: Q=0, sz=0, Rm=0, Rn=31, Rd=31
    let encoding: u32 = 0x0E20FFFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_q_0_size_variant_0_64512_0e60fc00() {
    // Encoding: 0x0E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Q=0, Rm=0, sz=1
    let encoding: u32 = 0x0E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_q_1_size_variant_1_64512_4e60fc00() {
    // Encoding: 0x4E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rm=0, Q=1, Rd=0, sz=1
    let encoding: u32 = 0x4E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_sz_0_size_variant_0_64512_0e20fc00() {
    // Encoding: 0x0E20FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value sz = 0 (Size variant 0)
    // Fields: sz=0, Rm=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E20FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_sz_1_size_variant_1_64512_0e60fc00() {
    // Encoding: 0x0E60FC00
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value sz = 1 (Size variant 1)
    // Fields: Rd=0, sz=1, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E60FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_rn_31_stack_pointer_sp_may_require_alignment_64512_0e60ffe0() {
    // Encoding: 0x0E60FFE0
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, sz=1, Rd=0, Q=0
    let encoding: u32 = 0x0E60FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_64512_0e60fc1f() {
    // Encoding: 0x0E60FC1F
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Q=0, sz=1, Rn=0, Rd=31
    let encoding: u32 = 0x0E60FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_reg_write_0_5e403c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x5E403C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E403C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_sp_rn_5e403fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd with Rn = SP (31)
    // Encoding: 0x5E403FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E403FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd_zr_rd_5e403c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x5E403C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E403C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_reg_write_0_5e20fc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd register write: SimdFromField("d")
    // Encoding: 0x5E20FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_sp_rn_5e20ffe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd with Rn = SP (31)
    // Encoding: 0x5E20FFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20FFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_sisd_zr_rd_5e20fc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_sisd with Rd = ZR (31)
    // Encoding: 0x5E20FC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_reg_write_0_0e403c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x0E403C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E403C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_sp_rn_0e403fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd with Rn = SP (31)
    // Encoding: 0x0E403FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E403FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd_zr_rd_0e403c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_fp16_simd with Rd = ZR (31)
    // Encoding: 0x0E403C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E403C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_reg_write_0_0e20fc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd register write: SimdFromField("d")
    // Encoding: 0x0E20FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_sp_rn_0e20ffe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd with Rn = SP (31)
    // Encoding: 0x0E20FFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20FFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_recps_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_recps_simd_zr_rd_0e20fc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_recps_simd with Rd = ZR (31)
    // Encoding: 0x0E20FC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20FC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_float_narrow Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_q_0_min_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field Q = 0 (Min)
    // Fields: Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_q_1_max_6800_4e216800() {
    // Encoding: 0x4E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field Q = 1 (Max)
    // Fields: Rn=0, Q=1, sz=0, Rd=0
    let encoding: u32 = 0x4E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_sz_0_min_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field sz = 0 (Min)
    // Fields: Rd=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_sz_1_max_6800_0e616800() {
    // Encoding: 0x0E616800
    // Test aarch64_vector_arithmetic_unary_float_narrow field sz = 1 (Max)
    // Fields: Rn=0, Q=0, Rd=0, sz=1
    let encoding: u32 = 0x0E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rn_0_min_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rn = 0 (Min)
    // Fields: sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rn_1_poweroftwo_6800_0e216820() {
    // Encoding: 0x0E216820
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=1, Q=0, Rd=0
    let encoding: u32 = 0x0E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rn_30_poweroftwominusone_6800_0e216bc0() {
    // Encoding: 0x0E216BC0
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rn_31_max_6800_0e216be0() {
    // Encoding: 0x0E216BE0
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, sz=0, Rn=31
    let encoding: u32 = 0x0E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rd_0_min_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rd = 0 (Min)
    // Fields: sz=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rd_1_poweroftwo_6800_0e216801() {
    // Encoding: 0x0E216801
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rd=1, Rn=0
    let encoding: u32 = 0x0E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rd_30_poweroftwominusone_6800_0e21681e() {
    // Encoding: 0x0E21681E
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=30, Rn=0, Q=0
    let encoding: u32 = 0x0E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_field_rd_31_max_6800_0e21681f() {
    // Encoding: 0x0E21681F
    // Test aarch64_vector_arithmetic_unary_float_narrow field Rd = 31 (Max)
    // Fields: sz=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_0_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_1_6800_4e216800() {
    // Encoding: 0x4E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=1, Rn=0, sz=0
    let encoding: u32 = 0x4E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_2_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_3_6800_0e616800() {
    // Encoding: 0x0E616800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, Q=0, sz=1
    let encoding: u32 = 0x0E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_4_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_5_6800_0e216820() {
    // Encoding: 0x0E216820
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Q=0, Rd=0, sz=0, Rn=1
    let encoding: u32 = 0x0E216820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_6_6800_0e216bc0() {
    // Encoding: 0x0E216BC0
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rn=30, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x0E216BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_7_6800_0e216be0() {
    // Encoding: 0x0E216BE0
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: Rn=31, sz=0, Rd=0, Q=0
    let encoding: u32 = 0x0E216BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_8_6800_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_9_6800_0e216801() {
    // Encoding: 0x0E216801
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: sz=0, Rd=1, Q=0, Rn=0
    let encoding: u32 = 0x0E216801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_10_6800_0e21681e() {
    // Encoding: 0x0E21681E
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: Rn=0, Q=0, sz=0, Rd=30
    let encoding: u32 = 0x0E21681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_11_6800_0e21681f() {
    // Encoding: 0x0E21681F
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: sz=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x0E21681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_12_6800_0e216821() {
    // Encoding: 0x0E216821
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: Q=0, Rn=1, sz=0, Rd=1
    let encoding: u32 = 0x0E216821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_combo_13_6800_0e216bff() {
    // Encoding: 0x0E216BFF
    // Test aarch64_vector_arithmetic_unary_float_narrow field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: sz=0, Q=0, Rn=31, Rd=31
    let encoding: u32 = 0x0E216BFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_q_0_size_variant_0_26624_0e616800() {
    // Encoding: 0x0E616800
    // Test aarch64_vector_arithmetic_unary_float_narrow special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Q=0, Rd=0, sz=1
    let encoding: u32 = 0x0E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_q_1_size_variant_1_26624_4e616800() {
    // Encoding: 0x4E616800
    // Test aarch64_vector_arithmetic_unary_float_narrow special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, sz=1, Q=1
    let encoding: u32 = 0x4E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_sz_0_size_variant_0_26624_0e216800() {
    // Encoding: 0x0E216800
    // Test aarch64_vector_arithmetic_unary_float_narrow special value sz = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_sz_1_size_variant_1_26624_0e616800() {
    // Encoding: 0x0E616800
    // Test aarch64_vector_arithmetic_unary_float_narrow special value sz = 1 (Size variant 1)
    // Fields: Rd=0, sz=1, Rn=0, Q=0
    let encoding: u32 = 0x0E616800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_rn_31_stack_pointer_sp_may_require_alignment_26624_0e616be0() {
    // Encoding: 0x0E616BE0
    // Test aarch64_vector_arithmetic_unary_float_narrow special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, sz=1, Rd=0, Rn=31
    let encoding: u32 = 0x0E616BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_26624_0e61681f() {
    // Encoding: 0x0E61681F
    // Test aarch64_vector_arithmetic_unary_float_narrow special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, sz=1, Rd=31, Rn=0
    let encoding: u32 = 0x0E61681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_sp_rn_0e216be0() {
    // Test aarch64_vector_arithmetic_unary_float_narrow with Rn = SP (31)
    // Encoding: 0x0E216BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E216BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_float_narrow
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_float_narrow_zr_rd_0e21681f() {
    // Test aarch64_vector_arithmetic_unary_float_narrow with Rd = ZR (31)
    // Encoding: 0x0E21681F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E21681F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_unary_special_recip_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rn_0_min_d800_5ef9d800() {
    // Encoding: 0x5EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rn_1_poweroftwo_d800_5ef9d820() {
    // Encoding: 0x5EF9D820
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0
    let encoding: u32 = 0x5EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rn_30_poweroftwominusone_d800_5ef9dbc0() {
    // Encoding: 0x5EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0
    let encoding: u32 = 0x5EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rn_31_max_d800_5ef9dbe0() {
    // Encoding: 0x5EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0
    let encoding: u32 = 0x5EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rd_0_min_d800_5ef9d800() {
    // Encoding: 0x5EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rd = 0 (Min)
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rd_1_poweroftwo_d800_5ef9d801() {
    // Encoding: 0x5EF9D801
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0
    let encoding: u32 = 0x5EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rd_30_poweroftwominusone_d800_5ef9d81e() {
    // Encoding: 0x5EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30
    let encoding: u32 = 0x5EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_field_rd_31_max_d800_5ef9d81f() {
    // Encoding: 0x5EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31
    let encoding: u32 = 0x5EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_0_d800_5ef9d800() {
    // Encoding: 0x5EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=0, Rd=0
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_1_d800_5ef9d820() {
    // Encoding: 0x5EF9D820
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=1, Rd=0
    // Fields: Rd=0, Rn=1
    let encoding: u32 = 0x5EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_2_d800_5ef9dbc0() {
    // Encoding: 0x5EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=30, Rd=0
    // Fields: Rd=0, Rn=30
    let encoding: u32 = 0x5EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_3_d800_5ef9dbe0() {
    // Encoding: 0x5EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=31, Rd=0
    // Fields: Rd=0, Rn=31
    let encoding: u32 = 0x5EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_4_d800_5ef9d800() {
    // Encoding: 0x5EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=0, Rd=0
    // Fields: Rd=0, Rn=0
    let encoding: u32 = 0x5EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_5_d800_5ef9d801() {
    // Encoding: 0x5EF9D801
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=0, Rd=1
    // Fields: Rd=1, Rn=0
    let encoding: u32 = 0x5EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_6_d800_5ef9d81e() {
    // Encoding: 0x5EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=0, Rd=30
    // Fields: Rn=0, Rd=30
    let encoding: u32 = 0x5EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_7_d800_5ef9d81f() {
    // Encoding: 0x5EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=0, Rd=31
    // Fields: Rd=31, Rn=0
    let encoding: u32 = 0x5EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_8_d800_5ef9d821() {
    // Encoding: 0x5EF9D821
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=1, Rd=1
    // Fields: Rn=1, Rd=1
    let encoding: u32 = 0x5EF9D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_combo_9_d800_5ef9dbff() {
    // Encoding: 0x5EF9DBFF
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd field combination: Rn=31, Rd=31
    // Fields: Rn=31, Rd=31
    let encoding: u32 = 0x5EF9DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_5ef9dbe0() {
    // Encoding: 0x5EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0
    let encoding: u32 = 0x5EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_5ef9d81f() {
    // Encoding: 0x5EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rn=0
    let encoding: u32 = 0x5EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_sz_0_min_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field sz = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_sz_1_max_d800_5ee1d800() {
    // Encoding: 0x5EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field sz = 1 (Max)
    // Fields: Rn=0, sz=1, Rd=0
    let encoding: u32 = 0x5EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rn_0_min_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rn = 0 (Min)
    // Fields: Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rn_1_poweroftwo_d800_5ea1d820() {
    // Encoding: 0x5EA1D820
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, sz=0, Rn=1
    let encoding: u32 = 0x5EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rn_30_poweroftwominusone_d800_5ea1dbc0() {
    // Encoding: 0x5EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=30, sz=0
    let encoding: u32 = 0x5EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rn_31_max_d800_5ea1dbe0() {
    // Encoding: 0x5EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rn = 31 (Max)
    // Fields: sz=0, Rd=0, Rn=31
    let encoding: u32 = 0x5EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rd_0_min_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rd_1_poweroftwo_d800_5ea1d801() {
    // Encoding: 0x5EA1D801
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, sz=0, Rd=1
    let encoding: u32 = 0x5EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rd_30_poweroftwominusone_d800_5ea1d81e() {
    // Encoding: 0x5EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, sz=0, Rd=30
    let encoding: u32 = 0x5EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_field_rd_31_max_d800_5ea1d81f() {
    // Encoding: 0x5EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field Rd = 31 (Max)
    // Fields: sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x5EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_0_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_1_d800_5ee1d800() {
    // Encoding: 0x5EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=1, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x5EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_2_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_3_d800_5ea1d820() {
    // Encoding: 0x5EA1D820
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=1, Rd=0
    // Fields: sz=0, Rn=1, Rd=0
    let encoding: u32 = 0x5EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_4_d800_5ea1dbc0() {
    // Encoding: 0x5EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=30, Rd=0
    // Fields: Rd=0, Rn=30, sz=0
    let encoding: u32 = 0x5EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_5_d800_5ea1dbe0() {
    // Encoding: 0x5EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=31, Rd=0
    // Fields: Rn=31, Rd=0, sz=0
    let encoding: u32 = 0x5EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_6_d800_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_7_d800_5ea1d801() {
    // Encoding: 0x5EA1D801
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=1
    // Fields: sz=0, Rn=0, Rd=1
    let encoding: u32 = 0x5EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_8_d800_5ea1d81e() {
    // Encoding: 0x5EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=30
    // Fields: Rd=30, sz=0, Rn=0
    let encoding: u32 = 0x5EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_9_d800_5ea1d81f() {
    // Encoding: 0x5EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, sz=0
    let encoding: u32 = 0x5EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_10_d800_5ea1d821() {
    // Encoding: 0x5EA1D821
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rn=1, Rd=1
    let encoding: u32 = 0x5EA1D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_combo_11_d800_5ea1dbff() {
    // Encoding: 0x5EA1DBFF
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd field combination: sz=0, Rn=31, Rd=31
    // Fields: Rn=31, sz=0, Rd=31
    let encoding: u32 = 0x5EA1DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_special_sz_0_size_variant_0_55296_5ea1d800() {
    // Encoding: 0x5EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd special value sz = 0 (Size variant 0)
    // Fields: sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_special_sz_1_size_variant_1_55296_5ee1d800() {
    // Encoding: 0x5EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rn=0, Rd=0
    let encoding: u32 = 0x5EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_5ee1dbe0() {
    // Encoding: 0x5EE1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=1, Rd=0, Rn=31
    let encoding: u32 = 0x5EE1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_5ee1d81f() {
    // Encoding: 0x5EE1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=1, Rd=31, Rn=0
    let encoding: u32 = 0x5EE1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_q_0_min_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Q = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_q_1_max_d800_4ef9d800() {
    // Encoding: 0x4EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Q = 1 (Max)
    // Fields: Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x4EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rn_0_min_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rn_1_poweroftwo_d800_0ef9d820() {
    // Encoding: 0x0EF9D820
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Q=0, Rd=0
    let encoding: u32 = 0x0EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rn_30_poweroftwominusone_d800_0ef9dbc0() {
    // Encoding: 0x0EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Q=0, Rd=0
    let encoding: u32 = 0x0EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rn_31_max_d800_0ef9dbe0() {
    // Encoding: 0x0EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rn = 31 (Max)
    // Fields: Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x0EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rd_0_min_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rd = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rd_1_poweroftwo_d800_0ef9d801() {
    // Encoding: 0x0EF9D801
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Q=0
    let encoding: u32 = 0x0EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rd_30_poweroftwominusone_d800_0ef9d81e() {
    // Encoding: 0x0EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Q=0
    let encoding: u32 = 0x0EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_field_rd_31_max_d800_0ef9d81f() {
    // Encoding: 0x0EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_0_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_1_d800_4ef9d800() {
    // Encoding: 0x4EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=1, Rn=0, Rd=0
    // Fields: Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x4EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_2_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_3_d800_0ef9d820() {
    // Encoding: 0x0EF9D820
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=1, Rd=0
    // Fields: Q=0, Rn=1, Rd=0
    let encoding: u32 = 0x0EF9D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_4_d800_0ef9dbc0() {
    // Encoding: 0x0EF9DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=30, Rd=0
    // Fields: Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x0EF9DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_5_d800_0ef9dbe0() {
    // Encoding: 0x0EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=31, Rd=0
    // Fields: Rd=0, Q=0, Rn=31
    let encoding: u32 = 0x0EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_6_d800_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_7_d800_0ef9d801() {
    // Encoding: 0x0EF9D801
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=1
    // Fields: Rd=1, Q=0, Rn=0
    let encoding: u32 = 0x0EF9D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_8_d800_0ef9d81e() {
    // Encoding: 0x0EF9D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=30
    // Fields: Rn=0, Q=0, Rd=30
    let encoding: u32 = 0x0EF9D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_9_d800_0ef9d81f() {
    // Encoding: 0x0EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=0, Rd=31
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_10_d800_0ef9d821() {
    // Encoding: 0x0EF9D821
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=1, Rd=1
    // Fields: Rd=1, Q=0, Rn=1
    let encoding: u32 = 0x0EF9D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_combo_11_d800_0ef9dbff() {
    // Encoding: 0x0EF9DBFF
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd field combination: Q=0, Rn=31, Rd=31
    // Fields: Q=0, Rn=31, Rd=31
    let encoding: u32 = 0x0EF9DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_special_q_0_size_variant_0_55296_0ef9d800() {
    // Encoding: 0x0EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_special_q_1_size_variant_1_55296_4ef9d800() {
    // Encoding: 0x4EF9D800
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x4EF9D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_0ef9dbe0() {
    // Encoding: 0x0EF9DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Q=0, Rd=0
    let encoding: u32 = 0x0EF9DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_0ef9d81f() {
    // Encoding: 0x0EF9D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Q=0
    let encoding: u32 = 0x0EF9D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_q_0_min_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Q = 0 (Min)
    // Fields: Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_q_1_max_d800_4ea1d800() {
    // Encoding: 0x4EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Q = 1 (Max)
    // Fields: sz=0, Rd=0, Rn=0, Q=1
    let encoding: u32 = 0x4EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_sz_0_min_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field sz = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_sz_1_max_d800_0ee1d800() {
    // Encoding: 0x0EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field sz = 1 (Max)
    // Fields: Rn=0, Q=0, sz=1, Rd=0
    let encoding: u32 = 0x0EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rn_0_min_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rn = 0 (Min)
    // Fields: sz=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rn_1_poweroftwo_d800_0ea1d820() {
    // Encoding: 0x0EA1D820
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x0EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rn_30_poweroftwominusone_d800_0ea1dbc0() {
    // Encoding: 0x0EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x0EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rn_31_max_d800_0ea1dbe0() {
    // Encoding: 0x0EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rn = 31 (Max)
    // Fields: sz=0, Rd=0, Rn=31, Q=0
    let encoding: u32 = 0x0EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rd_0_min_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rd = 0 (Min)
    // Fields: Rd=0, sz=0, Rn=0, Q=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rd_1_poweroftwo_d800_0ea1d801() {
    // Encoding: 0x0EA1D801
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, sz=0, Q=0, Rd=1
    let encoding: u32 = 0x0EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rd_30_poweroftwominusone_d800_0ea1d81e() {
    // Encoding: 0x0EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30, sz=0
    let encoding: u32 = 0x0EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_field_rd_31_max_d800_0ea1d81f() {
    // Encoding: 0x0EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field Rd = 31 (Max)
    // Fields: Rd=31, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_0_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: sz=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_1_d800_4ea1d800() {
    // Encoding: 0x4EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=1, sz=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=1, sz=0, Rn=0
    let encoding: u32 = 0x4EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_2_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Rn=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_3_d800_0ee1d800() {
    // Encoding: 0x0EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=1, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, Rd=0, sz=1
    let encoding: u32 = 0x0EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_4_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_5_d800_0ea1d820() {
    // Encoding: 0x0EA1D820
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=1, Rd=0
    // Fields: Rn=1, sz=0, Q=0, Rd=0
    let encoding: u32 = 0x0EA1D820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_6_d800_0ea1dbc0() {
    // Encoding: 0x0EA1DBC0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=30, Rd=0
    // Fields: Rd=0, Q=0, sz=0, Rn=30
    let encoding: u32 = 0x0EA1DBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_7_d800_0ea1dbe0() {
    // Encoding: 0x0EA1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=31, Rd=0
    // Fields: sz=0, Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x0EA1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_8_d800_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_9_d800_0ea1d801() {
    // Encoding: 0x0EA1D801
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=1
    // Fields: Rn=0, Q=0, Rd=1, sz=0
    let encoding: u32 = 0x0EA1D801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_10_d800_0ea1d81e() {
    // Encoding: 0x0EA1D81E
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=30
    // Fields: sz=0, Rn=0, Q=0, Rd=30
    let encoding: u32 = 0x0EA1D81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_11_d800_0ea1d81f() {
    // Encoding: 0x0EA1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=0, Rd=31
    // Fields: Rn=0, Q=0, Rd=31, sz=0
    let encoding: u32 = 0x0EA1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_12_d800_0ea1d821() {
    // Encoding: 0x0EA1D821
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=1, Rd=1
    // Fields: sz=0, Rn=1, Q=0, Rd=1
    let encoding: u32 = 0x0EA1D821;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_combo_13_d800_0ea1dbff() {
    // Encoding: 0x0EA1DBFF
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd field combination: Q=0, sz=0, Rn=31, Rd=31
    // Fields: Q=0, sz=0, Rd=31, Rn=31
    let encoding: u32 = 0x0EA1DBFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_q_0_size_variant_0_55296_0ee1d800() {
    // Encoding: 0x0EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Q=0, sz=1, Rn=0
    let encoding: u32 = 0x0EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_q_1_size_variant_1_55296_4ee1d800() {
    // Encoding: 0x4EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Q=1, sz=1, Rd=0
    let encoding: u32 = 0x4EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_sz_0_size_variant_0_55296_0ea1d800() {
    // Encoding: 0x0EA1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value sz = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0EA1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_sz_1_size_variant_1_55296_0ee1d800() {
    // Encoding: 0x0EE1D800
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value sz = 1 (Size variant 1)
    // Fields: Rd=0, Rn=0, sz=1, Q=0
    let encoding: u32 = 0x0EE1D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_rn_31_stack_pointer_sp_may_require_alignment_55296_0ee1dbe0() {
    // Encoding: 0x0EE1DBE0
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, sz=1, Q=0
    let encoding: u32 = 0x0EE1DBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_55296_0ee1d81f() {
    // Encoding: 0x0EE1D81F
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rn=0, sz=1, Q=0
    let encoding: u32 = 0x0EE1D81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_reg_write_0_5ef9d800() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x5EF9D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_sp_rn_5ef9dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd with Rn = SP (31)
    // Encoding: 0x5EF9DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_sisd_zr_rd_5ef9d81f() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x5EF9D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EF9D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_reg_write_0_5ea1d800() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd register write: SimdFromField("d")
    // Encoding: 0x5EA1D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_sp_rn_5ea1dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd with Rn = SP (31)
    // Encoding: 0x5EA1DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_sisd_zr_rd_5ea1d81f() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_sisd with Rd = ZR (31)
    // Encoding: 0x5EA1D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5EA1D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_reg_write_0_0ef9d800() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x0EF9D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF9D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_sp_rn_0ef9dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd with Rn = SP (31)
    // Encoding: 0x0EF9DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF9DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_fp16_simd_zr_rd_0ef9d81f() {
    // Test aarch64_vector_arithmetic_unary_special_recip_fp16_simd with Rd = ZR (31)
    // Encoding: 0x0EF9D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EF9D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_reg_write_0_0ea1d800() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd register write: SimdFromField("d")
    // Encoding: 0x0EA1D800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1D800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_sp_rn_0ea1dbe0() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd with Rn = SP (31)
    // Encoding: 0x0EA1DBE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1DBE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_unary_special_recip_float_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_unary_special_recip_float_simd_zr_rd_0ea1d81f() {
    // Test aarch64_vector_arithmetic_unary_special_recip_float_simd with Rd = ZR (31)
    // Encoding: 0x0EA1D81F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0EA1D81F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

