//! A64 vector mul tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_q_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Q = 0 (Min)
    // Fields: Q=0, Rn=0, S=0, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_q_1_max_ec00_4e20ec00() {
    // Encoding: 0x4E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Q = 1 (Max)
    // Fields: Q=1, sz=0, Rd=0, S=0, Rn=0, Rm=0
    let encoding: u32 = 0x4E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field S 23 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_s_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field S = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0, S=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field S 23 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_s_1_max_ec00_0ea0ec00() {
    // Encoding: 0x0EA0EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field S = 1 (Max)
    // Fields: Rm=0, Rd=0, Rn=0, Q=0, S=1, sz=0
    let encoding: u32 = 0x0EA0EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_sz_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field sz = 0 (Min)
    // Fields: S=0, Rd=0, Q=0, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_sz_1_max_ec00_0e60ec00() {
    // Encoding: 0x0E60EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field sz = 1 (Max)
    // Fields: sz=1, Rn=0, Q=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E60EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rm_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rm = 0 (Min)
    // Fields: Rm=0, sz=0, S=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rm_1_poweroftwo_ec00_0e21ec00() {
    // Encoding: 0x0E21EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Q=0, sz=0, Rm=1, Rn=0, S=0
    let encoding: u32 = 0x0E21EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rm_30_poweroftwominusone_ec00_0e3eec00() {
    // Encoding: 0x0E3EEC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, sz=0, Rn=0, Rd=0, Q=0, S=0
    let encoding: u32 = 0x0E3EEC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rm_31_max_ec00_0e3fec00() {
    // Encoding: 0x0E3FEC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rm = 31 (Max)
    // Fields: Q=0, sz=0, Rn=0, Rm=31, S=0, Rd=0
    let encoding: u32 = 0x0E3FEC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rn_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rn = 0 (Min)
    // Fields: Rd=0, sz=0, S=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rn_1_poweroftwo_ec00_0e20ec20() {
    // Encoding: 0x0E20EC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, S=0, Rm=0, Rd=0, Q=0, Rn=1
    let encoding: u32 = 0x0E20EC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rn_30_poweroftwominusone_ec00_0e20efc0() {
    // Encoding: 0x0E20EFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rd=0, Rm=0, Rn=30, Q=0, sz=0
    let encoding: u32 = 0x0E20EFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rn_31_max_ec00_0e20efe0() {
    // Encoding: 0x0E20EFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rn = 31 (Max)
    // Fields: Rm=0, Q=0, S=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E20EFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rd_0_min_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rd = 0 (Min)
    // Fields: Rd=0, sz=0, Q=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rd_1_poweroftwo_ec00_0e20ec01() {
    // Encoding: 0x0E20EC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rd=1, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x0E20EC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rd_30_poweroftwominusone_ec00_0e20ec1e() {
    // Encoding: 0x0E20EC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, S=0, sz=0, Rm=0, Rd=30, Rn=0
    let encoding: u32 = 0x0E20EC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_field_rd_31_max_ec00_0e20ec1f() {
    // Encoding: 0x0E20EC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field Rd = 31 (Max)
    // Fields: S=0, Q=0, Rm=0, sz=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E20EC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_combo_0_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower field combination: Q=0, S=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, Rm=0, Q=0, sz=0, S=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_q_0_size_variant_0_60416_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value Q = 0 (Size variant 0)
    // Fields: Rd=0, sz=0, S=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_q_1_size_variant_1_60416_4e20ec00() {
    // Encoding: 0x4E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value Q = 1 (Size variant 1)
    // Fields: S=0, Rd=0, Rn=0, sz=0, Q=1, Rm=0
    let encoding: u32 = 0x4E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_s_0_size_variant_0_60416_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value S = 0 (Size variant 0)
    // Fields: S=0, sz=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_s_1_size_variant_1_60416_0ea0ec00() {
    // Encoding: 0x0EA0EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value S = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, S=1, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x0EA0EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_sz_0_size_variant_0_60416_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value sz = 0 (Size variant 0)
    // Fields: Rd=0, S=0, Q=0, Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_sz_1_size_variant_1_60416_0e60ec00() {
    // Encoding: 0x0E60EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value sz = 1 (Size variant 1)
    // Fields: Q=0, sz=1, Rn=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x0E60EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_rn_31_stack_pointer_sp_may_require_alignment_60416_0e20efe0() {
    // Encoding: 0x0E20EFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=0, Q=0, Rn=31, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x0E20EFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_60416_0e20ec1f() {
    // Encoding: 0x0E20EC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=0, Rm=0, S=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E20EC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16MulNoRoundingToFP32Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_invalid_0_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }
    // Fields: Q=0, S=0, sz=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_invalid_1_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, S=0, Rn=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_invalid_2_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }
    // Fields: Rn=0, Rd=0, Rm=0, Q=0, S=0, sz=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_invalid_3_ec00_0e20ec00() {
    // Encoding: 0x0E20EC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, Rd=0, Rn=0, Q=0, S=0
    let encoding: u32 = 0x0E20EC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_q_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Q = 0 (Min)
    // Fields: Rd=0, sz=0, S=0, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_q_1_max_cc00_6e20cc00() {
    // Encoding: 0x6E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Q = 1 (Max)
    // Fields: Rd=0, S=0, Q=1, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x6E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field S 23 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_s_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field S = 0 (Min)
    // Fields: S=0, Rm=0, Rn=0, Rd=0, Q=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field S 23 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_s_1_max_cc00_2ea0cc00() {
    // Encoding: 0x2EA0CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field S = 1 (Max)
    // Fields: S=1, Rm=0, sz=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2EA0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_sz_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field sz = 0 (Min)
    // Fields: Rn=0, Q=0, Rm=0, S=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_sz_1_max_cc00_2e60cc00() {
    // Encoding: 0x2E60CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field sz = 1 (Max)
    // Fields: sz=1, Q=0, S=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E60CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rm_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rm = 0 (Min)
    // Fields: Rd=0, Q=0, S=0, Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rm_1_poweroftwo_cc00_2e21cc00() {
    // Encoding: 0x2E21CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, Rm=1, Q=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E21CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rm_30_poweroftwominusone_cc00_2e3ecc00() {
    // Encoding: 0x2E3ECC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=0, Q=0, S=0, Rn=0, Rm=30
    let encoding: u32 = 0x2E3ECC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rm_31_max_cc00_2e3fcc00() {
    // Encoding: 0x2E3FCC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Rd=0, S=0, sz=0, Q=0
    let encoding: u32 = 0x2E3FCC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rn_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rn = 0 (Min)
    // Fields: Rm=0, Q=0, Rn=0, S=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rn_1_poweroftwo_cc00_2e20cc20() {
    // Encoding: 0x2E20CC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rn = 1 (PowerOfTwo)
    // Fields: S=0, Rd=0, Q=0, Rm=0, Rn=1, sz=0
    let encoding: u32 = 0x2E20CC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rn_30_poweroftwominusone_cc00_2e20cfc0() {
    // Encoding: 0x2E20CFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rm=0, Rn=30, Q=0, Rd=0, S=0
    let encoding: u32 = 0x2E20CFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rn_31_max_cc00_2e20cfe0() {
    // Encoding: 0x2E20CFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rn = 31 (Max)
    // Fields: Rm=0, S=0, Q=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x2E20CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rd_0_min_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, sz=0, Rm=0, Q=0, S=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rd_1_poweroftwo_cc00_2e20cc01() {
    // Encoding: 0x2E20CC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=0, Q=0, Rm=0, S=0, Rd=1
    let encoding: u32 = 0x2E20CC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rd_30_poweroftwominusone_cc00_2e20cc1e() {
    // Encoding: 0x2E20CC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, sz=0, Rm=0, S=0, Rn=0, Rd=30
    let encoding: u32 = 0x2E20CC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_field_rd_31_max_cc00_2e20cc1f() {
    // Encoding: 0x2E20CC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field Rd = 31 (Max)
    // Fields: Rm=0, S=0, Rn=0, Rd=31, sz=0, Q=0
    let encoding: u32 = 0x2E20CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_combo_0_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper field combination: Q=0, S=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: sz=0, Rn=0, Rd=0, Rm=0, S=0, Q=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_q_0_size_variant_0_52224_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value Q = 0 (Size variant 0)
    // Fields: S=0, Q=0, Rm=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_q_1_size_variant_1_52224_6e20cc00() {
    // Encoding: 0x6E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value Q = 1 (Size variant 1)
    // Fields: Rm=0, S=0, Q=1, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x6E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_s_0_size_variant_0_52224_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value S = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rm=0, sz=0, Rd=0, S=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_s_1_size_variant_1_52224_2ea0cc00() {
    // Encoding: 0x2EA0CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value S = 1 (Size variant 1)
    // Fields: Rn=0, sz=0, S=1, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x2EA0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_sz_0_size_variant_0_52224_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value sz = 0 (Size variant 0)
    // Fields: Rd=0, Rm=0, S=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_sz_1_size_variant_1_52224_2e60cc00() {
    // Encoding: 0x2E60CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rm=0, Q=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0x2E60CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_rn_31_stack_pointer_sp_may_require_alignment_52224_2e20cfe0() {
    // Encoding: 0x2E20CFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, S=0, Q=0, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x2E20CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_52224_2e20cc1f() {
    // Encoding: 0x2E20CC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, sz=0, S=0, Rm=0, Rd=31, Q=0
    let encoding: u32 = 0x2E20CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16MulNoRoundingToFP32Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_invalid_0_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }
    // Fields: Rn=0, Q=0, Rd=0, sz=0, S=0, Rm=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_invalid_1_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, S=0, Rd=0, Rn=0, Q=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_invalid_2_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }
    // Fields: Rn=0, sz=0, S=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_invalid_3_cc00_2e20cc00() {
    // Encoding: 0x2E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Q=0, Rd=0, S=0, sz=0
    let encoding: u32 = 0x2E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_reg_write_0_0e20ec00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower register write: SimdFromField("d")
    // Encoding: 0x0E20EC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20EC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_sp_rn_0e20efe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower with Rn = SP (31)
    // Encoding: 0x0E20EFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20EFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower_zr_rd_0e20ec1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower with Rd = ZR (31)
    // Encoding: 0x0E20EC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20EC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_reg_write_0_2e20cc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper register write: SimdFromField("d")
    // Encoding: 0x2E20CC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20CC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_sp_rn_2e20cfe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper with Rn = SP (31)
    // Encoding: 0x2E20CFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20CFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper_zr_rd_2e20cc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper with Rd = ZR (31)
    // Encoding: 0x2E20CC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20CC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_int_accum Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_q_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Q = 0 (Min)
    // Fields: Q=0, U=0, Rn=0, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_q_1_max_9400_4e209400() {
    // Encoding: 0x4E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Q = 1 (Max)
    // Fields: Rm=0, size=0, U=0, Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x4E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_u_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field U = 0 (Min)
    // Fields: size=0, Rm=0, Q=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_u_1_max_9400_2e209400() {
    // Encoding: 0x2E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field U = 1 (Max)
    // Fields: U=1, Q=0, size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_size_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field size = 0 (Min)
    // Fields: U=0, Rd=0, Q=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_size_1_poweroftwo_9400_0e609400() {
    // Encoding: 0x0E609400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field size = 1 (PowerOfTwo)
    // Fields: Rm=0, Rd=0, U=0, size=1, Q=0, Rn=0
    let encoding: u32 = 0x0E609400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_size_2_poweroftwo_9400_0ea09400() {
    // Encoding: 0x0EA09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field size = 2 (PowerOfTwo)
    // Fields: Q=0, U=0, Rm=0, size=2, Rn=0, Rd=0
    let encoding: u32 = 0x0EA09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_size_3_max_9400_0ee09400() {
    // Encoding: 0x0EE09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field size = 3 (Max)
    // Fields: Q=0, size=3, Rn=0, U=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EE09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rm_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rm = 0 (Min)
    // Fields: Rd=0, size=0, Rm=0, U=0, Q=0, Rn=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rm_1_poweroftwo_9400_0e219400() {
    // Encoding: 0x0E219400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rm = 1 (PowerOfTwo)
    // Fields: size=0, U=0, Rn=0, Rm=1, Rd=0, Q=0
    let encoding: u32 = 0x0E219400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rm_30_poweroftwominusone_9400_0e3e9400() {
    // Encoding: 0x0E3E9400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rn=0, U=0, Rm=30, Q=0, size=0
    let encoding: u32 = 0x0E3E9400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rm_31_max_9400_0e3f9400() {
    // Encoding: 0x0E3F9400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rm = 31 (Max)
    // Fields: size=0, Rm=31, Rd=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E3F9400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rn_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rn = 0 (Min)
    // Fields: U=0, size=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rn_1_poweroftwo_9400_0e209420() {
    // Encoding: 0x0E209420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rm=0, Rn=1, U=0, Rd=0
    let encoding: u32 = 0x0E209420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rn_30_poweroftwominusone_9400_0e2097c0() {
    // Encoding: 0x0E2097C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, size=0, Rn=30, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x0E2097C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rn_31_max_9400_0e2097e0() {
    // Encoding: 0x0E2097E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rn = 31 (Max)
    // Fields: Rn=31, size=0, Q=0, Rm=0, U=0, Rd=0
    let encoding: u32 = 0x0E2097E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rd_0_min_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rd = 0 (Min)
    // Fields: size=0, U=0, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rd_1_poweroftwo_9400_0e209401() {
    // Encoding: 0x0E209401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, size=0, Rm=0, U=0, Q=0, Rd=1
    let encoding: u32 = 0x0E209401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rd_30_poweroftwominusone_9400_0e20941e() {
    // Encoding: 0x0E20941E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, Rm=0, size=0, Rn=0, Q=0
    let encoding: u32 = 0x0E20941E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_field_rd_31_max_9400_0e20941f() {
    // Encoding: 0x0E20941F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field Rd = 31 (Max)
    // Fields: Rm=0, Q=0, Rd=31, U=0, size=0, Rn=0
    let encoding: u32 = 0x0E20941F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_combo_0_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum field combination: Q=0, U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, size=0, Rm=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_q_0_size_variant_0_37888_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value Q = 0 (Size variant 0)
    // Fields: Q=0, size=0, Rm=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_q_1_size_variant_1_37888_4e209400() {
    // Encoding: 0x4E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value Q = 1 (Size variant 1)
    // Fields: Rd=0, size=0, Rn=0, U=0, Q=1, Rm=0
    let encoding: u32 = 0x4E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_size_0_size_variant_0_37888_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value size = 0 (Size variant 0)
    // Fields: U=0, Rd=0, Rn=0, Q=0, Rm=0, size=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_size_1_size_variant_1_37888_0e609400() {
    // Encoding: 0x0E609400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value size = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, Q=0, U=0, Rn=0, size=1
    let encoding: u32 = 0x0E609400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_size_2_size_variant_2_37888_0ea09400() {
    // Encoding: 0x0EA09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value size = 2 (Size variant 2)
    // Fields: Rm=0, Q=0, U=0, size=2, Rd=0, Rn=0
    let encoding: u32 = 0x0EA09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_size_3_size_variant_3_37888_0ee09400() {
    // Encoding: 0x0EE09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value size = 3 (Size variant 3)
    // Fields: size=3, Q=0, Rn=0, U=0, Rm=0, Rd=0
    let encoding: u32 = 0x0EE09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_rn_31_stack_pointer_sp_may_require_alignment_37888_0e2097e0() {
    // Encoding: 0x0E2097E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rd=0, U=0, Q=0, Rn=31, size=0
    let encoding: u32 = 0x0E2097E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_37888_0e20941f() {
    // Encoding: 0x0E20941F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, Q=0, U=0, size=0, Rd=31
    let encoding: u32 = 0x0E20941F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_invalid_0_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: size=0, U=0, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_invalid_1_9400_0e209400() {
    // Encoding: 0x0E209400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, Rn=0, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_reg_write_0_0e209400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum register write: SimdFromField("d")
    // Encoding: 0x0E209400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E209400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_sp_rn_0e2097e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum with Rn = SP (31)
    // Encoding: 0x0E2097E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2097E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_accum
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_accum_zr_rd_0e20941f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_accum with Rd = ZR (31)
    // Encoding: 0x0E20941F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20941F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_int_dotp Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_q_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Q = 0 (Min)
    // Fields: Rd=0, size=0, Q=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_q_1_max_9400_4e009400() {
    // Encoding: 0x4E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Q = 1 (Max)
    // Fields: Rn=0, Q=1, size=0, Rd=0, Rm=0, U=0
    let encoding: u32 = 0x4E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_u_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field U = 0 (Min)
    // Fields: size=0, Rm=0, Rn=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_u_1_max_9400_2e009400() {
    // Encoding: 0x2E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field U = 1 (Max)
    // Fields: Rm=0, Q=0, size=0, Rn=0, Rd=0, U=1
    let encoding: u32 = 0x2E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_size_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field size = 0 (Min)
    // Fields: Rd=0, Q=0, U=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_size_1_poweroftwo_9400_0e409400() {
    // Encoding: 0x0E409400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field size = 1 (PowerOfTwo)
    // Fields: Rn=0, size=1, Rd=0, Rm=0, Q=0, U=0
    let encoding: u32 = 0x0E409400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_size_2_poweroftwo_9400_0e809400() {
    // Encoding: 0x0E809400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field size = 2 (PowerOfTwo)
    // Fields: Rm=0, U=0, Rd=0, Q=0, Rn=0, size=2
    let encoding: u32 = 0x0E809400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_size_3_max_9400_0ec09400() {
    // Encoding: 0x0EC09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field size = 3 (Max)
    // Fields: Rm=0, Q=0, Rd=0, size=3, Rn=0, U=0
    let encoding: u32 = 0x0EC09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rm_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rm = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0, size=0, Rm=0, U=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rm_1_poweroftwo_9400_0e019400() {
    // Encoding: 0x0E019400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rm = 1 (PowerOfTwo)
    // Fields: size=0, Rm=1, Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E019400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rm_30_poweroftwominusone_9400_0e1e9400() {
    // Encoding: 0x0E1E9400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rm=30, Rd=0, Rn=0, size=0, Q=0
    let encoding: u32 = 0x0E1E9400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rm_31_max_9400_0e1f9400() {
    // Encoding: 0x0E1F9400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rm = 31 (Max)
    // Fields: Q=0, size=0, Rn=0, Rd=0, U=0, Rm=31
    let encoding: u32 = 0x0E1F9400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rn_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rn = 0 (Min)
    // Fields: Q=0, U=0, Rn=0, Rd=0, size=0, Rm=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rn_1_poweroftwo_9400_0e009420() {
    // Encoding: 0x0E009420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, size=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E009420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rn_30_poweroftwominusone_9400_0e0097c0() {
    // Encoding: 0x0E0097C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Q=0, Rd=0, size=0, U=0, Rn=30
    let encoding: u32 = 0x0E0097C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rn_31_max_9400_0e0097e0() {
    // Encoding: 0x0E0097E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rn = 31 (Max)
    // Fields: Q=0, U=0, Rd=0, Rn=31, Rm=0, size=0
    let encoding: u32 = 0x0E0097E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rd_0_min_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rd = 0 (Min)
    // Fields: Q=0, Rm=0, size=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rd_1_poweroftwo_9400_0e009401() {
    // Encoding: 0x0E009401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Q=0, Rm=0, Rn=0, Rd=1, size=0
    let encoding: u32 = 0x0E009401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rd_30_poweroftwominusone_9400_0e00941e() {
    // Encoding: 0x0E00941E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rm=0, size=0, Rn=0, Q=0, U=0
    let encoding: u32 = 0x0E00941E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_field_rd_31_max_9400_0e00941f() {
    // Encoding: 0x0E00941F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, size=0, Rd=31, Rm=0, U=0
    let encoding: u32 = 0x0E00941F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_combo_0_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp field combination: Q=0, U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, Rd=0, Rm=0, U=0, Rn=0, size=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_q_0_size_variant_0_37888_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value Q = 0 (Size variant 0)
    // Fields: size=0, Q=0, Rm=0, Rn=0, Rd=0, U=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_q_1_size_variant_1_37888_4e009400() {
    // Encoding: 0x4E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, U=0, Q=1, size=0, Rn=0
    let encoding: u32 = 0x4E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_size_0_size_variant_0_37888_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value size = 0 (Size variant 0)
    // Fields: Q=0, Rd=0, U=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_size_1_size_variant_1_37888_0e409400() {
    // Encoding: 0x0E409400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value size = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, Rn=0, U=0, Q=0, size=1
    let encoding: u32 = 0x0E409400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_size_2_size_variant_2_37888_0e809400() {
    // Encoding: 0x0E809400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value size = 2 (Size variant 2)
    // Fields: size=2, Rn=0, Rm=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E809400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_size_3_size_variant_3_37888_0ec09400() {
    // Encoding: 0x0EC09400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value size = 3 (Size variant 3)
    // Fields: Rd=0, size=3, U=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0EC09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_rn_31_stack_pointer_sp_may_require_alignment_37888_0e0097e0() {
    // Encoding: 0x0E0097E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Q=0, size=0, Rm=0, U=0, Rn=31
    let encoding: u32 = 0x0E0097E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_37888_0e00941f() {
    // Encoding: 0x0E00941F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rd=31, Rn=0, Rm=0, U=0, size=0
    let encoding: u32 = 0x0E00941F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveDOTPExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveDOTPExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_invalid_0_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveDOTPExt" }, args: [] } }
    // Fields: U=0, size=0, Rd=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_invalid_1_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Rd=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_invalid_2_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // Fields: Rn=0, Rm=0, Rd=0, U=0, Q=0, size=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_invalid_3_9400_0e009400() {
    // Encoding: 0x0E009400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Rm=0, U=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E009400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_reg_write_0_0e009400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp register write: SimdFromField("d")
    // Encoding: 0x0E009400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E009400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_sp_rn_0e0097e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp with Rn = SP (31)
    // Encoding: 0x0E0097E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E0097E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_dotp
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_dotp_zr_rd_0e00941f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_dotp with Rd = ZR (31)
    // Encoding: 0x0E00941F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E00941F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_complex Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_q_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Q = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, rot=0, H=0, L=0, M=0, Q=0, size=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_q_1_max_1000_6f001000() {
    // Encoding: 0x6F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Q = 1 (Max)
    // Fields: Q=1, Rd=0, Rm=0, rot=0, Rn=0, M=0, L=0, size=0, H=0
    let encoding: u32 = 0x6F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_size_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field size = 0 (Min)
    // Fields: Rd=0, L=0, rot=0, M=0, Rm=0, size=0, Rn=0, H=0, Q=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_size_1_poweroftwo_1000_2f401000() {
    // Encoding: 0x2F401000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field size = 1 (PowerOfTwo)
    // Fields: M=0, L=0, Q=0, Rn=0, Rd=0, rot=0, Rm=0, H=0, size=1
    let encoding: u32 = 0x2F401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_size_2_poweroftwo_1000_2f801000() {
    // Encoding: 0x2F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field size = 2 (PowerOfTwo)
    // Fields: Rm=0, rot=0, M=0, L=0, Rn=0, H=0, size=2, Q=0, Rd=0
    let encoding: u32 = 0x2F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_size_3_max_1000_2fc01000() {
    // Encoding: 0x2FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field size = 3 (Max)
    // Fields: Rd=0, Q=0, H=0, Rm=0, size=3, M=0, L=0, rot=0, Rn=0
    let encoding: u32 = 0x2FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_l_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field L = 0 (Min)
    // Fields: Rn=0, Rm=0, size=0, Rd=0, M=0, Q=0, L=0, rot=0, H=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_l_1_max_1000_2f201000() {
    // Encoding: 0x2F201000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field L = 1 (Max)
    // Fields: Rd=0, rot=0, H=0, L=1, Rm=0, Q=0, size=0, Rn=0, M=0
    let encoding: u32 = 0x2F201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_m_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field M = 0 (Min)
    // Fields: L=0, Rm=0, rot=0, Q=0, Rn=0, H=0, Rd=0, M=0, size=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_m_1_max_1000_2f101000() {
    // Encoding: 0x2F101000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field M = 1 (Max)
    // Fields: L=0, H=0, Q=0, Rd=0, Rn=0, Rm=0, size=0, M=1, rot=0
    let encoding: u32 = 0x2F101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rm_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rm = 0 (Min)
    // Fields: H=0, Rd=0, Rm=0, L=0, size=0, Rn=0, rot=0, Q=0, M=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rm_1_poweroftwo_1000_2f011000() {
    // Encoding: 0x2F011000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rm = 1 (PowerOfTwo)
    // Fields: rot=0, M=0, Rn=0, Q=0, Rd=0, Rm=1, size=0, L=0, H=0
    let encoding: u32 = 0x2F011000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field rot 13 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rot_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field rot = 0 (Min)
    // Fields: M=0, Rn=0, Rd=0, Q=0, Rm=0, size=0, rot=0, L=0, H=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field rot 13 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rot_1_poweroftwo_1000_2f003000() {
    // Encoding: 0x2F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field rot = 1 (PowerOfTwo)
    // Fields: Q=0, M=0, H=0, Rn=0, Rm=0, L=0, size=0, rot=1, Rd=0
    let encoding: u32 = 0x2F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field rot 13 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rot_3_max_1000_2f007000() {
    // Encoding: 0x2F007000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field rot = 3 (Max)
    // Fields: Rd=0, Rm=0, Rn=0, M=0, rot=3, H=0, size=0, L=0, Q=0
    let encoding: u32 = 0x2F007000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_h_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field H = 0 (Min)
    // Fields: Rm=0, L=0, rot=0, H=0, Rn=0, size=0, Rd=0, Q=0, M=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_h_1_max_1000_2f001800() {
    // Encoding: 0x2F001800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field H = 1 (Max)
    // Fields: L=0, H=1, size=0, Rm=0, Rn=0, Rd=0, M=0, Q=0, rot=0
    let encoding: u32 = 0x2F001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rn_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rn = 0 (Min)
    // Fields: rot=0, Rd=0, size=0, Rn=0, L=0, M=0, Rm=0, Q=0, H=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rn_1_poweroftwo_1000_2f001020() {
    // Encoding: 0x2F001020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rn = 1 (PowerOfTwo)
    // Fields: H=0, size=0, Rn=1, rot=0, Rd=0, M=0, Q=0, L=0, Rm=0
    let encoding: u32 = 0x2F001020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rn_30_poweroftwominusone_1000_2f0013c0() {
    // Encoding: 0x2F0013C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: rot=0, Rd=0, H=0, L=0, M=0, Rn=30, Q=0, size=0, Rm=0
    let encoding: u32 = 0x2F0013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rn_31_max_1000_2f0013e0() {
    // Encoding: 0x2F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rn = 31 (Max)
    // Fields: Q=0, L=0, Rn=31, H=0, M=0, size=0, Rd=0, rot=0, Rm=0
    let encoding: u32 = 0x2F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rd_0_min_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rd = 0 (Min)
    // Fields: Q=0, M=0, size=0, L=0, Rn=0, Rm=0, Rd=0, H=0, rot=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rd_1_poweroftwo_1000_2f001001() {
    // Encoding: 0x2F001001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, size=0, L=0, Q=0, Rm=0, Rn=0, M=0, rot=0, H=0
    let encoding: u32 = 0x2F001001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rd_30_poweroftwominusone_1000_2f00101e() {
    // Encoding: 0x2F00101E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rm=0, L=0, H=0, rot=0, Rd=30, Rn=0, size=0, M=0
    let encoding: u32 = 0x2F00101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_field_rd_31_max_1000_2f00101f() {
    // Encoding: 0x2F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field Rd = 31 (Max)
    // Fields: size=0, rot=0, M=0, H=0, Rd=31, L=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x2F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_combo_0_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex field combination: Q=0, size=0, L=0, M=0, Rm=0, rot=0, H=0, Rn=0, Rd=0
    // Fields: Rd=0, rot=0, Rm=0, L=0, M=0, Q=0, size=0, H=0, Rn=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_q_0_size_variant_0_4096_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value Q = 0 (Size variant 0)
    // Fields: size=0, Q=0, rot=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_q_1_size_variant_1_4096_6f001000() {
    // Encoding: 0x6F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value Q = 1 (Size variant 1)
    // Fields: L=0, M=0, rot=0, Rn=0, H=0, size=0, Rm=0, Q=1, Rd=0
    let encoding: u32 = 0x6F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_size_0_size_variant_0_4096_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value size = 0 (Size variant 0)
    // Fields: Rn=0, L=0, Q=0, H=0, Rd=0, rot=0, M=0, size=0, Rm=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_size_1_size_variant_1_4096_2f401000() {
    // Encoding: 0x2F401000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value size = 1 (Size variant 1)
    // Fields: Q=0, size=1, L=0, Rm=0, rot=0, Rn=0, M=0, H=0, Rd=0
    let encoding: u32 = 0x2F401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_size_2_size_variant_2_4096_2f801000() {
    // Encoding: 0x2F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value size = 2 (Size variant 2)
    // Fields: Rn=0, size=2, M=0, Rd=0, Rm=0, rot=0, H=0, Q=0, L=0
    let encoding: u32 = 0x2F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_size_3_size_variant_3_4096_2fc01000() {
    // Encoding: 0x2FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value size = 3 (Size variant 3)
    // Fields: M=0, H=0, Q=0, Rm=0, size=3, L=0, rot=0, Rn=0, Rd=0
    let encoding: u32 = 0x2FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_rn_31_stack_pointer_sp_may_require_alignment_4096_2f0013e0() {
    // Encoding: 0x2F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, Rm=0, Rn=31, size=0, M=0, rot=0, Q=0, Rd=0, H=0
    let encoding: u32 = 0x2F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_4096_2f00101f() {
    // Encoding: 0x2F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, L=0, H=0, Rn=0, rot=0, size=0, M=0, Rm=0, Rd=31
    let encoding: u32 = 0x2F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFCADDExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFCADDExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_0_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFCADDExt" }, args: [] } }
    // Fields: H=0, rot=0, Rm=0, Rd=0, L=0, Q=0, size=0, M=0, Rn=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_1_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unconditional UNDEFINED
    // Fields: M=0, rot=0, Q=0, H=0, L=0, Rn=0, Rd=0, Rm=0, size=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_2_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: Rn=0, Rm=0, Q=0, rot=0, Rd=0, H=0, M=0, L=0, size=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_3_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unconditional UNDEFINED
    // Fields: rot=0, Rd=0, H=0, Q=0, Rm=0, L=0, size=0, Rn=0, M=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "esize" }) }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"esize\" }) }, rhs: LitInt(16) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_4_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "esize" }) }, rhs: LitInt(16) }
    // Fields: M=0, rot=0, H=0, Rd=0, Q=0, size=0, L=0, Rm=0, Rn=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_5_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unconditional UNDEFINED
    // Fields: H=0, rot=0, Q=0, Rm=0, L=0, size=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "L" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }) } }, rhs: LitBits([false]) } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([true, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"L\" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }) } }, rhs: LitBits([false]) } } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_6_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, false]), rhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "L" }), rhs: Binary { op: Or, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }) } }, rhs: LitBits([false]) } } }
    // Fields: Q=0, L=0, rot=0, Rn=0, size=0, Rd=0, Rm=0, H=0, M=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_7_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, H=0, M=0, rot=0, Q=0, size=0, Rd=0, L=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "H" }) } }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }) } }, rhs: LitBits([false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"H\" }) } }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }) } }, rhs: LitBits([false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_8_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "H" }) } }, rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }) } }, rhs: LitBits([false]) }
    // Fields: rot=0, Rm=0, Rn=0, H=0, M=0, size=0, L=0, Q=0, Rd=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_invalid_9_1000_2f001000() {
    // Encoding: 0x2F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, rot=0, M=0, size=0, Rn=0, L=0, H=0, Rm=0, Rd=0
    let encoding: u32 = 0x2F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_reg_write_0_2f001000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex register write: SimdFromField("d")
    // Encoding: 0x2F001000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_sp_rn_2f0013e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex with Rn = SP (31)
    // Encoding: 0x2F0013E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F0013E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_complex
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_complex_zr_rd_2f00101f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_complex with Rd = ZR (31)
    // Encoding: 0x2F00101F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F00101F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_int Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_q_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Q = 0 (Min)
    // Fields: size=0, H=0, Rm=0, L=0, Rd=0, M=0, Rn=0, Q=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_q_1_max_8000_4f008000() {
    // Encoding: 0x4F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Q = 1 (Max)
    // Fields: Rd=0, M=0, Rn=0, size=0, Q=1, L=0, H=0, Rm=0
    let encoding: u32 = 0x4F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_size_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field size = 0 (Min)
    // Fields: L=0, Rn=0, size=0, H=0, Rm=0, Rd=0, M=0, Q=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_size_1_poweroftwo_8000_0f408000() {
    // Encoding: 0x0F408000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field size = 1 (PowerOfTwo)
    // Fields: H=0, M=0, L=0, Rm=0, Q=0, size=1, Rn=0, Rd=0
    let encoding: u32 = 0x0F408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_size_2_poweroftwo_8000_0f808000() {
    // Encoding: 0x0F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field size = 2 (PowerOfTwo)
    // Fields: Rd=0, Rn=0, M=0, L=0, Rm=0, Q=0, size=2, H=0
    let encoding: u32 = 0x0F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_size_3_max_8000_0fc08000() {
    // Encoding: 0x0FC08000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field size = 3 (Max)
    // Fields: M=0, L=0, Q=0, Rm=0, size=3, Rn=0, Rd=0, H=0
    let encoding: u32 = 0x0FC08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_l_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field L = 0 (Min)
    // Fields: size=0, Rn=0, H=0, Q=0, L=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_l_1_max_8000_0f208000() {
    // Encoding: 0x0F208000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field L = 1 (Max)
    // Fields: Rd=0, Rm=0, M=0, size=0, L=1, H=0, Q=0, Rn=0
    let encoding: u32 = 0x0F208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_m_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field M = 0 (Min)
    // Fields: L=0, H=0, Rm=0, Rd=0, Q=0, size=0, M=0, Rn=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_m_1_max_8000_0f108000() {
    // Encoding: 0x0F108000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field M = 1 (Max)
    // Fields: M=1, Rd=0, Q=0, Rm=0, L=0, H=0, Rn=0, size=0
    let encoding: u32 = 0x0F108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rm_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rm = 0 (Min)
    // Fields: Q=0, size=0, M=0, Rn=0, L=0, Rd=0, H=0, Rm=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rm_1_poweroftwo_8000_0f018000() {
    // Encoding: 0x0F018000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Q=0, Rn=0, Rm=1, L=0, size=0, M=0, H=0
    let encoding: u32 = 0x0F018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_h_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field H = 0 (Min)
    // Fields: M=0, Rd=0, L=0, Q=0, Rm=0, size=0, H=0, Rn=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_h_1_max_8000_0f008800() {
    // Encoding: 0x0F008800
    // Test aarch64_vector_arithmetic_binary_element_mul_int field H = 1 (Max)
    // Fields: Rd=0, Q=0, L=0, size=0, Rm=0, Rn=0, M=0, H=1
    let encoding: u32 = 0x0F008800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rn_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rn = 0 (Min)
    // Fields: H=0, L=0, Rm=0, Rn=0, Q=0, M=0, Rd=0, size=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rn_1_poweroftwo_8000_0f008020() {
    // Encoding: 0x0F008020
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, L=0, Rd=0, size=0, Rm=0, H=0, M=0, Rn=1
    let encoding: u32 = 0x0F008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rn_30_poweroftwominusone_8000_0f0083c0() {
    // Encoding: 0x0F0083C0
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, M=0, size=0, Rm=0, Rd=0, Rn=30, L=0, H=0
    let encoding: u32 = 0x0F0083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rn_31_max_8000_0f0083e0() {
    // Encoding: 0x0F0083E0
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rn = 31 (Max)
    // Fields: Rn=31, H=0, L=0, Rm=0, size=0, Rd=0, Q=0, M=0
    let encoding: u32 = 0x0F0083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rd_0_min_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rd = 0 (Min)
    // Fields: size=0, H=0, Rm=0, Rd=0, Rn=0, Q=0, L=0, M=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rd_1_poweroftwo_8000_0f008001() {
    // Encoding: 0x0F008001
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, M=0, H=0, Rd=1, L=0, Q=0, Rn=0
    let encoding: u32 = 0x0F008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rd_30_poweroftwominusone_8000_0f00801e() {
    // Encoding: 0x0F00801E
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, Rm=0, L=0, size=0, H=0, Q=0, Rn=0, Rd=30
    let encoding: u32 = 0x0F00801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_field_rd_31_max_8000_0f00801f() {
    // Encoding: 0x0F00801F
    // Test aarch64_vector_arithmetic_binary_element_mul_int field Rd = 31 (Max)
    // Fields: size=0, Rd=31, Q=0, L=0, Rm=0, H=0, M=0, Rn=0
    let encoding: u32 = 0x0F00801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_combo_0_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int field combination: Q=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: L=0, Q=0, size=0, H=0, Rn=0, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_q_0_size_variant_0_32768_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rm=0, Rd=0, L=0, M=0, H=0, size=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_q_1_size_variant_1_32768_4f008000() {
    // Encoding: 0x4F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value Q = 1 (Size variant 1)
    // Fields: Rm=0, L=0, Q=1, size=0, H=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x4F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_size_0_size_variant_0_32768_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value size = 0 (Size variant 0)
    // Fields: Rm=0, size=0, L=0, H=0, M=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_size_1_size_variant_1_32768_0f408000() {
    // Encoding: 0x0F408000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value size = 1 (Size variant 1)
    // Fields: H=0, Rn=0, Rd=0, Q=0, Rm=0, L=0, M=0, size=1
    let encoding: u32 = 0x0F408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_size_2_size_variant_2_32768_0f808000() {
    // Encoding: 0x0F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value size = 2 (Size variant 2)
    // Fields: L=0, Rm=0, H=0, Q=0, Rn=0, M=0, Rd=0, size=2
    let encoding: u32 = 0x0F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_size_3_size_variant_3_32768_0fc08000() {
    // Encoding: 0x0FC08000
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rm=0, L=0, Q=0, H=0, M=0, Rd=0, size=3
    let encoding: u32 = 0x0FC08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_rn_31_stack_pointer_sp_may_require_alignment_32768_0f0083e0() {
    // Encoding: 0x0F0083E0
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: M=0, Rm=0, H=0, size=0, Rn=31, Q=0, L=0, Rd=0
    let encoding: u32 = 0x0F0083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_32768_0f00801f() {
    // Encoding: 0x0F00801F
    // Test aarch64_vector_arithmetic_binary_element_mul_int special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: size=0, Rm=0, Rd=31, M=0, Rn=0, Q=0, L=0, H=0
    let encoding: u32 = 0x0F00801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_invalid_0_8000_0f008000() {
    // Encoding: 0x0F008000
    // Test aarch64_vector_arithmetic_binary_element_mul_int invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, Rn=0, Rm=0, M=0, H=0, Rd=0, size=0, L=0
    let encoding: u32 = 0x0F008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_reg_write_0_0f008000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_int register write: SimdFromField("d")
    // Encoding: 0x0F008000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_sp_rn_0f0083e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_int with Rn = SP (31)
    // Encoding: 0x0F0083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F0083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_int
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_int_zr_rd_0f00801f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_int with Rd = ZR (31)
    // Encoding: 0x0F00801F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_mul_accum Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_q_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Q = 0 (Min)
    // Fields: Rn=0, size=0, U=0, Rm=0, o1=0, Rd=0, Q=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_q_1_max_8000_4e208000() {
    // Encoding: 0x4E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Q = 1 (Max)
    // Fields: Rm=0, size=0, Rn=0, Q=1, Rd=0, U=0, o1=0
    let encoding: u32 = 0x4E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_u_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field U = 0 (Min)
    // Fields: Rd=0, U=0, size=0, Q=0, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_u_1_max_8000_2e208000() {
    // Encoding: 0x2E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field U = 1 (Max)
    // Fields: Rm=0, size=0, U=1, o1=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_size_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field size = 0 (Min)
    // Fields: U=0, o1=0, size=0, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_size_1_poweroftwo_8000_0e608000() {
    // Encoding: 0x0E608000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field size = 1 (PowerOfTwo)
    // Fields: size=1, Q=0, Rm=0, o1=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_size_2_poweroftwo_8000_0ea08000() {
    // Encoding: 0x0EA08000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field size = 2 (PowerOfTwo)
    // Fields: o1=0, U=0, size=2, Rn=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0EA08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_size_3_max_8000_0ee08000() {
    // Encoding: 0x0EE08000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field size = 3 (Max)
    // Fields: Rd=0, U=0, Rm=0, o1=0, size=3, Rn=0, Q=0
    let encoding: u32 = 0x0EE08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rm_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rm = 0 (Min)
    // Fields: Rd=0, Rn=0, U=0, size=0, Q=0, Rm=0, o1=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rm_1_poweroftwo_8000_0e218000() {
    // Encoding: 0x0E218000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, o1=0, size=0, U=0, Rd=0, Rn=0, Rm=1
    let encoding: u32 = 0x0E218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rm_30_poweroftwominusone_8000_0e3e8000() {
    // Encoding: 0x0E3E8000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, Rm=30, o1=0, Rd=0, U=0, Rn=0
    let encoding: u32 = 0x0E3E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rm_31_max_8000_0e3f8000() {
    // Encoding: 0x0E3F8000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rm = 31 (Max)
    // Fields: Rn=0, size=0, Rm=31, U=0, o1=0, Q=0, Rd=0
    let encoding: u32 = 0x0E3F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_o1_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field o1 = 0 (Min)
    // Fields: Rd=0, Q=0, U=0, size=0, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_o1_1_max_8000_0e20a000() {
    // Encoding: 0x0E20A000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field o1 = 1 (Max)
    // Fields: Rm=0, Q=0, o1=1, size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rn_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0, Q=0, size=0, o1=0, U=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rn_1_poweroftwo_8000_0e208020() {
    // Encoding: 0x0E208020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rn=1, size=0, o1=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0E208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rn_30_poweroftwominusone_8000_0e2083c0() {
    // Encoding: 0x0E2083C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Q=0, Rm=0, Rn=30, Rd=0, o1=0, U=0
    let encoding: u32 = 0x0E2083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rn_31_max_8000_0e2083e0() {
    // Encoding: 0x0E2083E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rn = 31 (Max)
    // Fields: U=0, Rn=31, size=0, Rd=0, Rm=0, Q=0, o1=0
    let encoding: u32 = 0x0E2083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rd_0_min_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, size=0, U=0, o1=0, Q=0, Rm=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rd_1_poweroftwo_8000_0e208001() {
    // Encoding: 0x0E208001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Q=0, o1=0, Rd=1, size=0, U=0, Rm=0
    let encoding: u32 = 0x0E208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rd_30_poweroftwominusone_8000_0e20801e() {
    // Encoding: 0x0E20801E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o1=0, size=0, Rn=0, Rd=30, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E20801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_field_rd_31_max_8000_0e20801f() {
    // Encoding: 0x0E20801F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field Rd = 31 (Max)
    // Fields: o1=0, U=0, Rd=31, Q=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0x0E20801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_combo_0_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum field combination: Q=0, U=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: Q=0, o1=0, Rm=0, Rn=0, Rd=0, U=0, size=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_q_0_size_variant_0_32768_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value Q = 0 (Size variant 0)
    // Fields: o1=0, Rn=0, Q=0, Rd=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_q_1_size_variant_1_32768_4e208000() {
    // Encoding: 0x4E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Rm=0, Q=1, o1=0, U=0, size=0
    let encoding: u32 = 0x4E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_size_0_size_variant_0_32768_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value size = 0 (Size variant 0)
    // Fields: size=0, U=0, Rm=0, Rn=0, Q=0, Rd=0, o1=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_size_1_size_variant_1_32768_0e608000() {
    // Encoding: 0x0E608000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value size = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, size=1, Q=0, U=0, o1=0, Rn=0
    let encoding: u32 = 0x0E608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_size_2_size_variant_2_32768_0ea08000() {
    // Encoding: 0x0EA08000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value size = 2 (Size variant 2)
    // Fields: Rn=0, o1=0, size=2, U=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0EA08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_size_3_size_variant_3_32768_0ee08000() {
    // Encoding: 0x0EE08000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value size = 3 (Size variant 3)
    // Fields: Rm=0, o1=0, Rn=0, Rd=0, Q=0, size=3, U=0
    let encoding: u32 = 0x0EE08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_rn_31_stack_pointer_sp_may_require_alignment_32768_0e2083e0() {
    // Encoding: 0x0E2083E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, o1=0, Q=0, size=0, Rd=0, Rm=0, Rn=31
    let encoding: u32 = 0x0E2083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_32768_0e20801f() {
    // Encoding: 0x0E20801F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, o1=0, Rn=0, U=0, Rd=31, Q=0, size=0
    let encoding: u32 = 0x0E20801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_invalid_0_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: size=0, Rn=0, Rd=0, Q=0, U=0, Rm=0, o1=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_invalid_1_8000_0e208000() {
    // Encoding: 0x0E208000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Q=0, o1=0, Rm=0, Rn=0, U=0, size=0
    let encoding: u32 = 0x0E208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_reg_write_0_0e208000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum register write: SimdFromField("d")
    // Encoding: 0x0E208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_sp_rn_0e2083e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum with Rn = SP (31)
    // Encoding: 0x0E2083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_accum
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_accum_zr_rd_0e20801f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_accum with Rd = ZR (31)
    // Encoding: 0x0E20801F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_high_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_size_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field size = 0 (Min)
    // Fields: Rd=0, H=0, Rn=0, L=0, Rm=0, op=0, size=0, M=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_size_1_poweroftwo_c000_5f40c000() {
    // Encoding: 0x5F40C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field size = 1 (PowerOfTwo)
    // Fields: op=0, Rn=0, Rm=0, Rd=0, M=0, size=1, H=0, L=0
    let encoding: u32 = 0x5F40C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_size_2_poweroftwo_c000_5f80c000() {
    // Encoding: 0x5F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field size = 2 (PowerOfTwo)
    // Fields: size=2, H=0, op=0, Rd=0, M=0, L=0, Rm=0, Rn=0
    let encoding: u32 = 0x5F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_size_3_max_c000_5fc0c000() {
    // Encoding: 0x5FC0C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field size = 3 (Max)
    // Fields: Rm=0, Rd=0, op=0, Rn=0, M=0, L=0, size=3, H=0
    let encoding: u32 = 0x5FC0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_l_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field L = 0 (Min)
    // Fields: H=0, Rn=0, Rd=0, size=0, L=0, Rm=0, M=0, op=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_l_1_max_c000_5f20c000() {
    // Encoding: 0x5F20C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field L = 1 (Max)
    // Fields: op=0, Rn=0, size=0, Rd=0, Rm=0, H=0, M=0, L=1
    let encoding: u32 = 0x5F20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_m_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field M = 0 (Min)
    // Fields: size=0, op=0, Rd=0, Rn=0, L=0, H=0, Rm=0, M=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_m_1_max_c000_5f10c000() {
    // Encoding: 0x5F10C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field M = 1 (Max)
    // Fields: M=1, size=0, Rm=0, H=0, Rd=0, op=0, L=0, Rn=0
    let encoding: u32 = 0x5F10C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rm_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rm = 0 (Min)
    // Fields: M=0, Rd=0, size=0, Rn=0, H=0, L=0, op=0, Rm=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rm_1_poweroftwo_c000_5f01c000() {
    // Encoding: 0x5F01C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rm = 1 (PowerOfTwo)
    // Fields: L=0, op=0, Rm=1, size=0, M=0, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x5F01C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_op_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field op = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, H=0, op=0, Rd=0, M=0, L=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_op_1_max_c000_5f00d000() {
    // Encoding: 0x5F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field op = 1 (Max)
    // Fields: Rd=0, L=0, op=1, M=0, size=0, H=0, Rn=0, Rm=0
    let encoding: u32 = 0x5F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_h_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field H = 0 (Min)
    // Fields: op=0, Rn=0, size=0, M=0, L=0, H=0, Rd=0, Rm=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_h_1_max_c000_5f00c800() {
    // Encoding: 0x5F00C800
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field H = 1 (Max)
    // Fields: Rn=0, M=0, size=0, L=0, Rd=0, Rm=0, op=0, H=1
    let encoding: u32 = 0x5F00C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rn_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rn = 0 (Min)
    // Fields: L=0, Rn=0, op=0, H=0, M=0, Rd=0, Rm=0, size=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rn_1_poweroftwo_c000_5f00c020() {
    // Encoding: 0x5F00C020
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, op=0, Rm=0, L=0, size=0, M=0, H=0, Rn=1
    let encoding: u32 = 0x5F00C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rn_30_poweroftwominusone_c000_5f00c3c0() {
    // Encoding: 0x5F00C3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: L=0, H=0, Rd=0, Rm=0, size=0, M=0, op=0, Rn=30
    let encoding: u32 = 0x5F00C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rn_31_max_c000_5f00c3e0() {
    // Encoding: 0x5F00C3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rn = 31 (Max)
    // Fields: Rd=0, H=0, size=0, L=0, Rn=31, M=0, op=0, Rm=0
    let encoding: u32 = 0x5F00C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rd_0_min_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rd = 0 (Min)
    // Fields: Rd=0, size=0, Rm=0, op=0, H=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rd_1_poweroftwo_c000_5f00c001() {
    // Encoding: 0x5F00C001
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rd = 1 (PowerOfTwo)
    // Fields: H=0, size=0, L=0, Rn=0, op=0, Rm=0, Rd=1, M=0
    let encoding: u32 = 0x5F00C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rd_30_poweroftwominusone_c000_5f00c01e() {
    // Encoding: 0x5F00C01E
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, size=0, Rm=0, L=0, Rn=0, M=0, op=0, H=0
    let encoding: u32 = 0x5F00C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_field_rd_31_max_c000_5f00c01f() {
    // Encoding: 0x5F00C01F
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field Rd = 31 (Max)
    // Fields: Rd=31, H=0, Rm=0, op=0, size=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x5F00C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_combo_0_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd field combination: size=0, L=0, M=0, Rm=0, op=0, H=0, Rn=0, Rd=0
    // Fields: Rd=0, M=0, size=0, Rn=0, H=0, L=0, op=0, Rm=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_size_0_size_variant_0_49152_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value size = 0 (Size variant 0)
    // Fields: H=0, L=0, size=0, Rn=0, op=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_size_1_size_variant_1_49152_5f40c000() {
    // Encoding: 0x5F40C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value size = 1 (Size variant 1)
    // Fields: L=0, M=0, Rn=0, Rm=0, op=0, Rd=0, H=0, size=1
    let encoding: u32 = 0x5F40C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_size_2_size_variant_2_49152_5f80c000() {
    // Encoding: 0x5F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value size = 2 (Size variant 2)
    // Fields: M=0, L=0, Rm=0, op=0, H=0, size=2, Rd=0, Rn=0
    let encoding: u32 = 0x5F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_size_3_size_variant_3_49152_5fc0c000() {
    // Encoding: 0x5FC0C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value size = 3 (Size variant 3)
    // Fields: L=0, size=3, Rm=0, op=0, Rn=0, M=0, H=0, Rd=0
    let encoding: u32 = 0x5FC0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_49152_5f00c3e0() {
    // Encoding: 0x5F00C3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rd=0, op=0, H=0, Rn=31, size=0, L=0, M=0
    let encoding: u32 = 0x5F00C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_49152_5f00c01f() {
    // Encoding: 0x5F00C01F
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: op=0, H=0, size=0, M=0, Rd=31, L=0, Rn=0, Rm=0
    let encoding: u32 = 0x5F00C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_invalid_0_c000_5f00c000() {
    // Encoding: 0x5F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, H=0, M=0, op=0, Rn=0, Rd=0, L=0
    let encoding: u32 = 0x5F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_q_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Q = 0 (Min)
    // Fields: M=0, L=0, Rn=0, Q=0, op=0, size=0, Rd=0, Rm=0, H=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_q_1_max_c000_4f00c000() {
    // Encoding: 0x4F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Q = 1 (Max)
    // Fields: H=0, size=0, op=0, Q=1, L=0, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x4F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_size_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field size = 0 (Min)
    // Fields: M=0, size=0, H=0, Rm=0, Q=0, L=0, Rn=0, Rd=0, op=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_size_1_poweroftwo_c000_0f40c000() {
    // Encoding: 0x0F40C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field size = 1 (PowerOfTwo)
    // Fields: M=0, L=0, H=0, size=1, Rd=0, Q=0, Rn=0, Rm=0, op=0
    let encoding: u32 = 0x0F40C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_size_2_poweroftwo_c000_0f80c000() {
    // Encoding: 0x0F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field size = 2 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rm=0, H=0, Rd=0, size=2, L=0, M=0, op=0
    let encoding: u32 = 0x0F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_size_3_max_c000_0fc0c000() {
    // Encoding: 0x0FC0C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field size = 3 (Max)
    // Fields: op=0, size=3, Rm=0, M=0, Rd=0, Rn=0, Q=0, H=0, L=0
    let encoding: u32 = 0x0FC0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_l_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field L = 0 (Min)
    // Fields: L=0, op=0, Rd=0, Q=0, H=0, size=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_l_1_max_c000_0f20c000() {
    // Encoding: 0x0F20C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field L = 1 (Max)
    // Fields: size=0, op=0, H=0, L=1, M=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0F20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_m_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field M = 0 (Min)
    // Fields: M=0, op=0, Rn=0, Q=0, Rd=0, size=0, Rm=0, L=0, H=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_m_1_max_c000_0f10c000() {
    // Encoding: 0x0F10C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field M = 1 (Max)
    // Fields: Q=0, H=0, Rd=0, op=0, size=0, Rm=0, Rn=0, L=0, M=1
    let encoding: u32 = 0x0F10C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rm_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rm = 0 (Min)
    // Fields: size=0, Rn=0, H=0, Q=0, L=0, M=0, Rm=0, Rd=0, op=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rm_1_poweroftwo_c000_0f01c000() {
    // Encoding: 0x0F01C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rm = 1 (PowerOfTwo)
    // Fields: op=0, size=0, Q=0, Rm=1, Rd=0, L=0, Rn=0, H=0, M=0
    let encoding: u32 = 0x0F01C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_op_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field op = 0 (Min)
    // Fields: size=0, Rm=0, Q=0, L=0, M=0, H=0, Rn=0, op=0, Rd=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field op 12 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_op_1_max_c000_0f00d000() {
    // Encoding: 0x0F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field op = 1 (Max)
    // Fields: Rd=0, size=0, L=0, M=0, op=1, Rm=0, Q=0, H=0, Rn=0
    let encoding: u32 = 0x0F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_h_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field H = 0 (Min)
    // Fields: Rm=0, H=0, Q=0, Rn=0, Rd=0, L=0, size=0, op=0, M=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_h_1_max_c000_0f00c800() {
    // Encoding: 0x0F00C800
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field H = 1 (Max)
    // Fields: L=0, H=1, M=0, Rm=0, size=0, op=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0F00C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rn_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rn = 0 (Min)
    // Fields: Rm=0, op=0, Rn=0, M=0, Q=0, H=0, L=0, size=0, Rd=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rn_1_poweroftwo_c000_0f00c020() {
    // Encoding: 0x0F00C020
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, size=0, Rm=0, M=0, op=0, H=0, Rn=1, Q=0, L=0
    let encoding: u32 = 0x0F00C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rn_30_poweroftwominusone_c000_0f00c3c0() {
    // Encoding: 0x0F00C3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: L=0, size=0, Rm=0, H=0, Rd=0, M=0, Rn=30, Q=0, op=0
    let encoding: u32 = 0x0F00C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rn_31_max_c000_0f00c3e0() {
    // Encoding: 0x0F00C3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rn = 31 (Max)
    // Fields: M=0, size=0, Rd=0, Q=0, L=0, Rm=0, op=0, H=0, Rn=31
    let encoding: u32 = 0x0F00C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rd_0_min_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rd = 0 (Min)
    // Fields: M=0, H=0, Rm=0, Q=0, L=0, Rd=0, op=0, Rn=0, size=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rd_1_poweroftwo_c000_0f00c001() {
    // Encoding: 0x0F00C001
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, size=0, op=0, M=0, Rd=1, Rm=0, L=0, H=0, Q=0
    let encoding: u32 = 0x0F00C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rd_30_poweroftwominusone_c000_0f00c01e() {
    // Encoding: 0x0F00C01E
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, M=0, Rm=0, op=0, L=0, Q=0, size=0, H=0, Rn=0
    let encoding: u32 = 0x0F00C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_field_rd_31_max_c000_0f00c01f() {
    // Encoding: 0x0F00C01F
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field Rd = 31 (Max)
    // Fields: size=0, M=0, Q=0, L=0, Rn=0, op=0, H=0, Rd=31, Rm=0
    let encoding: u32 = 0x0F00C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_combo_0_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd field combination: Q=0, size=0, L=0, M=0, Rm=0, op=0, H=0, Rn=0, Rd=0
    // Fields: op=0, Rn=0, size=0, L=0, M=0, H=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_q_0_size_variant_0_49152_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value Q = 0 (Size variant 0)
    // Fields: size=0, L=0, H=0, Rm=0, Q=0, M=0, Rn=0, Rd=0, op=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_q_1_size_variant_1_49152_4f00c000() {
    // Encoding: 0x4F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value Q = 1 (Size variant 1)
    // Fields: H=0, M=0, L=0, Rd=0, size=0, Rm=0, Q=1, op=0, Rn=0
    let encoding: u32 = 0x4F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_size_0_size_variant_0_49152_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value size = 0 (Size variant 0)
    // Fields: L=0, Q=0, size=0, M=0, H=0, op=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_size_1_size_variant_1_49152_0f40c000() {
    // Encoding: 0x0F40C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value size = 1 (Size variant 1)
    // Fields: Q=0, op=0, size=1, Rm=0, Rn=0, Rd=0, H=0, M=0, L=0
    let encoding: u32 = 0x0F40C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_size_2_size_variant_2_49152_0f80c000() {
    // Encoding: 0x0F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value size = 2 (Size variant 2)
    // Fields: Rd=0, Q=0, L=0, H=0, op=0, M=0, Rm=0, Rn=0, size=2
    let encoding: u32 = 0x0F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_size_3_size_variant_3_49152_0fc0c000() {
    // Encoding: 0x0FC0C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, op=0, H=0, size=3, Rd=0, Rm=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x0FC0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_rn_31_stack_pointer_sp_may_require_alignment_49152_0f00c3e0() {
    // Encoding: 0x0F00C3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, H=0, Rn=31, Rm=0, Rd=0, op=0, M=0, Q=0, size=0
    let encoding: u32 = 0x0F00C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_49152_0f00c01f() {
    // Encoding: 0x0F00C01F
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: H=0, M=0, Q=0, size=0, L=0, Rd=31, Rm=0, op=0, Rn=0
    let encoding: u32 = 0x0F00C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_invalid_0_c000_0f00c000() {
    // Encoding: 0x0F00C000
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, size=0, L=0, H=0, Rn=0, Q=0, M=0, Rm=0, op=0
    let encoding: u32 = 0x0F00C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_reg_write_0_5f00c000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd register write: SimdFromField("d")
    // Encoding: 0x5F00C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_sp_rn_5f00c3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd with Rn = SP (31)
    // Encoding: 0x5F00C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_sisd_zr_rd_5f00c01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_sisd with Rd = ZR (31)
    // Encoding: 0x5F00C01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00C01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_reg_write_0_0f00c000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd register write: SimdFromField("d")
    // Encoding: 0x0F00C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_sp_rn_0f00c3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd with Rn = SP (31)
    // Encoding: 0x0F00C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_high_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_high_simd_zr_rd_0f00c01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_high_simd with Rd = ZR (31)
    // Encoding: 0x0F00C01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00C01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_size_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field size = 0 (Min)
    // Fields: S=0, Rn=0, Rm=0, L=0, Rd=0, size=0, M=0, H=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_size_1_poweroftwo_d000_7f40d000() {
    // Encoding: 0x7F40D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field size = 1 (PowerOfTwo)
    // Fields: S=0, Rm=0, H=0, Rd=0, Rn=0, L=0, size=1, M=0
    let encoding: u32 = 0x7F40D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_size_2_poweroftwo_d000_7f80d000() {
    // Encoding: 0x7F80D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field size = 2 (PowerOfTwo)
    // Fields: M=0, S=0, L=0, Rd=0, size=2, Rm=0, H=0, Rn=0
    let encoding: u32 = 0x7F80D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_size_3_max_d000_7fc0d000() {
    // Encoding: 0x7FC0D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field size = 3 (Max)
    // Fields: M=0, S=0, Rd=0, L=0, Rn=0, Rm=0, H=0, size=3
    let encoding: u32 = 0x7FC0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_l_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field L = 0 (Min)
    // Fields: H=0, S=0, Rd=0, M=0, size=0, Rn=0, L=0, Rm=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_l_1_max_d000_7f20d000() {
    // Encoding: 0x7F20D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field L = 1 (Max)
    // Fields: H=0, Rm=0, Rd=0, Rn=0, L=1, M=0, S=0, size=0
    let encoding: u32 = 0x7F20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_m_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field M = 0 (Min)
    // Fields: M=0, Rn=0, Rd=0, L=0, Rm=0, size=0, H=0, S=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_m_1_max_d000_7f10d000() {
    // Encoding: 0x7F10D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field M = 1 (Max)
    // Fields: H=0, Rn=0, Rm=0, size=0, Rd=0, L=0, S=0, M=1
    let encoding: u32 = 0x7F10D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rm_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rm = 0 (Min)
    // Fields: Rm=0, M=0, Rd=0, Rn=0, H=0, L=0, size=0, S=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rm_1_poweroftwo_d000_7f01d000() {
    // Encoding: 0x7F01D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rm = 1 (PowerOfTwo)
    // Fields: S=0, Rm=1, Rn=0, size=0, L=0, H=0, M=0, Rd=0
    let encoding: u32 = 0x7F01D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field S 13 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_s_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field S = 0 (Min)
    // Fields: Rm=0, size=0, Rd=0, Rn=0, L=0, M=0, S=0, H=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field S 13 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_s_1_max_d000_7f00f000() {
    // Encoding: 0x7F00F000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field S = 1 (Max)
    // Fields: L=0, H=0, Rn=0, M=0, size=0, Rd=0, S=1, Rm=0
    let encoding: u32 = 0x7F00F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_h_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field H = 0 (Min)
    // Fields: size=0, S=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_h_1_max_d000_7f00d800() {
    // Encoding: 0x7F00D800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field H = 1 (Max)
    // Fields: size=0, M=0, Rm=0, Rd=0, L=0, H=1, Rn=0, S=0
    let encoding: u32 = 0x7F00D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rn_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rn = 0 (Min)
    // Fields: size=0, Rn=0, M=0, L=0, H=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rn_1_poweroftwo_d000_7f00d020() {
    // Encoding: 0x7F00D020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rn = 1 (PowerOfTwo)
    // Fields: M=0, size=0, S=0, L=0, H=0, Rn=1, Rm=0, Rd=0
    let encoding: u32 = 0x7F00D020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rn_30_poweroftwominusone_d000_7f00d3c0() {
    // Encoding: 0x7F00D3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, L=0, Rd=0, H=0, M=0, Rn=30, size=0, S=0
    let encoding: u32 = 0x7F00D3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rn_31_max_d000_7f00d3e0() {
    // Encoding: 0x7F00D3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rn = 31 (Max)
    // Fields: Rn=31, M=0, Rd=0, S=0, Rm=0, H=0, L=0, size=0
    let encoding: u32 = 0x7F00D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rd_0_min_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rd = 0 (Min)
    // Fields: L=0, Rd=0, M=0, S=0, Rn=0, H=0, size=0, Rm=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rd_1_poweroftwo_d000_7f00d001() {
    // Encoding: 0x7F00D001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rd = 1 (PowerOfTwo)
    // Fields: M=0, H=0, S=0, Rn=0, Rm=0, size=0, L=0, Rd=1
    let encoding: u32 = 0x7F00D001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rd_30_poweroftwominusone_d000_7f00d01e() {
    // Encoding: 0x7F00D01E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, S=0, M=0, Rd=30, H=0, size=0, L=0, Rm=0
    let encoding: u32 = 0x7F00D01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_field_rd_31_max_d000_7f00d01f() {
    // Encoding: 0x7F00D01F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field Rd = 31 (Max)
    // Fields: L=0, M=0, Rm=0, S=0, H=0, Rd=31, Rn=0, size=0
    let encoding: u32 = 0x7F00D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_combo_0_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd field combination: size=0, L=0, M=0, Rm=0, S=0, H=0, Rn=0, Rd=0
    // Fields: Rd=0, H=0, Rm=0, Rn=0, M=0, S=0, L=0, size=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_size_0_size_variant_0_53248_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value size = 0 (Size variant 0)
    // Fields: M=0, Rd=0, Rm=0, Rn=0, L=0, S=0, H=0, size=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_size_1_size_variant_1_53248_7f40d000() {
    // Encoding: 0x7F40D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value size = 1 (Size variant 1)
    // Fields: Rd=0, size=1, M=0, S=0, Rm=0, Rn=0, H=0, L=0
    let encoding: u32 = 0x7F40D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_size_2_size_variant_2_53248_7f80d000() {
    // Encoding: 0x7F80D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value size = 2 (Size variant 2)
    // Fields: Rm=0, S=0, H=0, Rn=0, Rd=0, size=2, L=0, M=0
    let encoding: u32 = 0x7F80D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_size_3_size_variant_3_53248_7fc0d000() {
    // Encoding: 0x7FC0D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value size = 3 (Size variant 3)
    // Fields: M=0, L=0, H=0, Rm=0, Rn=0, size=3, Rd=0, S=0
    let encoding: u32 = 0x7FC0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_s_0_size_variant_0_53248_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value S = 0 (Size variant 0)
    // Fields: L=0, Rn=0, Rm=0, M=0, S=0, size=0, Rd=0, H=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_s_1_size_variant_1_53248_7f00f000() {
    // Encoding: 0x7F00F000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value S = 1 (Size variant 1)
    // Fields: S=1, Rm=0, size=0, L=0, Rn=0, H=0, M=0, Rd=0
    let encoding: u32 = 0x7F00F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_53248_7f00d3e0() {
    // Encoding: 0x7F00D3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, S=0, H=0, Rd=0, Rn=31, M=0, Rm=0, size=0
    let encoding: u32 = 0x7F00D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_53248_7f00d01f() {
    // Encoding: 0x7F00D01F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: S=0, M=0, H=0, Rd=31, L=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0x7F00D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveQRDMLAHExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_invalid_0_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }
    // Fields: Rn=0, size=0, H=0, S=0, L=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_invalid_1_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, H=0, S=0, L=0, size=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_invalid_2_d000_7f00d000() {
    // Encoding: 0x7F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, H=0, Rm=0, L=0, S=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x7F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_q_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Q = 0 (Min)
    // Fields: Rd=0, size=0, S=0, M=0, Rm=0, Rn=0, Q=0, L=0, H=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_q_1_max_d000_6f00d000() {
    // Encoding: 0x6F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Q = 1 (Max)
    // Fields: M=0, Rm=0, S=0, H=0, Q=1, size=0, L=0, Rn=0, Rd=0
    let encoding: u32 = 0x6F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_size_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field size = 0 (Min)
    // Fields: Rd=0, Rm=0, S=0, M=0, L=0, Q=0, H=0, Rn=0, size=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_size_1_poweroftwo_d000_2f40d000() {
    // Encoding: 0x2F40D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field size = 1 (PowerOfTwo)
    // Fields: S=0, Rd=0, L=0, Rm=0, M=0, size=1, Q=0, Rn=0, H=0
    let encoding: u32 = 0x2F40D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_size_2_poweroftwo_d000_2f80d000() {
    // Encoding: 0x2F80D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field size = 2 (PowerOfTwo)
    // Fields: Rd=0, Rm=0, size=2, L=0, H=0, Rn=0, Q=0, M=0, S=0
    let encoding: u32 = 0x2F80D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_size_3_max_d000_2fc0d000() {
    // Encoding: 0x2FC0D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field size = 3 (Max)
    // Fields: size=3, L=0, S=0, Rm=0, H=0, Rn=0, Q=0, M=0, Rd=0
    let encoding: u32 = 0x2FC0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_l_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field L = 0 (Min)
    // Fields: size=0, S=0, L=0, Q=0, Rd=0, M=0, Rn=0, Rm=0, H=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_l_1_max_d000_2f20d000() {
    // Encoding: 0x2F20D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field L = 1 (Max)
    // Fields: Rd=0, H=0, Rn=0, M=0, size=0, Q=0, S=0, Rm=0, L=1
    let encoding: u32 = 0x2F20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_m_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field M = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, L=0, M=0, size=0, H=0, Q=0, S=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_m_1_max_d000_2f10d000() {
    // Encoding: 0x2F10D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field M = 1 (Max)
    // Fields: Rm=0, S=0, Rd=0, Q=0, size=0, Rn=0, H=0, L=0, M=1
    let encoding: u32 = 0x2F10D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rm_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rm = 0 (Min)
    // Fields: Rd=0, Rm=0, size=0, L=0, S=0, H=0, Rn=0, M=0, Q=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rm_1_poweroftwo_d000_2f01d000() {
    // Encoding: 0x2F01D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rm = 1 (PowerOfTwo)
    // Fields: S=0, Q=0, Rn=0, L=0, Rd=0, Rm=1, H=0, size=0, M=0
    let encoding: u32 = 0x2F01D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field S 13 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_s_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field S = 0 (Min)
    // Fields: M=0, Rm=0, Rd=0, L=0, size=0, Q=0, S=0, H=0, Rn=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field S 13 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_s_1_max_d000_2f00f000() {
    // Encoding: 0x2F00F000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field S = 1 (Max)
    // Fields: size=0, H=0, Q=0, L=0, S=1, Rd=0, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x2F00F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_h_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field H = 0 (Min)
    // Fields: Rm=0, size=0, L=0, H=0, M=0, S=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_h_1_max_d000_2f00d800() {
    // Encoding: 0x2F00D800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field H = 1 (Max)
    // Fields: S=0, M=0, L=0, Rn=0, H=1, Q=0, Rm=0, size=0, Rd=0
    let encoding: u32 = 0x2F00D800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rn_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rn = 0 (Min)
    // Fields: Q=0, size=0, M=0, H=0, Rd=0, L=0, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rn_1_poweroftwo_d000_2f00d020() {
    // Encoding: 0x2F00D020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rn = 1 (PowerOfTwo)
    // Fields: M=0, Q=0, L=0, S=0, Rn=1, H=0, Rd=0, size=0, Rm=0
    let encoding: u32 = 0x2F00D020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rn_30_poweroftwominusone_d000_2f00d3c0() {
    // Encoding: 0x2F00D3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Q=0, H=0, Rd=0, S=0, L=0, size=0, M=0, Rn=30
    let encoding: u32 = 0x2F00D3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rn_31_max_d000_2f00d3e0() {
    // Encoding: 0x2F00D3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rn = 31 (Max)
    // Fields: S=0, Q=0, Rn=31, L=0, H=0, Rd=0, size=0, Rm=0, M=0
    let encoding: u32 = 0x2F00D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rd_0_min_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rd = 0 (Min)
    // Fields: Q=0, M=0, S=0, Rm=0, L=0, Rn=0, Rd=0, H=0, size=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rd_1_poweroftwo_d000_2f00d001() {
    // Encoding: 0x2F00D001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, S=0, Rn=0, size=0, L=0, Rm=0, H=0, Rd=1, M=0
    let encoding: u32 = 0x2F00D001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rd_30_poweroftwominusone_d000_2f00d01e() {
    // Encoding: 0x2F00D01E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, size=0, Q=0, Rn=0, H=0, M=0, S=0, Rd=30, L=0
    let encoding: u32 = 0x2F00D01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_field_rd_31_max_d000_2f00d01f() {
    // Encoding: 0x2F00D01F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field Rd = 31 (Max)
    // Fields: S=0, M=0, H=0, size=0, Rm=0, Rn=0, Rd=31, L=0, Q=0
    let encoding: u32 = 0x2F00D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_combo_0_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd field combination: Q=0, size=0, L=0, M=0, Rm=0, S=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, M=0, Q=0, size=0, H=0, L=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_q_0_size_variant_0_53248_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value Q = 0 (Size variant 0)
    // Fields: size=0, L=0, Q=0, M=0, H=0, Rm=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_q_1_size_variant_1_53248_6f00d000() {
    // Encoding: 0x6F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, M=0, S=0, Rn=0, size=0, Rm=0, L=0, H=0, Rd=0
    let encoding: u32 = 0x6F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_size_0_size_variant_0_53248_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value size = 0 (Size variant 0)
    // Fields: Rd=0, H=0, M=0, Rm=0, Rn=0, Q=0, size=0, L=0, S=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_size_1_size_variant_1_53248_2f40d000() {
    // Encoding: 0x2F40D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value size = 1 (Size variant 1)
    // Fields: Rn=0, H=0, Rm=0, size=1, M=0, S=0, Q=0, Rd=0, L=0
    let encoding: u32 = 0x2F40D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_size_2_size_variant_2_53248_2f80d000() {
    // Encoding: 0x2F80D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value size = 2 (Size variant 2)
    // Fields: H=0, M=0, Rd=0, Rn=0, L=0, size=2, Q=0, Rm=0, S=0
    let encoding: u32 = 0x2F80D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_size_3_size_variant_3_53248_2fc0d000() {
    // Encoding: 0x2FC0D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value size = 3 (Size variant 3)
    // Fields: M=0, L=0, Q=0, size=3, Rn=0, Rm=0, S=0, H=0, Rd=0
    let encoding: u32 = 0x2FC0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_s_0_size_variant_0_53248_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value S = 0 (Size variant 0)
    // Fields: M=0, Rm=0, size=0, Rd=0, S=0, H=0, L=0, Rn=0, Q=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_s_1_size_variant_1_53248_2f00f000() {
    // Encoding: 0x2F00F000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value S = 1 (Size variant 1)
    // Fields: Rd=0, size=0, M=0, S=1, H=0, Q=0, Rm=0, L=0, Rn=0
    let encoding: u32 = 0x2F00F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_rn_31_stack_pointer_sp_may_require_alignment_53248_2f00d3e0() {
    // Encoding: 0x2F00D3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: M=0, L=0, Rm=0, Q=0, size=0, H=0, Rn=31, Rd=0, S=0
    let encoding: u32 = 0x2F00D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_53248_2f00d01f() {
    // Encoding: 0x2F00D01F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: H=0, S=0, size=0, Q=0, Rm=0, Rd=31, M=0, Rn=0, L=0
    let encoding: u32 = 0x2F00D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveQRDMLAHExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_invalid_0_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }
    // Fields: L=0, Rn=0, Rd=0, Q=0, Rm=0, S=0, H=0, M=0, size=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_invalid_1_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, S=0, Q=0, H=0, size=0, M=0, L=0, Rd=0, Rn=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_invalid_2_d000_2f00d000() {
    // Encoding: 0x2F00D000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd invalid encoding: Unconditional UNDEFINED
    // Fields: M=0, H=0, size=0, L=0, Rn=0, Rd=0, Q=0, S=0, Rm=0
    let encoding: u32 = 0x2F00D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_reg_write_0_7f00d000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd register write: SimdFromField("d")
    // Encoding: 0x7F00D000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7F00D000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_sp_rn_7f00d3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd with Rn = SP (31)
    // Encoding: 0x7F00D3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7F00D3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd_zr_rd_7f00d01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_sisd with Rd = ZR (31)
    // Encoding: 0x7F00D01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7F00D01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_reg_write_0_2f00d000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd register write: SimdFromField("d")
    // Encoding: 0x2F00D000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F00D000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_sp_rn_2f00d3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd with Rn = SP (31)
    // Encoding: 0x2F00D3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F00D3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_high_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_high_simd_zr_rd_2f00d01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_high_simd with Rd = ZR (31)
    // Encoding: 0x2F00D01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F00D01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_size_0_min_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field size = 0 (Min)
    // Fields: size=0, o1=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_size_1_poweroftwo_9000_5e609000() {
    // Encoding: 0x5E609000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field size = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=0, o1=0, size=1, Rn=0
    let encoding: u32 = 0x5E609000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_size_2_poweroftwo_9000_5ea09000() {
    // Encoding: 0x5EA09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Rd=0, size=2, o1=0
    let encoding: u32 = 0x5EA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_size_3_max_9000_5ee09000() {
    // Encoding: 0x5EE09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field size = 3 (Max)
    // Fields: Rm=0, size=3, o1=0, Rd=0, Rn=0
    let encoding: u32 = 0x5EE09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rm_0_min_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, size=0, Rd=0, o1=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rm_1_poweroftwo_9000_5e219000() {
    // Encoding: 0x5E219000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, o1=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x5E219000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rm_30_poweroftwominusone_9000_5e3e9000() {
    // Encoding: 0x5E3E9000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, o1=0, Rm=30, Rn=0, Rd=0
    let encoding: u32 = 0x5E3E9000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rm_31_max_9000_5e3f9000() {
    // Encoding: 0x5E3F9000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rm = 31 (Max)
    // Fields: Rn=0, o1=0, size=0, Rm=31, Rd=0
    let encoding: u32 = 0x5E3F9000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_o1_0_min_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field o1 = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0, size=0, o1=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_o1_1_max_9000_5e20b000() {
    // Encoding: 0x5E20B000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field o1 = 1 (Max)
    // Fields: size=0, Rn=0, Rd=0, Rm=0, o1=1
    let encoding: u32 = 0x5E20B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rn_0_min_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rn = 0 (Min)
    // Fields: size=0, Rn=0, Rd=0, Rm=0, o1=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rn_1_poweroftwo_9000_5e209020() {
    // Encoding: 0x5E209020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, size=0, Rm=0, Rn=1, o1=0
    let encoding: u32 = 0x5E209020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rn_30_poweroftwominusone_9000_5e2093c0() {
    // Encoding: 0x5E2093C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, Rm=0, Rd=0, o1=0
    let encoding: u32 = 0x5E2093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rn_31_max_9000_5e2093e0() {
    // Encoding: 0x5E2093E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rn = 31 (Max)
    // Fields: size=0, Rm=0, o1=0, Rn=31, Rd=0
    let encoding: u32 = 0x5E2093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rd_0_min_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, o1=0, Rm=0, size=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rd_1_poweroftwo_9000_5e209001() {
    // Encoding: 0x5E209001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rd = 1 (PowerOfTwo)
    // Fields: o1=0, Rn=0, size=0, Rm=0, Rd=1
    let encoding: u32 = 0x5E209001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rd_30_poweroftwominusone_9000_5e20901e() {
    // Encoding: 0x5E20901E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, size=0, Rd=30, o1=0
    let encoding: u32 = 0x5E20901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_field_rd_31_max_9000_5e20901f() {
    // Encoding: 0x5E20901F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field Rd = 31 (Max)
    // Fields: size=0, Rn=0, Rd=31, o1=0, Rm=0
    let encoding: u32 = 0x5E20901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_combo_0_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd field combination: size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: size=0, Rd=0, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_size_0_size_variant_0_36864_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Rd=0, o1=0, Rm=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_size_1_size_variant_1_36864_5e609000() {
    // Encoding: 0x5E609000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value size = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, o1=0, size=1, Rn=0
    let encoding: u32 = 0x5E609000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_size_2_size_variant_2_36864_5ea09000() {
    // Encoding: 0x5EA09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value size = 2 (Size variant 2)
    // Fields: Rd=0, Rm=0, o1=0, Rn=0, size=2
    let encoding: u32 = 0x5EA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_size_3_size_variant_3_36864_5ee09000() {
    // Encoding: 0x5EE09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value size = 3 (Size variant 3)
    // Fields: o1=0, Rd=0, Rm=0, Rn=0, size=3
    let encoding: u32 = 0x5EE09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_5e2093e0() {
    // Encoding: 0x5E2093E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rm=0, Rn=31, o1=0, Rd=0
    let encoding: u32 = 0x5E2093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_5e20901f() {
    // Encoding: 0x5E20901F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o1=0, Rm=0, Rd=31, Rn=0, size=0
    let encoding: u32 = 0x5E20901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_invalid_0_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: Rd=0, Rn=0, Rm=0, o1=0, size=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_invalid_1_9000_5e209000() {
    // Encoding: 0x5E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Rm=0, Rn=0, size=0, o1=0
    let encoding: u32 = 0x5E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_q_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Q = 0 (Min)
    // Fields: size=0, Q=0, Rd=0, Rm=0, o1=0, Rn=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_q_1_max_9000_4e209000() {
    // Encoding: 0x4E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Q = 1 (Max)
    // Fields: o1=0, Q=1, size=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x4E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_size_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field size = 0 (Min)
    // Fields: Rd=0, o1=0, Q=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_size_1_poweroftwo_9000_0e609000() {
    // Encoding: 0x0E609000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field size = 1 (PowerOfTwo)
    // Fields: Rd=0, size=1, Rm=0, Rn=0, Q=0, o1=0
    let encoding: u32 = 0x0E609000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_size_2_poweroftwo_9000_0ea09000() {
    // Encoding: 0x0EA09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field size = 2 (PowerOfTwo)
    // Fields: size=2, Rd=0, Q=0, o1=0, Rm=0, Rn=0
    let encoding: u32 = 0x0EA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_size_3_max_9000_0ee09000() {
    // Encoding: 0x0EE09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field size = 3 (Max)
    // Fields: Rm=0, Rn=0, Q=0, size=3, o1=0, Rd=0
    let encoding: u32 = 0x0EE09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rm_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rm = 0 (Min)
    // Fields: size=0, Rn=0, o1=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rm_1_poweroftwo_9000_0e219000() {
    // Encoding: 0x0E219000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rn=0, Rd=0, Rm=1, o1=0
    let encoding: u32 = 0x0E219000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rm_30_poweroftwominusone_9000_0e3e9000() {
    // Encoding: 0x0E3E9000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rm=30, Q=0, Rd=0, o1=0, Rn=0
    let encoding: u32 = 0x0E3E9000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rm_31_max_9000_0e3f9000() {
    // Encoding: 0x0E3F9000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rm = 31 (Max)
    // Fields: size=0, Rn=0, Q=0, o1=0, Rd=0, Rm=31
    let encoding: u32 = 0x0E3F9000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_o1_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field o1 = 0 (Min)
    // Fields: Rd=0, Q=0, Rm=0, size=0, o1=0, Rn=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field o1 13 +: 1`
/// Requirement: FieldBoundary { field: "o1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_o1_1_max_9000_0e20b000() {
    // Encoding: 0x0E20B000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field o1 = 1 (Max)
    // Fields: o1=1, Rn=0, Rd=0, size=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rn_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rn = 0 (Min)
    // Fields: Rm=0, Q=0, size=0, Rn=0, Rd=0, o1=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rn_1_poweroftwo_9000_0e209020() {
    // Encoding: 0x0E209020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, o1=0, Q=0, Rd=0, size=0
    let encoding: u32 = 0x0E209020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rn_30_poweroftwominusone_9000_0e2093c0() {
    // Encoding: 0x0E2093C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, o1=0, Rn=30, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E2093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rn_31_max_9000_0e2093e0() {
    // Encoding: 0x0E2093E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rn = 31 (Max)
    // Fields: Q=0, Rm=0, size=0, o1=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E2093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rd_0_min_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rd = 0 (Min)
    // Fields: size=0, Rn=0, o1=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rd_1_poweroftwo_9000_0e209001() {
    // Encoding: 0x0E209001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rm=0, Q=0, size=0, o1=0, Rn=0
    let encoding: u32 = 0x0E209001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rd_30_poweroftwominusone_9000_0e20901e() {
    // Encoding: 0x0E20901E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rm=0, size=0, Rd=30, o1=0
    let encoding: u32 = 0x0E20901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_field_rd_31_max_9000_0e20901f() {
    // Encoding: 0x0E20901F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field Rd = 31 (Max)
    // Fields: Rn=0, Q=0, o1=0, Rm=0, Rd=31, size=0
    let encoding: u32 = 0x0E20901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_combo_0_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd field combination: Q=0, size=0, Rm=0, o1=0, Rn=0, Rd=0
    // Fields: o1=0, size=0, Rm=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_q_0_size_variant_0_36864_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value Q = 0 (Size variant 0)
    // Fields: size=0, Rd=0, Q=0, Rm=0, Rn=0, o1=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_q_1_size_variant_1_36864_4e209000() {
    // Encoding: 0x4E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, Q=1, o1=0, Rn=0, size=0
    let encoding: u32 = 0x4E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_size_0_size_variant_0_36864_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value size = 0 (Size variant 0)
    // Fields: Rd=0, o1=0, Q=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_size_1_size_variant_1_36864_0e609000() {
    // Encoding: 0x0E609000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value size = 1 (Size variant 1)
    // Fields: Rd=0, o1=0, Rm=0, Q=0, Rn=0, size=1
    let encoding: u32 = 0x0E609000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_size_2_size_variant_2_36864_0ea09000() {
    // Encoding: 0x0EA09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value size = 2 (Size variant 2)
    // Fields: Rd=0, Rn=0, size=2, Rm=0, Q=0, o1=0
    let encoding: u32 = 0x0EA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_size_3_size_variant_3_36864_0ee09000() {
    // Encoding: 0x0EE09000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value size = 3 (Size variant 3)
    // Fields: size=3, o1=0, Rm=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EE09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_0e2093e0() {
    // Encoding: 0x0E2093E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rn=31, Rd=0, Q=0, o1=0, Rm=0
    let encoding: u32 = 0x0E2093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_0e20901f() {
    // Encoding: 0x0E20901F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, size=0, o1=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_invalid_0_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: Rn=0, Q=0, o1=0, Rd=0, size=0, Rm=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_invalid_1_9000_0e209000() {
    // Encoding: 0x0E209000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, Rm=0, o1=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_reg_write_0_5e209000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd register write: SimdFromField("d")
    // Encoding: 0x5E209000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E209000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_sp_rn_5e2093e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd with Rn = SP (31)
    // Encoding: 0x5E2093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E2093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd_zr_rd_5e20901f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_sisd with Rd = ZR (31)
    // Encoding: 0x5E20901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_reg_write_0_0e209000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd register write: SimdFromField("d")
    // Encoding: 0x0E209000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E209000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_sp_rn_0e2093e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd with Rn = SP (31)
    // Encoding: 0x0E2093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E2093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd_zr_rd_0e20901f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_dmacc_simd with Rd = ZR (31)
    // Encoding: 0x0E20901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_int Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_q_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Q = 0 (Min)
    // Fields: H=0, Rm=0, L=0, o2=0, size=0, Rn=0, M=0, Q=0, Rd=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_q_1_max_0_6f000000() {
    // Encoding: 0x6F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Q = 1 (Max)
    // Fields: Q=1, Rm=0, size=0, Rn=0, M=0, Rd=0, H=0, L=0, o2=0
    let encoding: u32 = 0x6F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_size_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field size = 0 (Min)
    // Fields: L=0, M=0, Rd=0, Rm=0, Q=0, o2=0, Rn=0, H=0, size=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_size_1_poweroftwo_0_2f400000() {
    // Encoding: 0x2F400000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field size = 1 (PowerOfTwo)
    // Fields: L=0, Q=0, Rn=0, Rm=0, H=0, Rd=0, size=1, M=0, o2=0
    let encoding: u32 = 0x2F400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_size_2_poweroftwo_0_2f800000() {
    // Encoding: 0x2F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field size = 2 (PowerOfTwo)
    // Fields: H=0, L=0, o2=0, Q=0, Rm=0, Rd=0, M=0, Rn=0, size=2
    let encoding: u32 = 0x2F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_size_3_max_0_2fc00000() {
    // Encoding: 0x2FC00000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field size = 3 (Max)
    // Fields: Q=0, size=3, Rd=0, H=0, L=0, M=0, Rn=0, Rm=0, o2=0
    let encoding: u32 = 0x2FC00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_l_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field L = 0 (Min)
    // Fields: L=0, Rd=0, Q=0, size=0, Rm=0, M=0, Rn=0, o2=0, H=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_l_1_max_0_2f200000() {
    // Encoding: 0x2F200000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field L = 1 (Max)
    // Fields: H=0, M=0, o2=0, Q=0, size=0, Rm=0, Rd=0, L=1, Rn=0
    let encoding: u32 = 0x2F200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_m_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field M = 0 (Min)
    // Fields: o2=0, L=0, M=0, Rm=0, Rd=0, size=0, Rn=0, H=0, Q=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_m_1_max_0_2f100000() {
    // Encoding: 0x2F100000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field M = 1 (Max)
    // Fields: o2=0, L=0, Q=0, Rm=0, size=0, M=1, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x2F100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rm_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rm = 0 (Min)
    // Fields: Rn=0, Q=0, size=0, H=0, Rd=0, L=0, Rm=0, o2=0, M=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rm_1_poweroftwo_0_2f010000() {
    // Encoding: 0x2F010000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rm = 1 (PowerOfTwo)
    // Fields: M=0, size=0, Rm=1, L=0, Q=0, H=0, o2=0, Rn=0, Rd=0
    let encoding: u32 = 0x2F010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_o2_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field o2 = 0 (Min)
    // Fields: Rm=0, H=0, o2=0, Rn=0, L=0, Q=0, M=0, Rd=0, size=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_o2_1_max_0_2f004000() {
    // Encoding: 0x2F004000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field o2 = 1 (Max)
    // Fields: size=0, M=0, Rm=0, H=0, Rd=0, Q=0, o2=1, Rn=0, L=0
    let encoding: u32 = 0x2F004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_h_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field H = 0 (Min)
    // Fields: L=0, M=0, Rm=0, Rn=0, Rd=0, size=0, o2=0, H=0, Q=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_h_1_max_0_2f000800() {
    // Encoding: 0x2F000800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field H = 1 (Max)
    // Fields: M=0, size=0, L=0, o2=0, Rn=0, Rm=0, Q=0, Rd=0, H=1
    let encoding: u32 = 0x2F000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rn_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rn = 0 (Min)
    // Fields: Q=0, H=0, L=0, o2=0, Rm=0, M=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rn_1_poweroftwo_0_2f000020() {
    // Encoding: 0x2F000020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Q=0, Rm=0, o2=0, Rd=0, Rn=1, L=0, M=0, H=0
    let encoding: u32 = 0x2F000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rn_30_poweroftwominusone_0_2f0003c0() {
    // Encoding: 0x2F0003C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Q=0, Rd=0, H=0, o2=0, Rn=30, L=0, Rm=0, M=0
    let encoding: u32 = 0x2F0003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rn_31_max_0_2f0003e0() {
    // Encoding: 0x2F0003E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rn = 31 (Max)
    // Fields: Rd=0, M=0, Q=0, Rn=31, o2=0, H=0, size=0, L=0, Rm=0
    let encoding: u32 = 0x2F0003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rd_0_min_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rd = 0 (Min)
    // Fields: o2=0, Rm=0, Rd=0, Rn=0, Q=0, size=0, M=0, H=0, L=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rd_1_poweroftwo_0_2f000001() {
    // Encoding: 0x2F000001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rd = 1 (PowerOfTwo)
    // Fields: L=0, o2=0, Rn=0, Rd=1, size=0, Q=0, Rm=0, H=0, M=0
    let encoding: u32 = 0x2F000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rd_30_poweroftwominusone_0_2f00001e() {
    // Encoding: 0x2F00001E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, M=0, Rd=30, o2=0, Q=0, H=0, L=0, Rm=0, size=0
    let encoding: u32 = 0x2F00001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_field_rd_31_max_0_2f00001f() {
    // Encoding: 0x2F00001F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field Rd = 31 (Max)
    // Fields: o2=0, Rn=0, M=0, size=0, Q=0, H=0, Rd=31, L=0, Rm=0
    let encoding: u32 = 0x2F00001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_combo_0_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int field combination: Q=0, size=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: L=0, Rm=0, o2=0, Q=0, Rn=0, size=0, Rd=0, M=0, H=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_q_0_size_variant_0_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value Q = 0 (Size variant 0)
    // Fields: H=0, size=0, L=0, M=0, Rm=0, Q=0, Rn=0, o2=0, Rd=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_q_1_size_variant_1_0_6f000000() {
    // Encoding: 0x6F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value Q = 1 (Size variant 1)
    // Fields: Q=1, H=0, o2=0, Rm=0, Rn=0, size=0, M=0, L=0, Rd=0
    let encoding: u32 = 0x6F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_size_0_size_variant_0_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value size = 0 (Size variant 0)
    // Fields: Rm=0, H=0, o2=0, L=0, Rn=0, Rd=0, size=0, Q=0, M=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_size_1_size_variant_1_0_2f400000() {
    // Encoding: 0x2F400000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value size = 1 (Size variant 1)
    // Fields: Rd=0, o2=0, L=0, H=0, Rm=0, Q=0, size=1, M=0, Rn=0
    let encoding: u32 = 0x2F400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_size_2_size_variant_2_0_2f800000() {
    // Encoding: 0x2F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value size = 2 (Size variant 2)
    // Fields: Q=0, o2=0, H=0, M=0, Rm=0, Rn=0, L=0, Rd=0, size=2
    let encoding: u32 = 0x2F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_size_3_size_variant_3_0_2fc00000() {
    // Encoding: 0x2FC00000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value size = 3 (Size variant 3)
    // Fields: size=3, o2=0, Q=0, L=0, Rm=0, Rd=0, H=0, Rn=0, M=0
    let encoding: u32 = 0x2FC00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_rn_31_stack_pointer_sp_may_require_alignment_0_2f0003e0() {
    // Encoding: 0x2F0003E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, Rm=0, o2=0, size=0, Rn=31, H=0, M=0, Q=0, Rd=0
    let encoding: u32 = 0x2F0003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_0_2f00001f() {
    // Encoding: 0x2F00001F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: o2=0, Rm=0, Rd=31, M=0, size=0, Q=0, H=0, Rn=0, L=0
    let encoding: u32 = 0x2F00001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_invalid_0_0_2f000000() {
    // Encoding: 0x2F000000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, M=0, Rd=0, Q=0, o2=0, L=0, H=0, size=0, Rm=0
    let encoding: u32 = 0x2F000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_reg_write_0_2f000000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int register write: SimdFromField("d")
    // Encoding: 0x2F000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_sp_rn_2f0003e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int with Rn = SP (31)
    // Encoding: 0x2F0003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F0003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_int
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_int_zr_rd_2f00001f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_int with Rd = ZR (31)
    // Encoding: 0x2F00001F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F00001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_long Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_q_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Q = 0 (Min)
    // Fields: Rd=0, L=0, Q=0, H=0, M=0, Rm=0, Rn=0, U=0, o2=0, size=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_q_1_max_2000_4f002000() {
    // Encoding: 0x4F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Q = 1 (Max)
    // Fields: o2=0, H=0, Rm=0, Rn=0, Q=1, U=0, L=0, Rd=0, M=0, size=0
    let encoding: u32 = 0x4F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_u_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field U = 0 (Min)
    // Fields: o2=0, Q=0, U=0, size=0, H=0, Rn=0, Rd=0, M=0, Rm=0, L=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_u_1_max_2000_2f002000() {
    // Encoding: 0x2F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field U = 1 (Max)
    // Fields: H=0, size=0, Q=0, M=0, Rm=0, o2=0, Rn=0, Rd=0, L=0, U=1
    let encoding: u32 = 0x2F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_size_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field size = 0 (Min)
    // Fields: size=0, L=0, Rd=0, U=0, Rm=0, H=0, Rn=0, M=0, Q=0, o2=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_size_1_poweroftwo_2000_0f402000() {
    // Encoding: 0x0F402000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field size = 1 (PowerOfTwo)
    // Fields: U=0, Rd=0, M=0, Rn=0, L=0, Q=0, H=0, o2=0, size=1, Rm=0
    let encoding: u32 = 0x0F402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_size_2_poweroftwo_2000_0f802000() {
    // Encoding: 0x0F802000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field size = 2 (PowerOfTwo)
    // Fields: Q=0, Rm=0, M=0, L=0, H=0, Rn=0, size=2, Rd=0, o2=0, U=0
    let encoding: u32 = 0x0F802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_size_3_max_2000_0fc02000() {
    // Encoding: 0x0FC02000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field size = 3 (Max)
    // Fields: Q=0, L=0, U=0, M=0, Rm=0, Rd=0, H=0, o2=0, Rn=0, size=3
    let encoding: u32 = 0x0FC02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_l_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field L = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, Rd=0, L=0, Q=0, M=0, U=0, H=0, o2=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_l_1_max_2000_0f202000() {
    // Encoding: 0x0F202000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field L = 1 (Max)
    // Fields: o2=0, Rn=0, size=0, M=0, Rm=0, L=1, Rd=0, H=0, Q=0, U=0
    let encoding: u32 = 0x0F202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_m_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field M = 0 (Min)
    // Fields: L=0, size=0, Rn=0, Q=0, o2=0, U=0, Rd=0, M=0, H=0, Rm=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_m_1_max_2000_0f102000() {
    // Encoding: 0x0F102000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field M = 1 (Max)
    // Fields: U=0, H=0, Rm=0, L=0, size=0, Rn=0, M=1, o2=0, Q=0, Rd=0
    let encoding: u32 = 0x0F102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rm_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rm = 0 (Min)
    // Fields: Q=0, H=0, U=0, size=0, Rm=0, Rd=0, o2=0, Rn=0, M=0, L=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rm_1_poweroftwo_2000_0f012000() {
    // Encoding: 0x0F012000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, M=0, L=0, Rn=0, Rd=0, size=0, H=0, o2=0, Q=0, U=0
    let encoding: u32 = 0x0F012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_o2_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field o2 = 0 (Min)
    // Fields: L=0, M=0, Rm=0, o2=0, size=0, U=0, H=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_o2_1_max_2000_0f006000() {
    // Encoding: 0x0F006000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field o2 = 1 (Max)
    // Fields: size=0, M=0, Rd=0, U=0, Rm=0, Rn=0, L=0, Q=0, H=0, o2=1
    let encoding: u32 = 0x0F006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_h_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field H = 0 (Min)
    // Fields: Rn=0, size=0, H=0, Rm=0, U=0, Rd=0, o2=0, M=0, L=0, Q=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_h_1_max_2000_0f002800() {
    // Encoding: 0x0F002800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field H = 1 (Max)
    // Fields: o2=0, Q=0, H=1, size=0, U=0, Rm=0, L=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F002800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rn_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rn = 0 (Min)
    // Fields: Q=0, o2=0, H=0, L=0, M=0, Rm=0, Rn=0, size=0, U=0, Rd=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rn_1_poweroftwo_2000_0f002020() {
    // Encoding: 0x0F002020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, L=0, Rd=0, Q=0, U=0, Rm=0, H=0, size=0, o2=0, M=0
    let encoding: u32 = 0x0F002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rn_30_poweroftwominusone_2000_0f0023c0() {
    // Encoding: 0x0F0023C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, L=0, Rm=0, o2=0, size=0, U=0, H=0, Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x0F0023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rn_31_max_2000_0f0023e0() {
    // Encoding: 0x0F0023E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rn = 31 (Max)
    // Fields: M=0, Rn=31, L=0, Q=0, Rd=0, Rm=0, H=0, o2=0, U=0, size=0
    let encoding: u32 = 0x0F0023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rd_0_min_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rd = 0 (Min)
    // Fields: Rd=0, H=0, Q=0, M=0, U=0, size=0, Rm=0, L=0, Rn=0, o2=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rd_1_poweroftwo_2000_0f002001() {
    // Encoding: 0x0F002001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, L=0, H=0, o2=0, Rn=0, Rd=1, U=0, M=0, Rm=0, size=0
    let encoding: u32 = 0x0F002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rd_30_poweroftwominusone_2000_0f00201e() {
    // Encoding: 0x0F00201E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, M=0, L=0, Rn=0, size=0, Rm=0, H=0, U=0, o2=0, Q=0
    let encoding: u32 = 0x0F00201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_field_rd_31_max_2000_0f00201f() {
    // Encoding: 0x0F00201F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field Rd = 31 (Max)
    // Fields: size=0, Rd=31, L=0, o2=0, H=0, M=0, Rn=0, Rm=0, Q=0, U=0
    let encoding: u32 = 0x0F00201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_combo_0_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: L=0, M=0, Rm=0, Rn=0, Rd=0, U=0, Q=0, size=0, o2=0, H=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_q_0_size_variant_0_8192_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value Q = 0 (Size variant 0)
    // Fields: H=0, L=0, size=0, M=0, Rn=0, o2=0, Q=0, Rm=0, U=0, Rd=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_q_1_size_variant_1_8192_4f002000() {
    // Encoding: 0x4F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rm=0, M=0, L=0, size=0, Rn=0, H=0, Rd=0, o2=0, U=0
    let encoding: u32 = 0x4F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_size_0_size_variant_0_8192_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value size = 0 (Size variant 0)
    // Fields: H=0, U=0, L=0, Rd=0, size=0, M=0, Rm=0, Q=0, o2=0, Rn=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_size_1_size_variant_1_8192_0f402000() {
    // Encoding: 0x0F402000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value size = 1 (Size variant 1)
    // Fields: L=0, o2=0, Rn=0, size=1, U=0, Q=0, M=0, Rm=0, H=0, Rd=0
    let encoding: u32 = 0x0F402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_size_2_size_variant_2_8192_0f802000() {
    // Encoding: 0x0F802000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value size = 2 (Size variant 2)
    // Fields: Q=0, U=0, o2=0, L=0, M=0, Rn=0, Rd=0, Rm=0, size=2, H=0
    let encoding: u32 = 0x0F802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_size_3_size_variant_3_8192_0fc02000() {
    // Encoding: 0x0FC02000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value size = 3 (Size variant 3)
    // Fields: Q=0, Rm=0, U=0, size=3, H=0, L=0, Rn=0, Rd=0, o2=0, M=0
    let encoding: u32 = 0x0FC02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_rn_31_stack_pointer_sp_may_require_alignment_8192_0f0023e0() {
    // Encoding: 0x0F0023E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, Q=0, H=0, U=0, o2=0, size=0, L=0, M=0, Rm=0
    let encoding: u32 = 0x0F0023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_8192_0f00201f() {
    // Encoding: 0x0F00201F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, size=0, Q=0, L=0, H=0, U=0, M=0, o2=0, Rd=31
    let encoding: u32 = 0x0F00201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_invalid_0_2000_0f002000() {
    // Encoding: 0x0F002000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long invalid encoding: Unconditional UNDEFINED
    // Fields: L=0, Rm=0, U=0, H=0, Q=0, Rn=0, size=0, Rd=0, o2=0, M=0
    let encoding: u32 = 0x0F002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_reg_write_0_0f002000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long register write: SimdFromField("d")
    // Encoding: 0x0F002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_sp_rn_0f0023e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long with Rn = SP (31)
    // Encoding: 0x0F0023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F0023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_long
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_long_zr_rd_0f00201f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_long with Rd = ZR (31)
    // Encoding: 0x0F00201F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00201F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_u_0_min_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field U = 0 (Min)
    // Fields: Rd=0, Rm=0, size=0, Rn=0, U=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_u_1_max_b400_7e20b400() {
    // Encoding: 0x7E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field U = 1 (Max)
    // Fields: U=1, Rd=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x7E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_size_0_min_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field size = 0 (Min)
    // Fields: U=0, Rd=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_size_1_poweroftwo_b400_5e60b400() {
    // Encoding: 0x5E60B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field size = 1 (PowerOfTwo)
    // Fields: size=1, Rm=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E60B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_size_2_poweroftwo_b400_5ea0b400() {
    // Encoding: 0x5EA0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field size = 2 (PowerOfTwo)
    // Fields: Rm=0, U=0, size=2, Rd=0, Rn=0
    let encoding: u32 = 0x5EA0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_size_3_max_b400_5ee0b400() {
    // Encoding: 0x5EE0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field size = 3 (Max)
    // Fields: U=0, Rm=0, Rn=0, Rd=0, size=3
    let encoding: u32 = 0x5EE0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rm_0_min_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rm = 0 (Min)
    // Fields: U=0, Rd=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rm_1_poweroftwo_b400_5e21b400() {
    // Encoding: 0x5E21B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, U=0, size=0, Rn=0, Rm=1
    let encoding: u32 = 0x5E21B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rm_30_poweroftwominusone_b400_5e3eb400() {
    // Encoding: 0x5E3EB400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, size=0, Rn=0, Rd=0, Rm=30
    let encoding: u32 = 0x5E3EB400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rm_31_max_b400_5e3fb400() {
    // Encoding: 0x5E3FB400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rm = 31 (Max)
    // Fields: U=0, Rm=31, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x5E3FB400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rn_0_min_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rn = 0 (Min)
    // Fields: U=0, size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rn_1_poweroftwo_b400_5e20b420() {
    // Encoding: 0x5E20B420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, size=0, U=0, Rn=1, Rm=0
    let encoding: u32 = 0x5E20B420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rn_30_poweroftwominusone_b400_5e20b7c0() {
    // Encoding: 0x5E20B7C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, U=0, Rn=30, Rd=0, size=0
    let encoding: u32 = 0x5E20B7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rn_31_max_b400_5e20b7e0() {
    // Encoding: 0x5E20B7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rn = 31 (Max)
    // Fields: U=0, Rm=0, size=0, Rd=0, Rn=31
    let encoding: u32 = 0x5E20B7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rd_0_min_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rd = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rd_1_poweroftwo_b400_5e20b401() {
    // Encoding: 0x5E20B401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, Rm=0, Rd=1, size=0
    let encoding: u32 = 0x5E20B401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rd_30_poweroftwominusone_b400_5e20b41e() {
    // Encoding: 0x5E20B41E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Rm=0, U=0, size=0
    let encoding: u32 = 0x5E20B41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_field_rd_31_max_b400_5e20b41f() {
    // Encoding: 0x5E20B41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field Rd = 31 (Max)
    // Fields: U=0, Rm=0, size=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E20B41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_combo_0_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd field combination: U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, size=0, Rd=0, U=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_size_0_size_variant_0_46080_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value size = 0 (Size variant 0)
    // Fields: Rd=0, Rm=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_size_1_size_variant_1_46080_5e60b400() {
    // Encoding: 0x5E60B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value size = 1 (Size variant 1)
    // Fields: Rd=0, U=0, size=1, Rm=0, Rn=0
    let encoding: u32 = 0x5E60B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_size_2_size_variant_2_46080_5ea0b400() {
    // Encoding: 0x5EA0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value size = 2 (Size variant 2)
    // Fields: U=0, Rm=0, Rn=0, size=2, Rd=0
    let encoding: u32 = 0x5EA0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_size_3_size_variant_3_46080_5ee0b400() {
    // Encoding: 0x5EE0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value size = 3 (Size variant 3)
    // Fields: Rm=0, U=0, Rd=0, size=3, Rn=0
    let encoding: u32 = 0x5EE0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_46080_5e20b7e0() {
    // Encoding: 0x5E20B7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, size=0, Rd=0, U=0
    let encoding: u32 = 0x5E20B7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_46080_5e20b41f() {
    // Encoding: 0x5E20B41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, size=0, Rd=31, Rm=0, Rn=0
    let encoding: u32 = 0x5E20B41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_invalid_0_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }
    // Fields: Rm=0, size=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_invalid_1_b400_5e20b400() {
    // Encoding: 0x5E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, U=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x5E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_q_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Q = 0 (Min)
    // Fields: U=0, Rm=0, Rd=0, Rn=0, Q=0, size=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_q_1_max_b400_4e20b400() {
    // Encoding: 0x4E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Q = 1 (Max)
    // Fields: U=0, Rm=0, Rn=0, Rd=0, Q=1, size=0
    let encoding: u32 = 0x4E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_u_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field U = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, size=0, U=0, Q=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_u_1_max_b400_2e20b400() {
    // Encoding: 0x2E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field U = 1 (Max)
    // Fields: Rn=0, U=1, Rm=0, size=0, Rd=0, Q=0
    let encoding: u32 = 0x2E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_size_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field size = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, size=0, Rd=0, U=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_size_1_poweroftwo_b400_0e60b400() {
    // Encoding: 0x0E60B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field size = 1 (PowerOfTwo)
    // Fields: U=0, size=1, Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E60B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_size_2_poweroftwo_b400_0ea0b400() {
    // Encoding: 0x0EA0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Rd=0, Rn=0, U=0, Q=0, size=2
    let encoding: u32 = 0x0EA0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_size_3_max_b400_0ee0b400() {
    // Encoding: 0x0EE0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field size = 3 (Max)
    // Fields: Rn=0, Rd=0, Q=0, size=3, U=0, Rm=0
    let encoding: u32 = 0x0EE0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rm_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rm = 0 (Min)
    // Fields: Q=0, U=0, Rn=0, size=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rm_1_poweroftwo_b400_0e21b400() {
    // Encoding: 0x0E21B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rd=0, Rm=1, Rn=0, U=0
    let encoding: u32 = 0x0E21B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rm_30_poweroftwominusone_b400_0e3eb400() {
    // Encoding: 0x0E3EB400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rm=30, Q=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E3EB400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rm_31_max_b400_0e3fb400() {
    // Encoding: 0x0E3FB400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rm = 31 (Max)
    // Fields: size=0, Rm=31, U=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E3FB400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rn_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Q=0, Rd=0, U=0, size=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rn_1_poweroftwo_b400_0e20b420() {
    // Encoding: 0x0E20B420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, Rn=1, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20B420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rn_30_poweroftwominusone_b400_0e20b7c0() {
    // Encoding: 0x0E20B7C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, Rm=0, Rn=30, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E20B7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rn_31_max_b400_0e20b7e0() {
    // Encoding: 0x0E20B7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, size=0, Rm=0, U=0, Rn=31
    let encoding: u32 = 0x0E20B7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rd_0_min_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, U=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rd_1_poweroftwo_b400_0e20b401() {
    // Encoding: 0x0E20B401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Rd=1, size=0, Q=0, U=0
    let encoding: u32 = 0x0E20B401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rd_30_poweroftwominusone_b400_0e20b41e() {
    // Encoding: 0x0E20B41E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rd=30, size=0, Rm=0, U=0
    let encoding: u32 = 0x0E20B41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_field_rd_31_max_b400_0e20b41f() {
    // Encoding: 0x0E20B41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field Rd = 31 (Max)
    // Fields: Rm=0, U=0, size=0, Rn=0, Q=0, Rd=31
    let encoding: u32 = 0x0E20B41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_combo_0_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd field combination: Q=0, U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, U=0, Rm=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_q_0_size_variant_0_46080_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, size=0, Rm=0, Q=0, U=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_q_1_size_variant_1_46080_4e20b400() {
    // Encoding: 0x4E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value Q = 1 (Size variant 1)
    // Fields: size=0, U=0, Rn=0, Rd=0, Rm=0, Q=1
    let encoding: u32 = 0x4E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_size_0_size_variant_0_46080_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value size = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Rm=0, size=0, Q=0, U=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_size_1_size_variant_1_46080_0e60b400() {
    // Encoding: 0x0E60B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value size = 1 (Size variant 1)
    // Fields: Q=0, U=0, Rn=0, Rm=0, Rd=0, size=1
    let encoding: u32 = 0x0E60B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_size_2_size_variant_2_46080_0ea0b400() {
    // Encoding: 0x0EA0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value size = 2 (Size variant 2)
    // Fields: U=0, Rm=0, Rd=0, Q=0, size=2, Rn=0
    let encoding: u32 = 0x0EA0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_size_3_size_variant_3_46080_0ee0b400() {
    // Encoding: 0x0EE0B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, Rm=0, Rd=0, U=0, Rn=0, size=3
    let encoding: u32 = 0x0EE0B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_rn_31_stack_pointer_sp_may_require_alignment_46080_0e20b7e0() {
    // Encoding: 0x0E20B7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, U=0, Rm=0, Q=0, Rn=31, size=0
    let encoding: u32 = 0x0E20B7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_46080_0e20b41f() {
    // Encoding: 0x0E20B41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, size=0, U=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20B41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_invalid_0_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }
    // Fields: Rm=0, Rn=0, U=0, size=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_invalid_1_b400_0e20b400() {
    // Encoding: 0x0E20B400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, U=0, Rn=0, size=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20B400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_reg_write_0_5e20b400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd register write: SimdFromField("d")
    // Encoding: 0x5E20B400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20B400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_sp_rn_5e20b7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd with Rn = SP (31)
    // Encoding: 0x5E20B7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20B7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd_zr_rd_5e20b41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_sisd with Rd = ZR (31)
    // Encoding: 0x5E20B41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20B41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_reg_write_0_0e20b400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd register write: SimdFromField("d")
    // Encoding: 0x0E20B400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20B400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_sp_rn_0e20b7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd with Rn = SP (31)
    // Encoding: 0x0E20B7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20B7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd_zr_rd_0e20b41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_simd with Rd = ZR (31)
    // Encoding: 0x0E20B41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20B41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_size_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field size = 0 (Min)
    // Fields: Rd=0, size=0, L=0, M=0, H=0, Rm=0, o2=0, Rn=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_size_1_poweroftwo_3000_5f403000() {
    // Encoding: 0x5F403000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field size = 1 (PowerOfTwo)
    // Fields: L=0, Rd=0, M=0, size=1, Rm=0, H=0, Rn=0, o2=0
    let encoding: u32 = 0x5F403000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_size_2_poweroftwo_3000_5f803000() {
    // Encoding: 0x5F803000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field size = 2 (PowerOfTwo)
    // Fields: M=0, Rn=0, H=0, L=0, o2=0, Rd=0, Rm=0, size=2
    let encoding: u32 = 0x5F803000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_size_3_max_3000_5fc03000() {
    // Encoding: 0x5FC03000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field size = 3 (Max)
    // Fields: o2=0, Rm=0, Rd=0, L=0, Rn=0, size=3, M=0, H=0
    let encoding: u32 = 0x5FC03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_l_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field L = 0 (Min)
    // Fields: L=0, H=0, o2=0, M=0, Rm=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_l_1_max_3000_5f203000() {
    // Encoding: 0x5F203000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field L = 1 (Max)
    // Fields: Rd=0, Rm=0, size=0, L=1, M=0, o2=0, Rn=0, H=0
    let encoding: u32 = 0x5F203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_m_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field M = 0 (Min)
    // Fields: size=0, H=0, L=0, M=0, Rn=0, o2=0, Rm=0, Rd=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_m_1_max_3000_5f103000() {
    // Encoding: 0x5F103000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field M = 1 (Max)
    // Fields: H=0, Rd=0, L=0, size=0, Rn=0, Rm=0, M=1, o2=0
    let encoding: u32 = 0x5F103000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rm_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rm = 0 (Min)
    // Fields: Rn=0, size=0, L=0, H=0, Rm=0, Rd=0, o2=0, M=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rm_1_poweroftwo_3000_5f013000() {
    // Encoding: 0x5F013000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=1, Rn=0, size=0, L=0, M=0, o2=0, H=0
    let encoding: u32 = 0x5F013000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_o2_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field o2 = 0 (Min)
    // Fields: L=0, M=0, Rn=0, o2=0, Rm=0, Rd=0, H=0, size=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_o2_1_max_3000_5f007000() {
    // Encoding: 0x5F007000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field o2 = 1 (Max)
    // Fields: L=0, H=0, Rn=0, Rd=0, Rm=0, o2=1, size=0, M=0
    let encoding: u32 = 0x5F007000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_h_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field H = 0 (Min)
    // Fields: size=0, o2=0, Rn=0, L=0, Rm=0, H=0, M=0, Rd=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_h_1_max_3000_5f003800() {
    // Encoding: 0x5F003800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field H = 1 (Max)
    // Fields: M=0, L=0, size=0, o2=0, H=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5F003800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rn_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rn = 0 (Min)
    // Fields: Rm=0, Rd=0, L=0, Rn=0, size=0, H=0, o2=0, M=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rn_1_poweroftwo_3000_5f003020() {
    // Encoding: 0x5F003020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rn = 1 (PowerOfTwo)
    // Fields: o2=0, H=0, M=0, L=0, Rd=0, size=0, Rn=1, Rm=0
    let encoding: u32 = 0x5F003020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rn_30_poweroftwominusone_3000_5f0033c0() {
    // Encoding: 0x5F0033C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, o2=0, Rd=0, M=0, H=0, L=0, Rm=0
    let encoding: u32 = 0x5F0033C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rn_31_max_3000_5f0033e0() {
    // Encoding: 0x5F0033E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rn = 31 (Max)
    // Fields: L=0, Rd=0, M=0, H=0, o2=0, size=0, Rn=31, Rm=0
    let encoding: u32 = 0x5F0033E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rd_0_min_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rd = 0 (Min)
    // Fields: M=0, H=0, size=0, Rm=0, Rn=0, Rd=0, o2=0, L=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rd_1_poweroftwo_3000_5f003001() {
    // Encoding: 0x5F003001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rd = 1 (PowerOfTwo)
    // Fields: o2=0, Rm=0, H=0, L=0, M=0, Rd=1, size=0, Rn=0
    let encoding: u32 = 0x5F003001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rd_30_poweroftwominusone_3000_5f00301e() {
    // Encoding: 0x5F00301E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o2=0, M=0, Rn=0, H=0, size=0, Rm=0, Rd=30, L=0
    let encoding: u32 = 0x5F00301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_field_rd_31_max_3000_5f00301f() {
    // Encoding: 0x5F00301F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field Rd = 31 (Max)
    // Fields: M=0, size=0, H=0, Rm=0, L=0, o2=0, Rd=31, Rn=0
    let encoding: u32 = 0x5F00301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_combo_0_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd field combination: size=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, o2=0, size=0, Rn=0, H=0, Rd=0, M=0, L=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_size_0_size_variant_0_12288_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value size = 0 (Size variant 0)
    // Fields: L=0, o2=0, size=0, Rm=0, M=0, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_size_1_size_variant_1_12288_5f403000() {
    // Encoding: 0x5F403000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value size = 1 (Size variant 1)
    // Fields: L=0, Rm=0, Rn=0, size=1, o2=0, Rd=0, M=0, H=0
    let encoding: u32 = 0x5F403000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_size_2_size_variant_2_12288_5f803000() {
    // Encoding: 0x5F803000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value size = 2 (Size variant 2)
    // Fields: M=0, Rn=0, Rd=0, Rm=0, size=2, o2=0, H=0, L=0
    let encoding: u32 = 0x5F803000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_size_3_size_variant_3_12288_5fc03000() {
    // Encoding: 0x5FC03000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value size = 3 (Size variant 3)
    // Fields: Rm=0, H=0, Rn=0, M=0, size=3, o2=0, L=0, Rd=0
    let encoding: u32 = 0x5FC03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_12288_5f0033e0() {
    // Encoding: 0x5F0033E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: H=0, Rn=31, size=0, Rd=0, M=0, o2=0, L=0, Rm=0
    let encoding: u32 = 0x5F0033E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_12288_5f00301f() {
    // Encoding: 0x5F00301F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: L=0, size=0, Rd=31, M=0, o2=0, H=0, Rn=0, Rm=0
    let encoding: u32 = 0x5F00301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_invalid_0_3000_5f003000() {
    // Encoding: 0x5F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, L=0, H=0, o2=0, Rm=0, Rn=0, M=0, Rd=0
    let encoding: u32 = 0x5F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_q_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Q = 0 (Min)
    // Fields: H=0, Rn=0, L=0, Q=0, o2=0, Rd=0, M=0, Rm=0, size=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_q_1_max_3000_4f003000() {
    // Encoding: 0x4F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Q = 1 (Max)
    // Fields: Rm=0, o2=0, H=0, Rd=0, size=0, Q=1, Rn=0, L=0, M=0
    let encoding: u32 = 0x4F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_size_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field size = 0 (Min)
    // Fields: size=0, o2=0, H=0, Q=0, Rd=0, Rm=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_size_1_poweroftwo_3000_0f403000() {
    // Encoding: 0x0F403000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field size = 1 (PowerOfTwo)
    // Fields: L=0, o2=0, Rm=0, Q=0, Rn=0, size=1, Rd=0, H=0, M=0
    let encoding: u32 = 0x0F403000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_size_2_poweroftwo_3000_0f803000() {
    // Encoding: 0x0F803000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field size = 2 (PowerOfTwo)
    // Fields: M=0, o2=0, Rm=0, H=0, size=2, L=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0F803000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_size_3_max_3000_0fc03000() {
    // Encoding: 0x0FC03000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field size = 3 (Max)
    // Fields: o2=0, M=0, Rn=0, Q=0, Rd=0, H=0, Rm=0, size=3, L=0
    let encoding: u32 = 0x0FC03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_l_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field L = 0 (Min)
    // Fields: size=0, H=0, Rd=0, L=0, M=0, Q=0, Rm=0, o2=0, Rn=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_l_1_max_3000_0f203000() {
    // Encoding: 0x0F203000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field L = 1 (Max)
    // Fields: M=0, size=0, Rd=0, L=1, Rm=0, o2=0, Rn=0, Q=0, H=0
    let encoding: u32 = 0x0F203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_m_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field M = 0 (Min)
    // Fields: Rd=0, H=0, Rm=0, Rn=0, o2=0, Q=0, size=0, M=0, L=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_m_1_max_3000_0f103000() {
    // Encoding: 0x0F103000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field M = 1 (Max)
    // Fields: Q=0, Rm=0, M=1, H=0, L=0, o2=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x0F103000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rm_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rm = 0 (Min)
    // Fields: L=0, o2=0, Rn=0, H=0, M=0, size=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rm_1_poweroftwo_3000_0f013000() {
    // Encoding: 0x0F013000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rm = 1 (PowerOfTwo)
    // Fields: o2=0, Rm=1, size=0, L=0, Rn=0, Rd=0, H=0, M=0, Q=0
    let encoding: u32 = 0x0F013000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_o2_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field o2 = 0 (Min)
    // Fields: size=0, L=0, Rd=0, Q=0, Rn=0, H=0, Rm=0, o2=0, M=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_o2_1_max_3000_0f007000() {
    // Encoding: 0x0F007000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field o2 = 1 (Max)
    // Fields: size=0, Rm=0, o2=1, Rn=0, H=0, L=0, Rd=0, M=0, Q=0
    let encoding: u32 = 0x0F007000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_h_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field H = 0 (Min)
    // Fields: Rn=0, Q=0, o2=0, H=0, Rd=0, L=0, size=0, M=0, Rm=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_h_1_max_3000_0f003800() {
    // Encoding: 0x0F003800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field H = 1 (Max)
    // Fields: M=0, Rm=0, Rn=0, o2=0, Rd=0, size=0, L=0, H=1, Q=0
    let encoding: u32 = 0x0F003800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rn_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rn = 0 (Min)
    // Fields: size=0, Rm=0, o2=0, Rn=0, Q=0, L=0, M=0, Rd=0, H=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rn_1_poweroftwo_3000_0f003020() {
    // Encoding: 0x0F003020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=0, Rn=1, Rm=0, size=0, o2=0, L=0, M=0, H=0
    let encoding: u32 = 0x0F003020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rn_30_poweroftwominusone_3000_0f0033c0() {
    // Encoding: 0x0F0033C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, L=0, H=0, M=0, Q=0, Rm=0, Rd=0, o2=0, Rn=30
    let encoding: u32 = 0x0F0033C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rn_31_max_3000_0f0033e0() {
    // Encoding: 0x0F0033E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rn = 31 (Max)
    // Fields: Q=0, H=0, Rm=0, Rn=31, size=0, o2=0, L=0, M=0, Rd=0
    let encoding: u32 = 0x0F0033E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rd_0_min_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rd = 0 (Min)
    // Fields: Rm=0, Rn=0, Rd=0, Q=0, M=0, L=0, H=0, o2=0, size=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rd_1_poweroftwo_3000_0f003001() {
    // Encoding: 0x0F003001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rd = 1 (PowerOfTwo)
    // Fields: size=0, L=0, o2=0, Rm=0, Q=0, H=0, Rn=0, M=0, Rd=1
    let encoding: u32 = 0x0F003001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rd_30_poweroftwominusone_3000_0f00301e() {
    // Encoding: 0x0F00301E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, Rn=0, L=0, H=0, Rm=0, Q=0, size=0, o2=0, Rd=30
    let encoding: u32 = 0x0F00301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_field_rd_31_max_3000_0f00301f() {
    // Encoding: 0x0F00301F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field Rd = 31 (Max)
    // Fields: H=0, Rd=31, M=0, Rn=0, Q=0, Rm=0, o2=0, size=0, L=0
    let encoding: u32 = 0x0F00301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_combo_0_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd field combination: Q=0, size=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: M=0, Rn=0, Rd=0, size=0, o2=0, H=0, Q=0, Rm=0, L=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_q_0_size_variant_0_12288_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value Q = 0 (Size variant 0)
    // Fields: M=0, H=0, o2=0, L=0, Rn=0, size=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_q_1_size_variant_1_12288_4f003000() {
    // Encoding: 0x4F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, Rm=0, M=0, o2=0, size=0, Q=1, H=0, L=0
    let encoding: u32 = 0x4F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_size_0_size_variant_0_12288_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value size = 0 (Size variant 0)
    // Fields: M=0, Q=0, Rn=0, size=0, L=0, o2=0, Rm=0, H=0, Rd=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_size_1_size_variant_1_12288_0f403000() {
    // Encoding: 0x0F403000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value size = 1 (Size variant 1)
    // Fields: o2=0, L=0, H=0, Rn=0, size=1, M=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0F403000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_size_2_size_variant_2_12288_0f803000() {
    // Encoding: 0x0F803000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value size = 2 (Size variant 2)
    // Fields: size=2, H=0, M=0, Rm=0, Q=0, Rn=0, Rd=0, L=0, o2=0
    let encoding: u32 = 0x0F803000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_size_3_size_variant_3_12288_0fc03000() {
    // Encoding: 0x0FC03000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value size = 3 (Size variant 3)
    // Fields: L=0, size=3, Q=0, M=0, o2=0, Rn=0, Rm=0, H=0, Rd=0
    let encoding: u32 = 0x0FC03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_rn_31_stack_pointer_sp_may_require_alignment_12288_0f0033e0() {
    // Encoding: 0x0F0033E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rm=0, M=0, o2=0, Rn=31, L=0, Q=0, Rd=0, H=0
    let encoding: u32 = 0x0F0033E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_12288_0f00301f() {
    // Encoding: 0x0F00301F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, M=0, size=0, L=0, Rd=31, Rm=0, o2=0, Rn=0, H=0
    let encoding: u32 = 0x0F00301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_invalid_0_3000_0f003000() {
    // Encoding: 0x0F003000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd invalid encoding: Unconditional UNDEFINED
    // Fields: H=0, size=0, Q=0, Rm=0, Rn=0, o2=0, Rd=0, L=0, M=0
    let encoding: u32 = 0x0F003000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_reg_write_0_5f003000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd register write: SimdFromField("d")
    // Encoding: 0x5F003000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_sp_rn_5f0033e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd with Rn = SP (31)
    // Encoding: 0x5F0033E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F0033E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd_zr_rd_5f00301f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_sisd with Rd = ZR (31)
    // Encoding: 0x5F00301F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00301F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_reg_write_0_0f003000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd register write: SimdFromField("d")
    // Encoding: 0x0F003000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_sp_rn_0f0033e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd with Rn = SP (31)
    // Encoding: 0x0F0033E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F0033E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_double_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_double_simd_zr_rd_0f00301f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_double_simd with Rd = ZR (31)
    // Encoding: 0x0F00301F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00301F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_size_0_min_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field size = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_size_1_poweroftwo_8400_7e408400() {
    // Encoding: 0x7E408400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field size = 1 (PowerOfTwo)
    // Fields: size=1, Rm=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x7E408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_size_2_poweroftwo_8400_7e808400() {
    // Encoding: 0x7E808400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field size = 2 (PowerOfTwo)
    // Fields: size=2, Rm=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x7E808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_size_3_max_8400_7ec08400() {
    // Encoding: 0x7EC08400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field size = 3 (Max)
    // Fields: size=3, Rn=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x7EC08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rm_0_min_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rm = 0 (Min)
    // Fields: Rm=0, S=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rm_1_poweroftwo_8400_7e018400() {
    // Encoding: 0x7E018400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, size=0, S=0, Rd=0
    let encoding: u32 = 0x7E018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rm_30_poweroftwominusone_8400_7e1e8400() {
    // Encoding: 0x7E1E8400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, size=0, Rd=0, S=0
    let encoding: u32 = 0x7E1E8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rm_31_max_8400_7e1f8400() {
    // Encoding: 0x7E1F8400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rm = 31 (Max)
    // Fields: Rm=31, size=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x7E1F8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_s_0_min_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field S = 0 (Min)
    // Fields: Rd=0, size=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_s_1_max_8400_7e008c00() {
    // Encoding: 0x7E008C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field S = 1 (Max)
    // Fields: S=1, size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E008C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rn_0_min_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rn = 0 (Min)
    // Fields: Rm=0, size=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rn_1_poweroftwo_8400_7e008420() {
    // Encoding: 0x7E008420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rn = 1 (PowerOfTwo)
    // Fields: S=0, Rn=1, Rd=0, Rm=0, size=0
    let encoding: u32 = 0x7E008420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rn_30_poweroftwominusone_8400_7e0087c0() {
    // Encoding: 0x7E0087C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x7E0087C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rn_31_max_8400_7e0087e0() {
    // Encoding: 0x7E0087E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rn = 31 (Max)
    // Fields: Rm=0, Rd=0, S=0, size=0, Rn=31
    let encoding: u32 = 0x7E0087E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rd_0_min_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rd = 0 (Min)
    // Fields: S=0, Rd=0, Rm=0, Rn=0, size=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rd_1_poweroftwo_8400_7e008401() {
    // Encoding: 0x7E008401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rd = 1 (PowerOfTwo)
    // Fields: S=0, Rn=0, Rd=1, size=0, Rm=0
    let encoding: u32 = 0x7E008401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rd_30_poweroftwominusone_8400_7e00841e() {
    // Encoding: 0x7E00841E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, S=0, Rd=30, size=0
    let encoding: u32 = 0x7E00841E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_field_rd_31_max_8400_7e00841f() {
    // Encoding: 0x7E00841F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field Rd = 31 (Max)
    // Fields: Rm=0, S=0, size=0, Rd=31, Rn=0
    let encoding: u32 = 0x7E00841F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_combo_0_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd field combination: size=0, Rm=0, S=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, size=0, Rn=0, S=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_size_0_size_variant_0_33792_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value size = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Rm=0, size=0, S=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_size_1_size_variant_1_33792_7e408400() {
    // Encoding: 0x7E408400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value size = 1 (Size variant 1)
    // Fields: S=0, size=1, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x7E408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_size_2_size_variant_2_33792_7e808400() {
    // Encoding: 0x7E808400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value size = 2 (Size variant 2)
    // Fields: Rn=0, Rm=0, size=2, Rd=0, S=0
    let encoding: u32 = 0x7E808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_size_3_size_variant_3_33792_7ec08400() {
    // Encoding: 0x7EC08400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rm=0, S=0, Rd=0, size=3
    let encoding: u32 = 0x7EC08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_s_0_size_variant_0_33792_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value S = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Rd=0, S=0, Rm=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_s_1_size_variant_1_33792_7e008c00() {
    // Encoding: 0x7E008C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value S = 1 (Size variant 1)
    // Fields: Rn=0, S=1, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x7E008C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_33792_7e0087e0() {
    // Encoding: 0x7E0087E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Rd=0, S=0, size=0
    let encoding: u32 = 0x7E0087E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_33792_7e00841f() {
    // Encoding: 0x7E00841F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, size=0, Rm=0, S=0
    let encoding: u32 = 0x7E00841F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveQRDMLAHExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_invalid_0_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }
    // Fields: size=0, S=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_invalid_1_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, S=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_invalid_2_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }
    // Fields: Rm=0, S=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_invalid_3_8400_7e008400() {
    // Encoding: 0x7E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, S=0, Rm=0, size=0, Rd=0
    let encoding: u32 = 0x7E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_q_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Q = 0 (Min)
    // Fields: S=0, size=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_q_1_max_8400_6e008400() {
    // Encoding: 0x6E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Q = 1 (Max)
    // Fields: S=0, Q=1, Rd=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x6E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_size_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field size = 0 (Min)
    // Fields: size=0, Q=0, S=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_size_1_poweroftwo_8400_2e408400() {
    // Encoding: 0x2E408400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field size = 1 (PowerOfTwo)
    // Fields: S=0, Rd=0, Rn=0, Q=0, Rm=0, size=1
    let encoding: u32 = 0x2E408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_size_2_poweroftwo_8400_2e808400() {
    // Encoding: 0x2E808400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field size = 2 (PowerOfTwo)
    // Fields: Rd=0, Q=0, size=2, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x2E808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_size_3_max_8400_2ec08400() {
    // Encoding: 0x2EC08400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field size = 3 (Max)
    // Fields: Rm=0, Rn=0, Rd=0, S=0, Q=0, size=3
    let encoding: u32 = 0x2EC08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rm_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rm = 0 (Min)
    // Fields: size=0, Rm=0, Rd=0, Q=0, S=0, Rn=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rm_1_poweroftwo_8400_2e018400() {
    // Encoding: 0x2E018400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Q=0, S=0, Rd=0, size=0
    let encoding: u32 = 0x2E018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rm_30_poweroftwominusone_8400_2e1e8400() {
    // Encoding: 0x2E1E8400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, S=0, size=0, Q=0, Rd=0
    let encoding: u32 = 0x2E1E8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rm_31_max_8400_2e1f8400() {
    // Encoding: 0x2E1F8400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rm = 31 (Max)
    // Fields: size=0, Rn=0, Rm=31, S=0, Rd=0, Q=0
    let encoding: u32 = 0x2E1F8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_s_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field S = 0 (Min)
    // Fields: S=0, Rd=0, Q=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field S 11 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_s_1_max_8400_2e008c00() {
    // Encoding: 0x2E008C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field S = 1 (Max)
    // Fields: S=1, Rm=0, size=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E008C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rn_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rn = 0 (Min)
    // Fields: Rd=0, size=0, S=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rn_1_poweroftwo_8400_2e008420() {
    // Encoding: 0x2E008420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=0, S=0, Rn=1, Rm=0, size=0
    let encoding: u32 = 0x2E008420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rn_30_poweroftwominusone_8400_2e0087c0() {
    // Encoding: 0x2E0087C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rd=0, S=0, Rn=30, Rm=0, Q=0
    let encoding: u32 = 0x2E0087C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rn_31_max_8400_2e0087e0() {
    // Encoding: 0x2E0087E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, size=0, Rm=0, S=0, Rn=31
    let encoding: u32 = 0x2E0087E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rd_0_min_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rd = 0 (Min)
    // Fields: size=0, Rm=0, Rn=0, Q=0, S=0, Rd=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rd_1_poweroftwo_8400_2e008401() {
    // Encoding: 0x2E008401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rd=1, Rn=0, size=0, S=0, Q=0
    let encoding: u32 = 0x2E008401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rd_30_poweroftwominusone_8400_2e00841e() {
    // Encoding: 0x2E00841E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rn=0, Rd=30, Q=0, size=0, Rm=0
    let encoding: u32 = 0x2E00841E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_field_rd_31_max_8400_2e00841f() {
    // Encoding: 0x2E00841F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field Rd = 31 (Max)
    // Fields: S=0, Rn=0, Rm=0, Q=0, size=0, Rd=31
    let encoding: u32 = 0x2E00841F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_combo_0_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd field combination: Q=0, size=0, Rm=0, S=0, Rn=0, Rd=0
    // Fields: size=0, S=0, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_q_0_size_variant_0_33792_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, S=0, Q=0, size=0, Rm=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_q_1_size_variant_1_33792_6e008400() {
    // Encoding: 0x6E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, S=0, Rd=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x6E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_size_0_size_variant_0_33792_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value size = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, size=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_size_1_size_variant_1_33792_2e408400() {
    // Encoding: 0x2E408400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value size = 1 (Size variant 1)
    // Fields: Rn=0, S=0, Rm=0, Rd=0, Q=0, size=1
    let encoding: u32 = 0x2E408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_size_2_size_variant_2_33792_2e808400() {
    // Encoding: 0x2E808400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value size = 2 (Size variant 2)
    // Fields: Rm=0, Rn=0, Q=0, size=2, Rd=0, S=0
    let encoding: u32 = 0x2E808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_size_3_size_variant_3_33792_2ec08400() {
    // Encoding: 0x2EC08400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value size = 3 (Size variant 3)
    // Fields: S=0, Rn=0, Rd=0, Q=0, size=3, Rm=0
    let encoding: u32 = 0x2EC08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_s_0_size_variant_0_33792_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value S = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, size=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_s_1_size_variant_1_33792_2e008c00() {
    // Encoding: 0x2E008C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value S = 1 (Size variant 1)
    // Fields: S=1, Q=0, Rm=0, Rd=0, Rn=0, size=0
    let encoding: u32 = 0x2E008C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_rn_31_stack_pointer_sp_may_require_alignment_33792_2e0087e0() {
    // Encoding: 0x2E0087E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rd=0, size=0, Q=0, Rm=0, S=0
    let encoding: u32 = 0x2E0087E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_33792_2e00841f() {
    // Encoding: 0x2E00841F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rm=0, S=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x2E00841F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveQRDMLAHExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_invalid_0_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveQRDMLAHExt" }, args: [] } }
    // Fields: Q=0, Rn=0, size=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_invalid_1_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, Rm=0, Rd=0, size=0, Rn=0, S=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_invalid_2_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([true, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }
    // Fields: size=0, S=0, Rn=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_invalid_3_8400_2e008400() {
    // Encoding: 0x2E008400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rd=0, Q=0, Rm=0, S=0, size=0
    let encoding: u32 = 0x2E008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_reg_write_0_7e008400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd register write: SimdFromField("d")
    // Encoding: 0x7E008400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E008400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_sp_rn_7e0087e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd with Rn = SP (31)
    // Encoding: 0x7E0087E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E0087E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd_zr_rd_7e00841f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd with Rd = ZR (31)
    // Encoding: 0x7E00841F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x7E00841F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_reg_write_0_2e008400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd register write: SimdFromField("d")
    // Encoding: 0x2E008400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E008400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_sp_rn_2e0087e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd with Rn = SP (31)
    // Encoding: 0x2E0087E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E0087E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd_zr_rd_2e00841f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd with Rd = ZR (31)
    // Encoding: 0x2E00841F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E00841F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_int_product Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_q_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Q = 0 (Min)
    // Fields: size=0, Rm=0, Q=0, U=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_q_1_max_9c00_4e209c00() {
    // Encoding: 0x4E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Q = 1 (Max)
    // Fields: Rn=0, Q=1, Rm=0, Rd=0, U=0, size=0
    let encoding: u32 = 0x4E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_u_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field U = 0 (Min)
    // Fields: Rd=0, Rn=0, Q=0, U=0, size=0, Rm=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_u_1_max_9c00_2e209c00() {
    // Encoding: 0x2E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field U = 1 (Max)
    // Fields: Rn=0, Q=0, size=0, U=1, Rm=0, Rd=0
    let encoding: u32 = 0x2E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_size_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field size = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, Rd=0, Q=0, U=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_size_1_poweroftwo_9c00_0e609c00() {
    // Encoding: 0x0E609C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field size = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, Rd=0, size=1, U=0, Rn=0
    let encoding: u32 = 0x0E609C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_size_2_poweroftwo_9c00_0ea09c00() {
    // Encoding: 0x0EA09C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field size = 2 (PowerOfTwo)
    // Fields: Q=0, U=0, size=2, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_size_3_max_9c00_0ee09c00() {
    // Encoding: 0x0EE09C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field size = 3 (Max)
    // Fields: Rn=0, Rm=0, Rd=0, Q=0, U=0, size=3
    let encoding: u32 = 0x0EE09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rm_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rm = 0 (Min)
    // Fields: Rd=0, Q=0, size=0, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rm_1_poweroftwo_9c00_0e219c00() {
    // Encoding: 0x0E219C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, size=0, Rn=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E219C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rm_30_poweroftwominusone_9c00_0e3e9c00() {
    // Encoding: 0x0E3E9C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Q=0, U=0, Rn=0, Rd=0, size=0
    let encoding: u32 = 0x0E3E9C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rm_31_max_9c00_0e3f9c00() {
    // Encoding: 0x0E3F9C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rm = 31 (Max)
    // Fields: Rm=31, size=0, U=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E3F9C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rn_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rn = 0 (Min)
    // Fields: U=0, Rm=0, Rd=0, size=0, Q=0, Rn=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rn_1_poweroftwo_9c00_0e209c20() {
    // Encoding: 0x0E209C20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rm=0, Rn=1, Rd=0, size=0, Q=0
    let encoding: u32 = 0x0E209C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rn_30_poweroftwominusone_9c00_0e209fc0() {
    // Encoding: 0x0E209FC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rm=0, Rn=30, Q=0, U=0, size=0
    let encoding: u32 = 0x0E209FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rn_31_max_9c00_0e209fe0() {
    // Encoding: 0x0E209FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rn = 31 (Max)
    // Fields: U=0, size=0, Rm=0, Q=0, Rd=0, Rn=31
    let encoding: u32 = 0x0E209FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rd_0_min_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rd = 0 (Min)
    // Fields: U=0, size=0, Rm=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rd_1_poweroftwo_9c00_0e209c01() {
    // Encoding: 0x0E209C01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rm=0, Rd=1, Q=0, Rn=0, size=0
    let encoding: u32 = 0x0E209C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rd_30_poweroftwominusone_9c00_0e209c1e() {
    // Encoding: 0x0E209C1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, U=0, size=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E209C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_field_rd_31_max_9c00_0e209c1f() {
    // Encoding: 0x0E209C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field Rd = 31 (Max)
    // Fields: U=0, Rd=31, size=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E209C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_combo_0_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product field combination: Q=0, U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: U=0, size=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_q_0_size_variant_0_39936_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value Q = 0 (Size variant 0)
    // Fields: Q=0, size=0, Rm=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_q_1_size_variant_1_39936_4e209c00() {
    // Encoding: 0x4E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value Q = 1 (Size variant 1)
    // Fields: Q=1, size=0, Rm=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x4E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_size_0_size_variant_0_39936_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value size = 0 (Size variant 0)
    // Fields: Rn=0, U=0, Q=0, size=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_size_1_size_variant_1_39936_0e609c00() {
    // Encoding: 0x0E609C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value size = 1 (Size variant 1)
    // Fields: Q=0, size=1, U=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E609C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_size_2_size_variant_2_39936_0ea09c00() {
    // Encoding: 0x0EA09C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value size = 2 (Size variant 2)
    // Fields: Rd=0, size=2, Q=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x0EA09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_size_3_size_variant_3_39936_0ee09c00() {
    // Encoding: 0x0EE09C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value size = 3 (Size variant 3)
    // Fields: U=0, size=3, Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0EE09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_rn_31_stack_pointer_sp_may_require_alignment_39936_0e209fe0() {
    // Encoding: 0x0E209FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, U=0, Rd=0, Rm=0, size=0, Rn=31
    let encoding: u32 = 0x0E209FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_39936_0e209c1f() {
    // Encoding: 0x0E209C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, U=0, Rd=31, size=0, Q=0, Rm=0
    let encoding: u32 = 0x0E209C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"U\" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_invalid_0_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "U" }), rhs: Binary { op: And, lhs: LitBits([true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([false, false]) }
    // Fields: Rd=0, size=0, U=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_invalid_1_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Rn=0, size=0, U=0, Q=0, Rm=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_invalid_2_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Rm=0, Q=0, Rd=0, Rn=0, size=0, U=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_invalid_3_9c00_0e209c00() {
    // Encoding: 0x0E209C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product invalid encoding: Unconditional UNDEFINED
    // Fields: U=0, Q=0, size=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_reg_write_0_0e209c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product register write: SimdFromField("d")
    // Encoding: 0x0E209C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E209C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_sp_rn_0e209fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product with Rn = SP (31)
    // Encoding: 0x0E209FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E209FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_int_product
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_int_product_zr_rd_0e209c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_int_product with Rd = ZR (31)
    // Encoding: 0x0E209C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E209C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_q_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Q = 0 (Min)
    // Fields: sz=0, M=0, Rn=0, Q=0, L=0, S=0, Rm=0, H=0, Rd=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_q_1_max_0_4f800000() {
    // Encoding: 0x4F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Q = 1 (Max)
    // Fields: Q=1, H=0, sz=0, M=0, L=0, Rn=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x4F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_sz_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field sz = 0 (Min)
    // Fields: S=0, M=0, Q=0, Rm=0, Rd=0, L=0, H=0, Rn=0, sz=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_sz_1_max_0_0fc00000() {
    // Encoding: 0x0FC00000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field sz = 1 (Max)
    // Fields: M=0, Rn=0, Rd=0, sz=1, L=0, S=0, H=0, Q=0, Rm=0
    let encoding: u32 = 0x0FC00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_l_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field L = 0 (Min)
    // Fields: Rd=0, H=0, L=0, sz=0, Rm=0, Q=0, M=0, S=0, Rn=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_l_1_max_0_0fa00000() {
    // Encoding: 0x0FA00000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field L = 1 (Max)
    // Fields: Rm=0, M=0, L=1, sz=0, S=0, Q=0, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x0FA00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_m_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field M = 0 (Min)
    // Fields: Rm=0, Q=0, M=0, Rd=0, S=0, Rn=0, H=0, sz=0, L=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_m_1_max_0_0f900000() {
    // Encoding: 0x0F900000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field M = 1 (Max)
    // Fields: Rn=0, S=0, Q=0, Rm=0, sz=0, L=0, M=1, Rd=0, H=0
    let encoding: u32 = 0x0F900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rm_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rm = 0 (Min)
    // Fields: Rd=0, Rn=0, sz=0, Rm=0, Q=0, H=0, M=0, L=0, S=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rm_1_poweroftwo_0_0f810000() {
    // Encoding: 0x0F810000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, M=0, S=0, L=0, Q=0, sz=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field S 14 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_s_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field S = 0 (Min)
    // Fields: Q=0, L=0, Rn=0, sz=0, Rd=0, Rm=0, H=0, M=0, S=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field S 14 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_s_1_max_0_0f804000() {
    // Encoding: 0x0F804000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field S = 1 (Max)
    // Fields: H=0, Q=0, Rd=0, Rn=0, L=0, sz=0, Rm=0, M=0, S=1
    let encoding: u32 = 0x0F804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_h_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field H = 0 (Min)
    // Fields: Q=0, Rm=0, S=0, M=0, L=0, Rd=0, H=0, sz=0, Rn=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_h_1_max_0_0f800800() {
    // Encoding: 0x0F800800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field H = 1 (Max)
    // Fields: Q=0, sz=0, L=0, Rd=0, Rn=0, S=0, Rm=0, H=1, M=0
    let encoding: u32 = 0x0F800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rn_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rn = 0 (Min)
    // Fields: Q=0, Rm=0, sz=0, L=0, M=0, S=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rn_1_poweroftwo_0_0f800020() {
    // Encoding: 0x0F800020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, M=0, Rn=1, H=0, L=0, S=0, sz=0, Q=0, Rm=0
    let encoding: u32 = 0x0F800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rn_30_poweroftwominusone_0_0f8003c0() {
    // Encoding: 0x0F8003C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, H=0, sz=0, M=0, Rm=0, L=0, Rn=30, S=0, Rd=0
    let encoding: u32 = 0x0F8003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rn_31_max_0_0f8003e0() {
    // Encoding: 0x0F8003E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rn = 31 (Max)
    // Fields: sz=0, Rd=0, Q=0, M=0, Rm=0, H=0, Rn=31, L=0, S=0
    let encoding: u32 = 0x0F8003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rd_0_min_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rd = 0 (Min)
    // Fields: Q=0, sz=0, Rn=0, Rd=0, H=0, M=0, S=0, L=0, Rm=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rd_1_poweroftwo_0_0f800001() {
    // Encoding: 0x0F800001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rd = 1 (PowerOfTwo)
    // Fields: S=0, sz=0, L=0, Q=0, Rm=0, H=0, Rn=0, M=0, Rd=1
    let encoding: u32 = 0x0F800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rd_30_poweroftwominusone_0_0f80001e() {
    // Encoding: 0x0F80001E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rn=0, M=0, Rd=30, L=0, H=0, sz=0, Q=0, Rm=0
    let encoding: u32 = 0x0F80001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_field_rd_31_max_0_0f80001f() {
    // Encoding: 0x0F80001F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field Rd = 31 (Max)
    // Fields: M=0, S=0, sz=0, H=0, L=0, Rd=31, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0F80001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_combo_0_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower field combination: Q=0, sz=0, L=0, M=0, Rm=0, S=0, H=0, Rn=0, Rd=0
    // Fields: M=0, S=0, sz=0, H=0, L=0, Q=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_q_0_size_variant_0_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value Q = 0 (Size variant 0)
    // Fields: sz=0, L=0, Rd=0, Q=0, Rm=0, M=0, Rn=0, H=0, S=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_q_1_size_variant_1_0_4f800000() {
    // Encoding: 0x4F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value Q = 1 (Size variant 1)
    // Fields: Rm=0, Rn=0, Q=1, L=0, Rd=0, H=0, sz=0, M=0, S=0
    let encoding: u32 = 0x4F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_sz_0_size_variant_0_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value sz = 0 (Size variant 0)
    // Fields: Rd=0, L=0, Rm=0, S=0, Rn=0, sz=0, M=0, H=0, Q=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_sz_1_size_variant_1_0_0fc00000() {
    // Encoding: 0x0FC00000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value sz = 1 (Size variant 1)
    // Fields: Q=0, Rm=0, M=0, Rd=0, H=0, sz=1, Rn=0, L=0, S=0
    let encoding: u32 = 0x0FC00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_s_0_size_variant_0_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value S = 0 (Size variant 0)
    // Fields: L=0, Rm=0, M=0, H=0, S=0, Rd=0, sz=0, Q=0, Rn=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_s_1_size_variant_1_0_0f804000() {
    // Encoding: 0x0F804000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value S = 1 (Size variant 1)
    // Fields: Rn=0, L=0, H=0, Rd=0, sz=0, M=0, Q=0, Rm=0, S=1
    let encoding: u32 = 0x0F804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_rn_31_stack_pointer_sp_may_require_alignment_0_0f8003e0() {
    // Encoding: 0x0F8003E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: M=0, S=0, H=0, sz=0, Rd=0, L=0, Q=0, Rm=0, Rn=31
    let encoding: u32 = 0x0F8003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_0_0f80001f() {
    // Encoding: 0x0F80001F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: sz=0, L=0, S=0, H=0, Q=0, Rm=0, M=0, Rn=0, Rd=31
    let encoding: u32 = 0x0F80001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16MulNoRoundingToFP32Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_invalid_0_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }
    // Fields: Q=0, L=0, sz=0, Rn=0, S=0, Rm=0, Rd=0, M=0, H=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_invalid_1_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower invalid encoding: Unconditional UNDEFINED
    // Fields: M=0, Rd=0, sz=0, Rm=0, L=0, Rn=0, Q=0, S=0, H=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_invalid_2_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }
    // Fields: L=0, Rn=0, Rm=0, Rd=0, M=0, sz=0, S=0, H=0, Q=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_invalid_3_0_0f800000() {
    // Encoding: 0x0F800000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, M=0, L=0, S=0, H=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0F800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_q_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Q = 0 (Min)
    // Fields: H=0, Rd=0, Rn=0, M=0, Rm=0, S=0, sz=0, L=0, Q=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_q_1_max_8000_6f808000() {
    // Encoding: 0x6F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Q = 1 (Max)
    // Fields: L=0, S=0, Rd=0, Q=1, M=0, H=0, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x6F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_sz_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field sz = 0 (Min)
    // Fields: M=0, S=0, Q=0, H=0, Rn=0, Rd=0, sz=0, L=0, Rm=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_sz_1_max_8000_2fc08000() {
    // Encoding: 0x2FC08000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field sz = 1 (Max)
    // Fields: Rn=0, sz=1, H=0, L=0, Rm=0, M=0, Q=0, S=0, Rd=0
    let encoding: u32 = 0x2FC08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_l_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field L = 0 (Min)
    // Fields: Q=0, L=0, H=0, Rd=0, Rm=0, Rn=0, M=0, S=0, sz=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_l_1_max_8000_2fa08000() {
    // Encoding: 0x2FA08000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field L = 1 (Max)
    // Fields: L=1, S=0, Rm=0, sz=0, Q=0, Rd=0, M=0, H=0, Rn=0
    let encoding: u32 = 0x2FA08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_m_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field M = 0 (Min)
    // Fields: Q=0, Rm=0, L=0, Rn=0, sz=0, S=0, M=0, H=0, Rd=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_m_1_max_8000_2f908000() {
    // Encoding: 0x2F908000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field M = 1 (Max)
    // Fields: S=0, M=1, Rn=0, L=0, sz=0, Q=0, Rd=0, Rm=0, H=0
    let encoding: u32 = 0x2F908000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rm_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rm = 0 (Min)
    // Fields: sz=0, Rd=0, H=0, Q=0, L=0, Rn=0, S=0, Rm=0, M=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rm_1_poweroftwo_8000_2f818000() {
    // Encoding: 0x2F818000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rm = 1 (PowerOfTwo)
    // Fields: H=0, Rn=0, L=0, S=0, M=0, Rd=0, Q=0, sz=0, Rm=1
    let encoding: u32 = 0x2F818000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field S 14 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_s_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field S = 0 (Min)
    // Fields: M=0, S=0, Rm=0, Rn=0, sz=0, L=0, Q=0, H=0, Rd=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field S 14 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_s_1_max_8000_2f80c000() {
    // Encoding: 0x2F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field S = 1 (Max)
    // Fields: M=0, S=1, Q=0, Rd=0, sz=0, L=0, Rm=0, Rn=0, H=0
    let encoding: u32 = 0x2F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_h_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field H = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0, S=0, Q=0, H=0, M=0, Rd=0, L=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_h_1_max_8000_2f808800() {
    // Encoding: 0x2F808800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field H = 1 (Max)
    // Fields: L=0, S=0, Rm=0, H=1, M=0, Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2F808800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rn_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rn = 0 (Min)
    // Fields: L=0, sz=0, Q=0, Rm=0, S=0, Rn=0, H=0, M=0, Rd=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rn_1_poweroftwo_8000_2f808020() {
    // Encoding: 0x2F808020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rn = 1 (PowerOfTwo)
    // Fields: L=0, M=0, Rn=1, Q=0, Rd=0, Rm=0, S=0, H=0, sz=0
    let encoding: u32 = 0x2F808020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rn_30_poweroftwominusone_8000_2f8083c0() {
    // Encoding: 0x2F8083C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: S=0, Rd=0, L=0, H=0, M=0, Q=0, Rm=0, Rn=30, sz=0
    let encoding: u32 = 0x2F8083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rn_31_max_8000_2f8083e0() {
    // Encoding: 0x2F8083E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rn = 31 (Max)
    // Fields: sz=0, L=0, M=0, Q=0, S=0, H=0, Rm=0, Rn=31, Rd=0
    let encoding: u32 = 0x2F8083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rd_0_min_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rd = 0 (Min)
    // Fields: sz=0, Rn=0, Rm=0, Q=0, H=0, Rd=0, S=0, L=0, M=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rd_1_poweroftwo_8000_2f808001() {
    // Encoding: 0x2F808001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, S=0, H=0, Q=0, Rm=0, sz=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x2F808001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rd_30_poweroftwominusone_8000_2f80801e() {
    // Encoding: 0x2F80801E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30, M=0, Q=0, Rm=0, L=0, sz=0, S=0, H=0
    let encoding: u32 = 0x2F80801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_field_rd_31_max_8000_2f80801f() {
    // Encoding: 0x2F80801F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field Rd = 31 (Max)
    // Fields: L=0, Rn=0, Rd=31, Rm=0, Q=0, M=0, S=0, sz=0, H=0
    let encoding: u32 = 0x2F80801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_combo_0_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper field combination: Q=0, sz=0, L=0, M=0, Rm=0, S=0, H=0, Rn=0, Rd=0
    // Fields: Q=0, H=0, Rd=0, S=0, sz=0, Rn=0, Rm=0, M=0, L=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_q_0_size_variant_0_32768_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value Q = 0 (Size variant 0)
    // Fields: Rn=0, sz=0, Rd=0, L=0, M=0, Rm=0, H=0, S=0, Q=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_q_1_size_variant_1_32768_6f808000() {
    // Encoding: 0x6F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value Q = 1 (Size variant 1)
    // Fields: S=0, Q=1, sz=0, Rd=0, L=0, M=0, H=0, Rn=0, Rm=0
    let encoding: u32 = 0x6F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_sz_0_size_variant_0_32768_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value sz = 0 (Size variant 0)
    // Fields: Q=0, H=0, Rn=0, Rd=0, sz=0, S=0, Rm=0, L=0, M=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_sz_1_size_variant_1_32768_2fc08000() {
    // Encoding: 0x2FC08000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value sz = 1 (Size variant 1)
    // Fields: H=0, sz=1, M=0, L=0, Q=0, S=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x2FC08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_s_0_size_variant_0_32768_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value S = 0 (Size variant 0)
    // Fields: L=0, Rm=0, Rn=0, H=0, sz=0, Q=0, S=0, Rd=0, M=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_s_1_size_variant_1_32768_2f80c000() {
    // Encoding: 0x2F80C000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value S = 1 (Size variant 1)
    // Fields: Rm=0, Rd=0, Q=0, sz=0, M=0, Rn=0, H=0, S=1, L=0
    let encoding: u32 = 0x2F80C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_rn_31_stack_pointer_sp_may_require_alignment_32768_2f8083e0() {
    // Encoding: 0x2F8083E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, M=0, sz=0, S=0, Q=0, L=0, Rn=31, H=0, Rm=0
    let encoding: u32 = 0x2F8083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_32768_2f80801f() {
    // Encoding: 0x2F80801F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: H=0, Rn=0, Q=0, L=0, M=0, sz=0, S=0, Rm=0, Rd=31
    let encoding: u32 = 0x2F80801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16MulNoRoundingToFP32Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_invalid_0_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16MulNoRoundingToFP32Ext" }, args: [] } }
    // Fields: Rd=0, L=0, H=0, Q=0, M=0, Rm=0, Rn=0, S=0, sz=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_invalid_1_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper invalid encoding: Unconditional UNDEFINED
    // Fields: L=0, S=0, Q=0, sz=0, Rm=0, Rd=0, M=0, Rn=0, H=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: LitBits([true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_invalid_2_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: LitBits([true]) }
    // Fields: S=0, H=0, Rm=0, M=0, Q=0, L=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_invalid_3_8000_2f808000() {
    // Encoding: 0x2F808000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, L=0, Rm=0, Q=0, Rd=0, Rn=0, S=0, H=0, M=0
    let encoding: u32 = 0x2F808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_reg_write_0_0f800000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower register write: SimdFromField("d")
    // Encoding: 0x0F800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_sp_rn_0f8003e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower with Rn = SP (31)
    // Encoding: 0x0F8003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F8003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower_zr_rd_0f80001f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower with Rd = ZR (31)
    // Encoding: 0x0F80001F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F80001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_reg_write_0_2f808000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper register write: SimdFromField("d")
    // Encoding: 0x2F808000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F808000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_sp_rn_2f8083e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper with Rn = SP (31)
    // Encoding: 0x2F8083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F8083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper_zr_rd_2f80801f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper with Rd = ZR (31)
    // Encoding: 0x2F80801F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2F80801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_fp_complex Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_q_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Q = 0 (Min)
    // Fields: Rn=0, Rd=0, Q=0, size=0, Rm=0, rot=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_q_1_max_c400_6e00c400() {
    // Encoding: 0x6E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Q = 1 (Max)
    // Fields: Q=1, Rm=0, rot=0, Rn=0, size=0, Rd=0
    let encoding: u32 = 0x6E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_size_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field size = 0 (Min)
    // Fields: Q=0, Rd=0, rot=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_size_1_poweroftwo_c400_2e40c400() {
    // Encoding: 0x2E40C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field size = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, rot=0, Rd=0, size=1, Rn=0
    let encoding: u32 = 0x2E40C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_size_2_poweroftwo_c400_2e80c400() {
    // Encoding: 0x2E80C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field size = 2 (PowerOfTwo)
    // Fields: size=2, Rn=0, Rd=0, Q=0, rot=0, Rm=0
    let encoding: u32 = 0x2E80C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_size_3_max_c400_2ec0c400() {
    // Encoding: 0x2EC0C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field size = 3 (Max)
    // Fields: Rd=0, size=3, Rm=0, rot=0, Rn=0, Q=0
    let encoding: u32 = 0x2EC0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rm_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rm = 0 (Min)
    // Fields: Rn=0, size=0, Rd=0, rot=0, Q=0, Rm=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rm_1_poweroftwo_c400_2e01c400() {
    // Encoding: 0x2E01C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rm = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rn=0, Rm=1, rot=0, Rd=0
    let encoding: u32 = 0x2E01C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rm_30_poweroftwominusone_c400_2e1ec400() {
    // Encoding: 0x2E1EC400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, rot=0, Rn=0, Rd=0, Rm=30
    let encoding: u32 = 0x2E1EC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rm_31_max_c400_2e1fc400() {
    // Encoding: 0x2E1FC400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rm = 31 (Max)
    // Fields: size=0, Rn=0, Rd=0, Q=0, Rm=31, rot=0
    let encoding: u32 = 0x2E1FC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field rot 11 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rot_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field rot = 0 (Min)
    // Fields: size=0, Rm=0, Rn=0, Q=0, rot=0, Rd=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field rot 11 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rot_1_poweroftwo_c400_2e00cc00() {
    // Encoding: 0x2E00CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field rot = 1 (PowerOfTwo)
    // Fields: rot=1, size=0, Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x2E00CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field rot 11 +: 2`
/// Requirement: FieldBoundary { field: "rot", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rot_3_max_c400_2e00dc00() {
    // Encoding: 0x2E00DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field rot = 3 (Max)
    // Fields: size=0, Rn=0, rot=3, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x2E00DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rn_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rn = 0 (Min)
    // Fields: size=0, Rm=0, Q=0, rot=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rn_1_poweroftwo_c400_2e00c420() {
    // Encoding: 0x2E00C420
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rn=1, Rd=0, rot=0, Rm=0
    let encoding: u32 = 0x2E00C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rn_30_poweroftwominusone_c400_2e00c7c0() {
    // Encoding: 0x2E00C7C0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0, rot=0, Rm=0, size=0
    let encoding: u32 = 0x2E00C7C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rn_31_max_c400_2e00c7e0() {
    // Encoding: 0x2E00C7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rn = 31 (Max)
    // Fields: Q=0, Rn=31, Rm=0, Rd=0, rot=0, size=0
    let encoding: u32 = 0x2E00C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rd_0_min_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rd = 0 (Min)
    // Fields: rot=0, Rn=0, Rm=0, Q=0, Rd=0, size=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rd_1_poweroftwo_c400_2e00c401() {
    // Encoding: 0x2E00C401
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, size=0, Rm=0, rot=0, Rn=0, Rd=1
    let encoding: u32 = 0x2E00C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rd_30_poweroftwominusone_c400_2e00c41e() {
    // Encoding: 0x2E00C41E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, size=0, rot=0, Rn=0, Rm=0, Rd=30
    let encoding: u32 = 0x2E00C41E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_field_rd_31_max_c400_2e00c41f() {
    // Encoding: 0x2E00C41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field Rd = 31 (Max)
    // Fields: size=0, Rm=0, Q=0, rot=0, Rn=0, Rd=31
    let encoding: u32 = 0x2E00C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_combo_0_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex field combination: Q=0, size=0, Rm=0, rot=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Q=0, size=0, rot=0, Rn=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_q_0_size_variant_0_50176_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rm=0, Q=0, Rd=0, size=0, rot=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_q_1_size_variant_1_50176_6e00c400() {
    // Encoding: 0x6E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value Q = 1 (Size variant 1)
    // Fields: rot=0, Q=1, size=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x6E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_size_0_size_variant_0_50176_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value size = 0 (Size variant 0)
    // Fields: size=0, Rd=0, rot=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_size_1_size_variant_1_50176_2e40c400() {
    // Encoding: 0x2E40C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value size = 1 (Size variant 1)
    // Fields: Rn=0, size=1, Rd=0, rot=0, Rm=0, Q=0
    let encoding: u32 = 0x2E40C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_size_2_size_variant_2_50176_2e80c400() {
    // Encoding: 0x2E80C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value size = 2 (Size variant 2)
    // Fields: Q=0, size=2, rot=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E80C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_size_3_size_variant_3_50176_2ec0c400() {
    // Encoding: 0x2EC0C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value size = 3 (Size variant 3)
    // Fields: size=3, Rm=0, Rn=0, Q=0, rot=0, Rd=0
    let encoding: u32 = 0x2EC0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_rn_31_stack_pointer_sp_may_require_alignment_50176_2e00c7e0() {
    // Encoding: 0x2E00C7E0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: rot=0, Rd=0, Rm=0, size=0, Rn=31, Q=0
    let encoding: u32 = 0x2E00C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_50176_2e00c41f() {
    // Encoding: 0x2E00C41F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: size=0, Rn=0, Rm=0, Rd=31, rot=0, Q=0
    let encoding: u32 = 0x2E00C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFCADDExt" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFCADDExt\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_0_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFCADDExt" }, args: [] } }
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, size=0, rot=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_1_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, Rm=0, size=0, Rn=0, rot=0, Rd=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_2_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Rd=0, Rm=0, Q=0, rot=0, size=0, Rn=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_3_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, rot=0, Rn=0, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_4_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: Binary { op: And, lhs: LitBits([false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: size=0, Rn=0, Rd=0, Q=0, Rm=0, rot=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_5_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, rot=0, Q=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "esize" }) }, rhs: LitInt(16) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"esize\" }) }, rhs: LitInt(16) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_6_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Binary { op: Eq, lhs: Binary { op: And, lhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "esize" }) }, rhs: LitInt(16) }
    // Fields: rot=0, Q=0, size=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_invalid_7_c400_2e00c400() {
    // Encoding: 0x2E00C400
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rd=0, size=0, Q=0, rot=0, Rm=0
    let encoding: u32 = 0x2E00C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_reg_write_0_2e00c400() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex register write: SimdFromField("d")
    // Encoding: 0x2E00C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E00C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_sp_rn_2e00c7e0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex with Rn = SP (31)
    // Encoding: 0x2E00C7E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E00C7E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_complex
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_complex_zr_rd_2e00c41f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_complex with Rd = ZR (31)
    // Encoding: 0x2E00C41F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E00C41F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_l_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field L = 0 (Min)
    // Fields: H=0, Rd=0, Rn=0, Rm=0, L=0, o2=0, M=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_l_1_max_1000_5f201000() {
    // Encoding: 0x5F201000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field L = 1 (Max)
    // Fields: Rm=0, L=1, H=0, Rn=0, o2=0, Rd=0, M=0
    let encoding: u32 = 0x5F201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_m_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field M = 0 (Min)
    // Fields: L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_m_1_max_1000_5f101000() {
    // Encoding: 0x5F101000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field M = 1 (Max)
    // Fields: L=0, M=1, Rn=0, Rd=0, o2=0, Rm=0, H=0
    let encoding: u32 = 0x5F101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rm_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rm = 0 (Min)
    // Fields: H=0, Rn=0, Rd=0, L=0, M=0, Rm=0, o2=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rm_1_poweroftwo_1000_5f011000() {
    // Encoding: 0x5F011000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=1, o2=0, L=0, H=0, M=0, Rn=0
    let encoding: u32 = 0x5F011000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_o2_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field o2 = 0 (Min)
    // Fields: Rn=0, M=0, Rm=0, L=0, o2=0, H=0, Rd=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_o2_1_max_1000_5f005000() {
    // Encoding: 0x5F005000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field o2 = 1 (Max)
    // Fields: Rd=0, H=0, L=0, Rm=0, Rn=0, M=0, o2=1
    let encoding: u32 = 0x5F005000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_h_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field H = 0 (Min)
    // Fields: Rn=0, L=0, M=0, Rm=0, o2=0, H=0, Rd=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_h_1_max_1000_5f001800() {
    // Encoding: 0x5F001800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field H = 1 (Max)
    // Fields: L=0, Rn=0, Rd=0, H=1, o2=0, M=0, Rm=0
    let encoding: u32 = 0x5F001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rn_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rn = 0 (Min)
    // Fields: o2=0, Rn=0, Rd=0, H=0, Rm=0, M=0, L=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rn_1_poweroftwo_1000_5f001020() {
    // Encoding: 0x5F001020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: M=0, H=0, Rm=0, Rn=1, Rd=0, L=0, o2=0
    let encoding: u32 = 0x5F001020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rn_30_poweroftwominusone_1000_5f0013c0() {
    // Encoding: 0x5F0013C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: H=0, Rn=30, Rd=0, L=0, Rm=0, o2=0, M=0
    let encoding: u32 = 0x5F0013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rn_31_max_1000_5f0013e0() {
    // Encoding: 0x5F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rn = 31 (Max)
    // Fields: H=0, Rn=31, Rd=0, o2=0, L=0, Rm=0, M=0
    let encoding: u32 = 0x5F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rd_0_min_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rd = 0 (Min)
    // Fields: L=0, o2=0, H=0, Rn=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rd_1_poweroftwo_1000_5f001001() {
    // Encoding: 0x5F001001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: H=0, Rm=0, o2=0, Rn=0, Rd=1, L=0, M=0
    let encoding: u32 = 0x5F001001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rd_30_poweroftwominusone_1000_5f00101e() {
    // Encoding: 0x5F00101E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o2=0, Rm=0, M=0, Rn=0, H=0, Rd=30, L=0
    let encoding: u32 = 0x5F00101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_field_rd_31_max_1000_5f00101f() {
    // Encoding: 0x5F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field Rd = 31 (Max)
    // Fields: Rn=0, Rd=31, M=0, Rm=0, o2=0, H=0, L=0
    let encoding: u32 = 0x5F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// L=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_combo_0_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd field combination: L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: Rd=0, H=0, M=0, o2=0, L=0, Rn=0, Rm=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_4096_5f0013e0() {
    // Encoding: 0x5F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, M=0, Rm=0, o2=0, L=0, H=0, Rn=31
    let encoding: u32 = 0x5F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_4096_5f00101f() {
    // Encoding: 0x5F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rm=0, o2=0, M=0, H=0, L=0, Rn=0
    let encoding: u32 = 0x5F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_invalid_0_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Rm=0, H=0, L=0, M=0, Rn=0, Rd=0, o2=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_invalid_1_1000_5f001000() {
    // Encoding: 0x5F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rd=0, L=0, H=0, Rm=0, M=0, o2=0
    let encoding: u32 = 0x5F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_sz_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field sz = 0 (Min)
    // Fields: M=0, Rm=0, H=0, Rn=0, L=0, o2=0, sz=0, Rd=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_sz_1_max_1000_5fc01000() {
    // Encoding: 0x5FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field sz = 1 (Max)
    // Fields: o2=0, Rn=0, M=0, L=0, H=0, sz=1, Rd=0, Rm=0
    let encoding: u32 = 0x5FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_l_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field L = 0 (Min)
    // Fields: H=0, Rn=0, M=0, o2=0, L=0, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_l_1_max_1000_5fa01000() {
    // Encoding: 0x5FA01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field L = 1 (Max)
    // Fields: H=0, M=0, Rn=0, Rm=0, o2=0, Rd=0, sz=0, L=1
    let encoding: u32 = 0x5FA01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_m_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field M = 0 (Min)
    // Fields: Rn=0, Rm=0, Rd=0, L=0, M=0, sz=0, o2=0, H=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_m_1_max_1000_5f901000() {
    // Encoding: 0x5F901000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field M = 1 (Max)
    // Fields: Rd=0, Rn=0, M=1, L=0, o2=0, Rm=0, sz=0, H=0
    let encoding: u32 = 0x5F901000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rm_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rm = 0 (Min)
    // Fields: Rn=0, H=0, M=0, sz=0, Rm=0, L=0, Rd=0, o2=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rm_1_poweroftwo_1000_5f811000() {
    // Encoding: 0x5F811000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, o2=0, M=0, Rn=0, H=0, Rm=1, L=0, Rd=0
    let encoding: u32 = 0x5F811000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_o2_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field o2 = 0 (Min)
    // Fields: H=0, sz=0, Rn=0, Rd=0, Rm=0, M=0, o2=0, L=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_o2_1_max_1000_5f805000() {
    // Encoding: 0x5F805000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field o2 = 1 (Max)
    // Fields: Rm=0, o2=1, M=0, Rn=0, L=0, sz=0, Rd=0, H=0
    let encoding: u32 = 0x5F805000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_h_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field H = 0 (Min)
    // Fields: Rd=0, sz=0, Rm=0, L=0, Rn=0, M=0, o2=0, H=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_h_1_max_1000_5f801800() {
    // Encoding: 0x5F801800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field H = 1 (Max)
    // Fields: Rn=0, Rd=0, Rm=0, o2=0, sz=0, L=0, H=1, M=0
    let encoding: u32 = 0x5F801800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rn_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rn = 0 (Min)
    // Fields: Rd=0, o2=0, sz=0, L=0, M=0, H=0, Rm=0, Rn=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rn_1_poweroftwo_1000_5f801020() {
    // Encoding: 0x5F801020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, L=0, Rn=1, Rm=0, o2=0, M=0, H=0, sz=0
    let encoding: u32 = 0x5F801020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rn_30_poweroftwominusone_1000_5f8013c0() {
    // Encoding: 0x5F8013C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=0, L=0, o2=0, Rm=0, Rn=30, M=0, H=0
    let encoding: u32 = 0x5F8013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rn_31_max_1000_5f8013e0() {
    // Encoding: 0x5F8013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rn = 31 (Max)
    // Fields: M=0, sz=0, L=0, Rm=0, Rd=0, H=0, Rn=31, o2=0
    let encoding: u32 = 0x5F8013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rd_0_min_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rm=0, sz=0, o2=0, L=0, M=0, Rd=0, H=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rd_1_poweroftwo_1000_5f801001() {
    // Encoding: 0x5F801001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, L=0, sz=0, M=0, o2=0, H=0, Rd=1
    let encoding: u32 = 0x5F801001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rd_30_poweroftwominusone_1000_5f80101e() {
    // Encoding: 0x5F80101E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: H=0, M=0, Rm=0, Rn=0, Rd=30, L=0, o2=0, sz=0
    let encoding: u32 = 0x5F80101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_field_rd_31_max_1000_5f80101f() {
    // Encoding: 0x5F80101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field Rd = 31 (Max)
    // Fields: sz=0, Rm=0, o2=0, Rn=0, L=0, M=0, Rd=31, H=0
    let encoding: u32 = 0x5F80101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_combo_0_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd field combination: sz=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, L=0, H=0, M=0, o2=0, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_special_sz_0_size_variant_0_4096_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd special value sz = 0 (Size variant 0)
    // Fields: M=0, Rd=0, H=0, Rn=0, L=0, sz=0, Rm=0, o2=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_special_sz_1_size_variant_1_4096_5fc01000() {
    // Encoding: 0x5FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd special value sz = 1 (Size variant 1)
    // Fields: Rm=0, L=0, Rd=0, M=0, H=0, Rn=0, sz=1, o2=0
    let encoding: u32 = 0x5FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_4096_5f8013e0() {
    // Encoding: 0x5F8013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=0, M=0, L=0, o2=0, Rm=0, Rn=31, H=0, Rd=0
    let encoding: u32 = 0x5F8013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_4096_5f80101f() {
    // Encoding: 0x5F80101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: M=0, o2=0, H=0, Rn=0, L=0, sz=0, Rm=0, Rd=31
    let encoding: u32 = 0x5F80101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_invalid_0_1000_5f801000() {
    // Encoding: 0x5F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, L=0, H=0, Rd=0, Rn=0, M=0, o2=0
    let encoding: u32 = 0x5F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_q_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Q = 0 (Min)
    // Fields: Rd=0, L=0, Q=0, o2=0, Rn=0, M=0, H=0, Rm=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_q_1_max_1000_4f001000() {
    // Encoding: 0x4F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Q = 1 (Max)
    // Fields: Q=1, H=0, Rd=0, Rm=0, L=0, M=0, o2=0, Rn=0
    let encoding: u32 = 0x4F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_l_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field L = 0 (Min)
    // Fields: Rn=0, o2=0, M=0, Q=0, Rm=0, L=0, Rd=0, H=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_l_1_max_1000_0f201000() {
    // Encoding: 0x0F201000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field L = 1 (Max)
    // Fields: o2=0, M=0, L=1, Q=0, Rd=0, H=0, Rn=0, Rm=0
    let encoding: u32 = 0x0F201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_m_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field M = 0 (Min)
    // Fields: o2=0, Rd=0, Rn=0, L=0, M=0, Q=0, Rm=0, H=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_m_1_max_1000_0f101000() {
    // Encoding: 0x0F101000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field M = 1 (Max)
    // Fields: o2=0, Rm=0, Rn=0, H=0, M=1, Q=0, Rd=0, L=0
    let encoding: u32 = 0x0F101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rm_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rm = 0 (Min)
    // Fields: H=0, Rd=0, Rm=0, Q=0, L=0, M=0, o2=0, Rn=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rm_1_poweroftwo_1000_0f011000() {
    // Encoding: 0x0F011000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rm = 1 (PowerOfTwo)
    // Fields: M=0, Rm=1, Q=0, L=0, Rd=0, H=0, o2=0, Rn=0
    let encoding: u32 = 0x0F011000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_o2_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field o2 = 0 (Min)
    // Fields: Rm=0, o2=0, M=0, L=0, Rn=0, H=0, Rd=0, Q=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_o2_1_max_1000_0f005000() {
    // Encoding: 0x0F005000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field o2 = 1 (Max)
    // Fields: o2=1, Q=0, Rm=0, H=0, Rd=0, M=0, L=0, Rn=0
    let encoding: u32 = 0x0F005000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_h_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field H = 0 (Min)
    // Fields: Rd=0, H=0, Rn=0, Q=0, M=0, L=0, Rm=0, o2=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_h_1_max_1000_0f001800() {
    // Encoding: 0x0F001800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field H = 1 (Max)
    // Fields: Rn=0, M=0, Q=0, H=1, L=0, o2=0, Rd=0, Rm=0
    let encoding: u32 = 0x0F001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rn_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rn = 0 (Min)
    // Fields: Q=0, L=0, Rd=0, Rn=0, H=0, Rm=0, o2=0, M=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rn_1_poweroftwo_1000_0f001020() {
    // Encoding: 0x0F001020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: M=0, Rd=0, o2=0, Q=0, Rm=0, H=0, Rn=1, L=0
    let encoding: u32 = 0x0F001020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rn_30_poweroftwominusone_1000_0f0013c0() {
    // Encoding: 0x0F0013C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, L=0, Rm=0, Rn=30, Rd=0, M=0, o2=0, H=0
    let encoding: u32 = 0x0F0013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rn_31_max_1000_0f0013e0() {
    // Encoding: 0x0F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rn = 31 (Max)
    // Fields: M=0, o2=0, Q=0, Rn=31, Rd=0, L=0, H=0, Rm=0
    let encoding: u32 = 0x0F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rd_0_min_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rd = 0 (Min)
    // Fields: M=0, H=0, Rm=0, o2=0, Rd=0, Rn=0, L=0, Q=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rd_1_poweroftwo_1000_0f001001() {
    // Encoding: 0x0F001001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, H=0, Rn=0, L=0, Rd=1, o2=0, Q=0, M=0
    let encoding: u32 = 0x0F001001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rd_30_poweroftwominusone_1000_0f00101e() {
    // Encoding: 0x0F00101E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: o2=0, H=0, Rd=30, Q=0, M=0, L=0, Rn=0, Rm=0
    let encoding: u32 = 0x0F00101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_field_rd_31_max_1000_0f00101f() {
    // Encoding: 0x0F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field Rd = 31 (Max)
    // Fields: M=0, Rm=0, Q=0, H=0, Rn=0, L=0, o2=0, Rd=31
    let encoding: u32 = 0x0F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_combo_0_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd field combination: Q=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, Rd=0, M=0, o2=0, Q=0, H=0, L=0, Rn=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_special_q_0_size_variant_0_4096_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, Rn=0, o2=0, Rd=0, M=0, L=0, H=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_special_q_1_size_variant_1_4096_4f001000() {
    // Encoding: 0x4F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: H=0, o2=0, L=0, Rn=0, Rm=0, Rd=0, M=0, Q=1
    let encoding: u32 = 0x4F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_4096_0f0013e0() {
    // Encoding: 0x0F0013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Rn=31, L=0, Rm=0, Q=0, M=0, H=0, o2=0
    let encoding: u32 = 0x0F0013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_4096_0f00101f() {
    // Encoding: 0x0F00101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: L=0, o2=0, Rm=0, H=0, Rn=0, Q=0, M=0, Rd=31
    let encoding: u32 = 0x0F00101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_invalid_0_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Q=0, o2=0, M=0, Rn=0, H=0, Rd=0, L=0, Rm=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_invalid_1_1000_0f001000() {
    // Encoding: 0x0F001000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd invalid encoding: Unconditional UNDEFINED
    // Fields: H=0, Rm=0, Rn=0, o2=0, Q=0, M=0, L=0, Rd=0
    let encoding: u32 = 0x0F001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_q_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Q = 0 (Min)
    // Fields: Q=0, sz=0, Rm=0, H=0, Rn=0, o2=0, M=0, Rd=0, L=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_q_1_max_1000_4f801000() {
    // Encoding: 0x4F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Q = 1 (Max)
    // Fields: o2=0, Rd=0, M=0, Rn=0, sz=0, Rm=0, Q=1, H=0, L=0
    let encoding: u32 = 0x4F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_sz_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field sz = 0 (Min)
    // Fields: Q=0, Rm=0, o2=0, L=0, M=0, sz=0, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_sz_1_max_1000_0fc01000() {
    // Encoding: 0x0FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field sz = 1 (Max)
    // Fields: Q=0, Rm=0, sz=1, L=0, o2=0, M=0, Rn=0, H=0, Rd=0
    let encoding: u32 = 0x0FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_l_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field L = 0 (Min)
    // Fields: H=0, Rm=0, L=0, sz=0, Q=0, Rn=0, M=0, o2=0, Rd=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_l_1_max_1000_0fa01000() {
    // Encoding: 0x0FA01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field L = 1 (Max)
    // Fields: M=0, L=1, H=0, o2=0, Rm=0, Q=0, Rn=0, Rd=0, sz=0
    let encoding: u32 = 0x0FA01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_m_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field M = 0 (Min)
    // Fields: Rn=0, sz=0, o2=0, Rm=0, Q=0, L=0, H=0, M=0, Rd=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_m_1_max_1000_0f901000() {
    // Encoding: 0x0F901000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field M = 1 (Max)
    // Fields: L=0, Rn=0, Rd=0, M=1, o2=0, Q=0, H=0, sz=0, Rm=0
    let encoding: u32 = 0x0F901000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rm_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rm = 0 (Min)
    // Fields: Q=0, Rm=0, sz=0, Rd=0, o2=0, Rn=0, H=0, L=0, M=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rm_1_poweroftwo_1000_0f811000() {
    // Encoding: 0x0F811000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, o2=0, L=0, Q=0, Rm=1, M=0, H=0, sz=0, Rn=0
    let encoding: u32 = 0x0F811000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_o2_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field o2 = 0 (Min)
    // Fields: sz=0, L=0, Rn=0, M=0, Q=0, Rm=0, o2=0, Rd=0, H=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field o2 14 +: 1`
/// Requirement: FieldBoundary { field: "o2", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_o2_1_max_1000_0f805000() {
    // Encoding: 0x0F805000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field o2 = 1 (Max)
    // Fields: H=0, sz=0, M=0, Rn=0, L=0, Q=0, o2=1, Rm=0, Rd=0
    let encoding: u32 = 0x0F805000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_h_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field H = 0 (Min)
    // Fields: Rm=0, o2=0, H=0, Rn=0, Q=0, Rd=0, sz=0, M=0, L=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_h_1_max_1000_0f801800() {
    // Encoding: 0x0F801800
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field H = 1 (Max)
    // Fields: Q=0, sz=0, Rn=0, M=0, L=0, H=1, Rd=0, Rm=0, o2=0
    let encoding: u32 = 0x0F801800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rn_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rn = 0 (Min)
    // Fields: Q=0, o2=0, Rn=0, M=0, H=0, sz=0, L=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rn_1_poweroftwo_1000_0f801020() {
    // Encoding: 0x0F801020
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rn = 1 (PowerOfTwo)
    // Fields: M=0, Rd=0, sz=0, Q=0, L=0, Rn=1, o2=0, Rm=0, H=0
    let encoding: u32 = 0x0F801020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rn_30_poweroftwominusone_1000_0f8013c0() {
    // Encoding: 0x0F8013C0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, H=0, Rn=30, sz=0, Rd=0, L=0, o2=0, M=0, Rm=0
    let encoding: u32 = 0x0F8013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rn_31_max_1000_0f8013e0() {
    // Encoding: 0x0F8013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rn = 31 (Max)
    // Fields: Rd=0, L=0, Q=0, M=0, o2=0, Rm=0, sz=0, H=0, Rn=31
    let encoding: u32 = 0x0F8013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rd_0_min_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rd = 0 (Min)
    // Fields: Q=0, Rd=0, o2=0, L=0, H=0, Rm=0, M=0, sz=0, Rn=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rd_1_poweroftwo_1000_0f801001() {
    // Encoding: 0x0F801001
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, L=0, sz=0, o2=0, H=0, Rm=0, Rn=0, Rd=1, M=0
    let encoding: u32 = 0x0F801001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rd_30_poweroftwominusone_1000_0f80101e() {
    // Encoding: 0x0F80101E
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, H=0, sz=0, Rn=0, Q=0, M=0, Rd=30, L=0, o2=0
    let encoding: u32 = 0x0F80101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_field_rd_31_max_1000_0f80101f() {
    // Encoding: 0x0F80101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field Rd = 31 (Max)
    // Fields: Rn=0, o2=0, L=0, H=0, Rd=31, Rm=0, sz=0, Q=0, M=0
    let encoding: u32 = 0x0F80101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_combo_0_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd field combination: Q=0, sz=0, L=0, M=0, Rm=0, o2=0, H=0, Rn=0, Rd=0
    // Fields: Rm=0, H=0, L=0, Q=0, M=0, o2=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_q_0_size_variant_0_4096_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value Q = 0 (Size variant 0)
    // Fields: Rm=0, Q=0, H=0, Rn=0, L=0, sz=0, Rd=0, M=0, o2=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_q_1_size_variant_1_4096_4f801000() {
    // Encoding: 0x4F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value Q = 1 (Size variant 1)
    // Fields: L=0, H=0, Rm=0, o2=0, M=0, Rd=0, Rn=0, Q=1, sz=0
    let encoding: u32 = 0x4F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_sz_0_size_variant_0_4096_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value sz = 0 (Size variant 0)
    // Fields: Q=0, L=0, o2=0, H=0, Rn=0, sz=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_sz_1_size_variant_1_4096_0fc01000() {
    // Encoding: 0x0FC01000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value sz = 1 (Size variant 1)
    // Fields: Q=0, M=0, sz=1, L=0, H=0, Rm=0, o2=0, Rd=0, Rn=0
    let encoding: u32 = 0x0FC01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_rn_31_stack_pointer_sp_may_require_alignment_4096_0f8013e0() {
    // Encoding: 0x0F8013E0
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, H=0, Rm=0, Rn=31, M=0, Rd=0, sz=0, o2=0, L=0
    let encoding: u32 = 0x0F8013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_4096_0f80101f() {
    // Encoding: 0x0F80101F
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: M=0, Rn=0, Rd=31, sz=0, Rm=0, Q=0, o2=0, H=0, L=0
    let encoding: u32 = 0x0F80101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_invalid_0_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, o2=0, L=0, Rd=0, sz=0, M=0, Rn=0, Rm=0, H=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true, false]) } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_invalid_1_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }
    // Fields: M=0, L=0, Rd=0, H=0, Rn=0, Rm=0, Q=0, sz=0, o2=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_invalid_2_1000_0f801000() {
    // Encoding: 0x0F801000
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd invalid encoding: Unconditional UNDEFINED
    // Fields: H=0, Rd=0, o2=0, sz=0, Rm=0, L=0, Q=0, Rn=0, M=0
    let encoding: u32 = 0x0F801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_reg_write_0_5f001000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x5F001000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_sp_rn_5f0013e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd with Rn = SP (31)
    // Encoding: 0x5F0013E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F0013E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd_zr_rd_5f00101f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x5F00101F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00101F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_reg_write_0_5f801000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd register write: SimdFromField("d")
    // Encoding: 0x5F801000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_sp_rn_5f8013e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd with Rn = SP (31)
    // Encoding: 0x5F8013E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F8013E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd_zr_rd_5f80101f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_sisd with Rd = ZR (31)
    // Encoding: 0x5F80101F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F80101F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_reg_write_0_0f001000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x0F001000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_sp_rn_0f0013e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd with Rn = SP (31)
    // Encoding: 0x0F0013E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F0013E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd_zr_rd_0f00101f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp16_simd with Rd = ZR (31)
    // Encoding: 0x0F00101F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00101F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_reg_write_0_0f801000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd register write: SimdFromField("d")
    // Encoding: 0x0F801000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_sp_rn_0f8013e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd with Rn = SP (31)
    // Encoding: 0x0F8013E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F8013E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd_zr_rd_0f80101f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_acc_fp_simd with Rd = ZR (31)
    // Encoding: 0x0F80101F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F80101F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_long Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_q_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Q = 0 (Min)
    // Fields: M=0, size=0, L=0, Rm=0, Rn=0, Rd=0, Q=0, U=0, H=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_q_1_max_a000_4f00a000() {
    // Encoding: 0x4F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Q = 1 (Max)
    // Fields: L=0, Q=1, Rd=0, M=0, U=0, size=0, H=0, Rn=0, Rm=0
    let encoding: u32 = 0x4F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_u_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field U = 0 (Min)
    // Fields: M=0, H=0, Q=0, size=0, Rd=0, U=0, L=0, Rn=0, Rm=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_u_1_max_a000_2f00a000() {
    // Encoding: 0x2F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field U = 1 (Max)
    // Fields: U=1, Rm=0, M=0, H=0, Rd=0, size=0, L=0, Q=0, Rn=0
    let encoding: u32 = 0x2F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_size_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field size = 0 (Min)
    // Fields: U=0, H=0, size=0, Rn=0, Rd=0, Q=0, M=0, L=0, Rm=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_size_1_poweroftwo_a000_0f40a000() {
    // Encoding: 0x0F40A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field size = 1 (PowerOfTwo)
    // Fields: size=1, Q=0, Rd=0, L=0, H=0, M=0, U=0, Rn=0, Rm=0
    let encoding: u32 = 0x0F40A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_size_2_poweroftwo_a000_0f80a000() {
    // Encoding: 0x0F80A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field size = 2 (PowerOfTwo)
    // Fields: H=0, Rd=0, Rm=0, Rn=0, U=0, M=0, Q=0, size=2, L=0
    let encoding: u32 = 0x0F80A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_size_3_max_a000_0fc0a000() {
    // Encoding: 0x0FC0A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field size = 3 (Max)
    // Fields: U=0, Q=0, size=3, H=0, Rn=0, L=0, M=0, Rd=0, Rm=0
    let encoding: u32 = 0x0FC0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_l_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field L = 0 (Min)
    // Fields: size=0, U=0, L=0, M=0, H=0, Rn=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_l_1_max_a000_0f20a000() {
    // Encoding: 0x0F20A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field L = 1 (Max)
    // Fields: Q=0, U=0, Rn=0, M=0, Rm=0, Rd=0, size=0, L=1, H=0
    let encoding: u32 = 0x0F20A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_m_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field M = 0 (Min)
    // Fields: H=0, U=0, L=0, Rd=0, M=0, size=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_m_1_max_a000_0f10a000() {
    // Encoding: 0x0F10A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field M = 1 (Max)
    // Fields: Rd=0, Rm=0, size=0, M=1, Q=0, U=0, H=0, L=0, Rn=0
    let encoding: u32 = 0x0F10A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rm_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rm = 0 (Min)
    // Fields: Rn=0, size=0, H=0, Q=0, U=0, L=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rm_1_poweroftwo_a000_0f01a000() {
    // Encoding: 0x0F01A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rm = 1 (PowerOfTwo)
    // Fields: size=0, U=0, H=0, Q=0, M=0, Rn=0, L=0, Rm=1, Rd=0
    let encoding: u32 = 0x0F01A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_h_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field H = 0 (Min)
    // Fields: U=0, Q=0, Rm=0, size=0, Rn=0, Rd=0, H=0, M=0, L=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_h_1_max_a000_0f00a800() {
    // Encoding: 0x0F00A800
    // Test aarch64_vector_arithmetic_binary_element_mul_long field H = 1 (Max)
    // Fields: H=1, U=0, Q=0, Rd=0, Rm=0, M=0, Rn=0, L=0, size=0
    let encoding: u32 = 0x0F00A800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rn_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rn = 0 (Min)
    // Fields: size=0, M=0, H=0, Rd=0, Rn=0, U=0, Rm=0, Q=0, L=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rn_1_poweroftwo_a000_0f00a020() {
    // Encoding: 0x0F00A020
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, M=0, Rd=0, Rn=1, Q=0, U=0, H=0, L=0
    let encoding: u32 = 0x0F00A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rn_30_poweroftwominusone_a000_0f00a3c0() {
    // Encoding: 0x0F00A3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, L=0, H=0, U=0, M=0, size=0, Rd=0, Q=0
    let encoding: u32 = 0x0F00A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rn_31_max_a000_0f00a3e0() {
    // Encoding: 0x0F00A3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rn = 31 (Max)
    // Fields: M=0, Rm=0, size=0, U=0, L=0, Rn=31, Q=0, H=0, Rd=0
    let encoding: u32 = 0x0F00A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rd_0_min_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rd = 0 (Min)
    // Fields: U=0, size=0, H=0, Rn=0, Q=0, L=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rd_1_poweroftwo_a000_0f00a001() {
    // Encoding: 0x0F00A001
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, M=0, Rm=0, size=0, L=0, Rn=0, H=0, Rd=1, U=0
    let encoding: u32 = 0x0F00A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rd_30_poweroftwominusone_a000_0f00a01e() {
    // Encoding: 0x0F00A01E
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, Rn=0, Rd=30, H=0, size=0, Q=0, U=0, L=0, Rm=0
    let encoding: u32 = 0x0F00A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_field_rd_31_max_a000_0f00a01f() {
    // Encoding: 0x0F00A01F
    // Test aarch64_vector_arithmetic_binary_element_mul_long field Rd = 31 (Max)
    // Fields: Rd=31, size=0, H=0, Q=0, M=0, L=0, Rm=0, Rn=0, U=0
    let encoding: u32 = 0x0F00A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_combo_0_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long field combination: Q=0, U=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: H=0, Rn=0, Rm=0, L=0, U=0, Rd=0, size=0, M=0, Q=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_q_0_size_variant_0_40960_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value Q = 0 (Size variant 0)
    // Fields: U=0, Rm=0, Rn=0, H=0, L=0, M=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_q_1_size_variant_1_40960_4f00a000() {
    // Encoding: 0x4F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value Q = 1 (Size variant 1)
    // Fields: H=0, Q=1, Rm=0, U=0, size=0, L=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0x4F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_size_0_size_variant_0_40960_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value size = 0 (Size variant 0)
    // Fields: H=0, Q=0, U=0, Rm=0, M=0, Rn=0, L=0, Rd=0, size=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_size_1_size_variant_1_40960_0f40a000() {
    // Encoding: 0x0F40A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value size = 1 (Size variant 1)
    // Fields: M=0, Rd=0, Q=0, L=0, Rn=0, H=0, size=1, Rm=0, U=0
    let encoding: u32 = 0x0F40A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_size_2_size_variant_2_40960_0f80a000() {
    // Encoding: 0x0F80A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value size = 2 (Size variant 2)
    // Fields: Rm=0, H=0, Q=0, M=0, Rn=0, size=2, L=0, Rd=0, U=0
    let encoding: u32 = 0x0F80A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_size_3_size_variant_3_40960_0fc0a000() {
    // Encoding: 0x0FC0A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value size = 3 (Size variant 3)
    // Fields: Rm=0, Q=0, H=0, Rd=0, U=0, size=3, Rn=0, L=0, M=0
    let encoding: u32 = 0x0FC0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_rn_31_stack_pointer_sp_may_require_alignment_40960_0f00a3e0() {
    // Encoding: 0x0F00A3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: H=0, U=0, L=0, M=0, size=0, Rm=0, Q=0, Rn=31, Rd=0
    let encoding: u32 = 0x0F00A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_40960_0f00a01f() {
    // Encoding: 0x0F00A01F
    // Test aarch64_vector_arithmetic_binary_element_mul_long special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: H=0, M=0, Rm=0, Rn=0, L=0, U=0, Q=0, size=0, Rd=31
    let encoding: u32 = 0x0F00A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_invalid_0_a000_0f00a000() {
    // Encoding: 0x0F00A000
    // Test aarch64_vector_arithmetic_binary_element_mul_long invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rd=0, H=0, M=0, U=0, L=0, Rm=0, size=0, Q=0
    let encoding: u32 = 0x0F00A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_reg_write_0_0f00a000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_long register write: SimdFromField("d")
    // Encoding: 0x0F00A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_sp_rn_0f00a3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_long with Rn = SP (31)
    // Encoding: 0x0F00A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_long
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_long_zr_rd_0f00a01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_long with Rd = ZR (31)
    // Encoding: 0x0F00A01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00A01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rm_0_min_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rm = 0 (Min)
    // Fields: Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rm_1_poweroftwo_1c00_5e411c00() {
    // Encoding: 0x5E411C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, Rm=1
    let encoding: u32 = 0x5E411C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rm_30_poweroftwominusone_1c00_5e5e1c00() {
    // Encoding: 0x5E5E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=0, Rm=30
    let encoding: u32 = 0x5E5E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rm_31_max_1c00_5e5f1c00() {
    // Encoding: 0x5E5F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rm = 31 (Max)
    // Fields: Rm=31, Rd=0, Rn=0
    let encoding: u32 = 0x5E5F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rn_0_min_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rn = 0 (Min)
    // Fields: Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rn_1_poweroftwo_1c00_5e401c20() {
    // Encoding: 0x5E401C20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Rm=0
    let encoding: u32 = 0x5E401C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rn_30_poweroftwominusone_1c00_5e401fc0() {
    // Encoding: 0x5E401FC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rd=0, Rn=30
    let encoding: u32 = 0x5E401FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rn_31_max_1c00_5e401fe0() {
    // Encoding: 0x5E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, Rd=0
    let encoding: u32 = 0x5E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rd_0_min_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rd_1_poweroftwo_1c00_5e401c01() {
    // Encoding: 0x5E401C01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x5E401C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rd_30_poweroftwominusone_1c00_5e401c1e() {
    // Encoding: 0x5E401C1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Rd=30
    let encoding: u32 = 0x5E401C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_field_rd_31_max_1c00_5e401c1f() {
    // Encoding: 0x5E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field Rd = 31 (Max)
    // Fields: Rm=0, Rn=0, Rd=31
    let encoding: u32 = 0x5E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_combo_0_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd field combination: Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_7168_5e401fe0() {
    // Encoding: 0x5E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, Rm=0, Rn=31
    let encoding: u32 = 0x5E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_7168_5e401c1f() {
    // Encoding: 0x5E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Rn=0, Rm=0
    let encoding: u32 = 0x5E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_invalid_0_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_invalid_1_1c00_5e401c00() {
    // Encoding: 0x5E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_sz_0_min_dc00_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field sz = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_sz_1_max_dc00_5e60dc00() {
    // Encoding: 0x5E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field sz = 1 (Max)
    // Fields: Rd=0, Rn=0, sz=1, Rm=0
    let encoding: u32 = 0x5E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rm_0_min_dc00_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rm = 0 (Min)
    // Fields: Rd=0, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rm_1_poweroftwo_dc00_5e21dc00() {
    // Encoding: 0x5E21DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, sz=0, Rm=1
    let encoding: u32 = 0x5E21DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rm_30_poweroftwominusone_dc00_5e3edc00() {
    // Encoding: 0x5E3EDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, sz=0, Rm=30, Rn=0
    let encoding: u32 = 0x5E3EDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rm_31_max_dc00_5e3fdc00() {
    // Encoding: 0x5E3FDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rm = 31 (Max)
    // Fields: sz=0, Rn=0, Rm=31, Rd=0
    let encoding: u32 = 0x5E3FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rn_0_min_dc00_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rn = 0 (Min)
    // Fields: Rm=0, sz=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rn_1_poweroftwo_dc00_5e20dc20() {
    // Encoding: 0x5E20DC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rm=0, Rd=0, Rn=1
    let encoding: u32 = 0x5E20DC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rn_30_poweroftwominusone_dc00_5e20dfc0() {
    // Encoding: 0x5E20DFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, sz=0, Rn=30, Rd=0
    let encoding: u32 = 0x5E20DFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rn_31_max_dc00_5e20dfe0() {
    // Encoding: 0x5E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x5E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rd_0_min_dc00_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rd = 0 (Min)
    // Fields: sz=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rd_1_poweroftwo_dc00_5e20dc01() {
    // Encoding: 0x5E20DC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rd = 1 (PowerOfTwo)
    // Fields: sz=0, Rn=0, Rm=0, Rd=1
    let encoding: u32 = 0x5E20DC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rd_30_poweroftwominusone_dc00_5e20dc1e() {
    // Encoding: 0x5E20DC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=30, Rm=0, sz=0
    let encoding: u32 = 0x5E20DC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_field_rd_31_max_dc00_5e20dc1f() {
    // Encoding: 0x5E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field Rd = 31 (Max)
    // Fields: Rd=31, Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x5E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_combo_0_dc00_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd field combination: sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_special_sz_0_size_variant_0_56320_5e20dc00() {
    // Encoding: 0x5E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd special value sz = 0 (Size variant 0)
    // Fields: Rm=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x5E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_special_sz_1_size_variant_1_56320_5e60dc00() {
    // Encoding: 0x5E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd special value sz = 1 (Size variant 1)
    // Fields: sz=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_56320_5e20dfe0() {
    // Encoding: 0x5E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=0, Rm=0, Rd=0, Rn=31
    let encoding: u32 = 0x5E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_56320_5e20dc1f() {
    // Encoding: 0x5E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rd=31, Rm=0, sz=0
    let encoding: u32 = 0x5E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_q_0_min_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Q = 0 (Min)
    // Fields: Rm=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_q_1_max_1c00_4e401c00() {
    // Encoding: 0x4E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Q = 1 (Max)
    // Fields: Rd=0, Rm=0, Q=1, Rn=0
    let encoding: u32 = 0x4E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rm_0_min_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rm = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rm_1_poweroftwo_1c00_0e411c00() {
    // Encoding: 0x0E411C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E411C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rm_30_poweroftwominusone_1c00_0e5e1c00() {
    // Encoding: 0x0E5E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, Rm=30, Rn=0, Q=0
    let encoding: u32 = 0x0E5E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rm_31_max_1c00_0e5f1c00() {
    // Encoding: 0x0E5F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rm = 31 (Max)
    // Fields: Rd=0, Q=0, Rm=31, Rn=0
    let encoding: u32 = 0x0E5F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rn_0_min_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rn = 0 (Min)
    // Fields: Q=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rn_1_poweroftwo_1c00_0e401c20() {
    // Encoding: 0x0E401C20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=0, Rn=1, Q=0
    let encoding: u32 = 0x0E401C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rn_30_poweroftwominusone_1c00_0e401fc0() {
    // Encoding: 0x0E401FC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rd=0, Rn=30, Q=0
    let encoding: u32 = 0x0E401FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rn_31_max_1c00_0e401fe0() {
    // Encoding: 0x0E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rn = 31 (Max)
    // Fields: Rn=31, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rd_0_min_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rd_1_poweroftwo_1c00_0e401c01() {
    // Encoding: 0x0E401C01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=0, Rm=0, Rd=1
    let encoding: u32 = 0x0E401C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rd_30_poweroftwominusone_1c00_0e401c1e() {
    // Encoding: 0x0E401C1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, Rm=0, Rd=30
    let encoding: u32 = 0x0E401C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_field_rd_31_max_1c00_0e401c1f() {
    // Encoding: 0x0E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field Rd = 31 (Max)
    // Fields: Rm=0, Q=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_combo_0_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_special_q_0_size_variant_0_7168_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_special_q_1_size_variant_1_7168_4e401c00() {
    // Encoding: 0x4E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x4E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_special_rn_31_stack_pointer_sp_may_require_alignment_7168_0e401fe0() {
    // Encoding: 0x0E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Q=0, Rn=31, Rd=0, Rm=0
    let encoding: u32 = 0x0E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_7168_0e401c1f() {
    // Encoding: 0x0E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rd=31, Rn=0, Rm=0
    let encoding: u32 = 0x0E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_invalid_0_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_invalid_1_1c00_0e401c00() {
    // Encoding: 0x0E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_q_0_min_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Q = 0 (Min)
    // Fields: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_q_1_max_dc00_4e20dc00() {
    // Encoding: 0x4E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Q = 1 (Max)
    // Fields: Rm=0, sz=0, Rn=0, Rd=0, Q=1
    let encoding: u32 = 0x4E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_sz_0_min_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field sz = 0 (Min)
    // Fields: sz=0, Q=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_sz_1_max_dc00_0e60dc00() {
    // Encoding: 0x0E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field sz = 1 (Max)
    // Fields: Rn=0, Q=0, sz=1, Rd=0, Rm=0
    let encoding: u32 = 0x0E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rm_0_min_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rm = 0 (Min)
    // Fields: sz=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rm_1_poweroftwo_dc00_0e21dc00() {
    // Encoding: 0x0E21DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=1, sz=0, Rn=0, Q=0
    let encoding: u32 = 0x0E21DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rm_30_poweroftwominusone_dc00_0e3edc00() {
    // Encoding: 0x0E3EDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, sz=0, Q=0, Rn=0, Rm=30
    let encoding: u32 = 0x0E3EDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rm_31_max_dc00_0e3fdc00() {
    // Encoding: 0x0E3FDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rm = 31 (Max)
    // Fields: Q=0, Rn=0, Rd=0, Rm=31, sz=0
    let encoding: u32 = 0x0E3FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rn_0_min_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rn = 0 (Min)
    // Fields: sz=0, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rn_1_poweroftwo_dc00_0e20dc20() {
    // Encoding: 0x0E20DC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rm=0, Rn=1, Rd=0
    let encoding: u32 = 0x0E20DC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rn_30_poweroftwominusone_dc00_0e20dfc0() {
    // Encoding: 0x0E20DFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rd=0, Q=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20DFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rn_31_max_dc00_0e20dfe0() {
    // Encoding: 0x0E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rn = 31 (Max)
    // Fields: Q=0, Rm=0, sz=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rd_0_min_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rd = 0 (Min)
    // Fields: Rd=0, Q=0, Rn=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rd_1_poweroftwo_dc00_0e20dc01() {
    // Encoding: 0x0E20DC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Rm=0, Q=0, sz=0
    let encoding: u32 = 0x0E20DC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rd_30_poweroftwominusone_dc00_0e20dc1e() {
    // Encoding: 0x0E20DC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rd=30, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x0E20DC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_field_rd_31_max_dc00_0e20dc1f() {
    // Encoding: 0x0E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field Rd = 31 (Max)
    // Fields: Q=0, sz=0, Rm=0, Rd=31, Rn=0
    let encoding: u32 = 0x0E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_combo_0_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_q_0_size_variant_0_56320_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rn=0, Rm=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_q_1_size_variant_1_56320_4e20dc00() {
    // Encoding: 0x4E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rm=0, sz=0, Rd=0, Rn=0
    let encoding: u32 = 0x4E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_sz_0_size_variant_0_56320_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value sz = 0 (Size variant 0)
    // Fields: Rd=0, sz=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_sz_1_size_variant_1_56320_0e60dc00() {
    // Encoding: 0x0E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value sz = 1 (Size variant 1)
    // Fields: Rm=0, Q=0, Rd=0, Rn=0, sz=1
    let encoding: u32 = 0x0E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_rn_31_stack_pointer_sp_may_require_alignment_56320_0e20dfe0() {
    // Encoding: 0x0E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_56320_0e20dc1f() {
    // Encoding: 0x0E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, sz=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true, false]) } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_invalid_0_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }
    // Fields: Rn=0, Rm=0, Rd=0, sz=0, Q=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_invalid_1_dc00_0e20dc00() {
    // Encoding: 0x0E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rd=0, Q=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_reg_write_0_5e401c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd register write: SimdFromField("d")
    // Encoding: 0x5E401C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E401C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_sp_rn_5e401fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd with Rn = SP (31)
    // Encoding: 0x5E401FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E401FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd_zr_rd_5e401c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd with Rd = ZR (31)
    // Encoding: 0x5E401C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E401C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_reg_write_0_5e20dc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd register write: SimdFromField("d")
    // Encoding: 0x5E20DC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20DC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_sp_rn_5e20dfe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd with Rn = SP (31)
    // Encoding: 0x5E20DFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20DFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd_zr_rd_5e20dc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_sisd with Rd = ZR (31)
    // Encoding: 0x5E20DC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20DC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_reg_write_0_0e401c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd register write: SimdFromField("d")
    // Encoding: 0x0E401C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E401C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_sp_rn_0e401fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd with Rn = SP (31)
    // Encoding: 0x0E401FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E401FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd_zr_rd_0e401c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_extended_simd with Rd = ZR (31)
    // Encoding: 0x0E401C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E401C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_reg_write_0_0e20dc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd register write: SimdFromField("d")
    // Encoding: 0x0E20DC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20DC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_sp_rn_0e20dfe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd with Rn = SP (31)
    // Encoding: 0x0E20DFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20DFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd_zr_rd_0e20dc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_extended_simd with Rd = ZR (31)
    // Encoding: 0x0E20DC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20DC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_fp16_product Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_q_0_min_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Q = 0 (Min)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_q_1_max_1c00_6e401c00() {
    // Encoding: 0x6E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Q = 1 (Max)
    // Fields: Q=1, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x6E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rm_0_min_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rm = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rm_1_poweroftwo_1c00_2e411c00() {
    // Encoding: 0x2E411C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, Rm=1, Q=0
    let encoding: u32 = 0x2E411C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rm_30_poweroftwominusone_1c00_2e5e1c00() {
    // Encoding: 0x2E5E1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rm=30, Rn=0, Rd=0
    let encoding: u32 = 0x2E5E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rm_31_max_1c00_2e5f1c00() {
    // Encoding: 0x2E5F1C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rm = 31 (Max)
    // Fields: Rm=31, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x2E5F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rn_0_min_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rn = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rn_1_poweroftwo_1c00_2e401c20() {
    // Encoding: 0x2E401C20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x2E401C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rn_30_poweroftwominusone_1c00_2e401fc0() {
    // Encoding: 0x2E401FC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Q=0, Rd=0
    let encoding: u32 = 0x2E401FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rn_31_max_1c00_2e401fe0() {
    // Encoding: 0x2E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rn = 31 (Max)
    // Fields: Rn=31, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rd_0_min_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rd = 0 (Min)
    // Fields: Rn=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rd_1_poweroftwo_1c00_2e401c01() {
    // Encoding: 0x2E401C01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x2E401C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rd_30_poweroftwominusone_1c00_2e401c1e() {
    // Encoding: 0x2E401C1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Q=0, Rd=30, Rm=0
    let encoding: u32 = 0x2E401C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_field_rd_31_max_1c00_2e401c1f() {
    // Encoding: 0x2E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field Rd = 31 (Max)
    // Fields: Rm=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x2E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_combo_0_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product field combination: Q=0, Rm=0, Rn=0, Rd=0
    // Fields: Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_special_q_0_size_variant_0_7168_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product special value Q = 0 (Size variant 0)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_special_q_1_size_variant_1_7168_6e401c00() {
    // Encoding: 0x6E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x6E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_special_rn_31_stack_pointer_sp_may_require_alignment_7168_2e401fe0() {
    // Encoding: 0x2E401FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Q=0, Rd=0
    let encoding: u32 = 0x2E401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_7168_2e401c1f() {
    // Encoding: 0x2E401C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rm=0, Rn=0, Rd=31
    let encoding: u32 = 0x2E401C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_invalid_0_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Q=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_invalid_1_1c00_2e401c00() {
    // Encoding: 0x2E401C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_q_0_min_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Q = 0 (Min)
    // Fields: sz=0, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_q_1_max_dc00_6e20dc00() {
    // Encoding: 0x6E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Q = 1 (Max)
    // Fields: Q=1, Rm=0, Rd=0, Rn=0, sz=0
    let encoding: u32 = 0x6E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_sz_0_min_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field sz = 0 (Min)
    // Fields: Rm=0, Rd=0, Rn=0, sz=0, Q=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_sz_1_max_dc00_2e60dc00() {
    // Encoding: 0x2E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field sz = 1 (Max)
    // Fields: Q=0, sz=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rm_0_min_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rm = 0 (Min)
    // Fields: sz=0, Rd=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rm_1_poweroftwo_dc00_2e21dc00() {
    // Encoding: 0x2E21DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Q=0, Rd=0, sz=0, Rn=0
    let encoding: u32 = 0x2E21DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rm_30_poweroftwominusone_dc00_2e3edc00() {
    // Encoding: 0x2E3EDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=0, sz=0, Rm=30, Rn=0, Q=0
    let encoding: u32 = 0x2E3EDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rm_31_max_dc00_2e3fdc00() {
    // Encoding: 0x2E3FDC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rm = 31 (Max)
    // Fields: Rd=0, Rm=31, Q=0, sz=0, Rn=0
    let encoding: u32 = 0x2E3FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rn_0_min_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rn = 0 (Min)
    // Fields: sz=0, Rd=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rn_1_poweroftwo_dc00_2e20dc20() {
    // Encoding: 0x2E20DC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rn=1, sz=0, Rm=0, Rd=0
    let encoding: u32 = 0x2E20DC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rn_30_poweroftwominusone_dc00_2e20dfc0() {
    // Encoding: 0x2E20DFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rd=0, Q=0, Rn=30, Rm=0
    let encoding: u32 = 0x2E20DFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rn_31_max_dc00_2e20dfe0() {
    // Encoding: 0x2E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rn = 31 (Max)
    // Fields: Rd=0, Rm=0, Q=0, sz=0, Rn=31
    let encoding: u32 = 0x2E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rd_0_min_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rd = 0 (Min)
    // Fields: sz=0, Q=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rd_1_poweroftwo_dc00_2e20dc01() {
    // Encoding: 0x2E20DC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Rd=1, sz=0, Q=0
    let encoding: u32 = 0x2E20DC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rd_30_poweroftwominusone_dc00_2e20dc1e() {
    // Encoding: 0x2E20DC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, sz=0, Rn=0, Rd=30, Q=0
    let encoding: u32 = 0x2E20DC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_field_rd_31_max_dc00_2e20dc1f() {
    // Encoding: 0x2E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field Rd = 31 (Max)
    // Fields: Q=0, Rn=0, Rm=0, sz=0, Rd=31
    let encoding: u32 = 0x2E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_combo_0_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product field combination: Q=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rd=0, sz=0, Q=0, Rm=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_q_0_size_variant_0_56320_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value Q = 0 (Size variant 0)
    // Fields: sz=0, Rd=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_q_1_size_variant_1_56320_6e20dc00() {
    // Encoding: 0x6E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value Q = 1 (Size variant 1)
    // Fields: Rn=0, Rm=0, sz=0, Q=1, Rd=0
    let encoding: u32 = 0x6E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_sz_0_size_variant_0_56320_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value sz = 0 (Size variant 0)
    // Fields: sz=0, Q=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_sz_1_size_variant_1_56320_2e60dc00() {
    // Encoding: 0x2E60DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rm=0, sz=1, Q=0, Rd=0
    let encoding: u32 = 0x2E60DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_rn_31_stack_pointer_sp_may_require_alignment_56320_2e20dfe0() {
    // Encoding: 0x2E20DFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, sz=0, Rn=31, Rm=0, Q=0
    let encoding: u32 = 0x2E20DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_56320_2e20dc1f() {
    // Encoding: 0x2E20DC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, Rd=31, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x2E20DC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true, false]) } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_invalid_0_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }
    // Fields: Rm=0, Rn=0, Q=0, Rd=0, sz=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_invalid_1_dc00_2e20dc00() {
    // Encoding: 0x2E20DC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x2E20DC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_reg_write_0_2e401c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product register write: SimdFromField("d")
    // Encoding: 0x2E401C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E401C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_sp_rn_2e401fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product with Rn = SP (31)
    // Encoding: 0x2E401FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E401FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_product
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_product_zr_rd_2e401c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_product with Rd = ZR (31)
    // Encoding: 0x2E401C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E401C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_reg_write_0_2e20dc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product register write: SimdFromField("d")
    // Encoding: 0x2E20DC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20DC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_sp_rn_2e20dfe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product with Rn = SP (31)
    // Encoding: 0x2E20DFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20DFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_product
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_product_zr_rd_2e20dc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_product with Rd = ZR (31)
    // Encoding: 0x2E20DC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2E20DC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_mul_poly Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_q_0_min_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Q = 0 (Min)
    // Fields: Rm=0, Rn=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_q_1_max_e000_4e20e000() {
    // Encoding: 0x4E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Q = 1 (Max)
    // Fields: Rm=0, Q=1, size=0, Rd=0, Rn=0
    let encoding: u32 = 0x4E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_size_0_min_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field size = 0 (Min)
    // Fields: size=0, Rn=0, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_size_1_poweroftwo_e000_0e60e000() {
    // Encoding: 0x0E60E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field size = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, Rn=0, Rd=0, size=1
    let encoding: u32 = 0x0E60E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_size_2_poweroftwo_e000_0ea0e000() {
    // Encoding: 0x0EA0E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field size = 2 (PowerOfTwo)
    // Fields: Q=0, Rm=0, size=2, Rd=0, Rn=0
    let encoding: u32 = 0x0EA0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_size_3_max_e000_0ee0e000() {
    // Encoding: 0x0EE0E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field size = 3 (Max)
    // Fields: size=3, Rd=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x0EE0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rm_0_min_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rm_1_poweroftwo_e000_0e21e000() {
    // Encoding: 0x0E21E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, Rm=1, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E21E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rm_30_poweroftwominusone_e000_0e3ee000() {
    // Encoding: 0x0E3EE000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Q=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E3EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rm_31_max_e000_0e3fe000() {
    // Encoding: 0x0E3FE000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rm = 31 (Max)
    // Fields: Rd=0, Q=0, size=0, Rm=31, Rn=0
    let encoding: u32 = 0x0E3FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rn_0_min_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rn = 0 (Min)
    // Fields: size=0, Q=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rn_1_poweroftwo_e000_0e20e020() {
    // Encoding: 0x0E20E020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rn = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=0, Rm=0, size=0, Rn=1
    let encoding: u32 = 0x0E20E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rn_30_poweroftwominusone_e000_0e20e3c0() {
    // Encoding: 0x0E20E3C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, size=0, Rd=0, Q=0, Rn=30
    let encoding: u32 = 0x0E20E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rn_31_max_e000_0e20e3e0() {
    // Encoding: 0x0E20E3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rn = 31 (Max)
    // Fields: Rd=0, Rm=0, size=0, Rn=31, Q=0
    let encoding: u32 = 0x0E20E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rd_0_min_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rd = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0, Q=0, size=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rd_1_poweroftwo_e000_0e20e001() {
    // Encoding: 0x0E20E001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, Rm=0, size=0, Q=0
    let encoding: u32 = 0x0E20E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rd_30_poweroftwominusone_e000_0e20e01e() {
    // Encoding: 0x0E20E01E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, size=0, Rm=0, Q=0, Rd=30
    let encoding: u32 = 0x0E20E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_field_rd_31_max_e000_0e20e01f() {
    // Encoding: 0x0E20E01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field Rd = 31 (Max)
    // Fields: Rn=0, size=0, Rd=31, Rm=0, Q=0
    let encoding: u32 = 0x0E20E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_combo_0_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Q=0, size=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_q_0_size_variant_0_57344_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value Q = 0 (Size variant 0)
    // Fields: size=0, Rd=0, Rn=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_q_1_size_variant_1_57344_4e20e000() {
    // Encoding: 0x4E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rd=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0x4E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_size_0_size_variant_0_57344_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value size = 0 (Size variant 0)
    // Fields: Q=0, size=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_size_1_size_variant_1_57344_0e60e000() {
    // Encoding: 0x0E60E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value size = 1 (Size variant 1)
    // Fields: Rm=0, Q=0, size=1, Rn=0, Rd=0
    let encoding: u32 = 0x0E60E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_size_2_size_variant_2_57344_0ea0e000() {
    // Encoding: 0x0EA0E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value size = 2 (Size variant 2)
    // Fields: Rd=0, Q=0, Rn=0, Rm=0, size=2
    let encoding: u32 = 0x0EA0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_size_3_size_variant_3_57344_0ee0e000() {
    // Encoding: 0x0EE0E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value size = 3 (Size variant 3)
    // Fields: Q=0, Rd=0, size=3, Rn=0, Rm=0
    let encoding: u32 = 0x0EE0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_rn_31_stack_pointer_sp_may_require_alignment_57344_0e20e3e0() {
    // Encoding: 0x0E20E3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E20E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_0e20e01f() {
    // Encoding: 0x0E20E01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: size=0, Rd=31, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_invalid_0_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, true]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, false]) }
    // Fields: Rn=0, Rd=0, Q=0, size=0, Rm=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_invalid_1_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } } } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveBit128PMULLExt\" }, args: [] } } } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_invalid_2_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: And, lhs: LitBits([true, true]), rhs: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveBit128PMULLExt" }, args: [] } } } }
    // Fields: Rd=0, size=0, Q=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_invalid_3_e000_0e20e000() {
    // Encoding: 0x0E20E000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, Rn=0, Rm=0, size=0, Rd=0
    let encoding: u32 = 0x0E20E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_reg_write_0_0e20e000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly register write: SimdFromField("d")
    // Encoding: 0x0E20E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_sp_rn_0e20e3e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly with Rn = SP (31)
    // Encoding: 0x0E20E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_poly
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_poly_zr_rd_0e20e01f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_poly with Rd = ZR (31)
    // Encoding: 0x0E20E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_double_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_size_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field size = 0 (Min)
    // Fields: Rd=0, L=0, Rm=0, H=0, size=0, Rn=0, M=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_size_1_poweroftwo_b000_5f40b000() {
    // Encoding: 0x5F40B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field size = 1 (PowerOfTwo)
    // Fields: H=0, Rm=0, Rd=0, M=0, Rn=0, L=0, size=1
    let encoding: u32 = 0x5F40B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_size_2_poweroftwo_b000_5f80b000() {
    // Encoding: 0x5F80B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field size = 2 (PowerOfTwo)
    // Fields: Rd=0, M=0, L=0, H=0, Rn=0, size=2, Rm=0
    let encoding: u32 = 0x5F80B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_size_3_max_b000_5fc0b000() {
    // Encoding: 0x5FC0B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field size = 3 (Max)
    // Fields: H=0, L=0, M=0, Rd=0, size=3, Rn=0, Rm=0
    let encoding: u32 = 0x5FC0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_l_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field L = 0 (Min)
    // Fields: Rd=0, H=0, M=0, Rn=0, L=0, size=0, Rm=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_l_1_max_b000_5f20b000() {
    // Encoding: 0x5F20B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field L = 1 (Max)
    // Fields: size=0, Rd=0, M=0, L=1, Rm=0, H=0, Rn=0
    let encoding: u32 = 0x5F20B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_m_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field M = 0 (Min)
    // Fields: M=0, L=0, size=0, Rn=0, Rd=0, Rm=0, H=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_m_1_max_b000_5f10b000() {
    // Encoding: 0x5F10B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field M = 1 (Max)
    // Fields: size=0, Rn=0, Rd=0, Rm=0, H=0, M=1, L=0
    let encoding: u32 = 0x5F10B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rm_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rm = 0 (Min)
    // Fields: Rd=0, M=0, Rm=0, size=0, L=0, H=0, Rn=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rm_1_poweroftwo_b000_5f01b000() {
    // Encoding: 0x5F01B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, L=0, Rn=0, size=0, M=0, H=0, Rd=0
    let encoding: u32 = 0x5F01B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_h_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field H = 0 (Min)
    // Fields: H=0, Rn=0, Rd=0, Rm=0, size=0, M=0, L=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_h_1_max_b000_5f00b800() {
    // Encoding: 0x5F00B800
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field H = 1 (Max)
    // Fields: Rm=0, H=1, size=0, Rn=0, Rd=0, M=0, L=0
    let encoding: u32 = 0x5F00B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rn_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rn = 0 (Min)
    // Fields: Rd=0, size=0, L=0, M=0, H=0, Rm=0, Rn=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rn_1_poweroftwo_b000_5f00b020() {
    // Encoding: 0x5F00B020
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rd=0, size=0, Rm=0, M=0, L=0, H=0
    let encoding: u32 = 0x5F00B020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rn_30_poweroftwominusone_b000_5f00b3c0() {
    // Encoding: 0x5F00B3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, M=0, L=0, H=0, Rd=0, Rm=0, Rn=30
    let encoding: u32 = 0x5F00B3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rn_31_max_b000_5f00b3e0() {
    // Encoding: 0x5F00B3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rn = 31 (Max)
    // Fields: H=0, Rn=31, Rd=0, size=0, L=0, Rm=0, M=0
    let encoding: u32 = 0x5F00B3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rd_0_min_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rd = 0 (Min)
    // Fields: M=0, size=0, Rm=0, H=0, Rn=0, L=0, Rd=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rd_1_poweroftwo_b000_5f00b001() {
    // Encoding: 0x5F00B001
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rd = 1 (PowerOfTwo)
    // Fields: size=0, M=0, L=0, Rm=0, H=0, Rn=0, Rd=1
    let encoding: u32 = 0x5F00B001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rd_30_poweroftwominusone_b000_5f00b01e() {
    // Encoding: 0x5F00B01E
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: L=0, M=0, Rd=30, H=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x5F00B01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_field_rd_31_max_b000_5f00b01f() {
    // Encoding: 0x5F00B01F
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field Rd = 31 (Max)
    // Fields: Rn=0, M=0, Rm=0, Rd=31, L=0, size=0, H=0
    let encoding: u32 = 0x5F00B01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_combo_0_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd field combination: size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: size=0, H=0, M=0, L=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_size_0_size_variant_0_45056_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value size = 0 (Size variant 0)
    // Fields: L=0, H=0, size=0, Rd=0, Rn=0, Rm=0, M=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_size_1_size_variant_1_45056_5f40b000() {
    // Encoding: 0x5F40B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value size = 1 (Size variant 1)
    // Fields: size=1, L=0, Rm=0, M=0, Rn=0, Rd=0, H=0
    let encoding: u32 = 0x5F40B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_size_2_size_variant_2_45056_5f80b000() {
    // Encoding: 0x5F80B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value size = 2 (Size variant 2)
    // Fields: Rn=0, L=0, H=0, M=0, size=2, Rm=0, Rd=0
    let encoding: u32 = 0x5F80B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_size_3_size_variant_3_45056_5fc0b000() {
    // Encoding: 0x5FC0B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value size = 3 (Size variant 3)
    // Fields: size=3, Rm=0, Rd=0, H=0, Rn=0, L=0, M=0
    let encoding: u32 = 0x5FC0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_45056_5f00b3e0() {
    // Encoding: 0x5F00B3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rd=0, L=0, size=0, H=0, Rm=0, Rn=31, M=0
    let encoding: u32 = 0x5F00B3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_45056_5f00b01f() {
    // Encoding: 0x5F00B01F
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: size=0, Rm=0, M=0, H=0, Rn=0, L=0, Rd=31
    let encoding: u32 = 0x5F00B01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_invalid_0_b000_5f00b000() {
    // Encoding: 0x5F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: H=0, Rn=0, Rd=0, size=0, Rm=0, L=0, M=0
    let encoding: u32 = 0x5F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_q_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Q = 0 (Min)
    // Fields: Rn=0, Rd=0, size=0, L=0, H=0, Q=0, M=0, Rm=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_q_1_max_b000_4f00b000() {
    // Encoding: 0x4F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Q = 1 (Max)
    // Fields: size=0, Rm=0, Q=1, L=0, H=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x4F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_size_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field size = 0 (Min)
    // Fields: L=0, Rm=0, Q=0, M=0, size=0, Rd=0, Rn=0, H=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_size_1_poweroftwo_b000_0f40b000() {
    // Encoding: 0x0F40B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field size = 1 (PowerOfTwo)
    // Fields: H=0, M=0, Rd=0, Q=0, size=1, L=0, Rm=0, Rn=0
    let encoding: u32 = 0x0F40B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_size_2_poweroftwo_b000_0f80b000() {
    // Encoding: 0x0F80B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field size = 2 (PowerOfTwo)
    // Fields: Rn=0, H=0, size=2, L=0, Q=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x0F80B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_size_3_max_b000_0fc0b000() {
    // Encoding: 0x0FC0B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field size = 3 (Max)
    // Fields: L=0, Q=0, M=0, Rm=0, Rd=0, Rn=0, H=0, size=3
    let encoding: u32 = 0x0FC0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_l_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field L = 0 (Min)
    // Fields: M=0, Q=0, H=0, Rn=0, size=0, L=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_l_1_max_b000_0f20b000() {
    // Encoding: 0x0F20B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field L = 1 (Max)
    // Fields: size=0, H=0, Rn=0, Q=0, L=1, Rm=0, M=0, Rd=0
    let encoding: u32 = 0x0F20B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_m_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field M = 0 (Min)
    // Fields: Q=0, H=0, M=0, Rm=0, size=0, Rn=0, Rd=0, L=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_m_1_max_b000_0f10b000() {
    // Encoding: 0x0F10B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field M = 1 (Max)
    // Fields: Rn=0, M=1, size=0, Q=0, H=0, Rd=0, L=0, Rm=0
    let encoding: u32 = 0x0F10B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rm_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rm = 0 (Min)
    // Fields: size=0, Rd=0, H=0, M=0, L=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rm_1_poweroftwo_b000_0f01b000() {
    // Encoding: 0x0F01B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rd=0, Q=0, size=0, M=0, H=0, Rn=0, L=0
    let encoding: u32 = 0x0F01B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_h_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field H = 0 (Min)
    // Fields: size=0, Rm=0, L=0, Q=0, M=0, Rn=0, Rd=0, H=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_h_1_max_b000_0f00b800() {
    // Encoding: 0x0F00B800
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field H = 1 (Max)
    // Fields: Q=0, M=0, Rd=0, H=1, Rn=0, size=0, L=0, Rm=0
    let encoding: u32 = 0x0F00B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rn_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rn = 0 (Min)
    // Fields: size=0, Rn=0, L=0, Rd=0, Rm=0, Q=0, H=0, M=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rn_1_poweroftwo_b000_0f00b020() {
    // Encoding: 0x0F00B020
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, L=0, H=0, Rd=0, Rm=0, size=0, Q=0, M=0
    let encoding: u32 = 0x0F00B020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rn_30_poweroftwominusone_b000_0f00b3c0() {
    // Encoding: 0x0F00B3C0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, Rd=0, Rn=30, size=0, Rm=0, Q=0, L=0, H=0
    let encoding: u32 = 0x0F00B3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rn_31_max_b000_0f00b3e0() {
    // Encoding: 0x0F00B3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, H=0, M=0, size=0, Rn=31, Rm=0, L=0
    let encoding: u32 = 0x0F00B3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rd_0_min_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rd = 0 (Min)
    // Fields: size=0, M=0, L=0, Rn=0, H=0, Rm=0, Q=0, Rd=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rd_1_poweroftwo_b000_0f00b001() {
    // Encoding: 0x0F00B001
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rd = 1 (PowerOfTwo)
    // Fields: M=0, Q=0, Rm=0, Rn=0, Rd=1, size=0, L=0, H=0
    let encoding: u32 = 0x0F00B001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rd_30_poweroftwominusone_b000_0f00b01e() {
    // Encoding: 0x0F00B01E
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: M=0, Rd=30, Q=0, size=0, L=0, H=0, Rm=0, Rn=0
    let encoding: u32 = 0x0F00B01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_field_rd_31_max_b000_0f00b01f() {
    // Encoding: 0x0F00B01F
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field Rd = 31 (Max)
    // Fields: Rd=31, Rn=0, Q=0, M=0, L=0, size=0, Rm=0, H=0
    let encoding: u32 = 0x0F00B01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_combo_0_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd field combination: Q=0, size=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Q=0, Rn=0, L=0, Rm=0, H=0, size=0, M=0, Rd=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_q_0_size_variant_0_45056_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value Q = 0 (Size variant 0)
    // Fields: size=0, Rn=0, H=0, M=0, Rm=0, Q=0, L=0, Rd=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_q_1_size_variant_1_45056_4f00b000() {
    // Encoding: 0x4F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value Q = 1 (Size variant 1)
    // Fields: H=0, Rn=0, M=0, Rd=0, L=0, size=0, Rm=0, Q=1
    let encoding: u32 = 0x4F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_size_0_size_variant_0_45056_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value size = 0 (Size variant 0)
    // Fields: Q=0, H=0, size=0, L=0, Rn=0, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_size_1_size_variant_1_45056_0f40b000() {
    // Encoding: 0x0F40B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value size = 1 (Size variant 1)
    // Fields: Q=0, H=0, Rn=0, size=1, L=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x0F40B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_size_2_size_variant_2_45056_0f80b000() {
    // Encoding: 0x0F80B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value size = 2 (Size variant 2)
    // Fields: Q=0, M=0, size=2, Rm=0, L=0, H=0, Rn=0, Rd=0
    let encoding: u32 = 0x0F80B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_size_3_size_variant_3_45056_0fc0b000() {
    // Encoding: 0x0FC0B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rd=0, Rm=0, L=0, M=0, size=3, H=0, Q=0
    let encoding: u32 = 0x0FC0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_rn_31_stack_pointer_sp_may_require_alignment_45056_0f00b3e0() {
    // Encoding: 0x0F00B3E0
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rd=0, Rm=0, H=0, L=0, M=0, Q=0, Rn=31
    let encoding: u32 = 0x0F00B3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_45056_0f00b01f() {
    // Encoding: 0x0F00B01F
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, L=0, Rd=31, Rm=0, M=0, Rn=0, size=0, H=0
    let encoding: u32 = 0x0F00B01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_invalid_0_b000_0f00b000() {
    // Encoding: 0x0F00B000
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, size=0, M=0, H=0, Rd=0, L=0, Q=0, Rm=0
    let encoding: u32 = 0x0F00B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_reg_write_0_5f00b000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd register write: SimdFromField("d")
    // Encoding: 0x5F00B000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00B000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_sp_rn_5f00b3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd with Rn = SP (31)
    // Encoding: 0x5F00B3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00B3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_sisd_zr_rd_5f00b01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_sisd with Rd = ZR (31)
    // Encoding: 0x5F00B01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00B01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_reg_write_0_0f00b000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd register write: SimdFromField("d")
    // Encoding: 0x0F00B000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00B000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_sp_rn_0f00b3e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd with Rn = SP (31)
    // Encoding: 0x0F00B3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00B3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_double_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_double_simd_zr_rd_0f00b01f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_double_simd with Rd = ZR (31)
    // Encoding: 0x0F00B01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00B01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_q_0_min_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Q = 0 (Min)
    // Fields: Rd=0, a=0, Rm=0, Q=0, Rn=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_q_1_max_c00_4e400c00() {
    // Encoding: 0x4E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Q = 1 (Max)
    // Fields: Rn=0, Rm=0, Q=1, a=0, Rd=0
    let encoding: u32 = 0x4E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field a 23 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_a_0_min_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field a = 0 (Min)
    // Fields: a=0, Rm=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field a 23 +: 1`
/// Requirement: FieldBoundary { field: "a", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_a_1_max_c00_0ec00c00() {
    // Encoding: 0x0EC00C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field a = 1 (Max)
    // Fields: Rm=0, Rd=0, Q=0, a=1, Rn=0
    let encoding: u32 = 0x0EC00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rm_0_min_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rm = 0 (Min)
    // Fields: Q=0, Rd=0, Rn=0, Rm=0, a=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rm_1_poweroftwo_c00_0e410c00() {
    // Encoding: 0x0E410C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=1, Rd=0, Q=0, a=0
    let encoding: u32 = 0x0E410C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rm_30_poweroftwominusone_c00_0e5e0c00() {
    // Encoding: 0x0E5E0C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, a=0, Rd=0, Q=0, Rn=0
    let encoding: u32 = 0x0E5E0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rm_31_max_c00_0e5f0c00() {
    // Encoding: 0x0E5F0C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Rd=0, a=0, Q=0
    let encoding: u32 = 0x0E5F0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rn_0_min_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rn = 0 (Min)
    // Fields: a=0, Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rn_1_poweroftwo_c00_0e400c20() {
    // Encoding: 0x0E400C20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, a=0, Rn=1, Rm=0, Q=0
    let encoding: u32 = 0x0E400C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rn_30_poweroftwominusone_c00_0e400fc0() {
    // Encoding: 0x0E400FC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Q=0, a=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E400FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rn_31_max_c00_0e400fe0() {
    // Encoding: 0x0E400FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rn = 31 (Max)
    // Fields: Rn=31, Rm=0, a=0, Q=0, Rd=0
    let encoding: u32 = 0x0E400FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rd_0_min_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rd = 0 (Min)
    // Fields: Q=0, Rn=0, Rm=0, a=0, Rd=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rd_1_poweroftwo_c00_0e400c01() {
    // Encoding: 0x0E400C01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rd = 1 (PowerOfTwo)
    // Fields: a=0, Rd=1, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E400C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rd_30_poweroftwominusone_c00_0e400c1e() {
    // Encoding: 0x0E400C1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Q=0, Rn=0, a=0, Rd=30, Rm=0
    let encoding: u32 = 0x0E400C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_field_rd_31_max_c00_0e400c1f() {
    // Encoding: 0x0E400C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field Rd = 31 (Max)
    // Fields: Rm=0, Q=0, a=0, Rd=31, Rn=0
    let encoding: u32 = 0x0E400C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_combo_0_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused field combination: Q=0, a=0, Rm=0, Rn=0, Rd=0
    // Fields: a=0, Rn=0, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_special_q_0_size_variant_0_3072_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused special value Q = 0 (Size variant 0)
    // Fields: a=0, Rm=0, Q=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_special_q_1_size_variant_1_3072_4e400c00() {
    // Encoding: 0x4E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused special value Q = 1 (Size variant 1)
    // Fields: Rm=0, a=0, Rn=0, Q=1, Rd=0
    let encoding: u32 = 0x4E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_special_rn_31_stack_pointer_sp_may_require_alignment_3072_0e400fe0() {
    // Encoding: 0x0E400FE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: a=0, Q=0, Rd=0, Rn=31, Rm=0
    let encoding: u32 = 0x0E400FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_3072_0e400c1f() {
    // Encoding: 0x0E400C1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Q=0, a=0, Rn=0, Rd=31
    let encoding: u32 = 0x0E400C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_invalid_0_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Rm=0, Rd=0, Rn=0, a=0, Q=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_invalid_1_c00_0e400c00() {
    // Encoding: 0x0E400C00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, a=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x0E400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_q_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Q = 0 (Min)
    // Fields: op=0, sz=0, Rm=0, Rn=0, Q=0, Rd=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_q_1_max_cc00_4e20cc00() {
    // Encoding: 0x4E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Q = 1 (Max)
    // Fields: sz=0, Q=1, Rm=0, Rn=0, op=0, Rd=0
    let encoding: u32 = 0x4E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field op 23 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_op_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field op = 0 (Min)
    // Fields: op=0, Rm=0, Rn=0, Q=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field op 23 +: 1`
/// Requirement: FieldBoundary { field: "op", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_op_1_max_cc00_0ea0cc00() {
    // Encoding: 0x0EA0CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field op = 1 (Max)
    // Fields: Q=0, sz=0, op=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_sz_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field sz = 0 (Min)
    // Fields: op=0, Rn=0, Rd=0, Rm=0, sz=0, Q=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_sz_1_max_cc00_0e60cc00() {
    // Encoding: 0x0E60CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field sz = 1 (Max)
    // Fields: sz=1, Rm=0, Rd=0, op=0, Q=0, Rn=0
    let encoding: u32 = 0x0E60CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rm_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rm = 0 (Min)
    // Fields: Q=0, Rm=0, op=0, Rn=0, sz=0, Rd=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rm_1_poweroftwo_cc00_0e21cc00() {
    // Encoding: 0x0E21CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Rd=0, Q=0, op=0, sz=0
    let encoding: u32 = 0x0E21CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rm_30_poweroftwominusone_cc00_0e3ecc00() {
    // Encoding: 0x0E3ECC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Rd=0, sz=0, op=0, Q=0
    let encoding: u32 = 0x0E3ECC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rm_31_max_cc00_0e3fcc00() {
    // Encoding: 0x0E3FCC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rm = 31 (Max)
    // Fields: Rn=0, Q=0, sz=0, op=0, Rm=31, Rd=0
    let encoding: u32 = 0x0E3FCC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rn_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rn = 0 (Min)
    // Fields: Rd=0, op=0, Rn=0, Q=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rn_1_poweroftwo_cc00_0e20cc20() {
    // Encoding: 0x0E20CC20
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rn = 1 (PowerOfTwo)
    // Fields: op=0, Rm=0, Q=0, Rn=1, Rd=0, sz=0
    let encoding: u32 = 0x0E20CC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rn_30_poweroftwominusone_cc00_0e20cfc0() {
    // Encoding: 0x0E20CFC0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, op=0, Q=0, Rm=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E20CFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rn_31_max_cc00_0e20cfe0() {
    // Encoding: 0x0E20CFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, op=0, sz=0, Q=0, Rm=0
    let encoding: u32 = 0x0E20CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rd_0_min_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rd = 0 (Min)
    // Fields: sz=0, op=0, Q=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rd_1_poweroftwo_cc00_0e20cc01() {
    // Encoding: 0x0E20CC01
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, Rn=0, sz=0, op=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20CC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rd_30_poweroftwominusone_cc00_0e20cc1e() {
    // Encoding: 0x0E20CC1E
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rm=0, Rn=0, Q=0, op=0, sz=0
    let encoding: u32 = 0x0E20CC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_field_rd_31_max_cc00_0e20cc1f() {
    // Encoding: 0x0E20CC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field Rd = 31 (Max)
    // Fields: Q=0, op=0, sz=0, Rd=31, Rn=0, Rm=0
    let encoding: u32 = 0x0E20CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_combo_0_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused field combination: Q=0, op=0, sz=0, Rm=0, Rn=0, Rd=0
    // Fields: Rd=0, Q=0, sz=0, op=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_q_0_size_variant_0_52224_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value Q = 0 (Size variant 0)
    // Fields: Rm=0, sz=0, Rn=0, op=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_q_1_size_variant_1_52224_4e20cc00() {
    // Encoding: 0x4E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value Q = 1 (Size variant 1)
    // Fields: Q=1, Rn=0, Rm=0, op=0, sz=0, Rd=0
    let encoding: u32 = 0x4E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_sz_0_size_variant_0_52224_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value sz = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, Q=0, op=0, sz=0, Rm=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_sz_1_size_variant_1_52224_0e60cc00() {
    // Encoding: 0x0E60CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value sz = 1 (Size variant 1)
    // Fields: sz=1, Q=0, Rm=0, op=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E60CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_rn_31_stack_pointer_sp_may_require_alignment_52224_0e20cfe0() {
    // Encoding: 0x0E20CFE0
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: op=0, Q=0, sz=0, Rm=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E20CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_52224_0e20cc1f() {
    // Encoding: 0x0E20CC1F
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, op=0, Rd=31, sz=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true, false]) } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_invalid_0_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }
    // Fields: Rd=0, Q=0, op=0, sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_invalid_1_cc00_0e20cc00() {
    // Encoding: 0x0E20CC00
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Rm=0, Q=0, op=0, sz=0, Rn=0
    let encoding: u32 = 0x0E20CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_reg_write_0_0e400c00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused register write: SimdFromField("d")
    // Encoding: 0x0E400C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E400C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_sp_rn_0e400fe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused with Rn = SP (31)
    // Encoding: 0x0E400FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E400FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused_zr_rd_0e400c1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp16_fused with Rd = ZR (31)
    // Encoding: 0x0E400C1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E400C1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_reg_write_0_0e20cc00() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused register write: SimdFromField("d")
    // Encoding: 0x0E20CC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20CC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_sp_rn_0e20cfe0() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused with Rn = SP (31)
    // Encoding: 0x0E20CFE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20CFE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_uniform_mul_fp_fused
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_uniform_mul_fp_fused_zr_rd_0e20cc1f() {
    // Test aarch64_vector_arithmetic_binary_uniform_mul_fp_fused with Rd = ZR (31)
    // Encoding: 0x0E20CC1F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20CC1F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_mul_double_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_size_0_min_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field size = 0 (Min)
    // Fields: Rd=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_size_1_poweroftwo_d000_5e60d000() {
    // Encoding: 0x5E60D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, size=1, Rd=0
    let encoding: u32 = 0x5E60D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_size_2_poweroftwo_d000_5ea0d000() {
    // Encoding: 0x5EA0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field size = 2 (PowerOfTwo)
    // Fields: Rd=0, Rn=0, Rm=0, size=2
    let encoding: u32 = 0x5EA0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_size_3_max_d000_5ee0d000() {
    // Encoding: 0x5EE0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field size = 3 (Max)
    // Fields: Rm=0, Rn=0, Rd=0, size=3
    let encoding: u32 = 0x5EE0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rm_0_min_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rm = 0 (Min)
    // Fields: size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rm_1_poweroftwo_d000_5e21d000() {
    // Encoding: 0x5E21D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E21D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rm_30_poweroftwominusone_d000_5e3ed000() {
    // Encoding: 0x5E3ED000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=0, size=0, Rm=30
    let encoding: u32 = 0x5E3ED000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rm_31_max_d000_5e3fd000() {
    // Encoding: 0x5E3FD000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Rd=0, size=0
    let encoding: u32 = 0x5E3FD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rn_0_min_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rn = 0 (Min)
    // Fields: Rn=0, Rd=0, Rm=0, size=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rn_1_poweroftwo_d000_5e20d020() {
    // Encoding: 0x5E20D020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Rn=1, Rm=0, size=0
    let encoding: u32 = 0x5E20D020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rn_30_poweroftwominusone_d000_5e20d3c0() {
    // Encoding: 0x5E20D3C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, size=0, Rd=0
    let encoding: u32 = 0x5E20D3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rn_31_max_d000_5e20d3e0() {
    // Encoding: 0x5E20D3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rn = 31 (Max)
    // Fields: size=0, Rm=0, Rd=0, Rn=31
    let encoding: u32 = 0x5E20D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rd_0_min_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rd = 0 (Min)
    // Fields: Rn=0, Rm=0, size=0, Rd=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rd_1_poweroftwo_d000_5e20d001() {
    // Encoding: 0x5E20D001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Rm=0, Rn=0, Rd=1
    let encoding: u32 = 0x5E20D001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rd_30_poweroftwominusone_d000_5e20d01e() {
    // Encoding: 0x5E20D01E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x5E20D01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_field_rd_31_max_d000_5e20d01f() {
    // Encoding: 0x5E20D01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field Rd = 31 (Max)
    // Fields: size=0, Rm=0, Rd=31, Rn=0
    let encoding: u32 = 0x5E20D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_combo_0_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd field combination: size=0, Rm=0, Rn=0, Rd=0
    // Fields: size=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_size_0_size_variant_0_53248_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value size = 0 (Size variant 0)
    // Fields: size=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_size_1_size_variant_1_53248_5e60d000() {
    // Encoding: 0x5E60D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value size = 1 (Size variant 1)
    // Fields: size=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E60D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_size_2_size_variant_2_53248_5ea0d000() {
    // Encoding: 0x5EA0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value size = 2 (Size variant 2)
    // Fields: Rd=0, Rm=0, Rn=0, size=2
    let encoding: u32 = 0x5EA0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_size_3_size_variant_3_53248_5ee0d000() {
    // Encoding: 0x5EE0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value size = 3 (Size variant 3)
    // Fields: Rm=0, Rn=0, size=3, Rd=0
    let encoding: u32 = 0x5EE0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_53248_5e20d3e0() {
    // Encoding: 0x5E20D3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x5E20D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_53248_5e20d01f() {
    // Encoding: 0x5E20D01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, Rm=0, Rd=31, size=0
    let encoding: u32 = 0x5E20D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_invalid_0_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: Rm=0, Rd=0, size=0, Rn=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_invalid_1_d000_5e20d000() {
    // Encoding: 0x5E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_q_0_min_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Q = 0 (Min)
    // Fields: size=0, Rn=0, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_q_1_max_d000_4e20d000() {
    // Encoding: 0x4E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Q = 1 (Max)
    // Fields: Rm=0, Rd=0, Rn=0, Q=1, size=0
    let encoding: u32 = 0x4E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_size_0_min_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field size = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_size_1_poweroftwo_d000_0e60d000() {
    // Encoding: 0x0E60D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=0, size=1, Rm=0, Q=0
    let encoding: u32 = 0x0E60D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_size_2_poweroftwo_d000_0ea0d000() {
    // Encoding: 0x0EA0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field size = 2 (PowerOfTwo)
    // Fields: Q=0, size=2, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0EA0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_size_3_max_d000_0ee0d000() {
    // Encoding: 0x0EE0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field size = 3 (Max)
    // Fields: Rn=0, Q=0, Rm=0, Rd=0, size=3
    let encoding: u32 = 0x0EE0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rm_0_min_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rm = 0 (Min)
    // Fields: Q=0, size=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rm_1_poweroftwo_d000_0e21d000() {
    // Encoding: 0x0E21D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rm = 1 (PowerOfTwo)
    // Fields: size=0, Rn=0, Rm=1, Rd=0, Q=0
    let encoding: u32 = 0x0E21D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rm_30_poweroftwominusone_d000_0e3ed000() {
    // Encoding: 0x0E3ED000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=0, Rm=30, size=0, Q=0
    let encoding: u32 = 0x0E3ED000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rm_31_max_d000_0e3fd000() {
    // Encoding: 0x0E3FD000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rm = 31 (Max)
    // Fields: Rm=31, size=0, Rd=0, Rn=0, Q=0
    let encoding: u32 = 0x0E3FD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rn_0_min_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rn = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, Rd=0, Q=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rn_1_poweroftwo_d000_0e20d020() {
    // Encoding: 0x0E20D020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rn = 1 (PowerOfTwo)
    // Fields: Rd=0, Q=0, size=0, Rm=0, Rn=1
    let encoding: u32 = 0x0E20D020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rn_30_poweroftwominusone_d000_0e20d3c0() {
    // Encoding: 0x0E20D3C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=30, Q=0, Rm=0, Rd=0
    let encoding: u32 = 0x0E20D3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rn_31_max_d000_0e20d3e0() {
    // Encoding: 0x0E20D3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rn = 31 (Max)
    // Fields: Q=0, Rm=0, size=0, Rn=31, Rd=0
    let encoding: u32 = 0x0E20D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rd_0_min_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rd = 0 (Min)
    // Fields: Rd=0, Rm=0, Q=0, size=0, Rn=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rd_1_poweroftwo_d000_0e20d001() {
    // Encoding: 0x0E20D001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rn=0, Rd=1, Rm=0, Q=0, size=0
    let encoding: u32 = 0x0E20D001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rd_30_poweroftwominusone_d000_0e20d01e() {
    // Encoding: 0x0E20D01E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rd=30, Rn=0, size=0, Q=0
    let encoding: u32 = 0x0E20D01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_field_rd_31_max_d000_0e20d01f() {
    // Encoding: 0x0E20D01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field Rd = 31 (Max)
    // Fields: Rd=31, size=0, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_combo_0_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd field combination: Q=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: Rn=0, Rm=0, Rd=0, Q=0, size=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_q_0_size_variant_0_53248_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value Q = 0 (Size variant 0)
    // Fields: Rm=0, size=0, Q=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_q_1_size_variant_1_53248_4e20d000() {
    // Encoding: 0x4E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, Rn=0, size=0, Q=1
    let encoding: u32 = 0x4E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_size_0_size_variant_0_53248_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value size = 0 (Size variant 0)
    // Fields: size=0, Rd=0, Q=0, Rn=0, Rm=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_size_1_size_variant_1_53248_0e60d000() {
    // Encoding: 0x0E60D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value size = 1 (Size variant 1)
    // Fields: Rn=0, size=1, Rd=0, Q=0, Rm=0
    let encoding: u32 = 0x0E60D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_size_2_size_variant_2_53248_0ea0d000() {
    // Encoding: 0x0EA0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value size = 2 (Size variant 2)
    // Fields: Rd=0, size=2, Rn=0, Rm=0, Q=0
    let encoding: u32 = 0x0EA0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_size_3_size_variant_3_53248_0ee0d000() {
    // Encoding: 0x0EE0D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value size = 3 (Size variant 3)
    // Fields: Q=0, Rn=0, size=3, Rm=0, Rd=0
    let encoding: u32 = 0x0EE0D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_rn_31_stack_pointer_sp_may_require_alignment_53248_0e20d3e0() {
    // Encoding: 0x0E20D3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Q=0, Rd=0, Rm=0, Rn=31
    let encoding: u32 = 0x0E20D3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_53248_0e20d01f() {
    // Encoding: 0x0E20D01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, size=0, Rd=31, Rn=0, Q=0
    let encoding: u32 = 0x0E20D01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }) } }, rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_invalid_0_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Or, lhs: LitBits([false, false]), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }) } }, rhs: LitBits([true, true]) }
    // Fields: Q=0, size=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_invalid_1_d000_0e20d000() {
    // Encoding: 0x0E20D000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, size=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x0E20D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_reg_write_0_5e20d000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd register write: SimdFromField("d")
    // Encoding: 0x5E20D000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20D000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_sp_rn_5e20d3e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd with Rn = SP (31)
    // Encoding: 0x5E20D3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20D3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_sisd_zr_rd_5e20d01f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_sisd with Rd = ZR (31)
    // Encoding: 0x5E20D01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5E20D01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_reg_write_0_0e20d000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd register write: SimdFromField("d")
    // Encoding: 0x0E20D000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20D000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_sp_rn_0e20d3e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd with Rn = SP (31)
    // Encoding: 0x0E20D3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20D3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_double_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_double_simd_zr_rd_0e20d01f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_double_simd with Rd = ZR (31)
    // Encoding: 0x0E20D01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20D01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_disparate_mul_product Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_q_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Q = 0 (Min)
    // Fields: Q=0, U=0, Rm=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_q_1_max_c000_4e20c000() {
    // Encoding: 0x4E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Q = 1 (Max)
    // Fields: size=0, U=0, Rn=0, Q=1, Rm=0, Rd=0
    let encoding: u32 = 0x4E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_u_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field U = 0 (Min)
    // Fields: Rd=0, size=0, Rm=0, Q=0, U=0, Rn=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_u_1_max_c000_2e20c000() {
    // Encoding: 0x2E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field U = 1 (Max)
    // Fields: Q=0, Rm=0, Rd=0, size=0, U=1, Rn=0
    let encoding: u32 = 0x2E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_size_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field size = 0 (Min)
    // Fields: Q=0, size=0, Rm=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_size_1_poweroftwo_c000_0e60c000() {
    // Encoding: 0x0E60C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field size = 1 (PowerOfTwo)
    // Fields: Q=0, Rd=0, size=1, U=0, Rm=0, Rn=0
    let encoding: u32 = 0x0E60C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_size_2_poweroftwo_c000_0ea0c000() {
    // Encoding: 0x0EA0C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field size = 2 (PowerOfTwo)
    // Fields: Rd=0, size=2, Rm=0, Rn=0, U=0, Q=0
    let encoding: u32 = 0x0EA0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_size_3_max_c000_0ee0c000() {
    // Encoding: 0x0EE0C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field size = 3 (Max)
    // Fields: Q=0, Rm=0, size=3, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0EE0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rm_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rm = 0 (Min)
    // Fields: Q=0, size=0, Rm=0, Rn=0, U=0, Rd=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rm_1_poweroftwo_c000_0e21c000() {
    // Encoding: 0x0E21C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, size=0, Rm=1, U=0, Q=0, Rd=0
    let encoding: u32 = 0x0E21C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rm_30_poweroftwominusone_c000_0e3ec000() {
    // Encoding: 0x0E3EC000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rd=0, Q=0, U=0, size=0, Rm=30
    let encoding: u32 = 0x0E3EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rm_31_max_c000_0e3fc000() {
    // Encoding: 0x0E3FC000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rm = 31 (Max)
    // Fields: U=0, Rm=31, size=0, Rn=0, Rd=0, Q=0
    let encoding: u32 = 0x0E3FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rn_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rn = 0 (Min)
    // Fields: Rn=0, U=0, size=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rn_1_poweroftwo_c000_0e20c020() {
    // Encoding: 0x0E20C020
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, U=0, Q=0, size=0, Rd=0
    let encoding: u32 = 0x0E20C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rn_30_poweroftwominusone_c000_0e20c3c0() {
    // Encoding: 0x0E20C3C0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, size=0, Rm=0, Q=0, Rn=30, Rd=0
    let encoding: u32 = 0x0E20C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rn_31_max_c000_0e20c3e0() {
    // Encoding: 0x0E20C3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rn = 31 (Max)
    // Fields: Rn=31, Rd=0, U=0, Q=0, Rm=0, size=0
    let encoding: u32 = 0x0E20C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rd_0_min_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rd = 0 (Min)
    // Fields: U=0, Rd=0, Q=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rd_1_poweroftwo_c000_0e20c001() {
    // Encoding: 0x0E20C001
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, Rm=0, U=0, Rn=0, size=0, Rd=1
    let encoding: u32 = 0x0E20C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rd_30_poweroftwominusone_c000_0e20c01e() {
    // Encoding: 0x0E20C01E
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, Rd=30, Q=0, U=0, size=0
    let encoding: u32 = 0x0E20C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_field_rd_31_max_c000_0e20c01f() {
    // Encoding: 0x0E20C01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field Rd = 31 (Max)
    // Fields: Rn=0, Q=0, U=0, Rd=31, size=0, Rm=0
    let encoding: u32 = 0x0E20C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_combo_0_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product field combination: Q=0, U=0, size=0, Rm=0, Rn=0, Rd=0
    // Fields: size=0, Rm=0, Rn=0, Rd=0, U=0, Q=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_q_0_size_variant_0_49152_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value Q = 0 (Size variant 0)
    // Fields: Rn=0, Rd=0, size=0, Q=0, U=0, Rm=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_q_1_size_variant_1_49152_4e20c000() {
    // Encoding: 0x4E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, Q=1, U=0, size=0, Rn=0
    let encoding: u32 = 0x4E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_size_0_size_variant_0_49152_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value size = 0 (Size variant 0)
    // Fields: U=0, Q=0, Rn=0, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_size_1_size_variant_1_49152_0e60c000() {
    // Encoding: 0x0E60C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value size = 1 (Size variant 1)
    // Fields: Rn=0, Rd=0, U=0, size=1, Q=0, Rm=0
    let encoding: u32 = 0x0E60C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_size_2_size_variant_2_49152_0ea0c000() {
    // Encoding: 0x0EA0C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value size = 2 (Size variant 2)
    // Fields: Rd=0, U=0, Rn=0, Q=0, Rm=0, size=2
    let encoding: u32 = 0x0EA0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_size_3_size_variant_3_49152_0ee0c000() {
    // Encoding: 0x0EE0C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rm=0, size=3, U=0, Rd=0, Q=0
    let encoding: u32 = 0x0EE0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_rn_31_stack_pointer_sp_may_require_alignment_49152_0e20c3e0() {
    // Encoding: 0x0E20C3E0
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rn=31, Q=0, Rm=0, Rd=0, size=0
    let encoding: u32 = 0x0E20C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_49152_0e20c01f() {
    // Encoding: 0x0E20C01F
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Q=0, size=0, Rm=0, Rd=31, Rn=0, U=0
    let encoding: u32 = 0x0E20C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_invalid_0_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: size=0, Rm=0, Rd=0, Q=0, Rn=0, U=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_invalid_1_c000_0e20c000() {
    // Encoding: 0x0E20C000
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product invalid encoding: Unconditional UNDEFINED
    // Fields: Q=0, U=0, Rm=0, size=0, Rn=0, Rd=0
    let encoding: u32 = 0x0E20C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_reg_write_0_0e20c000() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product register write: SimdFromField("d")
    // Encoding: 0x0E20C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_sp_rn_0e20c3e0() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product with Rn = SP (31)
    // Encoding: 0x0E20C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_disparate_mul_product
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_disparate_mul_product_zr_rd_0e20c01f() {
    // Test aarch64_vector_arithmetic_binary_disparate_mul_product with Rd = ZR (31)
    // Encoding: 0x0E20C01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0E20C01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// aarch64_vector_arithmetic_binary_element_mul_fp16_sisd Tests
// ============================================================================

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_u_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field U = 0 (Min)
    // Fields: H=0, U=0, Rm=0, M=0, L=0, Rn=0, Rd=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_u_1_max_9000_7f009000() {
    // Encoding: 0x7F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field U = 1 (Max)
    // Fields: Rn=0, Rm=0, Rd=0, L=0, U=1, M=0, H=0
    let encoding: u32 = 0x7F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_l_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field L = 0 (Min)
    // Fields: Rm=0, H=0, U=0, M=0, Rn=0, Rd=0, L=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_l_1_max_9000_5f209000() {
    // Encoding: 0x5F209000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field L = 1 (Max)
    // Fields: M=0, Rn=0, Rd=0, H=0, U=0, L=1, Rm=0
    let encoding: u32 = 0x5F209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_m_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field M = 0 (Min)
    // Fields: Rn=0, Rd=0, U=0, M=0, L=0, Rm=0, H=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_m_1_max_9000_5f109000() {
    // Encoding: 0x5F109000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field M = 1 (Max)
    // Fields: L=0, H=0, Rm=0, Rn=0, U=0, M=1, Rd=0
    let encoding: u32 = 0x5F109000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rm_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rm = 0 (Min)
    // Fields: Rn=0, U=0, H=0, M=0, L=0, Rd=0, Rm=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rm_1_poweroftwo_9000_5f019000() {
    // Encoding: 0x5F019000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rm = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, Rd=0, L=0, H=0, M=0, Rm=1
    let encoding: u32 = 0x5F019000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_h_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field H = 0 (Min)
    // Fields: U=0, L=0, Rn=0, Rd=0, M=0, Rm=0, H=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_h_1_max_9000_5f009800() {
    // Encoding: 0x5F009800
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field H = 1 (Max)
    // Fields: U=0, L=0, H=1, Rn=0, M=0, Rd=0, Rm=0
    let encoding: u32 = 0x5F009800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rn_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rn = 0 (Min)
    // Fields: L=0, H=0, U=0, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rn_1_poweroftwo_9000_5f009020() {
    // Encoding: 0x5F009020
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rn = 1 (PowerOfTwo)
    // Fields: L=0, U=0, H=0, Rn=1, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x5F009020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rn_30_poweroftwominusone_9000_5f0093c0() {
    // Encoding: 0x5F0093C0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, L=0, H=0, Rd=0, Rm=0, M=0, U=0
    let encoding: u32 = 0x5F0093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rn_31_max_9000_5f0093e0() {
    // Encoding: 0x5F0093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rn = 31 (Max)
    // Fields: Rm=0, M=0, U=0, H=0, Rn=31, Rd=0, L=0
    let encoding: u32 = 0x5F0093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rd_0_min_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rd = 0 (Min)
    // Fields: Rm=0, Rd=0, M=0, Rn=0, H=0, U=0, L=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rd_1_poweroftwo_9000_5f009001() {
    // Encoding: 0x5F009001
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rd = 1 (PowerOfTwo)
    // Fields: U=0, Rn=0, M=0, L=0, H=0, Rm=0, Rd=1
    let encoding: u32 = 0x5F009001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rd_30_poweroftwominusone_9000_5f00901e() {
    // Encoding: 0x5F00901E
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: H=0, Rn=0, Rd=30, L=0, Rm=0, U=0, M=0
    let encoding: u32 = 0x5F00901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_field_rd_31_max_9000_5f00901f() {
    // Encoding: 0x5F00901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field Rd = 31 (Max)
    // Fields: M=0, U=0, L=0, H=0, Rd=31, Rn=0, Rm=0
    let encoding: u32 = 0x5F00901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_combo_0_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd field combination: U=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: H=0, Rm=0, M=0, L=0, U=0, Rn=0, Rd=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_5f0093e0() {
    // Encoding: 0x5F0093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: U=0, Rd=0, M=0, Rn=31, H=0, L=0, Rm=0
    let encoding: u32 = 0x5F0093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_5f00901f() {
    // Encoding: 0x5F00901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: U=0, Rn=0, Rm=0, Rd=31, M=0, L=0, H=0
    let encoding: u32 = 0x5F00901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_invalid_0_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: Rm=0, L=0, H=0, Rn=0, U=0, Rd=0, M=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_invalid_1_9000_5f009000() {
    // Encoding: 0x5F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: L=0, U=0, Rn=0, M=0, Rm=0, Rd=0, H=0
    let encoding: u32 = 0x5F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_u_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field U = 0 (Min)
    // Fields: L=0, M=0, Rn=0, sz=0, Rm=0, U=0, H=0, Rd=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_u_1_max_9000_7f809000() {
    // Encoding: 0x7F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field U = 1 (Max)
    // Fields: U=1, L=0, sz=0, M=0, Rm=0, H=0, Rd=0, Rn=0
    let encoding: u32 = 0x7F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_sz_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field sz = 0 (Min)
    // Fields: H=0, Rd=0, U=0, Rn=0, sz=0, M=0, Rm=0, L=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_sz_1_max_9000_5fc09000() {
    // Encoding: 0x5FC09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field sz = 1 (Max)
    // Fields: Rn=0, Rd=0, H=0, L=0, M=0, Rm=0, U=0, sz=1
    let encoding: u32 = 0x5FC09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_l_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field L = 0 (Min)
    // Fields: L=0, U=0, sz=0, Rm=0, M=0, Rd=0, H=0, Rn=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_l_1_max_9000_5fa09000() {
    // Encoding: 0x5FA09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field L = 1 (Max)
    // Fields: L=1, Rd=0, U=0, H=0, sz=0, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x5FA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_m_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field M = 0 (Min)
    // Fields: H=0, L=0, M=0, Rd=0, Rn=0, Rm=0, sz=0, U=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_m_1_max_9000_5f909000() {
    // Encoding: 0x5F909000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field M = 1 (Max)
    // Fields: Rd=0, Rm=0, H=0, L=0, sz=0, M=1, Rn=0, U=0
    let encoding: u32 = 0x5F909000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rm_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rm = 0 (Min)
    // Fields: sz=0, M=0, Rm=0, Rn=0, L=0, U=0, Rd=0, H=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rm_1_poweroftwo_9000_5f819000() {
    // Encoding: 0x5F819000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rm = 1 (PowerOfTwo)
    // Fields: L=0, Rm=1, sz=0, Rd=0, M=0, U=0, Rn=0, H=0
    let encoding: u32 = 0x5F819000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_h_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field H = 0 (Min)
    // Fields: M=0, U=0, Rn=0, L=0, Rd=0, sz=0, H=0, Rm=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_h_1_max_9000_5f809800() {
    // Encoding: 0x5F809800
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field H = 1 (Max)
    // Fields: U=0, Rn=0, Rm=0, sz=0, M=0, H=1, L=0, Rd=0
    let encoding: u32 = 0x5F809800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rn_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rn = 0 (Min)
    // Fields: L=0, U=0, Rn=0, H=0, Rm=0, Rd=0, sz=0, M=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rn_1_poweroftwo_9000_5f809020() {
    // Encoding: 0x5F809020
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rn = 1 (PowerOfTwo)
    // Fields: H=0, Rm=0, Rn=1, sz=0, M=0, Rd=0, L=0, U=0
    let encoding: u32 = 0x5F809020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rn_30_poweroftwominusone_9000_5f8093c0() {
    // Encoding: 0x5F8093C0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, M=0, H=0, U=0, L=0, Rd=0, sz=0, Rm=0
    let encoding: u32 = 0x5F8093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rn_31_max_9000_5f8093e0() {
    // Encoding: 0x5F8093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rn = 31 (Max)
    // Fields: Rn=31, U=0, sz=0, Rd=0, M=0, H=0, L=0, Rm=0
    let encoding: u32 = 0x5F8093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rd_0_min_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rd = 0 (Min)
    // Fields: sz=0, L=0, H=0, U=0, M=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rd_1_poweroftwo_9000_5f809001() {
    // Encoding: 0x5F809001
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rd = 1 (PowerOfTwo)
    // Fields: M=0, L=0, H=0, Rn=0, Rd=1, U=0, sz=0, Rm=0
    let encoding: u32 = 0x5F809001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rd_30_poweroftwominusone_9000_5f80901e() {
    // Encoding: 0x5F80901E
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Rm=0, M=0, L=0, H=0, Rn=0, U=0, sz=0
    let encoding: u32 = 0x5F80901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_field_rd_31_max_9000_5f80901f() {
    // Encoding: 0x5F80901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field Rd = 31 (Max)
    // Fields: Rn=0, U=0, Rm=0, H=0, L=0, M=0, Rd=31, sz=0
    let encoding: u32 = 0x5F80901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// U=0 (minimum value)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_combo_0_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd field combination: U=0, sz=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: sz=0, M=0, Rd=0, U=0, L=0, Rm=0, H=0, Rn=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_special_sz_0_size_variant_0_36864_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd special value sz = 0 (Size variant 0)
    // Fields: H=0, Rn=0, M=0, Rd=0, U=0, sz=0, L=0, Rm=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_special_sz_1_size_variant_1_36864_5fc09000() {
    // Encoding: 0x5FC09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd special value sz = 1 (Size variant 1)
    // Fields: M=0, Rm=0, L=0, sz=1, Rd=0, U=0, Rn=0, H=0
    let encoding: u32 = 0x5FC09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_5f8093e0() {
    // Encoding: 0x5F8093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, Rd=0, U=0, sz=0, M=0, Rn=31, Rm=0, H=0
    let encoding: u32 = 0x5F8093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_5f80901f() {
    // Encoding: 0x5F80901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rm=0, Rn=0, H=0, Rd=31, L=0, sz=0, M=0, U=0
    let encoding: u32 = 0x5F80901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_invalid_0_9000_5f809000() {
    // Encoding: 0x5F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd invalid encoding: Unconditional UNDEFINED
    // Fields: L=0, M=0, H=0, U=0, sz=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x5F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_q_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Q = 0 (Min)
    // Fields: Q=0, L=0, Rn=0, U=0, Rd=0, Rm=0, H=0, M=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_q_1_max_9000_4f009000() {
    // Encoding: 0x4F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Q = 1 (Max)
    // Fields: U=0, L=0, M=0, Rm=0, Rn=0, Q=1, Rd=0, H=0
    let encoding: u32 = 0x4F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_u_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field U = 0 (Min)
    // Fields: L=0, Rm=0, Rd=0, H=0, Q=0, M=0, Rn=0, U=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_u_1_max_9000_2f009000() {
    // Encoding: 0x2F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field U = 1 (Max)
    // Fields: U=1, L=0, Q=0, Rm=0, Rn=0, M=0, Rd=0, H=0
    let encoding: u32 = 0x2F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_l_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field L = 0 (Min)
    // Fields: H=0, L=0, Rm=0, Rd=0, U=0, M=0, Rn=0, Q=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_l_1_max_9000_0f209000() {
    // Encoding: 0x0F209000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field L = 1 (Max)
    // Fields: Rn=0, M=0, L=1, H=0, Q=0, U=0, Rd=0, Rm=0
    let encoding: u32 = 0x0F209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_m_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field M = 0 (Min)
    // Fields: Rd=0, Rm=0, U=0, Q=0, M=0, H=0, L=0, Rn=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_m_1_max_9000_0f109000() {
    // Encoding: 0x0F109000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field M = 1 (Max)
    // Fields: H=0, Rn=0, U=0, M=1, L=0, Rd=0, Rm=0, Q=0
    let encoding: u32 = 0x0F109000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rm_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rm = 0 (Min)
    // Fields: L=0, Rn=0, U=0, Q=0, H=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rm_1_poweroftwo_9000_0f019000() {
    // Encoding: 0x0F019000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rm = 1 (PowerOfTwo)
    // Fields: Rd=0, M=0, U=0, Rm=1, Q=0, Rn=0, H=0, L=0
    let encoding: u32 = 0x0F019000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_h_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field H = 0 (Min)
    // Fields: Q=0, Rn=0, U=0, L=0, Rm=0, M=0, Rd=0, H=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_h_1_max_9000_0f009800() {
    // Encoding: 0x0F009800
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field H = 1 (Max)
    // Fields: H=1, Rn=0, M=0, Q=0, L=0, U=0, Rd=0, Rm=0
    let encoding: u32 = 0x0F009800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rn_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rn = 0 (Min)
    // Fields: Q=0, H=0, L=0, U=0, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rn_1_poweroftwo_9000_0f009020() {
    // Encoding: 0x0F009020
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rn = 1 (PowerOfTwo)
    // Fields: U=0, Rm=0, Rn=1, H=0, L=0, M=0, Rd=0, Q=0
    let encoding: u32 = 0x0F009020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rn_30_poweroftwominusone_9000_0f0093c0() {
    // Encoding: 0x0F0093C0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, H=0, U=0, M=0, L=0, Rn=30, Q=0, Rd=0
    let encoding: u32 = 0x0F0093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rn_31_max_9000_0f0093e0() {
    // Encoding: 0x0F0093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rn = 31 (Max)
    // Fields: Rd=0, Q=0, Rn=31, M=0, U=0, L=0, H=0, Rm=0
    let encoding: u32 = 0x0F0093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rd_0_min_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rd = 0 (Min)
    // Fields: L=0, Rn=0, Rd=0, Rm=0, U=0, H=0, M=0, Q=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rd_1_poweroftwo_9000_0f009001() {
    // Encoding: 0x0F009001
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, H=0, L=0, Rn=0, M=0, U=0, Rm=0, Q=0
    let encoding: u32 = 0x0F009001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rd_30_poweroftwominusone_9000_0f00901e() {
    // Encoding: 0x0F00901E
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, Q=0, H=0, Rn=0, U=0, Rm=0, M=0, L=0
    let encoding: u32 = 0x0F00901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_field_rd_31_max_9000_0f00901f() {
    // Encoding: 0x0F00901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field Rd = 31 (Max)
    // Fields: M=0, H=0, Rn=0, Q=0, L=0, U=0, Rd=31, Rm=0
    let encoding: u32 = 0x0F00901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_combo_0_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd field combination: Q=0, U=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: Q=0, Rm=0, L=0, H=0, Rn=0, Rd=0, U=0, M=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_special_q_0_size_variant_0_36864_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd special value Q = 0 (Size variant 0)
    // Fields: Q=0, U=0, Rm=0, Rd=0, H=0, L=0, Rn=0, M=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_special_q_1_size_variant_1_36864_4f009000() {
    // Encoding: 0x4F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd special value Q = 1 (Size variant 1)
    // Fields: Rn=0, M=0, Q=1, L=0, U=0, Rm=0, H=0, Rd=0
    let encoding: u32 = 0x4F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_0f0093e0() {
    // Encoding: 0x0F0093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: H=0, Rd=0, Rm=0, Q=0, L=0, Rn=31, M=0, U=0
    let encoding: u32 = 0x0F0093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_0f00901f() {
    // Encoding: 0x0F00901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: H=0, L=0, M=0, Q=0, Rm=0, Rn=0, Rd=31, U=0
    let encoding: u32 = 0x0F00901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveFP16Ext\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_invalid_0_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveFP16Ext" }, args: [] } }
    // Fields: L=0, M=0, Q=0, H=0, Rn=0, Rm=0, Rd=0, U=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_invalid_1_9000_0f009000() {
    // Encoding: 0x0F009000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, Rm=0, H=0, Rn=0, Q=0, L=0, M=0, U=0
    let encoding: u32 = 0x0F009000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_q_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Q = 0 (Min)
    // Fields: M=0, sz=0, Rn=0, Q=0, L=0, Rd=0, U=0, Rm=0, H=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Q 30 +: 1`
/// Requirement: FieldBoundary { field: "Q", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_q_1_max_9000_4f809000() {
    // Encoding: 0x4F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Q = 1 (Max)
    // Fields: H=0, Rn=0, Rm=0, Q=1, L=0, M=0, sz=0, Rd=0, U=0
    let encoding: u32 = 0x4F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_u_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field U = 0 (Min)
    // Fields: Q=0, M=0, U=0, H=0, sz=0, Rn=0, Rd=0, Rm=0, L=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field U 29 +: 1`
/// Requirement: FieldBoundary { field: "U", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_u_1_max_9000_2f809000() {
    // Encoding: 0x2F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field U = 1 (Max)
    // Fields: U=1, Rd=0, Q=0, sz=0, M=0, Rn=0, L=0, Rm=0, H=0
    let encoding: u32 = 0x2F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_sz_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field sz = 0 (Min)
    // Fields: Q=0, L=0, U=0, sz=0, H=0, Rd=0, Rn=0, Rm=0, M=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_sz_1_max_9000_0fc09000() {
    // Encoding: 0x0FC09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field sz = 1 (Max)
    // Fields: U=0, M=0, H=0, L=0, sz=1, Rn=0, Q=0, Rd=0, Rm=0
    let encoding: u32 = 0x0FC09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_l_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field L = 0 (Min)
    // Fields: Q=0, Rm=0, sz=0, Rn=0, U=0, M=0, H=0, Rd=0, L=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field L 21 +: 1`
/// Requirement: FieldBoundary { field: "L", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_l_1_max_9000_0fa09000() {
    // Encoding: 0x0FA09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field L = 1 (Max)
    // Fields: Rn=0, Rm=0, Rd=0, Q=0, sz=0, L=1, H=0, U=0, M=0
    let encoding: u32 = 0x0FA09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_m_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field M = 0 (Min)
    // Fields: M=0, Q=0, sz=0, Rd=0, H=0, Rn=0, Rm=0, L=0, U=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field M 20 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_m_1_max_9000_0f909000() {
    // Encoding: 0x0F909000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field M = 1 (Max)
    // Fields: H=0, M=1, Rm=0, Q=0, Rn=0, U=0, Rd=0, L=0, sz=0
    let encoding: u32 = 0x0F909000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rm_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rm = 0 (Min)
    // Fields: Rn=0, Rd=0, H=0, U=0, L=0, M=0, Rm=0, Q=0, sz=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rm 16 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rm_1_poweroftwo_9000_0f819000() {
    // Encoding: 0x0F819000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rm = 1 (PowerOfTwo)
    // Fields: sz=0, U=0, L=0, M=0, Rd=0, H=0, Q=0, Rn=0, Rm=1
    let encoding: u32 = 0x0F819000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_h_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field H = 0 (Min)
    // Fields: sz=0, H=0, L=0, Rm=0, U=0, Rd=0, M=0, Q=0, Rn=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field H 11 +: 1`
/// Requirement: FieldBoundary { field: "H", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_h_1_max_9000_0f809800() {
    // Encoding: 0x0F809800
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field H = 1 (Max)
    // Fields: H=1, Rd=0, M=0, Rn=0, Rm=0, U=0, Q=0, sz=0, L=0
    let encoding: u32 = 0x0F809800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rn_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rn = 0 (Min)
    // Fields: Rm=0, sz=0, M=0, U=0, Rn=0, Q=0, L=0, H=0, Rd=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rn_1_poweroftwo_9000_0f809020() {
    // Encoding: 0x0F809020
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Q=0, Rn=1, Rd=0, Rm=0, U=0, L=0, H=0, M=0
    let encoding: u32 = 0x0F809020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rn_30_poweroftwominusone_9000_0f8093c0() {
    // Encoding: 0x0F8093C0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: L=0, U=0, Rm=0, H=0, Rn=30, sz=0, M=0, Q=0, Rd=0
    let encoding: u32 = 0x0F8093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rn_31_max_9000_0f8093e0() {
    // Encoding: 0x0F8093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rn = 31 (Max)
    // Fields: U=0, Q=0, Rm=0, Rd=0, M=0, H=0, L=0, sz=0, Rn=31
    let encoding: u32 = 0x0F8093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rd_0_min_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rd = 0 (Min)
    // Fields: Rm=0, sz=0, Q=0, U=0, Rd=0, H=0, L=0, Rn=0, M=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rd_1_poweroftwo_9000_0f809001() {
    // Encoding: 0x0F809001
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rd = 1 (PowerOfTwo)
    // Fields: Q=0, L=0, M=0, Rd=1, H=0, U=0, sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x0F809001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rd_30_poweroftwominusone_9000_0f80901e() {
    // Encoding: 0x0F80901E
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: U=0, M=0, Rn=0, Rd=30, L=0, Rm=0, Q=0, sz=0, H=0
    let encoding: u32 = 0x0F80901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_field_rd_31_max_9000_0f80901f() {
    // Encoding: 0x0F80901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field Rd = 31 (Max)
    // Fields: Q=0, U=0, Rm=0, Rd=31, H=0, Rn=0, sz=0, M=0, L=0
    let encoding: u32 = 0x0F80901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Q=0 (8-bit / byte size)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_combo_0_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd field combination: Q=0, U=0, sz=0, L=0, M=0, Rm=0, H=0, Rn=0, Rd=0
    // Fields: U=0, Rm=0, Rd=0, Rn=0, L=0, H=0, sz=0, M=0, Q=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Q = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "Q", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_q_0_size_variant_0_36864_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value Q = 0 (Size variant 0)
    // Fields: Rd=0, M=0, sz=0, H=0, Rm=0, Rn=0, Q=0, L=0, U=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Q = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "Q", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_q_1_size_variant_1_36864_4f809000() {
    // Encoding: 0x4F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value Q = 1 (Size variant 1)
    // Fields: Rd=0, Rm=0, U=0, M=0, H=0, Rn=0, Q=1, sz=0, L=0
    let encoding: u32 = 0x4F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_sz_0_size_variant_0_36864_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value sz = 0 (Size variant 0)
    // Fields: H=0, Rm=0, L=0, Rn=0, Rd=0, M=0, Q=0, sz=0, U=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_sz_1_size_variant_1_36864_0fc09000() {
    // Encoding: 0x0FC09000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value sz = 1 (Size variant 1)
    // Fields: Rd=0, Q=0, Rm=0, H=0, M=0, U=0, sz=1, L=0, Rn=0
    let encoding: u32 = 0x0FC09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_rn_31_stack_pointer_sp_may_require_alignment_36864_0f8093e0() {
    // Encoding: 0x0F8093E0
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: L=0, U=0, Rn=31, Rd=0, sz=0, M=0, Rm=0, Q=0, H=0
    let encoding: u32 = 0x0F8093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_36864_0f80901f() {
    // Encoding: 0x0F80901F
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rn=0, U=0, Rd=31, L=0, M=0, H=0, Rm=0, sz=0, Q=0
    let encoding: u32 = 0x0F80901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_invalid_0_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd invalid encoding: Unconditional UNDEFINED
    // Fields: M=0, U=0, Rd=0, sz=0, H=0, L=0, Rm=0, Rn=0, Q=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sz\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Q\" }), rhs: LitBits([true, false]) } }" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_invalid_1_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sz" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Q" }), rhs: LitBits([true, false]) } }
    // Fields: H=0, L=0, sz=0, M=0, Rn=0, Q=0, Rd=0, U=0, Rm=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_invalid_2_9000_0f809000() {
    // Encoding: 0x0F809000
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, sz=0, U=0, H=0, Rd=0, M=0, Q=0, L=0, Rm=0
    let encoding: u32 = 0x0F809000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_reg_write_0_5f009000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd register write: SimdFromField("d")
    // Encoding: 0x5F009000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F009000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_sp_rn_5f0093e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd with Rn = SP (31)
    // Encoding: 0x5F0093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F0093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_sisd_zr_rd_5f00901f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_sisd with Rd = ZR (31)
    // Encoding: 0x5F00901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F00901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_reg_write_0_5f809000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd register write: SimdFromField("d")
    // Encoding: 0x5F809000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F809000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_sp_rn_5f8093e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd with Rn = SP (31)
    // Encoding: 0x5F8093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F8093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_sisd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_sisd_zr_rd_5f80901f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_sisd with Rd = ZR (31)
    // Encoding: 0x5F80901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x5F80901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_reg_write_0_0f009000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd register write: SimdFromField("d")
    // Encoding: 0x0F009000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F009000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_sp_rn_0f0093e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd with Rn = SP (31)
    // Encoding: 0x0F0093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F0093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp16_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp16_simd_zr_rd_0f00901f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp16_simd with Rd = ZR (31)
    // Encoding: 0x0F00901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F00901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_reg_write_0_0f809000() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd register write: SimdFromField("d")
    // Encoding: 0x0F809000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F809000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_sp_rn_0f8093e0() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd with Rn = SP (31)
    // Encoding: 0x0F8093E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F8093E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: aarch64_vector_arithmetic_binary_element_mul_fp_simd
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_aarch64_vector_arithmetic_binary_element_mul_fp_simd_zr_rd_0f80901f() {
    // Test aarch64_vector_arithmetic_binary_element_mul_fp_simd with Rd = ZR (31)
    // Encoding: 0x0F80901F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0F80901F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

