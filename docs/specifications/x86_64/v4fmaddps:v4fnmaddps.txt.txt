V4FMADDPS/V4FNMADDPS — Packed Single Precision Floating-Point Fused Multiply-Add(4-Iterations) \* Index \* December 2023 V4FMADDPS/V4FNMADDPS — Packed Single Precision Floating-Point Fused Multiply-Add(4-Iterations) | Opcode/Instruction |Op/En|64/32 bit Mode Support|CPUID Feature Flag| Description | |--------------------------------------------------------------|-----|----------------------|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------| |EVEX.512. F2.0F38. W0 9A /r V4FMADDPS zmm1{k1}{z}, zmm2+3, m128 | A | V/V | AVX512\\\_4FMAPS | Multiply packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1. | |EVEX.512. F2.0F38. W0 AA /r V4FNMADDPS zmm1{k1}{z}, zmm2+3, m128| A | V/V | AVX512\\\_4FMAPS |Multiply and negate packed single-precision floating-point values from source register block indicated by zmm2 by values from m128 and accumulate the result in zmm1. | Instruction Operand Encoding ¶ | Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4 | | | | | | |-------------------------------------------------------------|---|---|---|---|---| |A Tuple1\\\_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A| | | | | | Description ¶ This instruction computes 4 sequential packed fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps. In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based on that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand. This instruction supports memory fault suppression. The entire memory operand is loaded if any of the 16 lowest significant mask bits is set to 1 or if a “no masking” encoding is used. The tuple type Tuple1\\\_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction. Rounding is performed at every FMA (fused multiply and add) boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc Operation ¶ ``` src\_reg\_id is the 5 bit index of the vector register specified in the instruction as the src1 register. define NFMA\_PS(kl, vl, dest, k1, msrc, regs\_loaded, src\_base, posneg): tmpdest := dest // reg[] is an array representing the SIMD register file. FOR j := 0 to regs\_loaded-1: FOR i := 0 to kl-1: IF k1[i] or \*no writemask\*: IF posneg = 0: tmpdestsingle[i] := RoundFPControl\_MXCSR(tmpdestsingle[i] - reg[src\_base + j ]. single[i] \* msrc. single[j]) ELSE: tmpdestsingle[i] := RoundFPControl\_MXCSR(tmpdestsingle[i] + reg[src\_base + j ]. single[i] \* msrc. single[j]) ELSE IF \*zeroing\*: tmpdestsingle[i] := 0 dest := tmpdst dest[MAX\_VL-1:VL] := 0 V4FMADDPS and V4FNMADDPS dest{k1}, src1, msrc (AVX512) KL, VL = (16,512) regs\_loaded := 4 src\_base := src\_reg\_id & \~3 // for src1 operand posneg := 0 if negative form, 1 otherwise NFMA\_PS(kl, vl, dest, k1, msrc, regs\_loaded, src\_base, posneg) ``` Intel C/C++ Compiler Intrinsic Equivalent ¶ ``` V4FMADDPS \_\_m512 \_mm512\_4fmadd\_ps( \_\_m512, \_\_m512x4, \_\_m128 \*); ``` ``` V4FMADDPS \_\_m512 \_mm512\_mask\_4fmadd\_ps(\_\_m512, \_\_mmask16, \_\_m512x4, \_\_m128 \*); ``` ``` V4FMADDPS \_\_m512 \_mm512\_maskz\_4fmadd\_ps(\_\_mmask16, \_\_m512, \_\_m512x4, \_\_m128 \*); ``` ``` V4FNMADDPS \_\_m512 \_mm512\_4fnmadd\_ps(\_\_m512, \_\_m512x4, \_\_m128 \*); ``` ``` V4FNMADDPS \_\_m512 \_mm512\_mask\_4fnmadd\_ps(\_\_m512, \_\_mmask16, \_\_m512x4, \_\_m128 \*); ``` ``` V4FNMADDPS \_\_m512 \_mm512\_maskz\_4fnmadd\_ps(\_\_mmask16, \_\_m512, \_\_m512x4, \_\_m128 \*); ``` SIMD Floating-Point Exceptions ¶ Overflow, Underflow, Invalid, Precision, Denormal. Other Exceptions ¶ See Type E2; additionally: |\\#UD|If the EVEX broadcast bit is set to 1. | |----|--------------------------------------| |\\#UD| If the MODRM.mod = 0b11. | This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be incomplete or b r oke n in various obvious or non-obvious ways. Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual for anything serious.