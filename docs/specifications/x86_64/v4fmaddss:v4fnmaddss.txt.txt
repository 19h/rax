V4FMADDSS/V4FNMADDSS — Scalar Single Precision Floating-Point Fused Multiply-Add(4-Iterations) \* Index \* December 2023 V4FMADDSS/V4FNMADDSS — Scalar Single Precision Floating-Point Fused Multiply-Add(4-Iterations) | Opcode/Instruction |Op/En|64/32 bit Mode Support|CPUID Feature Flag| Description | |---------------------------------------------------------------|-----|----------------------|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------| |EVEX.LLIG.F2.0F38. W0 9B /r V4FMADDSS xmm1{k1}{z}, xmm2+3, m128 | A | V/V | AVX512\\\_4FMAPS | Multiply scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1. | |EVEX.LLIG.F2.0F38. W0 AB /r V4FNMADDSS xmm1{k1}{z}, xmm2+3, m128| A | V/V | AVX512\\\_4FMAPS |Multiply and negate scalar single-precision floating-point values from source register block indicated by xmm2 by values from m128 and accumulate the result in xmm1. | Instruction Operand Encoding ¶ | Op/En Tuple Operand 1 Operand 2 Operand 3 Operand 4 | | | | | | |-------------------------------------------------------------|---|---|---|---|---| |A Tuple1\\\_4X ModRM:reg (r, w) EVEX.vvvv (r) ModRM:r/m (r) N/A| | | | | | Description ¶ This instruction computes 4 sequential scalar fused single-precision floating-point multiply-add instructions with a sequentially selected memory operand in each of the four steps. In the above box, the notation of “+3” is used to denote that the instruction accesses 4 source registers based that operand; sources are consecutive, start in a multiple of 4 boundary, and contain the encoded register operand. This instruction supports memory fault suppression. The entire memory operand is loaded if the least significant mask bit is set to 1 or if a “no masking” encoding is used. The tuple type Tuple1\\\_4X implies that four 32-bit elements (16 bytes) are referenced by the memory operation portion of this instruction. Rounding is performed at every FMA boundary. Exceptions are also taken sequentially. Pre- and post-computational exceptions of the first FMA take priority over the pre- and post-computational exceptions of the second FMA, etc Operation ¶ ``` src\_reg\_id is the 5 bit index of the vector register specified in the instruction as the src1 register. define NFMA\_SS(vl, dest, k1, msrc, regs\_loaded, src\_base, posneg): tmpdest := dest // reg[] is an array representing the SIMD register file. IF k1or \*no writemask\*: FOR j := 0 to regs\_loaded - 1: IF posneg = 0: tmpdestsingle:= RoundFPControl\_MXCSR(tmpdestsingle- reg[src\_base + j ]. single\* msrc. single[j]) ELSE: tmpdestsingle:= RoundFPControl\_MXCSR(tmpdestsingle+ reg[src\_base + j ]. single\* msrc. single[j]) ELSE IF \*zeroing\*: tmpdestsingle:= 0 dest := tmpdst dest[MAX\_VL-1:VL] := 0 ``` V4FMADDSS and V4FNMADDSS dest{k1}, src1, msrc (AVX512) ¶ ``` VL = 128 regs\_loaded := 4 src\_base := src\_reg\_id & \~3 // for src1 operand posneg := 0 if negative form, 1 otherwise NFMA\_SS(vl, dest, k1, msrc, regs\_loaded, src\_base, posneg) ``` Intel C/C++ Compiler Intrinsic Equivalent ¶ ``` V4FMADDSS \_\_m128 \_mm\_4fmadd\_ss(\_\_m128, \_\_m128x4, \_\_m128 \*); ``` ``` V4FMADDSS \_\_m128 \_mm\_mask\_4fmadd\_ss(\_\_m128, \_\_mmask8, \_\_m128x4, \_\_m128 \*); ``` ``` V4FMADDSS \_\_m128 \_mm\_maskz\_4fmadd\_ss(\_\_mmask8, \_\_m128, \_\_m128x4, \_\_m128 \*); ``` ``` V4FNMADDSS \_\_m128 \_mm\_4fnmadd\_ss(\_\_m128, \_\_m128x4, \_\_m128 \*); ``` ``` V4FNMADDSS \_\_m128 \_mm\_mask\_4fnmadd\_ss(\_\_m128, \_\_mmask8, \_\_m128x4, \_\_m128 \*); ``` ``` V4FNMADDSS \_\_m128 \_mm\_maskz\_4fnmadd\_ss(\_\_mmask8, \_\_m128, \_\_m128x4, \_\_m128 \*); ``` SIMD Floating-Point Exceptions ¶ Overflow, Underflow, Invalid, Precision, Denormal. Other Exceptions ¶ See Type E2; additionally: |\\#UD|If the EVEX broadcast bit is set to 1. | |----|--------------------------------------| |\\#UD| If the MODRM.mod = 0b11. | This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be incomplete or b r oke n in various obvious or non-obvious ways. Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual for anything serious.