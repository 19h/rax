ERESUME — Re-Enters an Enclave

* Index

* December 2023

ERESUME — Re-Enters an Enclave

|  Opcode/Instruction  |Op/En|64/32 bit Mode Support|CPUID Feature Flag|               Description               |

|------------------------|-----|----------------------|------------------|---------------------------------------------------------------------|

|EAX = 03H ENCLU[ERESUME]| IR |     V/V     |    SGX1    |This leaf function is used to re-enter an enclave after an interrupt. |

Instruction Operand Encoding ¶

|Op/En|  RAX   |     RBX     |    RCX    |

|-----|------------|---------------------|-------------------|

| IR |ERESUME (In)|Address of a TCS (In)|Address of AEP (In)|

Description ¶

The ENCLU[ERESUME] instruction resumes execution of an enclave that was interrupted due to an exception or interrupt, using the machine state previously stored in the SSA.

ERESUME Memory Parameter Semantics ¶

|      TCS      |

|-------------------------|

|Enclave read/write access|

The instruction faults if any of the following occurs:

|     Address in RBX is not properly aligned. |             Any TCS.FLAGS’s must-be-zero bit is not zero. |

|----------------------------------------------------------|-----------------------------------------------------------------------------------------------|

|TCS pointed to by RBX is not valid or available or locked. |     Current 32/64 mode does not match the enclave mode in SECS.ATTRIBUTES.MODE64. |

|     The SECS is in use by another enclave. |   Either of TCS-specified FS and GS segment is not a subset of the current DS segment. |

|     Any one of DS, ES, CS, SS is not zero. |       If XSAVE available, CR4. OSXSAVE = 0, but SECS.ATTRIBUTES.XFRM ≠ 3. |

|           CR4. OSFXSR ≠ 1. |        If CR4. OSXSAVE = 1, SECS.ATTRIBUTES.XFRM is not a subset of XCR0. |

|     Offsets 520-535 of the XSAVE area not 0. |The bit vector stored at offset 512 of the XSAVE area must be a subset of SECS.ATTRIBUTES.XFRM.|

|     The SSA frame is not valid or in use. |    If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0. |

The following operations are performed by ERESUME:

* RSP and RBP are saved in the current SSA frame on EENTER and are automatically restored on EEXIT or an asynchronous exit due to any Interrupt event.

* The AEP contained in RCX is stored into the TCS for use by AEXs.FS and GS (including hidden portions) are saved and new values are constructed using TCS.OFSBASE/GSBASE (32 and 64-bit mode) and TCS.OFSLIMIT/GSLIMIT (32-bit mode only). The resulting segments must be a subset of the DS segment.

* If CR4. OSXSAVE == 1, XCR0 is saved and replaced by SECS.ATTRIBUTES.XFRM. The effect of RFLAGS.TF depends on whether the enclave entry is opt-in or opt-out (see Section 40.1. 2):

* On opt-out entry, TF is saved and cleared (it is restored on EEXIT or AEX). Any attempt to set TF via a POPF instruction while inside the enclave clears TF (see Section 40.2. 5).

* On opt-out entry, TF is saved and cleared (it is restored on EEXIT or AEX). Any attempt to set TF via a POPF instruction while inside the enclave clears TF (see Section 40.2. 5).

* On opt-in entry, a single-step debug exception is pended on the instruction boundary immediately after EENTER (see Section 40.2. 3).

* On opt-in entry, a single-step debug exception is pended on the instruction boundary immediately after EENTER (see Section 40.2. 3).

* All code breakpoints that do not overlap with ELRANGE are also suppressed. If the entry is an opt-out entry, all code and data breakpoints that overlap with the ELRANGE are suppressed.

* On opt-out entry, a number of performance monitoring counters and behaviors are modified or suppressed (see Section 40.2. 3):

* All performance monitoring activity on the current thread is suppressed except for incrementing and firing of FIXED\_CTR1 and FIXED\_CTR2.

* All performance monitoring activity on the current thread is suppressed except for incrementing and firing of FIXED\_CTR1 and FIXED\_CTR2.

* PEBS is suppressed.

* PEBS is suppressed.

* AnyThread counting on other threads is demoted to MyThread mode and IA32\_PERF\_GLOBAL\_STATUSon that thread is set.

* AnyThread counting on other threads is demoted to MyThread mode and IA32\_PERF\_GLOBAL\_STATUSon that thread is set.

* If the opt-out entry on a hardware thread results in suppression of any performance monitoring, then the processor sets IA32\_PERF\_GLOBAL\_STATUSand IA32\_PERF\_GLOBAL\_STATUS.

* If the opt-out entry on a hardware thread results in suppression of any performance monitoring, then the processor sets IA32\_PERF\_GLOBAL\_STATUSand IA32\_PERF\_GLOBAL\_STATUS.

Concurrency Restrictions ¶

|             Leaf             | Parameter |Base Concurrency Restrictions|  |  |

|--------------------------------------------------------|------------|-----------------------------|---|---|

|                            |On Conflict |               |  |  |

|ERESUME ERESUME TCS [DS:RBX] Shared ERESUME TCS [DS:RBX]|TCS [DS:RBX]|               |  |  |

Table 38-74. Base Concurrency Restrictions of ERESUME

|                                             Leaf                                             |               Parameter               |Additional Concurrency Restrictions|  |     |  |     |  |

|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------|-----------------------------------|---|----------|---|----------|---|

|vs EACCEPT, EACCEPTCOPY, vs EADD, EEXTEND, EINIT vs ETRACK, ETRACKC Access vs ETRACK, ETRACKC Access On Conflict Access vs ETRACK, ETRACKC Access On Conflict EMODPE, EMODPR, EMODT|vs EADD, EEXTEND, EINIT vs EADD, EEXTEND, EINIT vs ETRACK, ETRACKC|    vs ETRACK, ETRACKC    |  |     |  |     |  |

|                          Access On Conflict Access On Conflict Access Access On Conflict Access On Conflict                          |                                   |                  |  |     |  |     |  |

|                                            ERESUME                                             |              TCS [DS:RBX]               |      Concurrent       |  |Concurrent|  |Concurrent|  |

Table 38-75. Additional Concurrency Restrictions of ERESUME

Operation ¶

Temp Variables in ERESUME Operational Flow ¶

|    Name    |   Type    |Size |                Description                 |

|-------------------|-----------------|-----|----------------------------------------------------------------------------|

|  TMP\_FSBASE  |Effective Address|32/64|          Proposed base address for FS segment. |

|  TMP\_GSBASE  |Effective Address|32/64|          Proposed base address for FS segment. |

|  TMP\_FSLIMIT  |Effective Address|32/64|        Highest legal address in proposed FS segment. |

|  TMP\_GSLIMIT  |Effective Address|32/64|        Highest legal address in proposed GS segment. |

|  TMP\_TARGET  |Effective Address|32/64|Address of first instruction inside enclave at which execution is to resume. |

|   TMP\_SECS   |Effective Address|32/64|         Physical address of SECS for this enclave. |

|   TMP\_SSA   |Effective Address|32/64|            Address of current SSA frame. |

|  TMP\_XSIZE   |   integer   | 64 |       Size of XSAVE area based on SECS.ATTRIBUTES.XFRM.       |

| TMP\_SSA\_PAGE  |Effective Address|32/64|   Pointer used to iterate over the SSA pages in the current frame. |

|   TMP\_GPR   |Effective Address|32/64|      Address of the GPR area within the current SSA frame. |

|TMP\_BRANCH\_RECORD|  LBR Record  |   |       From/to addresses to be pushed onto the LBR stack. |

|  TMP\_NOTIFY  |   Boolean   | 1 |        When set to 1, deliver an AEX notification. |

TMP\_MODE64 := ((IA32\_EFER.LMA = 1) && (CS.L = 1));

(\* Make sure DS is usable, expand up \*)

IF (TMP\_MODE64 = 0 and (DS not usable or ( ( DS[S] = 1) and (DS[bit 11] = 0) and DS[bit 10] = 1))))

THEN #GP(0); FI;

(\* Check that CS, SS, DS, ES.base is 0 \*)

IF (TMP\_MODE64 = 0)

THEN

IF(CS.base ≠ 0 or DS.base ≠ 0) #GP(0); FI;

IF(ES usable and ES.base ≠ 0) #GP(0); FI;

IF(SS usable and SS.base ≠ 0) #GP(0); FI;

IF(SS usable and SS.B = 0) #GP(0); FI;

FI;

IF (DS:RBX is not 4KByte Aligned)

THEN #GP(0); FI;

IF (DS:RBX does not resolve within an EPC)

THEN #PF(DS:RBX); FI;

(\* Check AEP is canonical\*)

IF (TMP\_MODE64 = 1 and (CS:RCX is not canonical))

THEN #GP(0); FI;

(\* Check concurrency of TCS operation\*)

IF (Other Intel SGX instructions are operating on TCS)

THEN #GP(0); FI;

(\* TCS verification \*)

IF (EPCM(DS:RBX). VALID = 0)

THEN #PF(DS:RBX); FI;

IF (EPCM(DS:RBX). BLOCKED = 1)

THEN #PF(DS:RBX); FI;

IF ((EPCM(DS:RBX). PENDING = 1) or (EPCM(DS:RBX). MODIFIED = 1))

THEN #PF(DS:RBX); FI;

IF ( (EPCM(DS:RBX). ENCLAVEADDRESS ≠ DS:RBX) or (EPCM(DS:RBX). PT ≠ PT\_TCS))

THEN #PF(DS:RBX); FI;

IF ( (DS:RBX). OSSA is not 4KByte Aligned)

THEN #GP(0); FI;

(\* Check proposed FS and GS \*)

IF ( ( (DS:RBX). OFSBASE is not 4KByte Aligned) or ( (DS:RBX). OGSBASE is not 4KByte Aligned))

THEN #GP(0); FI;

(\* Get the SECS for the enclave in which the TCS resides \*)

TMP\_SECS := Address of SECS for TCS;

(\* Make sure that the FLAGS field in the TCS does not have any reserved bits set \*)

IF ( ( (DS:RBX). FLAGS & FFFFFFFFFFFFFFFCH) ≠ 0)

THEN #GP(0); FI;

(\* SECS must exist and enclave must have previously been EINITted \*)

IF (the enclave is not already initialized)

THEN #GP(0); FI;

(\* make sure the logical processor's operating mode matches the enclave \*)

IF ( (TMP\_MODE64 ≠ TMP\_SECS.ATTRIBUTES.MODE64BIT))

THEN #GP(0); FI;

IF (CR4. OSFXSR = 0)

THEN #GP(0); FI;

(\* Check for legal values of SECS.ATTRIBUTES.XFRM \*)

IF (CR4. OSXSAVE = 0)

THEN

IF (TMP\_SECS.ATTRIBUTES.XFRM ≠ 03H) THEN #GP(0); FI;

ELSE

IF ( (TMP\_SECS.ATTRIBUTES.XFRM & XCR0) ≠ TMP\_SECS.ATTRIBUTES.XFRM) THEN #GP(0); FI;

FI;

IF ( (DS:RBX). CSSA.FLAGS.DBGOPTIN = 0) and (DS:RBX). CSSA.FLAGS.AEXNOTIFY ≠ TMP\_SECS.ATTRIBUTES.AEXNOTIFY))

THEN #GP(0); FI;

(\* Make sure the SSA contains at least one active frame \*)

IF ( (DS:RBX). CSSA = 0)

THEN #GP(0); FI;

(\* Compute linear address of SSA frame \*)

TMP\_SSA := (DS:RBX). OSSA + TMP\_SECS.BASEADDR + 4096 \* TMP\_SECS.SSAFRAMESIZE \* ( (DS:RBX). CSSA - 1);

TMP\_XSIZE := compute\_XSAVE\_frame\_size(TMP\_SECS.ATTRIBUTES.XFRM);

FOR EACH TMP\_SSA\_PAGE = TMP\_SSA to TMP\_SSA + TMP\_XSIZE

(\* Check page is read/write accessible \*)

Check that DS:TMP\_SSA\_PAGE is read/write accessible;

If a fault occurs, release locks, abort and deliver that fault;

IF (DS:TMP\_SSA\_PAGE does not resolve to EPC page)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF (EPCM(DS:TMP\_SSA\_PAGE). VALID = 0)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF (EPCM(DS:TMP\_SSA\_PAGE). BLOCKED = 1)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF ((EPCM(DS:TMP\_SSA\_PAGE). PENDING = 1) or (EPCM(DS:TMP\_SSA\_PAGE\_. MODIFIED = 1))

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF ( ( EPCM(DS:TMP\_SSA\_PAGE). ENCLAVEADDRESS ≠ DS:TMPSSA\_PAGE) or (EPCM(DS:TMP\_SSA\_PAGE). PT ≠ PT\_REG) or

(EPCM(DS:TMP\_SSA\_PAGE). ENCLAVESECS ≠ EPCM(DS:RBX). ENCLAVESECS) or

(EPCM(DS:TMP\_SSA\_PAGE). R = 0) or (EPCM(DS:TMP\_SSA\_PAGE). W = 0) )

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

CR\_XSAVE\_PAGE\_n := Physical\_Address(DS:TMP\_SSA\_PAGE);

ENDFOR

(\* Compute address of GPR area\*)

TMP\_GPR := TMP\_SSA + 4096 \* DS:TMP\_SECS.SSAFRAMESIZE - sizeof(GPRSGX\_AREA);

Check that DS:TMP\_SSA\_PAGE is read/write accessible;

If a fault occurs, release locks, abort and deliver that fault;

IF (DS:TMP\_GPR does not resolve to EPC page)

THEN #PF(DS:TMP\_GPR); FI;

IF (EPCM(DS:TMP\_GPR). VALID = 0)

THEN #PF(DS:TMP\_GPR); FI;

IF (EPCM(DS:TMP\_GPR). BLOCKED = 1)

THEN #PF(DS:TMP\_GPR); FI;

IF ((EPCM(DS:TMP\_GPR). PENDING = 1) or (EPCM(DS:TMP\_GPR). MODIFIED = 1))

THEN #PF(DS:TMP\_GPR); FI;

IF ( ( EPCM(DS:TMP\_GPR). ENCLAVEADDRESS ≠ DS:TMP\_GPR) or (EPCM(DS:TMP\_GPR). PT ≠ PT\_REG) or

(EPCM(DS:TMP\_GPR). ENCLAVESECS ≠ EPCM(DS:RBX). ENCLAVESECS) or

(EPCM(DS:TMP\_GPR). R = 0) or (EPCM(DS:TMP\_GPR). W = 0))

THEN #PF(DS:TMP\_GPR); FI;

IF (TMP\_MODE64 = 0)

THEN

IF (TMP\_GPR + (GPR\_SIZE -1) is not in DS segment) THEN #GP(0); FI;

FI;

CR\_GPR\_PA := Physical\_Address (DS: TMP\_GPR);

IF ((DS:RBX). FLAGS.AEXNOTIFY = 1) and (DS:TMP\_GPR.AEXNOTIFY= 1))

THEN

TMP\_NOTIFY := 1;

ELSE

TMP\_NOTIFY := 0;

FI;

IF (TMP\_NOTIFY = 1)

THEN

(\* Make sure the SSA contains at least one more frame \*)

IF ((DS:RBX). CSSA ≥ (DS:RBX). NSSA)

THEN #GP(0); FI;

TMP\_SSA := TMP\_SSA + 4096 \* TMP\_SECS.SSAFRAMESIZE;

TMP\_XSIZE := compute\_XSAVE\_frame\_size(TMP\_SECS.ATTRIBUTES.XFRM);

FOR EACH TMP\_SSA\_PAGE = TMP\_SSA to TMP\_SSA + TMP\_XSIZE

(\* Check page is read/write accessible \*)

Check that DS:TMP\_SSA\_PAGE is read/write accessible;

If a fault occurs, release locks, abort and deliver that fault;

IF (DS:TMP\_SSA\_PAGE does not resolve to EPC page)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF (EPCM(DS:TMP\_SSA\_PAGE). VALID = 0)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF (EPCM(DS:TMP\_SSA\_PAGE). BLOCKED = 1)

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF ((EPCM(DS:TMP\_SSA\_PAGE). PENDING = 1) or

(EPCM(DS:TMP\_SSA\_PAGE). MODIFIED = 1))

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

IF ((EPCM(DS:TMP\_SSA\_PAGE). ENCLAVEADDRESS ≠ DS:TMP\_SSA\_PAGE) or

(EPCM(DS:TMP\_SSA\_PAGE). PT ≠ PT\_REG) or

(EPCM(DS:TMP\_SSA\_PAGE). ENCLAVESECS ≠ EPCM(DS:RBX). ENCLAVESECS) or

(EPCM(DS:TMP\_SSA\_PAGE). R = 0) or (EPCM(DS:TMP\_SSA\_PAGE). W = 0))

THEN #PF(DS:TMP\_SSA\_PAGE); FI;

CR\_XSAVE\_PAGE\_n := Physical\_Address(DS:TMP\_SSA\_PAGE);

ENDFOR

(\* Compute address of GPR area\*)

TMP\_GPR := TMP\_SSA + 4096 \* DS:TMP\_SECS.SSAFRAMESIZE - sizeof(GPRSGX\_AREA);

If a fault occurs; release locks, abort and deliver that fault;

IF (DS:TMP\_GPR does not resolve to EPC page)

THEN #PF(DS:TMP\_GPR); FI;

IF (EPCM(DS:TMP\_GPR). VALID = 0)

THEN #PF(DS:TMP\_GPR); FI;

IF (EPCM(DS:TMP\_GPR). BLOCKED = 1)

THEN #PF(DS:TMP\_GPR); FI;

IF ((EPCM(DS:TMP\_GPR). PENDING = 1) or (EPCM(DS:TMP\_GPR). MODIFIED = 1))

THEN #PF(DS:TMP\_GPR); FI;

IF ((EPCM(DS:TMP\_GPR). ENCLAVEADDRESS ≠ DS:TMP\_GPR) or

(EPCM(DS:TMP\_GPR). PT ≠ PT\_REG) or

(EPCM(DS:TMP\_GPR). ENCLAVESECS EPCM(DS:RBX). ENCLAVESECS) or

(EPCM(DS:TMP\_GPR). R = 0) or (EPCM(DS:TMP\_GPR). W = 0))

THEN #PF(DS:TMP\_GPR); FI;

IF (TMP\_MODE64 = 0)

THEN

IF (TMP\_GPR + (GPR\_SIZE -1) is not in DS segment) THEN #GP(0); FI;

FI;

CR\_GPR\_PA := Physical\_Address (DS: TMP\_GPR);

TMP\_TARGET := (DS:RBX). OENTRY + TMP\_SECS.BASEADDR;

ELSE

TMP\_TARGET := (DS:TMP\_GPR). RIP;

FI;

IF (TMP\_MODE64 = 1)

THEN

IF (TMP\_TARGET is not canonical) THEN #GP(0); FI;

ELSE

IF (TMP\_TARGET \> CS limit) THEN #GP(0); FI;

FI;

(\* Check proposed FS/GS segments fall within DS \*)

IF (TMP\_MODE64 = 0)

THEN

TMP\_FSBASE := (DS:RBX). OFSBASE + TMP\_SECS.BASEADDR;

TMP\_FSLIMIT := (DS:RBX). OFSBASE + TMP\_SECS.BASEADDR + (DS:RBX). FSLIMIT;

TMP\_GSBASE := (DS:RBX). OGSBASE + TMP\_SECS.BASEADDR;

TMP\_GSLIMIT := (DS:RBX). OGSBASE + TMP\_SECS.BASEADDR + (DS:RBX). GSLIMIT;

(\* if FS wrap-around, make sure DS has no holes\*)

IF (TMP\_FSLIMIT \< TMP\_FSBASE)

THEN

IF (DS.limit \< 4GB) THEN #GP(0); FI;

ELSE

IF (TMP\_FSLIMIT \> DS.limit) THEN #GP(0); FI;

FI;

(\* if GS wrap-around, make sure DS has no holes\*)

IF (TMP\_GSLIMIT \< TMP\_GSBASE)

THEN

IF (DS.limit \< 4GB) THEN #GP(0); FI;

ELSE

IF (TMP\_GSLIMIT \> DS.limit) THEN #GP(0); FI;

FI;

ELSE

IF (TMP\_NOTIFY = 1)

THEN

TMP\_FSBASE := (DS:RBX). OFSBASE + TMP\_SECS.BASEADDR;

TMP\_GSBASE := (DS:RBX). OGSBASE + TMP\_SECS.BASEADDR;

ELSE

TMP\_FSBASE := DS:TMP\_GPR.FSBASE;

TMP\_GSBASE := DS:TMP\_GPR.GSBASE;

FI;

IF ((TMP\_FSBASE is not canonical) or (TMP\_GSBASE is not canonical))

THEN #GP(0); FI;

FI;

(\* Ensure the enclave is not already active and this thread is the only one using the TCS\*)

IF (DS:RBX.STATE = ACTIVE))

THEN #GP(0); FI;

TMP\_IA32\_U\_CET := 0

TMP\_SSP := 0

IF (CPUID.(EAX=12H, ECX=1):EAX= 1)

THEN

IF ( CR4. CET = 0 )

THEN

(\* If part does not support CET or CET has not been enabled and enclave requires CET then fail \*)

IF (TMP\_SECS.CET\_ATTRIBUTES ≠ 0 OR TMP\_SECS.CET\_LEG\_BITMAP\_OFFSET ≠ 0) #GP(0); FI;

FI;

(\* If indirect branch tracking or shadow stacks enabled but CET state save area is not 16B aligned then fail ERESUME \*)

IF (TMP\_SECS.CET\_ATTRIBUTES.SH\_STK\_EN = 1 OR TMP\_SECS.CET\_ATTRIBUTES.ENDBR\_EN = 1)

THEN

IF (DS:RBX.OCETSSA is not 16B aligned) #GP(0); FI;

FI;

IF (TMP\_SECS.CET\_ATTRIBUTES.SH\_STK\_EN OR TMP\_SECS.CET\_ATTRIBUTES.ENDBR\_EN)

THEN

(\* Setup CET state from SECS, note tracker goes to IDLE \*)

TMP\_IA32\_U\_CET = TMP\_SECS.CET\_ATTRIBUTES;

IF (TMP\_IA32\_U\_CET.LEG\_IW\_EN = 1 AND TMP\_IA32\_U\_CET.ENDBR\_EN = 1)

THEN

TMP\_IA32\_U\_CET := TMP\_IA32\_U\_CET + TMP\_SECS.BASEADDR;

TMP\_IA32\_U\_CET := TMP\_IA32\_U\_CET + TMP\_SECS.CET\_LEG\_BITMAP\_BASE;

FI;

(\* Compute linear address of what will become new CET state save area and cache its PA \*)

IF (TMP\_NOTIFY = 1)

THEN

TMP\_CET\_SAVE\_AREA = DS:RBX.OCETSSA + TMP\_SECS.BASEADDR + (DS:RBX.CSSA) \* 16;

ELSE

TMP\_CET\_SAVE\_AREA = DS:RBX.OCETSSA + TMP\_SECS.BASEADDR + (DS:RBX.CSSA - 1) \* 16;

FI;

TMP\_CET\_SAVE\_PAGE = TMP\_CET\_SAVE\_AREA & \~0xFFF;

Check the TMP\_CET\_SAVE\_PAGE page is read/write accessible

If fault occurs release locks, abort and deliver fault

(\* read the EPCM VALID, PENDING, MODIFIED, BLOCKED and PT fields atomically \*)

IF ((DS:TMP\_CET\_SAVE\_PAGE Does NOT RESOLVE TO EPC PAGE) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). VALID = 0) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). PENDING = 1) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). MODIFIED = 1) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). BLOCKED = 1) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). R = 0) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). W = 0) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). ENCLAVEADDRESS ≠ DS:TMP\_CET\_SAVE\_PAGE) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). PT ≠ PT\_SS\_REST) OR

(EPCM(DS:TMP\_CET\_SAVE\_PAGE). ENCLAVESECS ≠ EPCM(DS:RBX). ENCLAVESECS))

THEN

\#PF(DS:TMP\_CET\_SAVE\_PAGE);

FI;

CR\_CET\_SAVE\_AREA\_PA := Physical address(DS:TMP\_CET\_SAVE\_AREA)

IF (TMP\_NOTIFY = 1)

THEN

IF TMP\_IA32\_U\_CET.SH\_STK\_EN = 1

THEN TMP\_SSP = TCS.PREVSSP; FI;

ELSE

TMP\_SSP = CR\_CET\_SAVE\_AREA\_PA.SSP

TMP\_IA32\_U\_CET.TRACKER = CR\_CET\_SAVE\_AREA\_PA.TRACKER;

TMP\_IA32\_U\_CET.SUPPRESS = CR\_CET\_SAVE\_AREA\_PA.SUPPRESS;

IF ( (TMP\_MODE64 = 1 AND TMP\_SSP is not canonical) OR

(TMP\_MODE64 = 0 AND (TMP\_SSP & 0xFFFFFFFF00000000) ≠ 0) OR

(TMP\_SSP is not 4 byte aligned) OR

(TMP\_IA32\_U\_CET.TRACKER = WAIT\_FOR\_ENDBRANCH AND TMP\_IA32\_U\_CET.SUPPRESS = 1) OR

(CR\_CET\_SAVE\_AREA\_PA.Reserved ≠ 0) ) #GP(0); FI;

FI;

FI;

FI;

IF (TMP\_NOTIFY = 0)

THEN

(\* SECS.ATTRIBUTES.XFRM selects the features to be saved. \*)

(\* CR\_XSAVE\_PAGE\_n: A list of 1 or more physical address of pages that contain the XSAVE area. \*)

XRSTOR(TMP\_MODE64, SECS.ATTRIBUTES.XFRM, CR\_XSAVE\_PAGE\_n);

IF (XRSTOR failed with #GP)

THEN

DS:RBX.STATE := INACTIVE;

\#GP(0);

FI;

FI;

CR\_ENCLAVE\_MODE := 1;

CR\_ACTIVE\_SECS := TMP\_SECS;

CR\_ELRANGE := (TMP\_SECS.BASEADDR, TMP\_SECS.SIZE);

(\* Save sate for possible AEXs \*)

CR\_TCS\_PA := Physical\_Address (DS:RBX);

CR\_TCS\_LA := RBX;

CR\_TCS\_LA.AEP := RCX;

(\* Save the hidden portions of FS and GS \*)

CR\_SAVE\_FS\_selector := FS.selector;

CR\_SAVE\_FS\_base := FS.base;

CR\_SAVE\_FS\_limit := FS.limit;

CR\_SAVE\_FS\_access\_rights := FS.access\_rights;

CR\_SAVE\_GS\_selector := GS.selector;

CR\_SAVE\_GS\_base := GS.base;

CR\_SAVE\_GS\_limit := GS.limit;

CR\_SAVE\_GS\_access\_rights := GS.access\_rights;

IF (TMP\_NOTIFY = 1)

THEN

(\* If XSAVE is enabled, save XCR0 and replace it with SECS.ATTRIBUTES.XFRM\*)

IF (CR4. OSXSAVE = 1)

THEN

CR\_SAVE\_XCR0 := XCR0;

XCR0 := TMP\_SECS.ATTRIBUTES.XFRM;

FI;

FI;

RIP := TMP\_TARGET;

IF (TMP\_NOTIFY = 1)

THEN

RCX := RIP;

RAX := (DS:RBX). CSSA;

(\* Save the outside RSP and RBP so they can be restored on interrupt or EEXIT \*)

DS:TMP\_SSA.U\_RSP := RSP;

DS:TMP\_SSA.U\_RBP := RBP;

ELSE

Restore\_GPRs from DS:TMP\_GPR;

(\*Restore the RFLAGS values from SSA\*)

RFLAGS.CF := DS:TMP\_GPR.RFLAGS.CF;

RFLAGS.PF := DS:TMP\_GPR.RFLAGS.PF;

RFLAGS.AF := DS:TMP\_GPR.RFLAGS.AF;

RFLAGS.ZF := DS:TMP\_GPR.RFLAGS.ZF;

RFLAGS.SF := DS:TMP\_GPR.RFLAGS.SF;

RFLAGS.DF := DS:TMP\_GPR.RFLAGS.DF;

RFLAGS.OF := DS:TMP\_GPR.RFLAGS.OF;

RFLAGS.NT := DS:TMP\_GPR.RFLAGS.NT;

RFLAGS.AC := DS:TMP\_GPR.RFLAGS.AC;

RFLAGS.ID := DS:TMP\_GPR.RFLAGS.ID;

RFLAGS.RF := DS:TMP\_GPR.RFLAGS.RF;

RFLAGS.VM := 0;

IF (RFLAGS.IOPL = 3)

THEN RFLAGS.IF := DS:TMP\_GPR.RFLAGS.IF; FI;

IF (TCS.FLAGS.OPTIN = 0)

THEN RFLAGS.TF := 0; FI;

(\* If XSAVE is enabled, save XCR0 and replace it with SECS.ATTRIBUTES.XFRM\*)

IF (CR4. OSXSAVE = 1)

THEN

CR\_SAVE\_XCR0 := XCR0;

XCR0 := TMP\_SECS.ATTRIBUTES.XFRM;

FI;

(\* Pop the SSA stack\*)

(DS:RBX). CSSA := (DS:RBX). CSSA -1;

FI;

(\* Do the FS/GS swap \*)

FS.base := TMP\_FSBASE;

FS.limit := DS:RBX.FSLIMIT;

FS.type := 0001b;

FS.W := DS.W;

FS.S := 1;

FS.DPL := DS.DPL;

FS.G := 1;

FS.B := 1;

FS.P := 1;

FS.AVL := DS.AVL;

FS.L := DS.L;

FS.unusable := 0;

FS.selector := 0BH;

GS.base := TMP\_GSBASE;

GS.limit := DS:RBX.GSLIMIT;

GS.type := 0001b;

GS.W := DS.W;

GS.S := 1;

GS.DPL := DS.DPL;

GS.G := 1;

GS.B := 1;

GS.P := 1;

GS.AVL := DS.AVL;

GS.L := DS.L;

GS.unusable := 0;

GS.selector := 0BH;

CR\_DBGOPTIN := TCS.FLAGS.DBGOPTIN;

Suppress all code breakpoints that are outside ELRANGE;

IF (CR\_DBGOPTIN = 0)

THEN

Suppress all code breakpoints that overlap with ELRANGE;

CR\_SAVE\_TF := RFLAGS.TF;

RFLAGS.TF := 0;

Suppress any MTF VM exits during execution of the enclave;

Clear all pending debug exceptions;

Clear any pending MTF VM exit;

ELSE

IF (TMP\_NOTIFY = 1)

THEN

IF RFLAGS.TF = 1

THEN pend a single-step #DB at the end of ERESUME; FI;

IF the “monitor trap flag” VM-execution control is set

THEN pend an MTF VM exit at the end of ERESUME; FI;

ELSE

Clear all pending debug exceptions;

Clear pending MTF VM exits;

FI;

FI;

IF ((CPUID.(EAX=7H, ECX=0):EDX[CET\_IBT] = 1) OR (CPUID.(EAX=7, ECX=0):ECX[CET\_SS] = 1)

THEN

(\* Save enclosing application CET state into save registers \*)

CR\_SAVE\_IA32\_U\_CET := IA32\_U\_CET

(\* Setup enclave CET state \*)

IF CPUID.(EAX=07H, ECX=00h):ECX[CET\_SS] = 1

THEN

CR\_SAVE\_SSP := SSP

SSP := TMP\_SSP;

FI;

IA32\_U\_CET := TMP\_IA32\_U\_CET;

FI;

(\* Assure consistent translations \*)

Flush\_linear\_context;

Clear\_Monitor\_FSM;

Allow\_front\_end\_to\_begin\_fetch\_at\_new\_RIP;

Flags Affected ¶

RFLAGS.TF is cleared on opt-out entry

Protected Mode Exceptions ¶

|                            \#GP(0)                            |     If DS:RBX is not page aligned. |

|-----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------|

|                     If the enclave is not initialized. |                         |

|                   If the thread is not in the INACTIVE state. |                         |

|                   If CS, DS, ES or SS bases are not all zero. |                         |

|                       If executed in enclave mode. |                         |

|         If part or all of the FS or GS segment specified by TCS is outside the DS segment. |                         |

|                   If any reserved field in the TCS FLAG is set. |                         |

|                 If the target address is not within the CS segment. |                         |

|                         If CR4. OSFXSR = 0. |                         |

|                  If CR4. OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3. |                         |

|             If CR4. OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0. |                         |

|          If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0. |                         |

|                           \#PF(error                            |code) If a page fault occurs in accessing memory. |

|                    If DS:RBX does not point to a valid TCS.                    |                         |

|If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT\_REG EPC page. |                         |

64-Bit Mode Exceptions ¶

|                            \#GP(0)                            |       If DS:RBX is not page aligned. |

|-----------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|

|                     If the enclave is not initialized. |                             |

|                   If the thread is not in the INACTIVE state. |                             |

|                   If CS, DS, ES or SS bases are not all zero. |                             |

|                       If executed in enclave mode. |                             |

|         If part or all of the FS or GS segment specified by TCS is outside the DS segment. |                             |

|                   If any reserved field in the TCS FLAG is set. |                             |

|                    If the target address is not canonical. |                             |

|                         If CR4. OSFXSR = 0. |                             |

|                  If CR4. OSXSAVE = 0 and SECS.ATTRIBUTES.XFRM ≠ 3. |                             |

|             If CR4. OSXSAVE = 1and SECS.ATTRIBUTES.XFRM is not a subset of XCR0. |                             |

|          If SECS.ATTRIBUTES.AEXNOTIFY ≠ TCS.FLAGS.AEXNOTIFY and TCS.FLAGS.DBGOPTIN = 0. |                             |

|                           \#PF(error                            |code) If a page fault occurs in accessing memory operands. |

|                    If DS:RBX does not point to a valid TCS.                    |                             |

|If one or more pages of the current SSA frame are not readable/writable, or do not resolve to a valid PT\_REG EPC page. |                             |

This UNOFFICIAL, mechanically-separated, non-verified reference is provided for convenience, but it may be incomplete or b r oke n in various obvious or non-obvious ways. Refer to Intel® 64 and IA-32 Architectures Software Developer’s Manual for anything serious.