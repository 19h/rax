Qualcomm Hexagon V68
Programmer’s Reference Manual
80-N2040-46 Rev. B
June 29, 2020

All Qualcomm products mentioned herein are products of Qualcomm Technologies, Inc. and/or its subsidiaries.
Qualcomm and Hexagon are trademarks of Qualcomm Incorporated, registered in the United States and other countries. Other
product and brand names may be trademarks or registered trademarks of their respective owners.
This technical data may be subject to U.S. and international export, re-export, or transfer (“export”) laws. Diversion contrary to U.S.
and international law is strictly prohibited.
Qualcomm Technologies, Inc.
5775 Morehouse Drive
San Diego, CA 92121
U.S.A.
© 2019--2020 Qualcomm Technologies, Inc. and/or its subsidiaries. All rights reserved.

Contents
Figures .............................................................................................................................. 14
Tables ................................................................................................................................ 15

1 Introduction......................................................................................... 17
1.1 Features....................................................................................................................... 17
1.2 Functional units .......................................................................................................... 19
1.2.1 Memory............................................................................................................. 20
1.2.2 Registers............................................................................................................ 20
1.2.3 Sequencer.......................................................................................................... 20
1.2.4 Execution units.................................................................................................. 20
1.2.5 Load/store units................................................................................................. 20
1.3 Instruction set ............................................................................................................. 21
1.3.1 Addressing modes............................................................................................. 21
1.3.2 Scalar operations............................................................................................... 22
1.3.3 Vector operations .............................................................................................. 22
1.3.4 Floating-point operations .................................................................................. 23
1.3.5 Program flow .................................................................................................... 24
1.3.6 Instruction packets ............................................................................................ 24
1.3.7 Dot-new instructions......................................................................................... 25
1.3.8 Compound instructions ..................................................................................... 25
1.3.9 Duplex instructions ........................................................................................... 25
1.3.10 Instruction classes ........................................................................................... 25
1.3.11 Instruction intrinsics........................................................................................ 26
1.4 Notation ...................................................................................................................... 27
1.4.1 Instruction syntax.............................................................................................. 27
1.4.2 Register operands.............................................................................................. 28
1.4.3 Numeric operands ............................................................................................. 30
1.5 Terminology ............................................................................................................... 31
1.6 Technical assistance.................................................................................................... 31

2 Registers ............................................................................................. 32
2.1 General registers......................................................................................................... 32
2.2 Control registers ......................................................................................................... 34
2.2.1 Program counter................................................................................................ 37
2.2.2 Loop registers.................................................................................................... 37

80-N2040-46 Rev. B

2

Hexagon V68 Programmer’s Reference Manual

Contents

2.2.3 User status register............................................................................................ 38
2.2.4 Modifier registers.............................................................................................. 41
2.2.5 Predicate registers ............................................................................................. 42
2.2.6 Circular start registers ....................................................................................... 43
2.2.7 User general pointer register............................................................................. 43
2.2.8 Global pointer ................................................................................................... 43
2.2.9 Cycle count registers......................................................................................... 44
2.2.10 Frame limit register......................................................................................... 44
2.2.11 Frame key register........................................................................................... 45
2.2.12 Packet count registers ..................................................................................... 45
2.2.13 Qtimer registers............................................................................................... 46

3 Instructions ......................................................................................... 47
3.1 Instruction syntax ....................................................................................................... 47
3.2 Instruction classes....................................................................................................... 48
3.3 Instruction packets...................................................................................................... 49
3.3.1 Packet execution semantics............................................................................... 50
3.3.2 Sequencing semantics ....................................................................................... 50
3.3.3 Resource constraints ......................................................................................... 51
3.3.4 Grouping constraints......................................................................................... 52
3.3.5 Dependency constraints .................................................................................... 53
3.3.6 Ordering constraints.......................................................................................... 53
3.3.7 Alignment constraints ....................................................................................... 54
3.4 Instruction intrinsics ................................................................................................... 54
3.5 Compound instructions............................................................................................... 55
3.6 Duplex instructions..................................................................................................... 55

4 Data Processing ................................................................................. 56
4.1 Data types ................................................................................................................... 57
4.1.1 Fixed-point data ................................................................................................ 57
4.1.2 Floating-point data ............................................................................................ 57
4.1.3 Complex data .................................................................................................... 57
4.1.4 Vector data ........................................................................................................ 57
4.2 Instruction options ...................................................................................................... 59
4.2.1 Fractional scaling .............................................................................................. 59
4.2.2 Saturation .......................................................................................................... 59
4.2.3 Arithmetic rounding.......................................................................................... 59
4.2.4 Convergent rounding ........................................................................................ 60
4.2.5 Scaling for divide and square-root.................................................................... 60
4.3 XTYPE operations...................................................................................................... 61
4.3.1 ALU .................................................................................................................. 61
4.3.2 Bit manipulation................................................................................................ 62

80-N2040-46 Rev. B

3

Hexagon V68 Programmer’s Reference Manual

Contents

4.3.3 Complex............................................................................................................ 62
4.3.4 Floating point .................................................................................................... 63
4.3.5 Multiply............................................................................................................. 64
4.3.6 Permute ............................................................................................................. 66
4.3.7 Predicate............................................................................................................ 66
4.3.8 Shift................................................................................................................... 67
4.4 ALU32 operations ...................................................................................................... 68
4.5 Vector operations ........................................................................................................ 69
4.6 CR operations ............................................................................................................. 71
4.7 Compound operations................................................................................................. 71
4.8 Special operations....................................................................................................... 71
4.8.1 H.264 CABAC processing................................................................................ 72
4.8.1.1 CABAC implementation ......................................................................... 73
4.8.1.2 Code example .......................................................................................... 74
4.8.2 IP internet checksum......................................................................................... 75
4.8.2.1 Code example .......................................................................................... 76
4.8.3 Software-defined radio...................................................................................... 77
4.8.3.1 Rake despreading .................................................................................... 77
4.8.3.2 Polynomial operations............................................................................. 78

5 Memory................................................................................................ 79
5.1 Memory model ........................................................................................................... 80
5.1.1 Address space.................................................................................................... 80
5.1.2 Byte order.......................................................................................................... 80
5.1.3 Alignment ......................................................................................................... 80
5.2 Memory loads............................................................................................................. 81
5.3 Memory stores ............................................................................................................ 82
5.4 Dual stores .................................................................................................................. 82
5.5 Slot 1 store with slot 0 load ........................................................................................ 83
5.6 New-value stores ........................................................................................................ 83
5.7 Mem-ops..................................................................................................................... 84
5.8 Addressing modes ...................................................................................................... 84
5.8.1 Absolute ............................................................................................................ 85
5.8.2 Absolute-set ...................................................................................................... 85
5.8.3 Absolute with register offset ............................................................................. 85
5.8.4 Global pointer relative ...................................................................................... 86
5.8.5 Indirect .............................................................................................................. 87
5.8.6 Indirect with offset ............................................................................................ 87
5.8.7 Indirect with register offset ............................................................................... 87
5.8.8 Indirect with auto-increment immediate........................................................... 88
5.8.9 Indirect with auto-increment register................................................................ 88
5.8.10 Circular with auto-increment immediate ........................................................ 89
5.8.11 Circular with auto-increment register ............................................................. 91

80-N2040-46 Rev. B

4

Hexagon V68 Programmer’s Reference Manual

Contents

5.8.12 Bit-reversed with auto-increment register ...................................................... 92
5.9 Conditional load/stores............................................................................................... 93
5.10 Cache memory.......................................................................................................... 94
5.10.1 Uncached memory .......................................................................................... 95
5.10.2 Tightly coupled memory................................................................................. 95
5.10.3 Cache maintenance operations........................................................................ 95
5.10.4 L2 cache operations ........................................................................................ 96
5.10.5 Cache line zero................................................................................................ 97
5.10.6 Cache prefetch ................................................................................................ 97
5.11 Memory ordering.................................................................................................... 100
5.12 Atomic operations .................................................................................................. 101

6 Conditional Execution..................................................................... 103
6.1 Scalar predicates....................................................................................................... 103
6.1.1 Generating scalar predicates ........................................................................... 104
6.1.2 Consuming scalar predicates........................................................................... 106
6.1.3 Auto-AND predicates ..................................................................................... 107
6.1.4 Dot-new predicates ......................................................................................... 108
6.1.5 Dependency constraints .................................................................................. 109
6.2 Vector predicates ...................................................................................................... 109
6.2.1 Vector compare ............................................................................................... 109
6.2.2 Vector mux instruction.................................................................................... 111
6.2.3 Using vector conditionals ............................................................................... 112
6.3 Predicate operations.................................................................................................. 113

7 Software Stack ...................................................................................114
7.1 Stack structure .......................................................................................................... 114
7.2 Stack frames ............................................................................................................. 115
7.3 Stack protection ........................................................................................................ 116
7.3.1 Stack bounds checking.................................................................................... 116
7.3.2 Stack smashing protection .............................................................................. 116
7.4 Stack registers........................................................................................................... 117
7.5 Stack instructions...................................................................................................... 118

8 Program Flow.....................................................................................119
8.1 Conditional instructions............................................................................................ 119
8.2 Hardware loops......................................................................................................... 120
8.2.1 Loop setup....................................................................................................... 121
8.2.2 Loop end ......................................................................................................... 122
8.2.3 Loop execution................................................................................................ 123
8.2.4 Pipelined hardware loops................................................................................ 124
8.2.5 Loop restrictions ............................................................................................. 126

80-N2040-46 Rev. B

5

Hexagon V68 Programmer’s Reference Manual

Contents

8.3 Software branches .................................................................................................... 127
8.3.1 Jumps .............................................................................................................. 128
8.3.2 Calls ................................................................................................................ 128
8.3.3 Returns ............................................................................................................ 129
8.3.4 Extended branches .......................................................................................... 130
8.3.5 Branches to and from packets ......................................................................... 130
8.4 Speculative jumps..................................................................................................... 131
8.5 Compare jumps......................................................................................................... 132
8.5.1 New-value compare jumps ............................................................................. 133
8.6 Register transfer jumps............................................................................................. 134
8.7 Dual jumps................................................................................................................ 135
8.8 Hint indirect jump target .......................................................................................... 136
8.9 Pauses ....................................................................................................................... 137
8.10 Exceptions .............................................................................................................. 137

9 PMU Events....................................................................................... 140
9.1 V68 processor event symbols................................................................................... 141

10 Instruction Encoding...................................................................... 153
10.1 Instructions ............................................................................................................. 153
10.2 Sub-instructions...................................................................................................... 154
10.3 Duplexes ................................................................................................................. 157
10.4 Instruction classes................................................................................................... 159
10.5 Instruction packets.................................................................................................. 160
10.6 Loop packets........................................................................................................... 161
10.7 Immediate values.................................................................................................... 162
10.8 Scaled immediates .................................................................................................. 162
10.9 Constant extenders.................................................................................................. 163
10.10 New-value operands ............................................................................................. 166
10.11 Instruction mapping .............................................................................................. 167

11 Instruction Set................................................................................. 168
11.1 ALU32 .................................................................................................................... 170
11.1.1 ALU32/ALU ................................................................................................. 170
Logical operations .......................................................................................... 172
Negate............................................................................................................. 174
Nop ................................................................................................................. 175
Subtract........................................................................................................... 176
Sign extend ..................................................................................................... 178
Transfer immediate......................................................................................... 179
Transfer register ............................................................................................. 181
Vector add halfwords ..................................................................................... 182

80-N2040-46 Rev. B

6

Hexagon V68 Programmer’s Reference Manual

Contents

Vector average halfwords............................................................................... 183
Vector subtract halfwords .............................................................................. 184
Zero extend..................................................................................................... 186
11.1.2 ALU32/PERM .............................................................................................. 187
Mux ................................................................................................................ 189
Shift word by 16 ............................................................................................. 191
Pack high and low halfwords ......................................................................... 193
11.1.3 ALU32/PRED ............................................................................................... 194
Conditional shift halfword.............................................................................. 196
Conditional combine ...................................................................................... 198
Conditional logical operations........................................................................ 199
Conditional subtract ....................................................................................... 201
Conditional sign extend.................................................................................. 202
Conditional transfer ........................................................................................ 204
Conditional zero extend.................................................................................. 205
Compare ......................................................................................................... 207
Compare to general register ........................................................................... 209
11.2 CR........................................................................................................................... 210
Corner detection acceleration ......................................................................... 212
Logical reductions on predicates .................................................................... 213
Looping instructions....................................................................................... 214
Add to PC ....................................................................................................... 216
Pipelined loop instructions ............................................................................. 217
Logical operations on predicates .................................................................... 219
User control register transfer .......................................................................... 221
11.3 JR ............................................................................................................................ 222
Hint an indirect jump address......................................................................... 224
Jump to address from register ........................................................................ 225
11.4 J............................................................................................................................... 226
Compare and jump ......................................................................................... 228
Jump to address .............................................................................................. 232
Jump to address conditioned on new predicate .............................................. 234
Jump to address condition on register value .................................................. 235
Transfer and jump .......................................................................................... 237
11.5 LD........................................................................................................................... 238
Load-acquire doubleword............................................................................... 240
Load doubleword conditionally...................................................................... 241
Load byte ........................................................................................................ 243
Load byte conditionally.................................................................................. 245
Load byte into shifted vector.......................................................................... 247
Load half into shifted vector .......................................................................... 250
Load halfword ................................................................................................ 253
Load halfword conditionally .......................................................................... 255

80-N2040-46 Rev. B

7

Hexagon V68 Programmer’s Reference Manual

Contents

Load unsigned byte ........................................................................................ 257
Load unsigned byte conditionally .................................................................. 259
Load unsigned halfword ................................................................................. 261
Load unsigned halfword conditionally........................................................... 263
Load word....................................................................................................... 265
Load-acquire word ......................................................................................... 267
Load word conditionally ................................................................................ 268
Deallocate stack frame ................................................................................... 270
Deallocate frame and return ........................................................................... 272
Load and unpack bytes to halfwords .............................................................. 274
11.6 MEMOP.................................................................................................................. 282
Operation on memory halfword ..................................................................... 284
Operation on memory word ........................................................................... 285
11.7 NV .......................................................................................................................... 286
11.7.1 NV/J .............................................................................................................. 286
11.7.2 NV/ST ........................................................................................................... 290
Store new-value byte conditionally ................................................................ 292
Store new-value halfword .............................................................................. 295
Store new-value halfword conditionally ........................................................ 297
Store new-value word..................................................................................... 300
Store new-value word conditionally............................................................... 302
11.8 ST............................................................................................................................ 305
Store-release doubleword ............................................................................... 308
Store doubleword conditionally ..................................................................... 309
Store byte........................................................................................................ 311
Store byte conditionally.................................................................................. 313
Store halfword ................................................................................................ 316
Store halfword conditionally .......................................................................... 319
Release............................................................................................................ 322
Store word ...................................................................................................... 323
Store-release word .......................................................................................... 325
Store word conditionally ................................................................................ 326
Allocate stack frame ....................................................................................... 329
11.9 SYSTEM ................................................................................................................ 331
11.9.1 SYSTEM/GUEST ......................................................................................... 331
11.9.2 SYSTEM/MONITOR ................................................................................... 333
Swap SGP control register ............................................................................. 334
Cancel pending interrupts............................................................................... 335
Data cache kill ................................................................................................ 336
Data cache maintenance monitor instructions................................................ 337
Read the interrupt mask for a thread .............................................................. 339
Acquire hardware lock ................................................................................... 340
Release hardware lock.................................................................................... 341

80-N2040-46 Rev. B

8

Hexagon V68 Programmer’s Reference Manual

Contents

Interrupt to thread assignment read ................................................................ 342
Interrupt to thread assignment write............................................................... 344
Instruction cache maintenance supervisor operations .................................... 346
Instruction cache maintenance operations (single-thread) ............................. 347
L2 cache operations by index ......................................................................... 348
L2 cache global operations............................................................................. 349
L2 cache operations by address...................................................................... 351
L2 tag read/write ............................................................................................ 353
Load from physical address............................................................................ 355
Raise NMI on threads..................................................................................... 356
Resume from Wait mode................................................................................ 357
Return from exception.................................................................................... 358
Set the interrupt mask for a thread ................................................................. 359
Set the priority for a thread............................................................................. 360
Set interrupt auto disable ................................................................................ 361
Start threads .................................................................................................... 362
Stop threads .................................................................................................... 363
Software interrupt........................................................................................... 364
TLB read/write/probe operations ................................................................... 365
System control register transfer...................................................................... 367
Transition threads to Wait mode .................................................................... 369
11.9.3 SYSTEM/USER............................................................................................ 370
Store conditional............................................................................................. 371
Zero a cache line............................................................................................. 373
Memory barrier............................................................................................... 374
Breakpoint ...................................................................................................... 375
Data cache prefetch ........................................................................................ 376
Data cache maintenance user operations........................................................ 377
Send value to DIAG trace .............................................................................. 379
Instruction cache maintenance user operations .............................................. 380
Instruction synchronization ............................................................................ 381
L2 cache prefetch ........................................................................................... 382
Pause............................................................................................................... 385
Memory thread synchronization..................................................................... 386
Send value to ETM trace ................................................................................ 388
Trap ................................................................................................................ 389
11.10 XTYPE ................................................................................................................. 391
11.10.1 XTYPE/ALU .............................................................................................. 391
Absolute value word....................................................................................... 392
Add and accumulate ....................................................................................... 393
Add doublewords ........................................................................................... 395
Add halfword.................................................................................................. 397
Add or subtract doublewords with carry ........................................................ 399

80-N2040-46 Rev. B

9

Hexagon V68 Programmer’s Reference Manual

Contents

Clip to unsigned.............................................................................................. 400
Logical doublewords ...................................................................................... 401
Logical-logical doublewords .......................................................................... 403
Logical-logical words..................................................................................... 404
Maximum words............................................................................................. 406
Maximum doublewords.................................................................................. 407
Minimum words ............................................................................................. 408
Minimum doublewords .................................................................................. 409
Modulo wrap .................................................................................................. 410
Negate............................................................................................................. 411
Round ............................................................................................................. 412
Subtract doublewords ..................................................................................... 415
Subtract and accumulate words ...................................................................... 416
Subtract halfword ........................................................................................... 417
Sign extend word to doubleword.................................................................... 419
Vector absolute value halfwords .................................................................... 420
Vector absolute value words .......................................................................... 421
Vector absolute difference bytes .................................................................... 422
Vector absolute difference halfwords............................................................. 423
Vector absolute difference words................................................................... 424
Vector add compare and select maximum bytes ............................................ 425
Vector add compare and select maximum halfwords .................................... 426
Vector add halfwords ..................................................................................... 428
Vector add halfwords with saturate and pack to unsigned bytes ................... 430
Vector reduce add unsigned bytes.................................................................. 431
Vector reduce add halfwords.......................................................................... 433
Vector add bytes ............................................................................................. 435
Vector add words............................................................................................ 436
Vector average halfwords............................................................................... 437
Vector average unsigned bytes....................................................................... 439
Vector average words ..................................................................................... 440
Vector clip to unsigned................................................................................... 442
Vector conditional negate............................................................................... 443
Vector maximum bytes .................................................................................. 445
Vector maximum halfwords ........................................................................... 446
Vector reduce maximum halfwords ............................................................... 447
Vector reduce maximum words ..................................................................... 449
Vector maximum words ................................................................................. 451
Vector minimum bytes ................................................................................... 452
Vector minimum halfwords............................................................................ 454
Vector reduce minimum halfwords ................................................................ 455
Vector reduce minimum words ...................................................................... 457
Vector minimum words.................................................................................. 459

80-N2040-46 Rev. B

10

Hexagon V68 Programmer’s Reference Manual

Contents

Vector sum of absolute differences unsigned bytes ....................................... 460
Vector subtract halfwords .............................................................................. 462
Vector subtract bytes ...................................................................................... 464
Vector subtract words..................................................................................... 465
11.10.2 XTYPE/BIT ................................................................................................ 466
Count population ............................................................................................ 469
Count trailing.................................................................................................. 470
Extract bitfield ................................................................................................ 471
Insert bit field ................................................................................................. 474
Interleave/deinterleave ................................................................................... 476
Linear feedback-shift iteration ....................................................................... 477
Masked parity ................................................................................................. 478
Bit reverse....................................................................................................... 479
Set/clear/toggle bit.......................................................................................... 480
Split bitfield .................................................................................................... 482
Table index ..................................................................................................... 484
11.10.3 XTYPE/COMPLEX.................................................................................... 487
Complex add/sub words ................................................................................. 490
Complex multiply........................................................................................... 492
Complex multiply real or imaginary .............................................................. 495
Complex multiply with round and pack ......................................................... 497
Complex multiply 32x16................................................................................ 499
Complex multiply real or imaginary 32-bit.................................................... 501
Vector complex multiply real or imaginary ................................................... 505
Vector complex conjugate.............................................................................. 508
Vector complex rotate .................................................................................... 509
Vector reduce complex multiply by scalar..................................................... 511
Vector reduce complex multiply by scalar with round and pack ................... 514
Vector reduce complex rotate......................................................................... 516
11.10.4 XTYPE/FP .................................................................................................. 519
Classify floating-point value .......................................................................... 520
Compare floating-point value......................................................................... 521
Convert floating-point value to other format ................................................. 523
Convert integer to floating-point value .......................................................... 524
Convert floating-point value to integer .......................................................... 526
Floating point extreme value assistance ......................................................... 528
Floating point fused multiply-add .................................................................. 529
Floating point fused multiply-add with scaling.............................................. 530
Floating point reciprocal square root approximation ..................................... 531
Floating point fused multiply-add for library routines ................................... 532
Create floating-point constant ........................................................................ 534
Floating point maximum ................................................................................ 535
Floating point minimum ................................................................................. 536

80-N2040-46 Rev. B

11

Hexagon V68 Programmer’s Reference Manual

Contents

Floating point multiply ................................................................................... 537
Floating point reciprocal approximation ........................................................ 538
Floating point subtraction............................................................................... 539
11.10.5 XTYPE/MPY .............................................................................................. 539
Multiply and use lower result ......................................................................... 540
Vector multiply word by signed half (32x16) ................................................ 543
Vector multiply word by unsigned half (32x16) ............................................ 547
Multiply signed halfwords.............................................................................. 551
Multiply unsigned halfwords.......................................................................... 558
Polynomial multiply words ............................................................................ 563
Vector reduce multiply word by signed half (32x16) .................................... 565
Multiply and use upper result ......................................................................... 567
Multiply and use full result ............................................................................ 570
Vector dual multiply....................................................................................... 572
Vector dual multiply with round and pack ..................................................... 575
Vector reduce multiply bytes ......................................................................... 577
Vector dual multiply signed by unsigned bytes ............................................. 579
Vector multiply even halfwords ..................................................................... 581
Vector multiply halfwords.............................................................................. 583
Vector multiply halfwords with round and pack............................................ 585
Vector multiply halfwords, signed by unsigned............................................. 587
Vector reduce multiply halfwords .................................................................. 589
Vector multiply bytes ..................................................................................... 591
Vector polynomial multiply halfwords .......................................................... 593
11.10.6 XTYPE/PERM............................................................................................ 595
Saturate ........................................................................................................... 597
Swizzle bytes .................................................................................................. 599
Vector align .................................................................................................... 600
Vector round and pack ................................................................................... 602
Vector saturate and pack ................................................................................ 604
Vector saturate without pack .......................................................................... 607
Vector shuffle ................................................................................................. 609
Vector splat bytes ........................................................................................... 611
Vector splat halfwords.................................................................................... 612
Vector splice................................................................................................... 613
Vector sign extend.......................................................................................... 614
Vector truncate ............................................................................................... 616
Vector zero extend.......................................................................................... 618
11.10.7 XTYPE/PRED ............................................................................................ 620
Compare byte ................................................................................................. 622
Compare half .................................................................................................. 624
Compare doublewords.................................................................................... 626
Compare bit mask........................................................................................... 627

80-N2040-46 Rev. B

12

Hexagon V68 Programmer’s Reference Manual

Contents

Mask generate from predicate ........................................................................ 628
Check for TLB match..................................................................................... 629
Predicate transfer ............................................................................................ 630
Test bit ............................................................................................................ 631
Vector compare halfwords ............................................................................. 632
Vector compare bytes for any match.............................................................. 634
Vector compare bytes ..................................................................................... 635
Vector compare words.................................................................................... 637
Viterbi pack even and odd predicate bits ....................................................... 639
Vector mux ..................................................................................................... 640
11.10.8 XTYPE/SHIFT............................................................................................ 641
Shift by immediate ......................................................................................... 642
Shift by immediate and accumulate ............................................................... 644
Shift by immediate and add............................................................................ 647
Shift by immediate and logical....................................................................... 648
Shift right by immediate with rounding ......................................................... 652
Shift left by immediate with saturation .......................................................... 654
Shift by register .............................................................................................. 655
Shift by register and accumulate .................................................................... 658
Shift by register and logical............................................................................ 661
Shift by register with saturation ..................................................................... 665
Vector shift halfwords by immediate ............................................................. 667
Vector arithmetic shift halfwords with round ................................................ 669
Vector arithmetic shift halfwords with saturate and pack .............................. 671
Vector shift halfwords by register .................................................................. 673
Vector shift words by immediate ................................................................... 675
Vector shift words by register ........................................................................ 677
Vector shift words with truncate and pack ..................................................... 679
Instruction Index ............................................................................................................. 681
Intrinsics Index ............................................................................................................... 696

80-N2040-46 Rev. B

13

Hexagon V68 Programmer’s Reference Manual

Figures

Figures
Figure 1-1
Figure 1-2
Figure 1-3
Figure 1-4
Figure 2-1
Figure 2-2
Figure 3-1
Figure 4-1
Figure 4-2
Figure 4-3
Figure 4-4
Figure 4-5
Figure 5-1
Figure 5-2
Figure 6-1
Figure 6-2
Figure 6-3
Figure 7-1
Figure 10-1

80-N2040-46 Rev. B

Hexagon V67 processor architecture ................................................... 19
Vector instruction example .................................................................. 23
Instruction classes and combinations................................................... 26
Register field symbols.......................................................................... 29
General registers .................................................................................. 32
Control registers................................................................................... 35
Packet grouping combinations ............................................................. 51
Vector byte operation........................................................................... 58
Vector halfword operation ................................................................... 58
Vector word operation ......................................................................... 58
64-bit shift and add/sub/logical............................................................ 67
Vector halfword shift right................................................................... 70
Hexagon processor byte order ............................................................. 80
L2FETCH instruction .......................................................................... 99
Vector byte compare .......................................................................... 110
Vector halfword compare .................................................................. 110
Vector mux instruction ...................................................................... 111
Stack structure.................................................................................... 115
Instruction packet encoding ............................................................... 158

14

Hexagon V68 Programmer’s Reference Manual

Tables

Tables
Table 1-1
Table 1-2
Table 1-3
Table 1-4
Table 2-1
Table 2-2
Table 2-3
Table 2-4
Table 2-5
Table 2-6
Table 2-7
Table 2-8
Table 2-9
Table 2-10
Table 2-11
Table 2-12
Table 2-13
Table 2-14
Table 2-15
Table 2-16
Table 2-17
Table 2-18
Table 3-1
Table 3-2
Table 4-1
Table 4-2
Table 4-3
Table 5-1
Table 5-2
Table 5-3
Table 5-4
Table 5-5
Table 5-6
Table 5-7
Table 5-8
Table 5-9
Table 5-10
Table 5-11
Table 5-12
Table 5-13
Table 5-14

80-N2040-46 Rev. B

Register symbols .................................................................................. 28
Register bit field symbols .................................................................... 29
Instruction operands............................................................................. 30
Data symbols........................................................................................ 31
General register aliases ........................................................................ 34
General register pairs ........................................................................... 34
Aliased control registers ...................................................................... 36
Control register pairs............................................................................ 37
Loop registers....................................................................................... 38
User status register ............................................................................... 39
Modifier registers (indirect auto-increment addressing)...................... 41
Modifier registers (circular addressing)............................................... 41
Modifier registers (bit-reversed addressing) ........................................ 42
Predicate registers ................................................................................ 42
Circular start registers .......................................................................... 43
User general pointer register ................................................................ 43
Global pointer register ......................................................................... 43
Cycle count registers............................................................................ 44
Frame limit register.............................................................................. 44
Frame key register................................................................................ 45
Packet count registers .......................................................................... 45
Qtimer registers.................................................................................... 46
Instruction symbols .............................................................................. 47
Instruction classes ................................................................................ 48
Single-precision multiply options ........................................................ 65
Double precision multiply options....................................................... 65
Control register transfer instructions ................................................... 71
Memory alignment restrictions ............................................................ 81
Load instructions.................................................................................. 81
Store instructions.................................................................................. 82
Mem-ops .............................................................................................. 84
Addressing modes ................................................................................ 84
Offset ranges (global pointer relative) ................................................. 86
Offset ranges (indirect with offset) ...................................................... 87
Increment ranges (indirect with auto-inc immediate) .......................... 88
Increment ranges (circular with auto-inc immediate) .......................... 89
Increment ranges (circular with auto-inc register)............................... 91
Addressing modes (conditional load/store) ......................................... 93
Conditional offset ranges (indirect with offset) ................................... 94
Cache instructions (user-level)............................................................. 96
Memory ordering instructions............................................................ 100

15

Hexagon V68 Programmer’s Reference Manual

Table 5-15
Table 6-1
Table 6-2
Table 6-3
Table 7-1
Table 7-2
Table 8-1
Table 8-2
Table 8-3
Table 8-4
Table 8-5
Table 8-6
Table 8-7
Table 8-8
Table 8-9
Table 8-10
Table 8-11
Table 8-12
Table 8-13
Table 8-14
Table 8-15
Table 9-1
Table 10-1
Table 10-2
Table 10-3
Table 10-4
Table 10-5
Table 10-6
Table 10-7
Table 10-8
Table 10-9
Table 10-10
Table 10-11
Table 11-1
Table 11-2

80-N2040-46 Rev. B

Tables

Atomic instructions ............................................................................ 101
Scalar predicate-generating instructions ............................................ 104
Vector mux instruction ....................................................................... 111
Predicate register instructions ............................................................ 113
Stack registers .................................................................................... 117
Stack instructions ............................................................................... 118
Loop instructions ............................................................................... 121
Software pipelined loop ..................................................................... 125
Software pipelined loop (using spNloop0) ........................................ 126
Software branch instructions.............................................................. 127
Jump instructions ............................................................................... 128
Call instructions ................................................................................. 128
Return instructions ............................................................................. 129
Speculative jump instructions ............................................................ 131
Compare jump instructions ................................................................ 133
New-value compare jump instructions .............................................. 134
Register transfer jump instructions .................................................... 135
Dual jump instructions ....................................................................... 135
Jump hint instruction.......................................................................... 136
Pause instruction ................................................................................ 137
V67 exceptions................................................................................... 138
V67 processor events symbols........................................................... 141
Instruction fields ................................................................................ 151
Sub-instructions ................................................................................. 153
Sub-instruction registers .................................................................... 154
Duplex instruction.............................................................................. 155
Duplex ICLASS field......................................................................... 155
Instruction class encoding.................................................................. 157
Loop packet encoding ........................................................................ 159
Scaled immediate encoding (indirect offsets) .................................... 160
Constant extender encoding ............................................................... 161
Constant extender instructions ........................................................... 162
Instruction mapping ........................................................................... 165
Instruction operand symbols .............................................................. 166
Instruction behavior symbols ............................................................. 167

16

1 Introduction
The Qualcomm Hexagon™ processor is a general-purpose digital signal processor
designed for high performance and low power across a wide variety of multimedia and
modem applications. V68 is a member of the sixth generation of the Hexagon processor
architecture.

1.1

Features
■

Memory
Program code and data are stored in a unified 32-bit address space. The load/store
architecture supports a complete set of addressing modes for both compiler code
generation and DSP application programming.

■

Registers
Thirty two 32-bit general purpose registers can be accessed as single registers or
as 64-bit register pairs. The general registers hold all data including scalar,
pointer, and packed vector data.

■

Data types
Instructions can perform a wide variety of operations on fixed-point or floatingpoint data. The fixed-point operations support scalar and vector data in a variety
of sizes. The floating-point operations support single-precision data.

■

Parallel execution
Instructions can be grouped into very long instruction word (VLIW) packets for
parallel execution, with each packet containing from one to four instructions.
Vector instructions operate on single instruction multiple data (SIMD) vectors.

■

Program flow
Nestable zero-overhead hardware loops are supported. Conditional/unconditional
jumps and subroutine calls support both PC-relative and register indirect
addressing. Two program flow instructions can be grouped into one packet.

■

Instruction pipeline
Pipeline hazards are resolved by the hardware: instruction scheduling is not
constrained by pipeline restrictions.

■

80-N2040-46 Rev. B

Code compression

17

Hexagon V68 Programmer’s Reference Manual

Introduction

Compound instructions merge certain common operation sequences (addaccumulate, shift-add, etc.) into a single instruction. Duplex encodings express
two parallel instructions in a single 32-bit word.
■

Cache memory
Memory accesses can be cached or uncached. Separate L1 instruction and data
caches exist for program code and data. A unified L2 cache can be partly or
wholly configured as tightly-coupled memory (TCM).

■

Virtual memory
Memory is addressed virtually, with virtual-to-physical memory mapping handled
by a resident OS. Virtual memory supports the implementation of memory
management and memory protection in a hardware-independent manner.

80-N2040-46 Rev. B

18

Hexagon V68 Programmer’s Reference Manual

1.2

Introduction

Functional units
Figure 1-1 shows the major functional units of the Hexagon V68 processor architecture:
■

Memory and registers

■

Instruction sequencer

■

Execution units

■

Load/store units

Memory
(unified address space)

128

4x32 bit
Instructions

Sequencer

Load/
Store

S3: X Unit

64

64

Load/
Store

XTYPE Instructions
ALU32 Instructions
J Instructions
CR Instructions

Packets of
1-4 instructions

S2: X Unit
XTYPE Instructions
ALU32 Instructions
J Instructions
JR Instructions

Control Registers
Hardware Loop Regs
Modifier Registers
Status Register
Program Counter
Predicate Registers
User General Pointer
Global Pointer
Circular Start Registers

S1: Load/Store
Unit
LD Instructions
ST Instructions
ALU32 Instructions

General
Registers
R0-R31

S0: Load/Store
Unit
LD Instructions
ST Instructions
ALU32 Instructions
MEMOP Instructions
NV Instructions
SYSTEM Instructions

Figure 1-1

80-N2040-46 Rev. B

Hexagon V68 processor architecture

19

Hexagon V68 Programmer’s Reference Manual

1.2.1

Introduction

Memory
The Hexagon processor features a unified byte-addressable memory. This memory has a
single 32-bit virtual address space which holds both instructions and data. It operates in
little-endian mode.

1.2.2

Registers
The Hexagon processor has two sets of registers: general registers and control registers.
The general registers include thirty-two 32-bit registers (named R0 through R31) which
can be accessed either as single registers or as aligned 64-bit register pairs. The general
registers contain all pointer, scalar, vector, and accumulator data.
The control registers include special-purpose registers such as program counter, status
register, loop registers, etc.

1.2.3

Sequencer
The instruction sequencer processes packets of one to four instructions in each cycle. If a
packet contains more than one instruction, the instructions are executed in parallel.
The instruction combinations allowed in a packet are limited to the instruction types that
can be executed in parallel in the four execution units (as shown in Figure 1-1).

1.2.4

Execution units
The dual execution units are identical: each includes a 64-bit shifter and a vector
multiply/accumulate unit with four 16x16 multipliers to support both scalar and vector
instructions.
These units also perform 32- and 64-bit ALU instructions, and jump and loop instructions.
NOTE

1.2.5

Each execution unit supports floating-point instructions.

Load/store units
The two load/store units can operate on signed or unsigned bytes, halfwords (16-bit),
words (32-bit), or double words (64-bit).
To increase the number of instruction combinations allowed in packets, the load units also
support 32-bit ALU instructions.

80-N2040-46 Rev. B

20

Hexagon V68 Programmer’s Reference Manual

1.3

Introduction

Instruction set
For the Hexagon processor to achieve large amounts of work per cycle, the instruction set
was designed with the following properties:
■

Static grouping (VLIW) architecture

■

Static fusing of simple dependent instructions

■

Extensive compound instructions

■

A large set of SIMD and application-specific instructions

To support efficient compilation, the instruction set is designed to be orthogonal with
respect to registers, addressing modes, and load/store access size.

1.3.1

Addressing modes
The Hexagon processor supports the following memory addressing modes:
■ 32-bit absolute
■

32-bit absolute-set

■

Absolute with register offset

■

Global pointer relative

■

Indirect

■

Indirect with offset

■

Indirect with register offset

■

Indirect with auto-increment (immediate or register)

■

Circular with auto-increment (immediate or register)

■

Bit-reversed with auto-increment register

For example:
R2 = memw(##myvariable)
R2 = memw(R3=##myvariable)
R2 = memw(R4<<#3+##myvariable)
R2 = memw(GP+#200)
R2 = memw(R1)
R2 = memw(R3+#100)
R2 = memw(R3+R4<<#2)
R2 = memw(R3++#4)
R2 = memw(R0++M1)
R0 = memw(R2++#8:circ(M0))
R0 = memw(R2++I:circ(M0))
R2 = memw(R0++M1:brev)

Auto-increment with register addressing uses one of the two dedicated address-modify
registers M0 and M1 (which are part of the control registers).

80-N2040-46 Rev. B

21

Hexagon V68 Programmer’s Reference Manual

NOTE

1.3.2

Introduction

Atomic memory operations (load locked/store conditional) are supported to
implement multi-thread synchronization.

Scalar operations
The Hexagon processor includes the following scalar operations on fixed-point data:
■ Multiplication of 16-bit, 32-bit, and complex data

1.3.3

■

Addition and subtraction of 16-, 32-, and 64-bit data (with and without saturation)

■

Logical operations on 32- and 64-bit data (AND, OR, XOR, NOT)

■

Shifts on 32- and 64-bit data (arithmetic and logical)

■

Min/max, negation, absolute value, parity, norm, swizzle

■

Compares of 8-, 16-, 32-, and 64-bit data

■

Sign and zero extension (8- and 16- to 32-bit, 32- to 64-bit)

■

Bit manipulation

■

Predicate operations

Vector operations
The Hexagon processor includes the following vector operations on fixed-point data:
■ Multiplication (halfwords, word by half, vector reduce, dual multiply)
■

Addition and subtraction of word and halfword data

■

Shifts on word and halfword data (arithmetic and logical)

■

Min/max, average, negative average, absolute difference, absolute value

■

Compares of word, halfword, and byte data

■

Reduce, sum of absolute differences on unsigned bytes

■

Special-purpose data arrangement (such as pack, splat, shuffle, align, saturate,
splice, truncate, complex conjugate, complex rotate, zero extend)

NOTE

Certain vector operations support automatic scaling, saturation, and rounding.

For example, the following instruction performs a vector operation:
R1:0 += vrmpyh(R3:2,R5:4)

It is defined to perform the following operations in one cycle:
R1:0 += ((R2.L * R4.L) +
(R2.H * R4.H) +
(R3.L * R5.L) +
(R3.H * R5.H)
)

80-N2040-46 Rev. B

22

Hexagon V68 Programmer’s Reference Manual

Introduction

Figure 1-2 shows a schematic of this instruction type.
Rss
Rtt

*

*

*
32

32

32

*
32

Add
64

64-bit Register Pair

Rdd

Figure 1-2 Vector instruction example

1.3.4

Floating-point operations
The Hexagon processor includes the following operations on floating-point data:
■ Addition and subtraction

80-N2040-46 Rev. B

■

Multiplication (with optional scaling)

■

Min/max/compare

■

Reciprocal/square root approximation

■

Format conversion

23

Hexagon V68 Programmer’s Reference Manual

1.3.5

Introduction

Program flow
The Hexagon processor supports zero-overhead hardware loops. For example:
loop0(start,#3)
// loop 3 times
start:
{ R0 = mpyi(R0,R0) } :endloop0

The loop instructions support nestable loops, with few restrictions on their use.
Software branches use a predicated branch mechanism. Explicit compare instructions
generate a predicate bit, which is then tested by conditional branch instructions. For
example:
P1 = cmp.eq(R2, R3)
if (P1) jump end

Jumps and subroutine calls can be conditional or unconditional, and support both PCrelative and register indirect addressing modes. For example:
jump end
jumpr R1
call function
callr R2

The subroutine call instructions store the return address in register R31. Subroutine
returns are performed using a jump indirect instruction through this register. For example:
jumpr R31

1.3.6

// subroutine return

Instruction packets
Sequences of instructions can be explicitly grouped into packets for parallel execution.
For example:
{
R8 = memh(R3++#2)
R12 = memw(R1++#4)
R = mpy(R10,R6):<<1:sat
R7 = add(R9,#2)
}

Brace characters delimit the start and end of an instruction packet.
Packets can be from one to four instructions long. Packets of varying length can be freely
mixed in a program.
Packets have various restrictions on the allowable instruction combinations. The primary
restriction is determined by the instruction class of the instructions in a packet.

80-N2040-46 Rev. B

24

Hexagon V68 Programmer’s Reference Manual

1.3.7

Introduction

Dot-new instructions
In many cases, a predicate or general register can be both generated and used in the same
instruction packet. This feature is expressed in assembly language by appending the suffix
“.new” to the specified register. For example:
{
P0 = cmp.eq(R2,#4)
if (P0.new) R3 = memw(R4)
if (!P0.new) R5 = #5
}
{
R2 = memh(R4+#8)
memw(R5) = R2.new
}

1.3.8

Compound instructions
Certain common operation pairs (add-accumulate, shift-add, deallocframe-return, etc.) can
be performed by compound instructions. Using compound instructions reduces code size
and improves code performance.

1.3.9

Duplex instructions
A subset of the most common instructions (load, store, branch, ALU) can be packed
together in pairs into single 32-bit instructions known as duplex instructions. Duplex
instructions reduce code size.

1.3.10

Instruction classes
The instructions are assigned to specific instruction classes. Classes are important for two
reasons:
■ Only certain combinations of instructions can be written in parallel (as shown in
Figure 1-1), and the allowable combinations are specified by instruction class.
■

80-N2040-46 Rev. B

Instruction classes logically correspond with instruction types, so they serve as
mnemonics for looking up specific instructions.

25

Hexagon V68 Programmer’s Reference Manual

Introduction

Figure 1-3 presents an overview of the instruction classes and how they can be grouped
together.

Slot 1

Slot 0
LD Instructions
ST Instructions
ALU32 Instructions
MEMOP Instructions
NV Instructions
SYSTEM Instructions
Some J Instructions

LD Instructions
ST Instructions
ALU32 Instructions
Some J Instructions

Slot 2
XTYPE Instructions
ALU32 Instructions
J Instructions
JR Instructions

Slot 3
XTYPE Instructions
ALU32 Instructions
J Instructions
CR Instructions

XTYPE Instructions (32/64 bit)

J Instructions

Arithmetic, Logical, Bit Manipulation
Multiply (Integer, Fractional, Complex)
Floating-point Operations
Permute / Vector Permute Operations
Predicate Operations
Shift / Shift with Add/Sub/Logical
Vector Byte ALU
Vector Halfword (ALU, Shift, Multiply)
Vector Word (ALU, Shift)

Jump/Call PC-relative

ALU32 Instructions

ST Instructions

Arithmetic / Logical (32 bit)
Vector Halfword

Stores (8/16/32/64 bit)
Allocframe

CR Instructions

MEMOP Instructions

Control-Register Transfers
Hardware Loop Setup
Predicate Logicals & Reductions

Operation on memory (8/16/32 bit)

NV Instructions
New-value Jumps
New-value Stores

JR Instructions
Jump/Call Register

LD Instructions
Loads (8/16/32/64 bit)
Deallocframe

SYSTEM Instructions
Prefetch
Cache Maintenance
Bus Operations

Figure 1-3 Instruction classes and combinations

1.3.11

Instruction intrinsics
To support efficient coding of the time-critical sections of a program (without resorting to
assembly language), the C compilers support intrinsics which directly express Hexagon
processor instructions from within C code. For example:
int main()
{
long long v1 = 0xFFFF0000FFFF0000;
long long v2 = 0x0000FFFF0000FFFF;
long long result;
// find the minimum for each half-word in 64-bit vector
result = Q6_P_vminh_PP(v1,v2);
}

Intrinsics are defined for most of the Hexagon processor instructions.

80-N2040-46 Rev. B

26

Hexagon V68 Programmer’s Reference Manual

1.4

Introduction

Notation
This section presents the notational conventions used in this document to describe
Hexagon processor instructions:
■ Instruction syntax
■

Register operands

■

Numeric operands

NOTE

1.4.1

The notation described here does not appear in actual assembly language
instructions. It is used only to specify the instruction syntax and behavior.

Instruction syntax
The following notation describes the syntax of instructions:

80-N2040-46 Rev. B

■

Monospaced font is used for instructions

■

Square brackets enclose optional items (e.g., [:sat], means that saturation is
optional)

■

Braces indicate a choice of items (e.g., {Rs,#s16}, means that either Rs or a
signed 16-bit immediate can be used)

27

Hexagon V68 Programmer’s Reference Manual

1.4.2

Introduction

Register operands
The following notation describes register operands in the syntax and behavior of
instructions:
Rds[.elst]

The ds field indicates the register operand type and bit size (as defined in Table 1-1).
Table 1-1
Symbol
d

Register symbols
Operand Type
Destination

32

dd
s

64
First source

32

ss
t

64
Second source

32

tt
u

64
Third source

32

uu
x

Size (in Bits)

64
Source and destination

xx

32
64

Examples of ds field (describing instruction syntax):
Rd = neg(Rs)
Rd = xor(Rs,Rt)
Rx = insert(Rs,Rtt)

// Rd -> 32-bit dest, Rs 32-bit source
// Rt -> 32-bit second source
// Rx -> both source and dest

Examples of ds field (describing instruction behavior):
Rdd = Rss + Rtt

80-N2040-46 Rev. B

// Rdd, Rss, Rtt -> 64-bit registers

28

Hexagon V68 Programmer’s Reference Manual

Introduction

The optional elst field (short for “element size and type”) specifies parts of a register when
the register is used as a vector. It can specify the following values:
■ A signed or unsigned byte, halfword, or word within the register (as defined in
Figure 1-4)
■

A bit-field within the register (as defined in Table 1-2)

Rds.elst
s, t, u = 32-bit source register
d
= 32-bit register destination
x
= 32-bit register source/destination
ss, tt, uu = 64-bit source register pair
dd
= 64-bit register destination
xx
= 64-bit register source/destination

Rds.elst
.b[7]

.b[6]

.b[5]

.b[4]

.b[3]

.b[2]

.b[1]

.b[0]

Signed Bytes

.ub[7]

.ub[6]

.ub[5]

.ub[4]

.ub[3]

.ub[2]

.ub[1]

.ub[0] Unsigned Bytes

.h[3]

.h[2]

.h[1]

.h[0]

Signed Halfwords

.uh[3]

.uh[2]

.uh[1]

.uh[0]

Unsigned Halfwords

.w[1]

.w[0]

Signed Words

.uw[1]

.uw[0]

Unsigned Words

Figure 1-4 Register field symbols
Table 1-2

Register bit field symbols

Symbol
.sN

Meaning
Bits [N-1:0] are treated as a N-bit signed number.
For example, R0.s16 means that the least significant 16-bits of R0
are treated as a 16-bit signed number.

.uN

Bits [N-1:0] are treated as a N-bit unsigned number.

.H

The most-significant 16 bits of a 32-bit register.

.L

The least-significant 16 bits of a 32-bit register.

Examples of elst field:
EA = Rt.h[1]
Pd = (Rss.u64 > Rtt.u64)
Rd = mpyu(Rs.L,Rt.H)
NOTE

80-N2040-46 Rev. B

// .h[1] -> bit field 31:16 in Rt
// .u64 -> unsigned 64-bit value
// .L/.H -> low/high 16-bit fields

The control and predicate registers use the same notation as the general
registers, but are written as Cx and Px (respectively) instead of Rx.

29

Hexagon V68 Programmer’s Reference Manual

1.4.3

Introduction

Numeric operands
Table 1-3 lists the notation that describes numeric operands in the syntax and behavior of
instructions:
Table 1-3

Instruction operands

Symbol

Meaning

Min

Max

#uN

Unsigned N-bit immediate value

0

2N-1

#sN

Signed N-bit immediate value

-2N-1

2N-1-1

#mN

Signed N-bit immediate value

-(2N-1-1)

2N-1-1

#uN:S

Unsigned N-bit immediate value representing
integral multiples of 2S in specified range

0

(2N-1)  2S

#sN:S

Signed N-bit immediate value representing
integral multiples of 2S in specified range

(-2N-1)  2S

(2N-1-1)  2S

#rN:S

Same as #sN:S, but value is offset from PC
of current packet

(-2N-1)  2S

(2N-1-1)  2S

##

Same as #, but associated value (u,s,m,r)
is 32 bits

–

–

usatN

Saturate value to unsigned N-bit number

0

2N-1

satN

Saturate value to signed N-bit number

-2N-1

2N-1-1

#uN, #sN, and #mN specify immediate operands in instructions. The # symbol appears in

the actual instruction to indicate the immediate operand.
#rN specifies loop and branch destinations in instructions. In this case the # symbol does
not appear in the actual instruction; instead, the entire #rN symbol (including its :S suffix)

is expressed as a loop or branch symbol whose numeric value is determined by the
assembler and linker. For example:
call my_proc

// instruction example

The :S suffix indicates that the S least-significant bits in a value are implied zero bits and
therefore not encoded in the instruction. The implied zero bits are called scale bits.
For example, #s4:2 denotes a signed immediate operand represented by four bits encoded
in the instruction, and two scale bits. The possible values for this operand are -32, -28, -24,
-20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, and 28.
## specifies a 32-bit immediate operand in an instruction (including a loop or branch
destination). The ## symbol appears in the actual instruction to indicate the operand.

Examples of operand symbols:
Rd = add(Rs,#s16)
Rd = memw(Rs++#s4:2)
call #r22:2
Rd = ##u32

80-N2040-46 Rev. B

// #s16
-> signed 16-bit imm value
// #s4:2 -> scaled signed 4-bit imm value
// #r22:2 -> scaled 22-bit PC-rel addr value
// ##u32 -> unsigned 32-bit imm value

30

Hexagon V68 Programmer’s Reference Manual

NOTE

1.5

Introduction

When an instruction contains more than one immediate operand, the operand
symbols are specified in upper and lower case (e.g., #uN and #UN) to indicate
where they appear in the instruction encodings

Terminology
Table 1-4 lists the symbols used in Hexagon processor instruction names to specify the
supported data types.
Table 1-4

Data symbols

Size

1.6

Symbol

Type

8-bit

B

Byte

8-bit

UB

Unsigned Byte

16-bit

H

Half word

16-bit

UH

Unsigned Half word

32-bit

W

Word

32-bit

UW

Unsigned Word

64-bit

D

Double word

Technical assistance
For assistance or clarification on information in this document, submit a case to
Qualcomm Technologies, Inc. (QTI) at https://createpoint.qti.qualcomm.com/.
If you do not have access to the CDMATech Support website, register for access or send
email to support.cdmatech@qti.qualcomm.com.

80-N2040-46 Rev. B

31

2 Registers
General registers are used for all general-purpose computation including address
generation and scalar and vector arithmetic.
Control registers support special-purpose processor features such as hardware loops and
predicates.

2.1

General registers
The Hexagon processor has thirty-two 32-bit general-purpose registers (named R0 through
R31). These registers store operands in virtually all the instructions:


Memory addresses for load/store instructions



Data operands for arithmetic/logic instructions



Vector operands for vector instructions

For example:
R1 = memh(R0)
R4 = add(R2,R3)
R28 = vaddh(R11,R10)

// Load from address R0
// Add
// Vector add halfword

Figure 2-1 shows the general registers.
R3

R2

..
.

R3:2

R31

R1

R30

R31:30

R0

R1:0

R29

R28

R29:28

Figure 2-1 General registers

80-N2040-46 Rev. B

32

Hexagon V68 Programmer’s Reference Manual

Registers

Aliased registers

Three of the general registers – R29 through R31 – support subroutines (Section 8.3.2)
and the software stack (Chapter 7). These registers are modified implicitly by the
subroutine and stack instructions. They have symbol aliases which indicate when these
registers are being accessed as subroutine and stack registers.
For example:
SP = add(SP, #-8)
allocframe
call init

// SP is alias of R29
// Modifies SP (R29) and FP (R30)
// Modifies LR (R31)

Table 2-1 defines the aliased general registers.
Table 2-1

General register aliases

Register

Alias

Name

R29

SP

Stack pointer

Points to topmost element of stack in memory.

Description

R30

FP

Frame pointer

Points to current procedure frame on stack.
Used by external debuggers to examine the stack
and determine call sequence, parameters, local
variables, etc.

R31

LR

Link register

Stores return address of a subroutine call.

Register pairs

The general registers can be specified as register pairs which represent a single 64-bit
register. For example:
R1:0 = memd(R3)
R7:6 = valignb(R9:8,R7:6, #2)
NOTE

// Load doubleword
// Vector align

The first register in a register pair must always be odd-numbered, and the
second must be the next lower register.

Table 2-2 lists the general register pairs.
Table 2-2

General register pairs

Register
R0

Register Pair
R1:0

R1
R2

R3:2

R3
R4

R5:4

R5
R6

R7:6

R7
…

80-N2040-46 Rev. B

33

Hexagon V68 Programmer’s Reference Manual

Table 2-2

Registers

General register pairs

Register
R24

Register Pair
R25:24

R25
R26

R27:26

R27
R28

R29:28

R29 (SP)
R30 (FP)

R31:30 (LR:FP)

R31 (LR)

2.2

Control registers
The Hexagon processor includes a set of 32-bit control registers which provide access to
processor features such as the program counter, hardware loops, and vector predicates.
Unlike general registers, control registers can be used as instruction operands only in the
following cases:


Instructions that require a specific control register as an operand



Register transfer instructions

For example:
R2 = memw(R0++M1)
R9 = PC
LC1 = R3
NOTE

80-N2040-46 Rev. B

// Auto-increment addressing mode (M1)
// Get program counter (PC)
// Set hardware loop count (LC1)

When a control register is used in a register transfer, the other operand must
be a general register.

34

Hexagon V68 Programmer’s Reference Manual

Registers

Figure 2-2 shows the control registers.

UPCYCLELO

LC0

SA0

LC1

SA1

UPCYCLEHI

PC

Program Counter

FRAMELIMIT

Stack Bounds Register

USR

User Status Register

FRAMEKEY

Stack Smash Register

Loop Registers

M0

Cycle Count Registers

PKTCOUNTLO
Modifier Registers

M1

Packet Count Registers
PKTCOUNTHI

P3:0

Predicate Registers

UGP

User General Pointer

GP

Global Pointer

UTIMERLO
Qtimer Registers
UTIMERHI

CS0

= V61 or greater
Circular Start Registers

CS1

Figure 2-2 Control registers

Aliased registers

The control registers have numeric aliases (C0 through C31).
Table 2-3 lists the aliased control registers.
Table 2-3

80-N2040-46 Rev. B

Aliased control registers

Register

Alias

Name

SA0

C0

Loop start address register 0

LC0

C1

Loop count register 0

SA1

C2

Loop start address register 1

LC1

C3

Loop count register 1

P3:0

C4

Predicate registers 3:0

reserved

C5

–

M0

C6

Modifier register 0

M1

C7

Modifier register 1

USR

C8

User status register

PC

C9

Program counter

35

Hexagon V68 Programmer’s Reference Manual

Table 2-3

Registers

Aliased control registers

Register

Alias

Name

UGP

C10

User general pointer

GP

C11

Global pointer

CS0

C12

Circular start register 0

CS1

C13

Circular start register 1

UPCYCLELO

C14

Cycle count register (low)

UPCYCLEHI

C15

Cycle count register (high)

UPCYCLE

C15:14

Cycle count register

FRAMELIMIT

C16

Frame limit register

FRAMEKEY

C17

Frame key register

PKTCOUNTLO

C18

Packet count register (low)

PKTCOUNTHI

C19

Packet count register (high)

PKTCOUNT

C19:18

Packet count register

reserved

C20-29

–

UTIMERLO

C30

Qtimer register (low)

UTIMERHI

C31

Qtimer register (high)

UTIMER

C31:30

Qtimer register

NOTE

The control register numbers (0-31) specify the control registers in instruction
encodings (Chapter 10).

Register pairs

The control registers can be specified as register pairs which represent a single 64-bit
register. Control registers specified as pairs must use their numeric aliases. For example:
C1:0 = R5:4
NOTE

80-N2040-46 Rev. B

// C1:0 specifies the LC0/SA0 register pair

The first register in a control register pair must always be odd-numbered, and
the second must be the next lower register.

36

Hexagon V68 Programmer’s Reference Manual

Registers

Table 2-4 lists the control register pairs.
Table 2-4

Control register pairs

Register
C0

Register Pair
C1:0

C1
C2

C3:2

C3
C4

C5:4

C5
C6

C7:6

C7
…
C30

C31:30

C31

2.2.1

Program counter
The Program Counter (PC) register points to the next instruction packet to execute
(Section 3.3). It is modified implicitly by instruction execution, but can be read directly.
For example:
R7 = PC
NOTE

2.2.2

// Get program counter

The PC register is read-only: writing to it has no effect.

Loop registers
The Hexagon processor includes two sets of loop registers to support nested hardware
loops (Section 8.2). Each hardware loop is implemented with a pair of registers containing
the loop count and loop start address. The loop registers are modified implicitly by the
loop instruction, but can also be accessed directly. For example:
loop0(start, R4)
LC1 = R22
R9 = SA1

// Modifies LC0 and SA0 (LC0=R4, SA0=&start)
// Set loop1 count
// Get loop1 start address

Table 2-5 defines the loop registers.
Table 2-5

Loop registers

Register

80-N2040-46 Rev. B

Name

Description

LC0, LC1

Loop count

Number of loop iterations to execute.

SA0, SA1

Loop start address

Address of first instruction in loop.

37

Hexagon V68 Programmer’s Reference Manual

2.2.3

Registers

User status register
The user status register (USR) stores processor status and control bits that are accessible
by user programs. The status bits contain the status results of certain instructions, while
the control bits contain user-settable processor modes for hardware prefetching. For
example:
R9:8 = vaddw(R9:8, R3:2):sat
R6 = USR

// Vector add words
// Get saturation status

USR stores the following status and control values:


Cache prefetch enable (Section 5.10.6)



Cache prefetch status (Section 5.10.6)



Floating point modes (Section 4.3.4)



Floating point status (Section 4.3.4)



Hardware loop configuration (Section 8.2)



Sticky saturation overflow (Section 4.2.2)
NOTE

A user control register transfer to USR cannot be grouped in an instruction
packet with a floating point instruction (Section 4.3.4).
Whenever a transfer to USR changes the Enable trap bits [29:25], an isync
instruction (Section 5.11) must be executed before the new exception
programming can take effect.

Table 2-6 defines the user status register.
Table 2-6
Name
USR

80-N2040-46 Rev. B

User status register
R/W

Bits
32

Field

Description
User Status Register

38

Hexagon V68 Programmer’s Reference Manual

Table 2-6
Name

Registers

User status register (Continued)
R/W

Bits

R

31

PFA

Field

L2 prefetch active.
1: l2fetch instruction in progress
0: l2fetch finished (or inactive)
Set when non-blocking l2fetch instruction is prefetching
requested data.
Remains set until l2fetch prefetch operation completes
(or inactive).

Description

R

30

reserved

Return 0 if read.
Reserved for future expansion. To remain compatible
with future processor versions, software should always
write this field with the same value read from the field.

R/W

29

FPINEE

Enable trap on IEEE inexact.

R/W

28

FPUNFE

Enable trap on IEEE underflow.

R/W

27

FPOVFE

Enable trap on IEEE overflow.

R/W

26

FPDBZE

Enable trap on IEEE divide-By-Zero.

R/W

25

FPINVE

Enable trap on IEEE invalid.

R

24

reserved

Reserved

R/W

23:22 FPRND

Rounding Mode for floating-point instructions.
00: Round to nearest, ties to even (default)
01: Toward zero
10: Downward (toward negative infinity)
11: Upward (toward positive infinity)

80-N2040-46 Rev. B

R

21:20 reserved

Return 0 if read.
Reserved for future expansion. To remain compatible
with future processor versions, software should always
write this field with the same value read from the field.

R

19:18 reserved

Reserved

R

17

Return 0 if read.
Reserved for future expansion. To remain compatible
with future processor versions, software should always
write this field with the same value read from the field.

R/W

16:15 HFI

reserved

L1 instruction prefetch.
00: Disable
01: Enable (1 line)
10: Enable (2 lines)

39

Hexagon V68 Programmer’s Reference Manual

Table 2-6
Name

Registers

User status register (Continued)
R/W

Bits

R/W

14:13 HFD

Field

Description
L1 Data Cache Prefetch.
Four levels are defined from disabled to Aggressive. It is
implementation-defined how these levels should be
interpreted.
00: Disable
01: Conservative
10: Moderate
11: Aggressive

R/W

12

PCMME

Enable packet counting in Monitor mode.

R/W

11

PCGME

Enable packet counting in Guest mode.

R/W

10

PCUME

Enable packet counting in User mode.

R/W

9:8

LPCFGE

Hardware Loop Configuration.
Number of loop iterations (0-3) remaining before pipeline
predicate should be set.

R

7:6

reserved

Return 0 if read.
Reserved for future expansion. To remain compatible
with future processor versions, software should always
write this field with the same value read from the field.

80-N2040-46 Rev. B

R/W

5

FPINPF

Floating-point IEEE Inexact Sticky Flag.

R/W

4

FPUNFF

Floating-point IEEE Underflow Sticky Flag.

R/W

3

FPOVFF

Floating-point IEEE Overflow Sticky Flag.

R/W

2

FPDBZF

Floating-point IEEE Divide-By-Zero Sticky Flag.

R/W

1

FPINVF

Floating-point IEEE Invalid Sticky Flag.

R/W

0

OVF

Sticky Saturation Overflow.
1: Saturation occurred
0: No saturation
Set when saturation occurs while executing instruction
that specifies optional saturation.
Remains set until explicitly cleared by a USR = Rs
instruction.

40

Hexagon V68 Programmer’s Reference Manual

2.2.4

Registers

Modifier registers
The modifier registers (M0-M1) are used in the following addressing modes:


Indirect auto-increment register addressing



Circular addressing



Bit-reversed addressing

Indirect auto-increment

In indirect auto-increment register addressing (Section 5.8.9) the modifier registers store a
signed 32-bit value which specifies the increment (or decrement) value. For example:
M1 = R0
R3 = memw(R2++M1)

// Set modifier register
// Load word

Table 2-7 defines the modifier registers as used in auto-increment register addressing.
Table 2-7

Modifier registers (indirect auto-increment addressing)

Register

Name

M0, M1

Increment

Description
Signed auto-increment value.

Circular

In circular addressing (Section 5.8.10) the modifier registers store the circular buffer
length and related “I” values. For example:
M0 = R7
R0 = memb(R2++#4:circ(M0))

// Set modifier register
// Load from circ buffer pointed
// to by R2 with buffer-size vals in M0

R0 = memb(R7++I:circ(M1))

// Load from circ buffer pointed
// to by R7 with buffer-size and I vals
// in M1

Table 2-8 defines the modifier registers as used in circular addressing.
Table 2-8
Name

Modifier registers (circular addressing)
R/W

M0, M1

80-N2040-46 Rev. B

Bits

Field

Description

32

Circular buffer specifier.

R/W

31:28 I[10:7]

I value (MSB - see Section 5.8.11)

R/W

27:24

0x0

R/W

23:17 I[6:0]

I value (LSB)

R/W

16:0

Circular buffer length

Length

41

Hexagon V68 Programmer’s Reference Manual

Registers

Bit-reversed

In bit-reversed addressing (Section 5.8.12) the modifier registers store a signed 32-bit
value which specifies the increment (or decrement) value. For example:
M1 = R7
// Set modifier register
R2 = memub(R0++M1:brev) // The address is (R0.H | bitrev(R0.L))
// The orginal R0 (not reversed) is added
// to M1 and written back to R0

Table 2-9 defines the modifier registers as used in bit-reversed addressing.
Table 2-9

Modifier registers (bit-reversed addressing)

Register

M0, M1

2.2.5

Name
Increment

Description
Signed auto-increment value.

Predicate registers
The predicate registers (P0-P3) store the status results of the scalar and vector compare
instructions (Chapter 6). For example:
P1 = cmp.eq(R2, R3)
if (P1) jump end
R8 = P1
P3:0 = R4

// Scalar compare
// Jump to address (conditional)
// Get compare status (P1 only)
// Set compare status (P0-P3)

The four predicate registers can be specified as a register quadruple (P3:0) which
represents a single 32-bit register.
NOTE

Unlike the other control registers, the predicate registers are only 8 bits wide
because vector compares return a maximum of 8 status results.

Table 2-10 defines the predicate registers.
Table 2-10 Predicate registers

80-N2040-46 Rev. B

Register

Bits

Description

P0, P1,P2, P3

8

Compare status results.

P3:0

32

Compare status results.

31:24

P3 register

23:16

P2 register

15:8

P1 register

7:0

P0 register

42

Hexagon V68 Programmer’s Reference Manual

2.2.6

Registers

Circular start registers
The circular start registers (CS0 - CS1) store the start address of a circular buffer in
circular addressing (Section 5.8.10). For example:
CS0 = R5
M0 = R7
R0 = memb(R2++#4:circ(M0))

// Set circ start register
// Set modifier register
// Load from circ buffer pointed
// to by CS0 with size/K vals in M0

Table 2-11 defines the circular start registers.
Table 2-11

2.2.7

Circular start registers

Register

Name

CS0, CS1

Circular Start

Description
Circular buffer start address.

User general pointer register
The user general pointer (UGP) register is a general-purpose control register. For example:
R9 = UGP
UGP = R3
NOTE

// Get UGP
// Set UGP

UGP typically stores the address of thread local storage.

Table 2-12 defines the user general pointer register.
Table 2-12 User general pointer register
Register

UGP

2.2.8

Name

Description

User General Pointer

General-purpose control register.

Global pointer
The Global Pointer (GP) is used in GP-relative addressing. For example:
GP = R7
R2 = memw(GP+#200)

// Set GP
// GP-relative load

Table 2-13 defines the global pointer register.
Table 2-13 Global pointer register
Name

R/W

Bits

Field

32

GP

Description
Global Pointer Register

R/W

31:7

GDP

Global Data Pointer (Section 5.8.4).

R

6:0

reserved

Return 0 if read.
Reserved for future expansion. To remain forwardcompatible with future processor versions, software
should always write this field with the same value
read from the field.

80-N2040-46 Rev. B

43

Hexagon V68 Programmer’s Reference Manual

2.2.9

Registers

Cycle count registers
The cycle count registers (UPCYCLELO - UPCYCLEHI) store a 64-bit value containing the
current number of processor cycles executed since the Hexagon processor was last reset.
For example:
R5 = UPCYCLEHI
R4 = UPCYCLELO
R5:4 = UPCYCLE
NOTE

// Get cycle count (high)
// Get cycle count (low)
// Get cycle count

The RTOS must grant permission to access these registers. Without this
permission, reading these registers from user code always returns zero.

Table 2-14 defines the cycle count registers.
Table 2-14 Cycle count registers
Register

Description

UPCYCLELO

Cycle count (low)

Processor cycle count (low 32 bits)

UPCYCLEHI

Cycle count (high)

Processor cycle count (high 32 bits)

Cycle count

Processor cycle count (64 bits)

UPCYCLE

2.2.10

Name

Frame limit register
The frame limit register (FRAMELIMIT) stores the low address of the memory area
reserved for the software stack (Section 7.3.1). For example:
R9 = FRAMELIMIT
FRAMELIMIT = R3

// Get frame limit register
// Set frame limit register

Table 2-15 defines the frame limit register.
Table 2-15 Frame limit register
Register

FRAMELIMIT

80-N2040-46 Rev. B

Name
Frame Limit

Description
Low address of software stack area.

44

Hexagon V68 Programmer’s Reference Manual

2.2.11

Registers

Frame key register
The frame key register (FRAMEKEY) stores the key value that XOR-scrambles return
addresses when they are stored on the software stack (Section 7.3.2). For example:
R2 = FRAMEKEY
FRAMEKEY = R1

// Get frame key register
// Set frame key register

Table 2-16 defines the frame key register.
Table 2-16 Frame key register
Register

FRAMEKEY

2.2.12

Name
Frame Key

Description
Key to scramble return addresses
stored on software stack.

Packet count registers
The packet count registers (PKTCOUNTLO - PKTCOUNTHI) store a 64-bit value
containing the current number of instruction packets executed since a PKTCOUNT register
was last written to. For example:
R9 = PKTCOUNTHI
R8 = PKTCOUNTLO
R9:8 = PKTCOUNT

// Get packet count (high)
// Get packet count (low)
// Get packet count

Packet counting can be configured to operate only in specific sets of processor modes
(e.g., User mode only, or Guest and Monitor modes only). The configuration for each
mode is controlled by bits [12:10] in the user status register (Section 2.2.3).
Packets with exceptions are not counted as committed packets.
NOTE

Each hardware thread has its own set of packet count registers.
The RTOS must grant permission to access these registers. Without this
permission, reading these registers from user code always returns zero.
When a value is written to a PKTCOUNT register, the 64-bit packet count
value is incremented before the value is stored in the register.

Table 2-17 defines the packet count registers.
Table 2-17 Packet count registers
Register

Description

PKTCOUNTLO

Packet count (low)

Processor packet count (low 32 bits)

PKTCOUNTHI

Packet count (high)

Processor packet count (high 32 bits)

Cycle count

Processor packet count (64 bits)

PKTCOUNT

80-N2040-46 Rev. B

Name

45

Hexagon V68 Programmer’s Reference Manual

2.2.13

Registers

Qtimer registers
The Qtimer registers (UTIMERLO - UTIMERHI) provide access to the Qtimer global
reference count value. They enable Hexagon software to read the 64-bit time value
without having to perform an expensive AHB load. For example:
R5 = UTIMERHI
R4 = UTIMERLO
R5:4 = UTIMER

// Get Qtimer reference count (high)
// Get Qtimer reference count (low)
// Get Qtimer reference count

These registers are read-only – they are automatically updated by hardware to always
contain the current Qtimer value.
NOTE

The RTOS must grant permission to access these registers. Without this
permission, reading these registers from user code always returns zero.

Table 2-18 defines the packet count registers.
Table 2-18 Qtimer registers
Register

Description

UTIMERLO

Qtimer (low)

Qtimer global reference count (low 32 bits)

UTIMERHI

Qtimer (high)

Qtimer global reference count (high 32 bits)

Qtimer

Qtimer global reference count (64 bits)

UTIMER

80-N2040-46 Rev. B

Name

46

3 Instructions
Instruction encoding is described in Chapter 10.
For detailed descriptions of the Hexagon processor instructions see Chapter 11.

3.1

Instruction syntax
Most Hexagon processor instructions have the following syntax:
dest = instr_name(source1,source2,...)[:option1][:option2]...

The item specified on the left-hand side (LHS) of the equation is assigned the value
specified by the right-hand side (RHS). For example:
R2 = add(R3,R1)

// Add R3 and R1, assign result to R2

Table 3-1 lists symbols commonly used in Hexagon processor instructions.
Table 3-1

Instruction symbols

Symbol

Example

Meaning

=

R2 = R3

Assignment of RHS to LHS

#

R1 = #1

Immediate value

0x

0xBABE

Hexadecimal number prefix

memXX

R2 = memub(R3)

Memory access
XX specifies access size and type

;

R2 = R3; R4 = R5;

Instruction delimiter, or end of instruction

{…}

{R2 = R3; R5 = R6}

Instruction packet delimiter

(…)

R2 = memw(R0 + #100)

Source list delimiter

:endloopX

:endloop0

Loop end
X specifies loop instruction (0 or 1)

:t

if (P0.new) jump:t target

Direction hint (jump taken)

:nt

if (!P1.new) jump:nt target

Direction hint (jump not taken)

:sat

R2 = add(R1,R2):sat

Saturate result

:rnd

R2 = mpy(R1.H,R2.H):rnd

Round result

:carry

R5:4=add(R1:0,R3:2,P1):carry

Predicate used as carry input and output

:<<16

R2 = add(R1.L,R2.L):<<16

Shift result left by halfword

:mem_noshuf

{memw(R5) = R2;
R3 = memh(R6)}:mem_noshuf

Inhibit load/store reordering (Section 5.5)

80-N2040-46 Rev. B

47

Hexagon V68 Programmer’s Reference Manual

3.2

Instructions

Instruction classes
The Hexagon processor instructions are assigned to specific instruction classes. Classes
determine what combinations of instructions can be written in parallel (Section 3.3).
Instruction classes logically correspond with instruction types. For instance, the ALU32
class contains ALU instructions which operate on 32-bit operands.
Table 3-2 lists the instruction classes and subclasses.

Table 3-2

Instruction classes

Class
XTYPE

ALU32

Subclass
–

Description
Various operations

Section
Section 11.10

ALU

64-bit ALU operations

Section 11.10.1

Bit

Bit operations

Section 11.10.2

Complex

Complex math (using real and
imaginary numbers)

Section 11.10.3

Floating point

Floating point operations

Section 11.10.4

Multiply

Multiply operations

Section 11.10.5

Permute

Vector permute and format conversion
(pack, splat, swizzle)

Section 11.10.6

Predicate

Predicate operations

Section 11.10.7

Shift

Shift operations
(with optional ALU operations)

Section 11.10.8

–

32-bit ALU operations

Section 11.1

ALU

Arithmetic and logical

Section 11.1.1

Permute

Permute

Section 11.1.2

Predicate

Predicate operations

Section 11.1.3

CR

–

Control register access, loops

Section 11.2

JR

–

Jumps (register indirect addressing mode)

Section 11.3

J

–

Jumps (PC-relative addressing mode)

Section 11.4

LD

–

Memory load operations

Section 11.5

MEMOP

–

Memory operations

Section 11.6

NV

–

New-value operations

Section 11.7

Jump

New-value jumps

Section 11.7.1

Store

New-value stores

Section 11.7.2

ST

–

Memory store operations;
alloc stack frame

Section 11.8

SYSTEM

–

Operating system access

Section 11.9

USER

80-N2040-46 Rev. B

Application-level access

Section 11.9.3

48

Hexagon V68 Programmer’s Reference Manual

3.3

Instructions

Instruction packets
Instructions can be grouped together to form packets of independent instructions which
are executed together in parallel. The packets can contain 1, 2, 3, or 4 instructions.
Instruction packets must be explicitly specified in software. They are expressed in
assembly language by enclosing groups of instructions in curly braces. For example:
{ R0 = R1; R2 = R3 }

Various rules and restrictions exist on what types of instructions can be grouped together,
and in what order they can appear in the packet. In particular, packet formation is subject
to the following constraints:










Resource constraints determine how many instructions of a specific type can
appear in a packet. The Hexagon processor has a fixed number of execution units:
each instruction is executed on a particular type of unit, and each unit can process
at most one instruction at a time. Thus, for example, because the Hexagon
processor contains only two load units, an instruction packet with three load
instructions is invalid. The resource constraints are described in Section 3.3.3
Grouping constraints are a small set of rules that apply above and beyond the
resource constraints. These rules are described in Section 3.3.4.
Dependency constraints ensure that no write-after-write hazards exist in a packet.
These rules are described in Section 3.3.5.
Ordering constraints dictate the ordering of instructions within a packet. These
rules are described in Section 3.3.6.
Alignment constraints dictate the placement of packets in memory. These rules are
described in Section 3.3.7.

NOTE

80-N2040-46 Rev. B

Individual instructions (which are not explicitly grouped in packets) are
executed by the Hexagon processor as packets containing a single instruction.

49

Hexagon V68 Programmer’s Reference Manual

3.3.1

Instructions

Packet execution semantics
Packets are defined to have parallel execution semantics. Specifically, the execution
behavior of a packet is defined as follows:


First, all instructions in the packet read their source registers in parallel.



Next, all instructions in the packet execute.



Finally, all instructions in the packet write their destination registers in parallel.

For example, consider the following packet:
{ R2 = R3; R3 = R2; }

In the first phase, registers R3 and R2 are read from the register file. Then, after execution,
R2 is written with the old value of R3 and R3 is written with the old value of R2. In effect,
the result of this packet is that the values of R2 and R3 are swapped.
NOTE

3.3.2

Dual stores (Section 5.4), dual jumps (Section 8.7), new-value stores
(Section 5.6), new-value compare jumps (Section 8.5.1), and dot-new
predicates (Section 6.1.4) have non-parallel execution semantics.

Sequencing semantics
Packets of any length can be freely mixed in code. A packet is considered an atomic unit:
in essence, a single large “instruction”. From the program perspective a packet either
executes to completion or not at all; it never executes only partially. For example, if a
packet causes a memory exception, the exception point is established before the packet.
A packet containing multiple load/store instructions can require service from the external
system. For instance, consider the case of a packet that performs two load operations that
both miss in the cache. The packet requires the memory system to supply the data:




From the memory system perspective the two resulting load requests are
processed serially.
From the program perspective, however, both load operations must complete
before the packet can complete.

Thus, the packet is atomic from the program perspective.
Packets have a single PC address, which is the address of the start of the packet. Branches
cannot be performed into the middle of a packet.
Architecturally, packets execute to completion – including updating all registers and
memory – before the next packet begins. As a result, application programs are not exposed
to any pipeline artifacts.

80-N2040-46 Rev. B

50

Hexagon V68 Programmer’s Reference Manual

3.3.3

Instructions

Resource constraints
A packet cannot use more hardware resources than are physically available on the
processor. For instance, because the Hexagon processor has only two load units, a packet
with three load instructions is invalid. The behavior of such a packet is undefined. The
assembler automatically rejects packets that oversubscribe the hardware resources.
The processor supports up to four parallel instructions. The instructions are executed in
four parallel pipelines which are referred to as slots.The four slots are named Slot 0,
Slot 1, Slot 2, and Slot 3. (For more information see Section 1.2.)
NOTE

endloopN instructions (Section 8.2.2) do not use any slots.

Each instruction belongs to a specific instruction class (Section 3.2). For example, jumps
belong to instruction class J, while loads belong to instruction class LD. An instruction’s
class determines which slot it can execute in.
Figure 3-1 shows which instruction classes can be assigned to each of the four slots.

Slot 0
LD Instructions
ST Instructions
ALU32 Instructions
MEMOP Instructions
NV Instructions
SYSTEM Instructions
Some J Instructions

Slot 1
LD Instructions
ST Instructions
ALU32 Instructions
Some J Instructions

Slot 2
XTYPE Instructions
ALU32 Instructions
J Instructions
JR Instructions

Slot 3
XTYPE Instructions
ALU32 Instructions
J Instructions
CR Instructions

XTYPE Instructions (32/64 bit)

J Instructions

Arithmetic, Logical, Bit Manipulation
Multiply (Integer, Fractional, Complex)
Floating-point Operations
Permute / Vector Permute Operations
Predicate Operations
Shift / Shift with Add/Sub/Logical
Vector Byte ALU
Vector Halfword (ALU, Shift, Multiply)
Vector W ord (ALU, Shift)

Jump/Call PC-relative

ALU32 Instructions

ST Instructions

Arithmetic / Logical (32 bit)
Vector Halfword

Stores (8/16/32/64 bit)
Allocfram e

CR Instructions

MEMOP Instructions

Control-Register Transfers
Hardware Loop Setup
Predicate Logicals & Reductions

Operation on memory (8/16/32 bit)

NV Instructions
New-value Jumps
New-value Stores

JR Instructions
Jump/Call Register

LD Instructions
Loads (8/16/32/64 bit)
Deallocframe

SYSTEM Instructions
Prefetch
Cache Maintenance
Bus Operations

Figure 3-1 Packet grouping combinations

80-N2040-46 Rev. B

51

Hexagon V68 Programmer’s Reference Manual

3.3.4

Instructions

Grouping constraints
A small number of restrictions determines what constitutes a valid packet. The assembler
ensures that all packets follow valid grouping rules. If a packet is executed which violates
a grouping rule, the behavior is undefined. The following rules must be followed:














Dot-new conditional instructions (Section 6.1.4) must be grouped in a packet with
an instruction that generates dot-new predicates.
ST-class instructions can be placed in Slot 1. In this case Slot 0 normally must
contain a second ST-class instruction (Section 5.4).
J-class instructions can be placed in Slots 2 or 3. However, only certain
combinations of program flow instructions (J or JR) can be grouped together in a
packet (Section 8.7). Otherwise, at most one program flow instruction is allowed
in a packet. Some Jump and Compare-Jump instructions can execute on slots 0 or
1, excluding calls, such as the following:


Instructions of the form “Pd=cmp.xx(); if(Pd.new)jump:hint <target>”



Instructions of the form “If(Pd[.new]) jump[:hint] <target>”



The “jump<target>” instruction

JR-class instructions can be placed in Slot 2. However, when encoded in a duplex
jumpr R31 can be placed in Slot 0 (Section 10.3).
Restrictions exist which limit the instructions that can appear in a packet at the
setup or end of a hardware loop (Section 8.2.4).
A user control register transfer to the control register USR cannot be grouped with
a floating point instruction (Section 2.2.3).
The SYSTEM-class instructions include prefetch, cache operations, bus
operations, load locked, and store conditional instructions (Section 5.10). These
instructions have the following grouping rules:


brkpt, trap, pause, icinva, isync, and syncht are solo instructions. They

must not be grouped with other instructions in a packet.


memw_locked, memd_locked, l2fetch, and trace must execute on Slot 0.

They must be grouped only with ALU32 or (non-FP) XTYPE instructions.


dccleana, dcinva, dccleaninva, and dczeroa must execute on Slot 0. Slot

1 must be empty or an ALU32 instruction.

80-N2040-46 Rev. B

52

Hexagon V68 Programmer’s Reference Manual

3.3.5

Instructions

Dependency constraints
Instructions in a packet cannot write to the same destination register. The assembler
automatically flags such packets as invalid. If the processor executes a packet with two
writes to the same general register, an error exception is raised.
If the processor executes a packet that performs multiple writes to the same predicate or
control register, the behavior is undefined. Three special cases exist for this rule:






3.3.6

Conditional writes are allowed to target the same destination register only if at
most one of the writes is actually performed (Section 6.1.5).
The overflow flag in the status register has defined behavior when multiple
instructions write to it (Section 2.2.3). Do not group instructions that write to the
entire user status register (for example, USR=R2) in a packet with any instruction
that writes to a bit in the user status register.
Multiple compare instructions are allowed to target the same predicate register to
perform a logical AND of the results (Section 6.1.3).

Ordering constraints
In assembly code, instructions can appear in a packet in any order (with the exception of
dual jumps – Section 8.7). The assembler automatically encodes instructions in the packet
in the proper order.
In the binary encoding of a packet, the instructions must be ordered from Slot 3 down to
Slot 0. If the packet contains less than four instructions, any unused slot is skipped – a
NOP is unnecessary as the hardware handles the proper spacing of the instructions.
In memory, instructions in a packet must appear in strictly decreasing slot order.
Additionally, if an instruction can go in a higher-numbered slot, and that slot is empty,
then it must be moved into the higher-numbered slot.
For example, if a packet contains three instructions and Slot 1 is not used, the instructions
should be encoded in the packet as follows:


Slot 3 instruction at lowest address



Slot 2 instruction follows Slot 3 instruction



Slot 0 instructions at the last (highest) address

If a packet contains a single load or store instruction, that instruction must go in Slot 0,
which is the highest address. As an example, a packet containing both LD and ALU32
instructions must be ordered so the LD is in Slot 0 and the ALU32 in another slot.

80-N2040-46 Rev. B

53

Hexagon V68 Programmer’s Reference Manual

3.3.7

Instructions

Alignment constraints
Packets have the following constraints on their placement or alignment in memory:
 Packets must be word-aligned (32-bit). If the processor executes an improperly
aligned packet, it raises an error exception (Section 8.10).


Packets should not wrap the 4GB address space. If address wraparound occurs,
the processor behavior is undefined.

No other core-based restrictions exist for code placement or alignment.
If the processor branches to a packet that crosses a 16-byte address boundary, the resulting
instruction fetch stalls for one cycle. Packets that are jump targets or loop body entries can
be explicitly aligned to ensure this does not occur (Section 9.5.2).

3.4

Instruction intrinsics
To support efficient coding of the time-critical sections of a program (without resorting to
assembly language), the C compilers support intrinsics which are directly express
Hexagon processor instructions from within C code.
The following example shows how to use an instruction intrinsic to express the XTYPE
instruction “Rdd = vminh(Rtt,Rss)”:
#include <hexagon_protos.h>
int main()
{
long long v1 = 0xFFFF0000FFFF0000LL;
long long v2 = 0x0000FFFF0000FFFFLL;
long long result;
// find the minimum for each half-word in 64-bit vector
result = Q6_P_vminh_PP(v1,v2);
}

Intrinsics are provided for instructions in the following classes:


ALU32



XTYPE



CR (predicate operations only)



SYSTEM (dcfetch only)

For more information on intrinsics see Chapter 11.

80-N2040-46 Rev. B

54

Hexagon V68 Programmer’s Reference Manual

3.5

Instructions

Compound instructions
The Hexagon processor supports compound instructions, which encode pairs of
commonly-used operations in a single instruction. For example, each of the following is a
single compound instruction:
dealloc_return
R2 &= and(R1, R0)
R7 = add(R4, sub(#15, R3))
R3 = sub(#20, asl(R3, #16))
R5 = add(R2, mpyi(#8, R4))
{
P0 = cmp.eq (R2, R5)
if (P0.new) jump:nt target
}
{
R2 = #15
jump target
}

// deallocate frame and return
// and and and
// subtract and add
// shift and subtract
// multiply and add
// compare and jump

// register transfer and jump

Using compound instructions reduces code size and improves code performance.
NOTE

3.6

Compound instructions (with the exception of X-and-jump, as shown above)
have distinct assembly syntax from the instructions they are composed of.

Duplex instructions
To reduce code size the Hexagon processor supports duplex instructions, which encode
pairs of commonly-used instructions in a 32-bit instruction container.
Unlike compound instructions (Section 3.5), duplex instructions do not have distinctive
syntax – in assembly code they appear identical to the instructions they are composed of.
The assembler is responsible for recognizing when a pair of instructions can be encoded as
a single duplex rather than a pair of regular instruction words.
To fit two instructions into a single 32-bit word, duplexes are limited to a subset of the
most common instructions (load, store, branch, ALU), and the most common register
operands.
For more information on duplexes, see Section 10.2 and Section 10.3.

80-N2040-46 Rev. B

55

4 Data Processing
The Hexagon processor provides a rich set of operations for processing scalar and vector
data.
This chapter presents an overview of the operations provided by the following Hexagon
processor instruction classes:


XTYPE – General-purpose data operations



ALU32 – Arithmetic/logical operations on 32-bit data

NOTE

80-N2040-46 Rev. B

For detailed descriptions of these instruction classes see Chapter 11.

56

Hexagon V68 Programmer’s Reference Manual

4.1

Data Processing

Data types
The Hexagon processor provides operations for processing the following data types:

4.1.1



Fixed-point data



Floating-point data



Complex data



Vector data

Fixed-point data
The Hexagon processor provides operations to process 8-, 16-, 32-, or 64-bit fixed-point
data. The data can be either integer or fractional, and in signed or unsigned format.

4.1.2

Floating-point data
The Hexagon processor provides operations to process 32-bit floating-point numbers. The
numbers are stored in IEEE single-precision floating-point format.
Per the IEEE standard, certain floating-point values are defined to represent positive or
negative infinity, as well as Not-a-Number (NaN), which represents values that have no
mathematical meaning.
Floating-point numbers can be held in a general register.

4.1.3

Complex data
The Hexagon processor provides operations to process 32- or 64-bit complex data.
Complex numbers include a signed real portion and a signed imaginary portion. Given
two complex numbers (a+bi) and (c+di), the complex multiply operations computes both
the real portion (ac-bd) and the imaginary portion (ad+bc) in a single instruction.
Complex numbers can be packed in a general register or register pair. When packed, the
imaginary portion occupies the most-significant portion of the register or register pair.

4.1.4

Vector data
The Hexagon processor provides operations to process 64-bit vector data.
Vector data types pack multiple data items – bytes, halfwords, or words – into 64-bit
registers. Vector data operations are common in video and image processing.
Eight 8-bit bytes can be packed into a 64-bit register.
Figure 4-1 shows an example of a vector byte operation.

80-N2040-46 Rev. B

57

Hexagon V68 Programmer’s Reference Manual

Data Processing

Rss
Rtt

Op

Op

Op

Op

Op

Op

Op

Op

Rdd
Figure 4-1 Vector byte operation

Four 16-bit halfword values can be packed in a single 64-bit register pair.
Figure 4-2 shows an example of a vector halfword operation.
Rss
Rtt

Op

Op

Op

Op

Rdd
Figure 4-2 Vector halfword operation

Two 32-bit word values can be packed in a single 64-bit register pair.
Figure 4-3 shows an example of a vector word operation.

Rss
Rtt

Op

Op

Rdd
Figure 4-3 Vector word operation

80-N2040-46 Rev. B

58

Hexagon V68 Programmer’s Reference Manual

4.2

Data Processing

Instruction options
Some instructions support optional scaling, saturation, and rounding. There are no mode
bits controlling these options – instead, they are explicitly specified as part of the
instruction name. The options are described in this section.

4.2.1

Fractional scaling
In fractional data format, data is treated as fixed-point fractional values whose range is
determined by the word length and radix point position.
Fractional scaling is specified in an instruction by adding the :<<1 specifier. For
example:
R3:2 = cmpy(R0,R1):<<1:sat

When two fractional numbers are multiplied, the product must be scaled to restore the
original fractional data format. The Hexagon processor allows specification of the
fractional scaling of the product in the instruction for shifts of 0 and 1. Perform a shift of 1
for Q1.15 numbers, perform a shift of 0 for integer multiplication.

4.2.2

Saturation
Certain instructions are available in saturating form. If a saturating arithmetic instruction
has a result which is smaller than the minimum value, the result is set to the minimum
value. Similarly, if the operation has a result which is greater than the maximum value, the
result is set to the maximum value.
Saturation is specified in an instruction by adding the :sat specifier. For example:
R2 = abs(R1):sat

The OVF bit in the user status register (Section 2.2.3) is set whenever a saturating
operation saturates to the maximum or minimum value. It remains set until explicitly
cleared by a control register transfer to USR. For vector-type saturating operations, if any
of the individual elements of the vector saturate, OVF is set.

4.2.3

Arithmetic rounding
Certain signed multiply instructions support optional arithmetic rounding (also known as
biased rounding). The arithmetic rounding operation takes a double precision fractional
value and adds 0x8000 to the low 16-bits (least significant 16-bit halfword).
Rounding is specified in an instruction by adding the :rnd specifier. For example:
R2 = mpy(R1.h,R2.h):rnd
NOTE

80-N2040-46 Rev. B

Arithmetic rounding can accumulate numerical errors, especially when the
number to round is exactly 0.5. This happens most frequently when dividing
by 2 or averaging.

59

Hexagon V68 Programmer’s Reference Manual

4.2.4

Data Processing

Convergent rounding
To address the problem of error accumulation in arithmetic rounding (Section 4.2.3), the
Hexagon processor includes four instructions that support positive and negative averaging
with a convergent rounding option.
These instructions work as follows:
1. Compute (A+B) or (A-B) for AVG and NAVG respectively.
2. Based on the two least-significant bits of the result, add a rounding constant as
follows:
 If the two LSBs are 00, add 0


If the two LSBs are 01, add 0



If the two LSBs are 10, add 0



If the two LSBs are 11, add 1

3. Shift the result right by one bit.

4.2.5

Scaling for divide and square-root
On the Hexagon processor, floating point divide and square-root operations are
implemented in software using library functions. To enable the efficient implementation of
these operations, the processor supports special variants of the multiply-accumulate
instruction. These are named scale FMA.
Scale FMA supports optional scaling of the product generated by the floating-point fused
multiply-add instruction.
Scaling is specified in the instruction by adding the :scale specifier and a predicate
register operand. For example:
R3 += sfmpy(R0,R1,P2):scale

For single precision, the scaling factor is two raised to the power specified by the contents
of the predicate register (which is treated as an 8-bit two's complement value). For double
precision, the predicate register value is doubled before being used as a power of two.
NOTE

80-N2040-46 Rev. B

Scale FMA instructions should not be used outside of divide and square-root
library routines. No guarantee is provided that future versions of the Hexagon
processor will implement these instructions using the same semantics. Future
versions assume only that compatibility for scale FMA is limited to the needs
of divide and square-root library routines.

60

Hexagon V68 Programmer’s Reference Manual

4.3

Data Processing

XTYPE operations
The XTYPE instruction class includes most of the data-processing operations performed
by the Hexagon processor. These operations are categorized by their operation type:

4.3.1



ALU



Bit manipulation



Complex



Floating point



Multiply



Permute



Predicate



Shift

ALU
ALU operations modify 8-, 16-, 32-, and 64-bit data. These operations include:


Add and subtract with and without saturation



Add and subtract with accumulate



Absolute value



Logical operations



Min, max, negate instructions



Register transfers of 64-bit data



Word to doubleword sign extension



Comparisons

For more information see Section 11.10.1.

80-N2040-46 Rev. B

61

Hexagon V68 Programmer’s Reference Manual

4.3.2

Data Processing

Bit manipulation
Bit manipulation operations modify bit fields in a register or register pair. These
operations include:


Bit field insert



Bit field signed and unsigned extract



Count leading and trailing bits



Compare bit masks



Set / Clear / Toggle bit



Test bit operation



Interleave/deinterleave bits



Bit reverse



Split bit field



Masked parity and Linear Feedback shift



Table index formation

For more information see Section 11.10.2.

4.3.3

Complex
Complex operations manipulate complex numbers. These operations include:


Complex add and subtract



Complex multiply with optional round and pack



Vector complex multiply



Vector complex conjugate



Vector complex rotate



Vector reduce complex multiply real or imaginary

For more information see Section 11.10.3.

80-N2040-46 Rev. B

62

Hexagon V68 Programmer’s Reference Manual

4.3.4

Data Processing

Floating point
Floating-point operations manipulate single-precision floating point numbers. These
operations include:


Addition and subtraction



Multiplication (with optional scaling)



Min/max/compare



Format conversion

The Hexagon floating-point operations are defined to support the IEEE floating-point
standard. However, certain IEEE-required operations – such as divide and square root –
are not supported directly. Instead, special instructions are defined to support the
implementation of the required operations as library routines. These instructions include:






A special version of the fused multiply-add instruction (designed specifically for
use in library routines)
Reciprocal/square root approximations (which compute the approximate initial
values used in reciprocal and reciprocal-square-root routines)
Extreme value assistance (which adjusts input values if they cannot produce
correct results using convergence algorithms)

For more information see Section 11.10.4.
NOTE

The special floating-point instructions are not intended for use directly in user
code – they should be used only in the floating point library.

Format conversion

The floating-point conversion instructions sfmake and dfmake convert an unsigned 10-bit
immediate value into the corresponding floating-point value.
The immediate value must be encoded so bits [5:0] contain the significand, and bits [9:6]
the exponent. The exponent value is added to the initial exponent value (bias - 6).
For example, to generate the single-precision floating point value 2.0, bits [5:0] must be
set to 0, and bits [9:6] set to 7. Performing sfmake on this immediate value yields the
floating point value 0x40000000, which is 2.0.
NOTE

The conversion instructions are designed to handle common floating point
values, including most integers and many basic fractions (1/2, 3/4, etc.).

Rounding

The Hexagon user status register (Section 2.2.3) includes the FPRND field, which
specifies the IEEE-defined floating-point rounding mode.

80-N2040-46 Rev. B

63

Hexagon V68 Programmer’s Reference Manual

Data Processing

Exceptions

The Hexagon user status register (Section 2.2.3) includes five status fields, which work as
sticky flags for the five IEEE-defined exception conditions: inexact, overflow, underflow,
divide by zero, and invalid. A sticky flag is set when the corresponding exception occurs,
and remains set until explicitly cleared.
The user status register also includes five mode fields which specify whether to perform
an operating-system trap if one of the floating-point exceptions occur. For every
instruction packet containing a floating-point operation, if a floating-point sticky flag and
the corresponding trap-enable bit are both set, a floating-point trap is generated. After the
packet commits, the Hexagon processor then automatically traps to the operating system.
NOTE

4.3.5

Non-floating-point instructions never generate a floating-point trap,
regardless of the state of the sticky flag and trap-enable bits.

Multiply
Multiply operations support fixed-point multiplication, including both single- and doubleprecision multiplication, and polynomial multiplication.
Single precision

In single-precision arithmetic a 16-bit value is multiplied by another 16-bit value. These
operands can come from the high portion or low portion of any register. Depending on the
instruction, the result of the 16  16 operation can optionally be accumulated, saturated,
rounded, or shifted left by 0-1 bits.
The instruction set supports operations on signed  signed, unsigned  unsigned, and
signed  unsigned data.

80-N2040-46 Rev. B

64

Hexagon V68 Programmer’s Reference Manual

Data Processing

Table 4-1 summarizes the options available for 16  16 single precision multiplications.
The symbols used in the table are as follows:


SS – Perform signed  signed multiply



UU – Perform unsigned  unsigned multiply



SU – Perform signed  unsigned multiply



A+ – Result added to accumulator



A- – Result subtracted from accumulator



0 – Result not added to accumulator

Table 4-1

Single-precision multiply options

Multiply

Result

Sign

Accumulate

Sat

Rnd

Scale

16  16

32

SS

A+, A-

Yes

No

0-1

16  16

32

SS

0

Yes

Yes

0-1

16  16

64

SS

A+, A-

No

No

0-1

16  16

64

SS

0

No

Yes

0-1

16  16

32

UU

A+, A-, 0

No

No

0-1

16  16

64

UU

A+, A-, 0

No

No

0-1

16  16

32

SU

A+, 0

Yes

No

0-1

Double precision

Double precision instructions are available for both 32  32 and 32  16 multiplication:




For 32  32 multiplication the result can be either 64 or 32 bits. The 32-bit result
can be either the high or low portion of the 64-bit product.
For 32  16 multiplication the result is always taken as the upper 32 bits.

The operands can be either signed or unsigned.
Table 4-2 summarizes the options available in double precision multiply.
Table 4-2

Double precision multiply options

Multiply

Result

Sign

Accumulate

Sat

Rnd

Scale

32 32

64

SS, UU

A+, A-, 0

No

No

0

32 32

32 (upper)

SS, UU

0

No

Yes

0

32 32

32 (low)

SS, UU

A+, 0

No

No

0

32 16

32 (upper)

SS, UU

A+, 0

Yes

Yes

0-1

32 32

32 (upper)

SU

0

No

No

0

Polynomial

Polynomial multiply instructions are available for both words and vector halfwords.

80-N2040-46 Rev. B

65

Hexagon V68 Programmer’s Reference Manual

Data Processing

These instructions are useful for many algorithms including scramble code generation,
cryptographic algorithms, convolutional, and Reed Solomon code.
For more information on multiply operations, see Section 11.10.5.

4.3.6

Permute
Permute operations perform various operations on vector data, including arithmetic,
format conversion, and rearrangement of vector elements. Many types of conversions are
supported:


Swizzle bytes



Vector shuffle



Vector align



Vector saturate and pack



Vector splat bytes



Vector splice



Vector sign extend halfwords



Vector zero extend bytes



Vector zero extend halfwords



Scalar saturate to byte, halfword, word



Vector pack high and low halfwords



Vector round and pack



Vector splat halfwords

For more information, see Section 11.10.6.

4.3.7

Predicate
Predicate operations modify predicate source data. The categories of instructions available
include:


Vector mask generation



Predicate transfers



Viterbi packing

For more information, see Section 11.10.7.

80-N2040-46 Rev. B

66

Hexagon V68 Programmer’s Reference Manual

4.3.8

Data Processing

Shift
Scalar shift operations perform a variety of 32 and 64-bit shifts followed by an optional
add/sub or logical operation. Figure 4-4 shows the general operation.
Rss
# / Rt
Shift
amount
64-bit Shifter

64-bit Add/Sub/Logical

Rxx
Figure 4-4 64-bit shift and add/sub/logical

Four shift types are supported:


ASR – Arithmetic shift right



ASL – Arithmetic shift left



LSR – Logical shift right



LSL – Logical shift left

In register-based shifts, the Rt register is a signed two’s-complement number. If this value
is positive, then the instruction opcode tells the direction of shift (right or left). If this
value is negative, then the shift direction indicated by the opcode is reversed.
When arithmetic right shifts are performed, the sign bit is shifted in, whereas logical right
shifts shift in zeros. Left shifts always shift in zeros.
Some shifts are available with saturation and rounding options.
For more information see Section 11.10.8.

80-N2040-46 Rev. B

67

Hexagon V68 Programmer’s Reference Manual

4.4

Data Processing

ALU32 operations
The ALU32 instruction class includes general arithmetic/logical operations on 32-bit data:






Add, subtract, negate without saturation on 32-bit data
Logical operations such as AND, OR, XOR, AND with immediate, and OR with
immediate
Scalar 32-bit compares
Combine halfwords, combine words, combine with immediates, shift halfwords,
and Mux



Conditional add, combine, logical, subtract, and transfer.



NOP



Sign and zero-extend bytes and halfwords



Transfer immediates and registers



Vector add, subtract, and average halfwords

For more information see Section 11.1.
NOTE

ALU32 instructions can be executed on any slot (Section 3.3.3).
Chapter 6 describes the conditional execution and compare instructions.

80-N2040-46 Rev. B

68

Hexagon V68 Programmer’s Reference Manual

4.5

Data Processing

Vector operations
Vector operations support arithmetic operations on vectors of bytes, halfwords, and words.
The vector operations belong to the XTYPE instruction class (except for vector add,
subtract, and average halfwords, which are ALU32).
Vector byte operations

The vector byte operations process packed vectors of signed or unsigned bytes. They
include the following operations:


Vector add and subtract signed or unsigned bytes



Vector min and max signed or unsigned bytes



Vector compare signed or unsigned bytes



Vector average unsigned bytes



Vector reduce add unsigned bytes



Vector sum of absolute differences unsigned bytes

Vector halfword operations

The vector halfword operations process packed 16-bit halfwords. They include the
following operations:

80-N2040-46 Rev. B



Vector add and subtract halfwords



Vector average halfwords



Vector compare halfwords



Vector min and max halfwords



Vector shift halfwords



Vector dual multiply



Vector dual multiply with round and pack



Vector multiply even halfwords with optional round and pack



Vector multiply halfwords



Vector reduce multiply halfwords

69

Hexagon V68 Programmer’s Reference Manual

Data Processing

For example, Figure 4-5 shows the operation of the vector arithmetic shift right halfword
(vasrh) instruction. In this instruction, each 16-bit half-word is shifted right by the same
amount which is specified in a register or with an immediate value. Because the shift is
arithmetic, the bits shifted in are copies of the sign bit.

Shift Amount

lost

s/z ext

lost

s/z ext

lost

s/z ext

lost

s/z ext

Rt / #u4
Rss

Rdd

Figure 4-5 Vector halfword shift right

Vector word operations

The vector word operations process packed vectors of two words. They include the
following operations:


Vector add and subtract words



Vector average words



Vector compare words



Vector min and max words



Vector shift words with optional truncate and pack

For more information on vector operations see Section 11.1.1 and Section 11.10.1.

80-N2040-46 Rev. B

70

Hexagon V68 Programmer’s Reference Manual

4.6

Data Processing

CR operations
The CR instruction class includes operations that access the control registers (Section 2.2).
Table 4-3 lists the instructions that access the control registers.
Table 4-3

Control register transfer instructions
Syntax

Operation
Move control register to / from a general register.

Rd = Cs
Cd = Rs

NOTE - PC is not a valid destination register.

Rdd = Css
Cdd = Rss

Move control register pair to / from a general register pair.
NOTE - PC is not a valid destination register.

NOTE

In register-pair transfers, control registers must be specified using their
numeric alias names – see Section 2.2 for details.

For more information see Section 11.2.

4.7

Compound operations
The instruction set includes a number of instructions that perform multiple logical or
arithmetic operations in a single instruction. They include the following operations:


And/Or with inverted input



Compound logical register



Compound logical predicate



Compound add-subtract with immediates



Compound shift-operation with immediates (arithmetic or logical)



Multiply-add with immediates

For more information see Section 11.10.1.

4.8

Special operations
The instruction set includes a number of special-purpose instructions to support specific
applications:

80-N2040-46 Rev. B



H.264 CABAC processing



IP internet checksum



Software-defined radio

71

Hexagon V68 Programmer’s Reference Manual

4.8.1

Data Processing

H.264 CABAC processing
H.264/AVC is adopted in a diverse range of multimedia applications:


HD-DVDs



HDTV broadcasting



Internet video streaming

Context Adaptive Binary Arithmetic Coding (CABAC) is one of the two alternative
entropy coding methods specified in the H.264 main profile. CABAC offers superior
coding efficiency at the expense of greater computational complexity. The Hexagon
processor includes a dedicated instruction (decbin) to support CABAC decoding.
Binary arithmetic coding is based on the principle of recursive interval subdivision, and its
state is characterized by two quantities:


The current interval range



The current offset in the current code interval

The offset is read from the encoded bit stream. When decoding a bin, the interval range is
subdivided in two intervals based on the estimation of the probability pLPS of LPS: one
interval with width of rLPS = range x pLPS, and another with width of rMPS = range x
pMPS = range -rLPS, where LPS stands for Least Probable Symbol, and MPS for Most
Probable Symbol.
Depending on which subinterval the offset falls into, the decoder decides whether the bin
is decoded as MPS or LPS, after which the two quantities are iteratively updated, as shown
in Figure 4-1.

LPS occurs

rMPS

rangeNew = rMPS
offsetNew = offset

Figure 4-1

80-N2040-46 Rev. B

rLPS

offset

offset

range

rLPS

range

MPS occurs

rMPS

rangeNew = rLPS
offsetNew = offset-rMPS

Arithmetic decoding for one bin

72

Hexagon V68 Programmer’s Reference Manual

4.8.1.1

Data Processing

CABAC implementation
In H.264 range is a 9-bit quantity, and offset is 9 bits in regular mode and 10 bits in bypass
mode during the whole decoding process. The calculation of rLPS is approximated by a
64×4 table of 256 bytes, where the range and the context state (selected for the bin to
decode) address the lookup table. To maintain the precision of the whole decoding
process, the new range must be renormalized to ensure that the most significant bit is
always 1, and that the offset is synchronously refilled from the bit stream.
To simplify the renormalization/refilling process, the decoding scheme shown in
Figure 4-2 significantly reduces the frequency of renormalization and refilling bits from
the bit-stream, while also being suitable for DSP implementation.
range: 32 bit register
18=29-bitpos
0000 0000 0001 xxxx xxxx 0000 0000 0000
9

bitpos=11

12=23-bitpos

offset: 32 bit register
0000 0000 000x xxxx xxxx xxxx xxxx xxxx
Decode Decision
(ctxIdx, range, offset)
bitpos=Count_leading_zeros(range)
rLPS=lutLPS[ctxIdx->state][(range>>(29-bitpos))&3]<<(23-bitpos)
rMPS=range-rLPS
Yes

No

offset >= rMPS

bin = !ctxIdx->valMPS
range = rLPS
offset = offset - rMPS

ctxIdx->state == 0

No

bin = ctxIdx->valMPS
range = rMPS

Yes

ctxIdx->valMPS=!ctxIdx->valMPS

ctxIdx->state =
TransIndexLPS(ctxIdx->state)

ctxIdx->state =
TransIndexMPS(ctxIdx->state)

Renormalization1
(range, offset)
Done
Figure 4-2

80-N2040-46 Rev. B

CABAC decoding engine for regular bin

73

Hexagon V68 Programmer’s Reference Manual

Data Processing

The Hexagon processor can use the decbin instruction to decode one regular bin in two
cycles (not counting the bin refilling process).
For more information on the decbin instruction see Section 11.10.6.
For example:
Rdd = decbin(Rss,Rtt)
INPUT: Rss and Rtt register pairs as:
Rtt.w1[5:0] = state
Rtt.w1[8] = valMPS
Rtt.w0[4:0] = bitpos
Rss.w0 = range
Rss.w1 = offset
OUTPUT: Rdd register pair is packed as
Rdd.w0[5:0] = state
Rdd.w0[8] = valMPS
Rdd.w0[31:23] = range
Rdd.w0[22:16] = '0'
Rdd.w1 = offset (normalized)
OUTPUT: P0
P0 = (bin)

4.8.1.2

Code example
H264CabacGetBinNC:
/****************************************************************
* Non-conventional call:
* Input: R1:0 = offset : range , R2 = dep,
R3 = ctxIdx,
* R4 = (*ctxIdx), R5 = bitpos
*
* Return:
*
R1: 0 - offset : range
*
P0 - (bin)
*****************************************************************/
// Cycle #1
{ R1:0= decbin(R1:0,R5:4)
R6 = asl(R22,R5)
}

// decoding one bin
// where R22 = 0x100

// Cycle #2
{ memb(R3) = R0
// save context to *ctxIdx
R1:0 = vlsrw(R1:0,R5)
// re-align range and offset
P1 = cmp.gtu(R6,R1)
// need refill? i.e., P1= (range<0x100)
IF (!P1.new) jumpr:t LR // return
}
RENORM_REFILL:
...

80-N2040-46 Rev. B

74

Hexagon V68 Programmer’s Reference Manual

4.8.2

Data Processing

IP internet checksum
The key features of the internet checksum1 include:



The checksum can be summed in any order
Carries may be accumulated using an accumulator larger than size being added, and
added back in at any time

Using standard data-processing instructions, the internet checksum can be computed at 8
bytes per cycle in the main loop, by loading words and accumulating into doublewords.
After the loop, the upper word is added to the lower word; then the upper halfword is
added to the lower halfword, and any carries are added back in.
The Hexagon processor supports a dedicated instruction (vradduh) which computes the
Internet checksum at a rate of 16 bytes per cycle.
The vradduh instruction accepts the halfwords of the two input vectors, adds them all
together, and places the result in a 32-bit destination register. This operation can both
compute the sum of 16 bytes of input while preserving the carries, and accumulate carries
at the end of computation.
For more information on the vradduh instruction see Section 11.10.1.
NOTE

This operation utilizes the maximum load bandwidth available in the
Hexagon processor.

1 See RFC 1071 (http://www.faqs.org/rfcs/rfc1071.html)

80-N2040-46 Rev. B

75

Hexagon V68 Programmer’s Reference Manual

4.8.2.1

Data Processing

Code example
.text
.global fast_ip_check
// Assumes data is 8-byte aligned
// Assumes data is padded at least 16 bytes afterwords with 0's.
// input R0 points to data
// input R1 is length of data
// returns IP checksum in R0
fast_ip_check:
{
R1 = lsr(R1,#4)
// 16-byte chunks, rounded down, +1
R9:8 = combine(#0,#0)
R3:2 = combine(#0,#0)
}
{
loop0(1f,R1)
R7:6 = memd(R0+#8)
R5:4 = memd(R0++#16)
}
.falign
1:
{
R7:6 = memd(R0+#8)
R5:4 = memd(R0++#16)
R2 = vradduh(R5:4,R7:6)
// accumulate 8 halfwords
R8 = vradduh(R3:2,R9:8)
// accumulate carries
}:endloop0
// drain pipeline
{
R2 = vradduh(R5:4,R7:6)
R8 = vradduh(R3:2,R9:8)
R5:4 = combine(#0,#0)
}
{
R8 = vradduh(R3:2,R9:8)
R1 = #0
}
// may have some carries to add back in
{
R0 = vradduh(R5:4,R9:8)
}
// possible for one more to pop out
{
R0 = vradduh(R5:4,R1:0)
}
{
R0 = not(R0)
jumpr LR
}

80-N2040-46 Rev. B

76

Hexagon V68 Programmer’s Reference Manual

4.8.3

Data Processing

Software-defined radio
The Hexagon processor includes six special-purpose instructions which support the
implementation of software-defined radio. The instructions greatly accelerate the
following algorithms:

4.8.3.1



Rake despreading



Scramble code generation



Polynomial field processing

Rake despreading
A fundamental operation in despreading is the PN multiply operation. In this operation the
received complex chips are compared against a pseudo-random sequence of QAM
constellation points and accumulated.
Figure 4-3 shows the vrcrotate instruction that performs this operation. The products
are summed to form a soft 32-bit complex symbol. The instruction has both accumulating
and non-accumulating versions.
Rxx += vrcrotate(Rss,Rt,#0)

Rt

1 j -1 -j

1 j -1 -j

1 j -1 -j

1 j -1 -j

mux

mux

mux

mux

Im3

Re3

Im2

*

*
+

I

Figure 4-3

Re2

Im1

Re1

Im0

Re0

Rs

*

*
+

R

Rxx

Vector reduce complex rotate

For more information on the vrcrotate instruction, see Section 11.10.3.

80-N2040-46 Rev. B

77

Hexagon V68 Programmer’s Reference Manual

NOTE

4.8.3.2

Data Processing

Using this instruction the Hexagon processor can process 5.3 chips per cycle,
and a 12-finger WCDMA user requires only 15 MHz.

Polynomial operations
The polynomial multiply instructions support the following operations:


Scramble code generation (at a rate of 8 symbols per cycle for WCDMA)



Cryptographic algorithms (such as Elliptic Curve)



CRC checks (at a rate of 21bits per cycle)



Convolutional encoding



Reed Solomon codes

The four versions of this instruction support 32 x 32 and vector 16 x 16 multiplication both
with and without accumulation, as shown in Figure 4-4.

Rxx += vpmpyh(Rs,Rt)

Rxx += pmpyw(Rs,Rt)

Rs
Rs
Rt
Rt

32x32
Carryless
Polynomial
mpy

*

16x16
Carryless
Polynomial
Mpy

*

*

XOR

XOR

16x16
Carryless
Polynomial
Mpy

XOR

Rxx

Figure 4-4

Rxx

Polynomial multiply

For more information on the pmpy instructions, see Section 11.10.5.

80-N2040-46 Rev. B

78

5 Memory
The Hexagon processor features a load/store architecture, where numeric and logical
instructions operate on registers. Explicit load instructions move operands from memory
to registers, while store instructions move operands from registers to memory. A small
number of instructions (known as mem-ops) perform numeric and logical operations
directly on memory.
The address space is unified: all accesses target the same linear address space, which
contains both instructions and data.

80-N2040-46 Rev. B

79

Hexagon V68 Programmer’s Reference Manual

5.1

Memory

Memory model
This section describes the memory model for the Hexagon processor.

5.1.1

Address space
The Hexagon processor has a 32-bit byte-addressable memory address space. The entire
4G linear address space is addressable by the user application. A virtual-to-physical
address translation mechanism is provided.

5.1.2

Byte order
The Hexagon processor is a little-endian machine: the lowest address byte in memory is
held in the least significant byte of a register, as shown in Figure 5-1.
Address

Contents

0

A

1

B

2

C

3

D

4

E

5

F

6

G

7

H

Register Contents
31

0

-

-

-

A

Load byte

-

-

B

A

Load Halfword

D

C

B

A

Load word

D

C

B

A

Load doubleword

63

H

G

F

E

Figure 5-1 Hexagon processor byte order

5.1.3

Alignment
Even though the Hexagon processor memory is byte-addressable, instructions and data
must be aligned in memory on specific address boundaries:
 Instructions and instruction packets must be 32-bit aligned


Data must be aligned to its native access size.

Any unaligned memory access causes a memory-alignment exception.
The permute instructions (Section 4.3.6) can be used in applications that need to reference
unaligned vector data. The loads and stores still must be memory-aligned; however, the
permute instructions enable easy rearrangement of the data in registers.

80-N2040-46 Rev. B

80

Hexagon V68 Programmer’s Reference Manual

Memory

Table 5-1 summarizes the alignment restrictions.
.

Table 5-1

Memory alignment restrictions

Data Type

Exception When

8

Never

Halfword
Unsigned halfword

16

LSB[0] != 0 1

Word
Unsigned word

32

LSB[1:0] != 00

Doubleword

64

LSB[2:0] != 000

Instruction
Instruction packet

32

LSB[1:0] != 00

1

5.2

Size (bits)

Byte
Unsigned byte

LSB = Least significant bits of address

Memory loads
Memory can be loaded in byte, halfword, word, or doubleword sizes. The data types
supported are signed or unsigned. The syntax used is memXX, where XX denotes the data
type.
Table 5-2 summarizes the supported load instructions.

Table 5-2

Load instructions
Source
Size
(bits)

Destination
Size
(bits)

Data
Placement

Rd = memub(Rs)

8

32

Low 8 bits

Zero-extend 8 to 32 bits

Rd = memb(Rs)

8

32

Low 8 bits

Sign-extend 8 to 32 bits

Rd = memuh(Rs)

16

32

Low 16 bits

Zero-extend 16 to 32 bits

Rd = memh(Rs)

16

32

Low 16 bits

Sign-extend 16 to 32 bits

Rd = memubh(Rs)

16

32

Bytes 0 and 2

Bytes 1 and 3 zeroed 1

Rd = membh(Rs)

16

32

Bytes 0 and 2

Bytes 1 and 3 sign-extended

Rd = memw(Rs)

32

32

All 32 bits

Rdd = memubh(Rs)

32

64

Bytes 0,2,4,6

Bytes 1,3,5,7 zeroed

Rdd = membh(Rs)

32

64

Bytes 0,2,4,6

Bytes 1,3,5,7 sign-extended

Rdd = memd(Rs)

64

64

All 64 bits

Load doubleword

Ryy = memh_fifo(Rs)

16

64

High 16 bits

Shift vector and load halfword

deallocframe

64

64

All 64 bits

See Chapter 7

dealloc_return

64

64

All 64 bits

See Chapter 7

Syntax

80-N2040-46 Rev. B

Comment

Load word

81

Hexagon V68 Programmer’s Reference Manual

1

Memory

The memubh and membh instructions load contiguous bytes from memory (either 2 or 4 bytes) and unpack these bytes into a
vector of halfwords. The instructions are useful when bytes are used as input into halfword vector operations, which is common in
video and image processing..

NOTE

5.3

The memory load instructions belong to instruction class LD, and can execute
only in Slots 0 or 1.

Memory stores
Memory can be stored in byte, halfword, word, or doubleword sizes. The syntax used is
memX, where X denotes the data type.
Table 5-3 summarizes the supported store instructions.
Table 5-3

Store instructions
Source
Size
(bits)

Destination
Size
(bits)

memb(Rs) = Rt

32

8

Store byte (bits 7:0)

memb(Rs) = #s8

8

8

Store byte

memh(Rs) = Rt

32

16

Store lower half (bits 15:0)

memh(Rs) = Rt.H

32

16

Store upper half (bits 31:16)

memh(Rs) = #s8

8

16

Sign-extend 8 to 16 bits

memw(Rs) = Rt

32

32

Store word

memw(Rs) = #s8

8

32

Sign-extend 8 to 32 bits

memd(Rs) = Rtt

64

64

Store doubleword

allocframe(#u11)

64

64

See Chapter 7

Syntax

NOTE

5.4

Comment

The memory store instructions belong to instruction class ST, and can execute
only in slot 0 or – when part of a dual store (Section 5.4) – slot 1.

Dual stores
Two memory store instructions can appear in the same instruction packet. The resulting
operation is considered a dual store. For example:
{
memw(R5) = R2
memh(R6) = R3
}

// dual store

Unlike most packetized operations, dual stores are not executed in parallel (Section 3.3.1).
Instead, the store instruction in Slot 1 effectively executes first, followed by the store
instruction in Slot 0.

80-N2040-46 Rev. B

82

Hexagon V68 Programmer’s Reference Manual

NOTE

5.5

Memory

The store instructions in a dual store must belong to instruction class ST
(Section 5.3), and can execute only in Slots 0 and 1.

Slot 1 store with slot 0 load
A slot 1 store operation with a slot 0 load operation can appear in a packet. The packet
attribute :mem_noshuf inhibits the instruction reordering that would otherwise be done by
the assembler. For example:
{
memw(R5) = R2
R3 = memh(R6)
}:mem_noshuf

// slot 1 store
// slot 0 load

Unlike most packetized operations, these memory operations are not executed in parallel
(Section 3.3.1). Instead, the store instruction in Slot 1 effectively executes first, followed
by the load instruction in Slot 0. If the addresses of the two operations are overlapping, the
load receives the newly stored data. This feature is supported in processor versions V65 or
greater.

5.6

New-value stores
A memory store instruction can store a register that is assigned a new value in the same
instruction packet (Section 3.3). This feature is expressed in assembly language by
appending the suffix “.new” to the source register. For example:
{
R2 = memh(R4+#8)
memw(R5) = R2.new
}

// load halfword
// store newly-loaded value

New-value store instructions have the following restrictions:






If an instruction uses auto-increment or absolute-set addressing mode
(Section 5.8), its address register cannot be used as the new-value register.
If an instruction produces a 64-bit result, its result registers cannot be used as the
new-value register.
If the instruction that sets a new-value register is conditional (Section 6.1.2), it
must always be executed.

NOTE

80-N2040-46 Rev. B

The new-value store instructions belong to instruction class NV, and can
execute only in Slot 0.

83

Hexagon V68 Programmer’s Reference Manual

5.7

Memory

Mem-ops
Mem-ops perform basic arithmetic, logical, and bit operations directly on memory
operands, without the need for a separate load or store. Mem-ops can be performed on
byte, halfword, or word sizes. Table 5-4 lists the mem-ops.
Table 5-4

Mem-ops
Syntax

memXX(Rs+#u6) [+-|&] = Rt

Arithmetic/logical on memory

memXX(Rs+#u6) [+-] = #u5

Arithmetic on memory

memXX(Rs+#u6) = clrbit(#u5)

Clear bit in memory

memXX(Rs+#u6) = setbit(#u5)

Set bit in memory

NOTE

5.8

Operation

The mem-op instructions belong to instruction class MEMOP, and can
execute only in Slot 0.

Addressing modes
Table 5-5 summarizes the supported addressing modes.

Table 5-5

Addressing modes
Mode

Operation 1

Syntax

Absolute

memXX(##address)

EA = address

Absolute-set

memXX(Re=##address)

EA = address
Re = address

Absolute with register offset

memXX(Ru<<#u2+##U32)

EA = imm + (Ru << #u2)

Global-pointer-relative

memXX(GP+#immediate)
memXX(#immediate)

EA = GP + immediate

Indirect

memXX(Rs)

EA = Rs

Indirect with offset

memXX(Rs+#s11)

EA = Rs + imm

Indirect with register offset

memXX(Rs+Ru<<#u2)

EA = Rs + (Ru << #u2)

Indirect

memXX(Rx++#s4)

EA = Rx;
Rx += (imm)

memXX(Rx++Mu)

EA = Rx;
Rx += Mu

memXX(Rx++#s4:circ(Mu))

EA = Rx;
Rx = circ_add(Rx,imm,Mu)

with auto-increment immediate
Indirect
with auto-increment register
Circular
with auto-increment immediate

80-N2040-46 Rev. B

84

Hexagon V68 Programmer’s Reference Manual

Table 5-5

Memory

Addressing modes
Mode

Operation 1

Syntax

Circular

memXX(Rx++I:circ(Mu))

EA = Rx;
Rx = circ_add(Rx,I,Mu)

memXX(Rx++Mu:brev)

EA = Rx.H + bit_reverse(Rx.L)
Rx += Mu

with auto-increment register
Bit-reversed
with auto-increment register
1

EA (Effective Address) is equivalent to VA (Virtual Address).

5.8.1

Absolute
The absolute addressing mode uses a 32-bit constant value as the effective memory
address. For example:
R2 = memw(##100000)
memw(##200000) = R4

5.8.2

// load R2 with word from addr 100000
// store R4 to word at addr 200000

Absolute-set
The absolute-set addressing mode assigns a 32-bit constant value to the specified general
register, then uses the assigned value as the effective memory address. For example:
R2 = memw(R1=##400000)
memw(R3=##600000) = R4

5.8.3

// load R2 with word from addr 400000
// and load R1 with value 400000
// store R4 to word at addr 600000
// and load R3 with value 600000

Absolute with register offset
The absolute with register offset addressing mode performs an arithmetic left shift of a 32bit general register value by the amount specified in a 2-bit unsigned immediate value, and
then adds the shifted result to an unsigned 32-bit constant value to create the 32-bit
effective memory address. For example:
R2 = memh(R3 << #3 + ##100000) // load R2 with signed halfword
// from addr [100000 + (R3 << 3)]

The 32-bit constant value is the base address, and the shifted result is the byte offset.
NOTE

80-N2040-46 Rev. B

This addressing mode is useful for loading an element from a global table,
where the immediate value is the name of the table, and the register holds the
index of the element.

85

Hexagon V68 Programmer’s Reference Manual

5.8.4

Memory

Global pointer relative
The global pointer relative addressing mode adds an unsigned offset value to the Hexagon
processor global data pointer GP to create the 32-bit effective memory address. This
addressing mode accesses global and static data in C.
Global pointer relative addresses can be expressed two ways in assembly language:


By explicitly adding an unsigned offset value to register GP



By specifying only an immediate value as the instruction operand

For example:
R2 = memh(GP+#100)

// load R2 with signed halfword
// from [GP + 100 bytes]

R3 = memh(#2000)

// load R3 with signed halfword
// from [GP + #2000 - _SDA_BASE]

Specifying only an immediate value causes the assembler and linker to automatically
subtract the value of the special symbol _SDA_BASE_ from the immediate value, and use
the result as the effective offset from GP.
The global data pointer is programmed in the GDP field of register GP (Section 2.2.8).
This field contains an unsigned 26-bit value which specifies the most significant 26 bits of
the 32-bit global data pointer. (The least significant 6 bits of the pointer are always defined
as zero.)
The memory area referenced by the global data pointer is known as the global data area. It
can be up to 512 KB in length, and – because of the way the global data pointer is
defined – must be aligned to a 64-byte boundary in virtual memory.
When expressed in assembly language, the offset values used in global pointer relative
addressing always specify byte offsets from the global data pointer. The offsets must be
integral multiples of the size of the instruction data type.
Table 5-6 lists the offset ranges for global pointer relative addressing.
Table 5-6

Offset ranges (global pointer relative)
Offset Range

Offset Must Be
Multiple Of

doubleword

0 ... 524280

8

word

0 ... 262140

4

halfword

0 ... 131070

2

byte

0 ... 65535

1

Data Type

NOTE

80-N2040-46 Rev. B

When using global pointer relative addressing, the immediate operand should
be a symbol in the .sdata or .sbss section to ensure that the offset is valid.

86

Hexagon V68 Programmer’s Reference Manual

5.8.5

Memory

Indirect
The indirect addressing mode uses a 32-bit value stored in a general register as the
effective memory address. For example:
R2 = memub(R1)

5.8.6

// load R2 with unsigned byte from addr R1

Indirect with offset
The indirect with offset addressing mode adds a signed offset value to a general register
value to create the 32-bit effective memory address. For example:
R2 = memh(R3 + #100)

// load R2 with signed halfword
// from [R3 + 100 bytes]

When expressed in assembly language, the offset values always specify byte offsets from
the general register value. The offsets must be integral multiples of the size of the
instruction data type.
Table 5-7 lists the offset ranges for indirect with offset addressing.
Table 5-7

Offset ranges (indirect with offset)
Offset Range

Offset Must Be
Multiple Of

doubleword

-8192 ... 8184

8

word

-4096 ... 4092

4

halfword

-2048 ... 2046

2

byte

-1024 ... 1023

1

Data Type

NOTE

5.8.7

The offset range is smaller for conditional instructions (Section 5.9).

Indirect with register offset
The indirect with register offset addressing mode adds a 32-bit general register value to
the result created by performing an arithmetic left shift of a second 32-bit general register
value by the amount specified in a 2-bit unsigned immediate value, forming the 32-bit
effective memory address. For example:
R2 = memh(R3+R4<<#1)

// load R2 with signed halfword
// from [R3 + (R4 << 1)]

The register values always specify byte addresses.

80-N2040-46 Rev. B

87

Hexagon V68 Programmer’s Reference Manual

5.8.8

Memory

Indirect with auto-increment immediate
The indirect with auto-increment immediate addressing mode uses a 32-bit value stored in
a general register to specify the effective memory address. However, after the address is
accessed, a signed value (known as the increment) is added to the register so it specifies a
different memory address (which is accessed in a subsequent instruction). For example:
R2 = memw(R3++#4)

// R3 contains the effective address
// R3 is then incremented by 4

When expressed in assembly language, the increment values always specify byte offsets
from the general register value. The offsets must be integral multiples of the size of the
instruction data type.
Table 5-8 lists the increment ranges for indirect with auto-increment immediate
addressing.
Table 5-8

Increment ranges (indirect with auto-inc immediate)
Increment
Range

Increment Must Be
Multiple Of

doubleword

-64 ... 56

8

word

-32 ... 28

4

halfword

-16 ... 14

2

byte

-8 ... 7

1

Data Type

5.8.9

Indirect with auto-increment register
The indirect with auto-increment register addressing mode is functionally equivalent to
indirect with auto-increment immediate, but uses a modifier register Mx (Section 2.2.4)
instead of an immediate value to hold the increment. For example:
R2 = memw(R0++M1)

// The effective addr is the value of R0.
// Next, M1 is added to R0 and the result
// is stored in R0.

When auto-incrementing with a modifier register, the increment is a signed 32-bit value
which is added to the general register. This offers two advantages over auto-increment
immediate:


A larger increment range



Variable increments (since the modifier register can be programmed at runtime)

The increment value always specifies a byte offset from the general register value.
NOTE

80-N2040-46 Rev. B

The signed 32-bit increment range is identical for all instruction data types
(doubleword, word, halfword, byte).

88

Hexagon V68 Programmer’s Reference Manual

5.8.10

Memory

Circular with auto-increment immediate
The circular with auto-increment immediate addressing mode is a variant of indirect with
auto-increment addressing – it accesses data buffers in a modulo wrap-around fashion.
Circular addressing is commonly used in data stream processing.
Circular addressing is expressed in assembly language with the address modifier
“:circ(Mx)”, where Mx specifies a modifier register which is programmed to specify
the circular buffer (Section 2.2.4). For example:
R0 = memb(R2++#4:circ(M0))
memw(R2++#8:circ(M1)) = R0

// load from R2 in circ buf specified
// by M0
// store to R2 in circ buf specified
// by M1

Circular addressing is set up by programming the following elements:
 The Length field of the Mx register is set to the length (in bytes) of the circular
buffer to access. A circular buffer can be from 4 to (128K-1) bytes long.



Bits 27:24 of the Mx register are always set to 0.
The circular start register CSx that corresponds to Mx (CS0 for M0, CS1 for M1)
is set to the start address of the circular buffer.

In circular addressing, after memory is accessed at the address specified in the general
register, the general register is incremented by the immediate increment value and then
modulo’d by the circular buffer length to implement wrap-around access of the buffer.
When expressed in assembly language, the increment values always specify byte offsets
from the general register value. The offsets must be integral multiples of the size of the
instruction data type.
Table 5-9 lists the increment ranges for circular with auto-increment immediate
addressing.
Table 5-9

Increment ranges (circular with auto-inc immediate)
Increment
Range

Increment Must Be
Multiple Of

doubleword

-64 ... 56

8

word

-32 ... 28

4

halfword

-16 ... 14

2

byte

-8 ... 7

1

Data Type

80-N2040-46 Rev. B

89

Hexagon V68 Programmer’s Reference Manual

Memory

When programming a circular buffer the following rules apply:
 The start address must be aligned to the native access size of the buffer elements.






ABS(Increment) < Length. The absolute value of the increment must be less than
the buffer length.
Access size < (Length-1). The memory access size (1 for byte, 2 for halfword, 4
for word, 8 for doubleword) must be less than (Length-1).
Buffers must not wrap around in the 32-bit address space.

NOTE

If any of these rules are not followed, the execution result is undefined.

For example, a 150-byte circular buffer can be set up and accessed as follows:
R4.H = #0
R4.L = #150
M0 = R4
R2 = ##cbuf
CS0 = R2
R0 = memb(R2++#4:circ(M0))

// M0[27:24]= 0x0
// length = 150
// start addr = cbuf
// Load byte from circ buf
// specified by M0/CS0
// inc R2 by 4 after load
// wrap R2 around if >= 150

The following C function describes the behavior of the circular add function:
unsigned int
fcircadd(unsigned int pointer, int offset,
unsigned int M_reg, unsigned int CS_reg)
{
unsigned int length;
int new_pointer, start_addr, end_addr;
length = (M_reg&0x01ffff); // lower 17-bits gives buffer size
new_pointer = pointer+offset;
start_addr = CS_reg;
end_addr = CS_reg + lenth;
if (new_pointer >= end_addr) {
new_pointer -= length;
} else if (new_pointer < start_addr) {
new_pointer += length;
}
return (new_pointer);
}

80-N2040-46 Rev. B

90

Hexagon V68 Programmer’s Reference Manual

5.8.11

Memory

Circular with auto-increment register
The circular with auto-increment register addressing mode is functionally equivalent to
circular with auto-increment immediate, but uses a register instead of an immediate value
to hold the increment.
Register increments are specified in circular addressing instructions by using the symbol I
as the increment (instead of an immediate value). For example:
R0 = memw(R2++I:circ(M1))

// load byte with incr of I*4 from
// circ buf specified by M1/CS1

When auto-incrementing with a register, the increment is a signed 11-bit value which is
added to the general register. This offers two advantages over circular addressing with
immediate increments:


Larger increment ranges



Variable increments (since the increment register can be programmed at runtime)

The circular register increment value is programmed in the I field of the modifier register
Mx (Section 2.2.4) as part of setting up the circular data access. This register field holds the
signed 11-bit increment value.
Increment values are expressed in units of the buffer element data type, and are
automatically scaled at runtime to the proper data access size.
Table 5-10 lists the increment ranges for circular with auto-increment register addressing.
Table 5-10 Increment ranges (circular with auto-inc register)
Increment
Range

Increment Must Be
Multiple Of

doubleword

-8192 ... 8184

8

word

-4096 ... 4092

4

halfword

-2048 ... 2046

2

byte

-1024 ... 1023

1

Data Type

When programming a circular buffer (with either a register or immediate increment), all
the rules that apply to circular addressing must be followed – for details see
Section 5.8.10.
NOTE

80-N2040-46 Rev. B

If any of these rules are not followed the execution result is undefined.

91

Hexagon V68 Programmer’s Reference Manual

5.8.12

Memory

Bit-reversed with auto-increment register
The bit-reversed with auto-increment register addressing mode is a variant of indirect with
auto-increment addressing – it accesses data buffers using an address value which is the
bit-wise reversal of the value stored in the general register. Bit-reversed addressing is used
in fast Fourier transforms (FFT) and Viterbi encoding.
The bit-wise reversal of a 32-bit address value is defined as follows:




The lower 16 bits are transformed by exchanging bit 0 with bit 15, bit 1 with bit
14, and so on.
The upper 16 bits remain unchanged.

Bit-reversed addressing is expressed in assembly language with the address modifier
“:brev”. For example:
R2 = memub(R0++M1:brev)

// The address is (R0.H | bitrev(R0.L))
// The orginal R0 (not reversed) is added
// to M1 and written back to R0

The initial values for the address and increment must be set in bit-reversed form, with the
hardware bit-reversing the bit-reversed address value to form the effective address.
The buffer length for a bit-reversed buffer must be an integral power of 2, with a
maximum length of 64K bytes.
To support bit-reversed addressing, buffers must be properly aligned in memory. A bitreversed buffer is properly aligned when its starting byte address is aligned to a power of 2
greater than or equal to the buffer size (in bytes). For example:
int bitrev_buf[256] __attribute__((aligned(1024)));

The bit-reversed buffer declared above is aligned to 1024 bytes because the buffer size is
1024 bytes (256 integer words  4 bytes), and 1024 is an integral power of 2.
The buffer location pointer for a bit-reversed buffer must be initialized so the leastsignificant 16 bits of the address value are bit-reversed.
The increment value must be initialized to the following value:
bitreverse(buffer_size_in_bytes / 2)

...where bitreverse is defined as bit-reversing the least-significant 16 bits while leaving
the remaining bits unchanged.
NOTE

To simplify the initialization of the bit-reversed pointer, bit-reversed buffers
can be aligned to a 64K byte boundary. This initializes the bit-reversed pointer
to the base address of the bit-reversed buffer, with no bit-reversing required
for the least-significant 16 bits of the pointer value (which are all set to 0 by
the 64K alignment).
Since buffers allocated on the stack only have an alignment of 8 bytes or less,
in most cases bit-reversed buffers should not be declared on the stack.

80-N2040-46 Rev. B

92

Hexagon V68 Programmer’s Reference Manual

Memory

After a bit-reversed memory access is completed, the general register is incremented by
the register increment value. The value in the general register is never affected by the bitreversal that is performed as part of the memory access.
NOTE

5.9

The Hexagon processor supports only register increments for bit-reversed
addressing – it does not support immediate increments.

Conditional load/stores
Some load and store instructions can be executed conditionally based on predicate values
which were set in a previous instruction. The compiler generates conditional loads and
stores to increase instruction-level parallelism.
Conditional loads and stores are expressed in assembly language with the instruction
prefix “if (pred_expr)”, where pred_expr specifies a predicate register expression
(Section 6.1). For example:
if (P0) R0 = memw(R2)
if (!P2) memh(R3 + #100) = R1
if (P1.new) R3 = memw(R3++#4)

// conditional load
// conditional store
// conditional load

Not all addressing modes are supported in conditional loads and stores. Table 5-11 shows
which modes are supported.
Table 5-11

Addressing modes (conditional load/store)
Addressing Mode

Conditional

Absolute

Yes

Absolute-set

No

Absolute with register offset

No

Global pointer relative

No

Indirect

Yes

Indirect with offset

Yes

Indirect with register offset

Yes

Indirect with auto-increment immediate

Yes

Indirect with auto-increment register

No

Circular with auto-increment immediate

No

Circular with auto-increment register

No

Bit-reversed with auto-increment register

No

When a conditional load or store instruction uses indirect-with-offset addressing mode, the
offset range is smaller than the range normally defined for indirect-with-offset addressing
(Section 5.8.6).

80-N2040-46 Rev. B

93

Hexagon V68 Programmer’s Reference Manual

Memory

Table 5-12 lists the conditional and normal offset ranges for indirect-with-offset
addressing.
Table 5-12 Conditional offset ranges (indirect with offset)
Offset Range
(Conditional)

Offset Range
(Normal)

Offset Must Be
Multiple Of

doubleword

0 ... 504

-8192 ... 8184

8

word

0 ... 252

-4096 ... 4092

4

halfword

0 ... 126

-2048 ... 2046

2

byte

0 ... 63

-1024 ... 1023

1

Data Type

NOTE

5.10

For more information on conditional execution see Chapter 6.

Cache memory
The Hexagon processor has a cache-based memory architecture:


A level 1 instruction cache holds recently-fetched instructions.



A level 1 data cache holds recently-accessed data memory.

Load/store operations that access memory through the level 1 caches are referred to as
cached accesses.
Load/stores that bypass the level 1 caches are referred to as uncached accesses.
Specific memory areas can be configured so they perform cached or uncached accesses.
This configuration is performed by the Hexagon processor’s memory management unit
(MMU). The operating system is responsible for programming the MMU.
Two types of caching are supported (as cache modes):




Write-through caching keep the cache data consistent with external memory by
always writing to the memory any data that is stored in the cache.
Write-back caching stores data in the cache without being immediately written to
external memory. Cached data that is inconsistent with external memory is
referred to as dirty.

The Hexagon processor includes dedicated cache maintenance instructions that push dirty
data out to external memory.

80-N2040-46 Rev. B

94

Hexagon V68 Programmer’s Reference Manual

5.10.1

Memory

Uncached memory
In some cases load/store operations need to bypass the cache memories and be serviced
externally (for example, when accessing memory-mapped I/O, registers, and peripheral
devices, or other system defined entities). The operating system is responsible for
configuring the MMU to generate uncached memory accesses.
Uncached memory is categorized into two distinct types:




Device-type is for accessing memory that has side-effects (such as a memorymapped FIFO peripheral). The hardware ensures that interrupts do not cancel a
pending device access. The hardware does not re-order device accesses.
Peripheral control registers should be marked as device-type.
Uncached-type is for memory-like memory. No side effects are associated with an
access. The hardware can load from uncached memory multiple times. The
hardware can re-order uncached accesses.

For instruction accesses, device-type memory is functionally identical to uncached-type
memory. For data accesses, they are different.
Code can be executed directly from the L2 cache, bypassing the L1 cache.

5.10.2

Tightly coupled memory
The Hexagon processor supports tightly-coupled instruction memory at Level 1, which is
defined as memory with similar access properties to the instruction cache.
Tightly-coupled memory is also supported at level 2, which is defined as backing store to
the primary caches.
For more information see Chapter 9.

5.10.3

Cache maintenance operations
The Hexagon processor includes dedicated cache maintenance instructions that invalidate
cache data or push dirty data out to external memory.
The cache maintenance instructions operate on specific memory addresses. If the
instruction causes an address error (due to a privilege violation), the processor raises an
exception.
NOTE

The exception to this rule is dcfetch, which never causes a processor
exception.

Whenever maintenance operations are performed on the instruction cache, the isync
instruction (Section 5.11) must be executed immediately afterwards. This instruction
ensures that the maintenance operations are observed by subsequent instructions.

80-N2040-46 Rev. B

95

Hexagon V68 Programmer’s Reference Manual

Memory

Table 5-13 lists the cache maintenance instructions.
Table 5-13 Cache instructions (user-level)
Syntax

icinva(Rs)

dccleaninva(Rs)

Permitted In
Packet
Solo 1

Instruction cache invalidate.
Look up instruction cache at address Rs.
If the address is in the cache, invalidate it.

Slot 1

Data cache clean and invalidate.

empty or
ALU32 only

dccleana(Rs)

Slot 1
empty or
ALU32 only

dcinva(Rs)

Operation

Slot 1

Look up data cache at address Rs.
If the address is in the cache and has dirty data, flush
that data out to memory. The cache line is then
invalidated, whether or not dirty data was written.
Data cache clean.
Look up data cache at address Rs.
If the address is in the cache and has dirty data, flush
that data out to memory.
Equivalent to dccleaninva(Rs).

empty or
ALU32 only

dcfetch(Rs)

Normal 2

Data cache prefetch.
Prefetch data at address Rs into the data cache.
NOTE - This instruction does not cause an exception.

l2fetch(Rs,Rt)

1
2

5.10.4

ALU32 or
XTYPE only

L2 cache prefetch.
Prefetch data from memory specified by Rs and Rt
into L2 cache.

Solo means that the instruction must not be grouped with other instructions in a packet.
Normal means that the normal instruction-grouping constraints apply.

L2 cache operations
The cache maintenance operations (Section 5.10.3) operate on both the L1 and L2 caches.
The data cache coherency operations (including clean, invalidate, and clean and
invalidate) affect both the L1 and L2 caches, and ensure that the memory hierarchy
remains coherent.
However, the instruction cache invalidate operation affects only the L1 cache. Therefore,
invalidating instructions that may be in the L1 or L2 caches requires a two-step procedure:
1. Use icinva to invalidate instructions from the L1 cache.
2. Use dcinva separately to invalidate instructions from the L2 cache.

80-N2040-46 Rev. B

96

Hexagon V68 Programmer’s Reference Manual

5.10.5

Memory

Cache line zero
The Hexagon processor includes the instruction dczeroa. This instruction allocates a line
in the L1 data cache and clears it (by storing all zeros). The behavior is as follows:






The Rs register value must be 32-byte aligned. If it is unaligned, the processor
raises an unaligned error exception.
In the case of a cache hit, the specified cache line is cleared (i.e., written with all
zeros) and made dirty.
In the case of a cache miss, the specified cache line is not fetched from external
memory. Instead, the line is allocated in the data cache, cleared, and made dirty.

This instruction is useful in optimizing write-only data. It allows for the use of write-back
pages – which are the most power and performance efficient – without the need to initially
fetch the line to write. This removes unnecessary read bandwidth and latency.
NOTE

dczeroa has the same exception behavior as write-back stores.

A packet with dczeroa must have Slot 1 either empty or containing an
ALU32 instruction.

5.10.6

Cache prefetch
The Hexagon processor supports the following types of cache prefetching:


Hardware-based instruction cache prefetching



Software-based data cache prefetching



Software-based L2FETCH



Hardware-based data cache prefetching

Hardware-based instruction cache prefetching

L1 and L2 instruction cache prefetching can be enabled or disabled on a per-thread basis –
this is done by setting the HFI field in the user status register (Section 2.2.3).
Software-based data cache prefetching

The Hexagon processor includes the instruction dcfetch. This instruction queries the L1
data cache based on the address specified in the instruction:





80-N2040-46 Rev. B

If the address is present in the cache, no action is taken.
If the cache line for the address is missing, the processor attempts to fill the cache
line from the next level of memory. The thread does not stall, but rather continues
executing while the cache line fill occurs in the background.
If the address is invalid, no exception is generated and the dcfetch instruction is
treated as a NOP.

97

Hexagon V68 Programmer’s Reference Manual

Memory

Software-based L2FETCH

More powerful L2 prefetching – of data or instructions – is provided by the l2fetch
instruction, which specifies an area of memory that is prefetched by the Hexagon
processor’s hardware prefetch engine. l2fetch specifies two registers (Rs and Rt) as
operands. Rs contains the 32-bit virtual start address of the memory area to prefetch. Rt
contains three bit fields which further specify the memory area:


Rt[15:8] – Width, specifies the width (in bytes) of a block of memory to fetch.



Rt[7:0] – Height, specifies the number of Width-sized blocks to fetch.



Rt[31:16] – Stride, specifies an unsigned byte offset that increments the pointer
after each Width-sized block is fetched.

The l2fetch instruction is non-blocking: it initiates a prefetch operation that is performed
in the background by the prefetch engine while the thread continues to execute Hexagon
processor instructions.
The prefetch engine requests all lines in the specified memory area. If the line(s) of
interest are already resident in the L2 cache, the prefetch engine performs no action. If the
lines are not in the L2 cache, the prefetch engine attempts to fetch them.
The prefetch engine makes a best effort to prefetch the requested data, and attempts to
perform prefetching at a lower priority than demand fetches. This prevents the prefetch
engine from adding bus traffic when the system is under a heavy load.
If a program executes an l2fetch instruction while the prefetch operation from a
previous l2fetch is still active, the prefetch engine halts the current prefetch operation.
NOTE

Executing l2fetch with any bit field operand programmed to zero cancels all
prefetch activity.

The status of the current prefetch operation is maintained in the PFA field of the user
status register (Section 2.2.3). This field can determine whether a prefetch operation has
completed.
With respect to MMU permissions and error checking, the l2fetch instruction behaves
similarly to a load instruction. If the virtual address causes a processor exception, the
exception is taken. This differs from the dcfetch instruction, which is treated as a NOP in
the presence of a translation/protection error.
NOTE

Prefetches are dropped when the generated prefetch address resides on a
different page than the start address. The programmer must use sufficiently
large pages to ensure this does not occur.

Figure 5-2 shows two examples of using the l2fetch instruction. The first shows a ‘box’
prefetch, where a 2-D range of memory is defined within a larger frame. The second
example shows a prefetch for a large linear memory area of size (Lines * 128).

80-N2040-46 Rev. B

98

Hexagon V68 Programmer’s Reference Manual

Memory

L2FETCH for large linear prefetch

L2FETCH for box prefetch
31

Rt

8 7

16 15

Stride

Rs

Width

31

0

Height

Start Address

Rt

128

Rs

8 7

16 15

128

0

Lines

Start Address

Stride

Width

Height

Prefetch
Area

128* Lines

Figure 5-2 L2FETCH instruction

Hardware-based data cache prefetching

L1 data cache prefetching can be enabled or disabled on a per-thread basis – this is done
by setting the HFD field in the user status register (Section 2.2.3).
When data cache prefetching is enabled, the Hexagon processor observes patterns of data
cache misses, and attempts to predict future misses based on any recurring patterns of
misses where the addresses are separated by a constant stride. If such patterns are found,
the processor attempts to automatically prefetch future cache lines.
Data cache prefetching can be user-enabled at four levels of aggressiveness:







80-N2040-46 Rev. B

HFD = 00: No prefetching
HFD = 01: Prefetch up to 4 lines for misses originating from a load, with a postupdate addressing mode that occurs within a hardware loop
HFD = 10: Prefetch up to 4 lines for misses originating from loads that occur
within a hardware loop
HFD = 11: Prefetch up to 8 lines for misses originating from loads

99

Hexagon V68 Programmer’s Reference Manual

5.11

Memory

Memory ordering
Some devices may require synchronization of stores and loads when they are accessed. In
this case a set of processor instructions enable programmer control of the synchronization
and ordering of memory accesses.
Table 5-14 lists the memory-ordering instructions.
Table 5-14 Memory ordering instructions
Syntax

isync

Operation
Instruction synchronize.
This instruction should be executed after any instruction cache maintenance
operation.

syncht

Synchronize transactions.
Perform “heavyweight” synchronization. Ensure that all previous program
transactions (e.g., memw_locked, cached and uncached load/store) have
completed before execution resumes past this instruction.
syncht ensures that outstanding memory operations from all threads are
complete before the syncht instruction is committed.

barrier

Set memory barrier.
Ensure proper ordering between the program accesses performed before the
instruction and those performed after the instruction.
All accesses before the barrier are globally observable before any access
occurring after the barrier can be observed.
barrier ensures that all outstanding memory operations from the thread
executing the barrier are complete before the instruction is committed.

Data memory accesses and program memory accesses are treated separately and held in
separate caches. Software should ensure coherency between data and program code if
necessary.
For example, with generated or self-modified code, the modified code is placed in the data
cache and may be inconsistent with program cache. The software must explicitly force
modified data cache lines to memory (either by using a write-through policy, or through
explicit cache clean instructions). Use abarrier instruction to ensure completion of the
stores. Finally, invalidate relevant instruction cache contents so the new instructions can
be re-fetched.

80-N2040-46 Rev. B

100

Hexagon V68 Programmer’s Reference Manual

Memory

Here is the recommended code sequence to change and then execute an instruction:
ICINVA(R1)
ISYNC
MEMW(R1)=R0
DCCLEANINVA(R1)
SYNCHT
JUMPR R1
NOTE

// clear code from instruction cache
// ensure that ICINVA is finished
// write the new instruction
// force data out of data cache
// ensure that it’s in memory
// can now execute code at R1

The memory-ordering instructions must not be grouped with other
instructions in a packet, otherwise the behavior is undefined.
This code sequence differs from the one used in previous processor versions.

5.12

Atomic operations
The Hexagon processor includes an LL/SC (Load Locked / Store Conditional) mechanism
to provide the atomic read-modify-write operation that is necessary to implement
synchronization primitives such as semaphores and mutexes.
These primitives synchronize the execution of different software programs running
concurrently on the Hexagon processor. They can also provide atomic memory support
between the Hexagon processor and external blocks.
Table 5-15 describes the atomic instructions.
Table 5-15 Atomic instructions
Syntax

Rd = memw_locked(Rs)

Description
Load locked word.
Reserve lock on word at address Rs.

memw_locked(Rs,Pd) = Rt

Store conditional word.
If no other atomic operation has been performed at
the address (i.e., atomicity is ensured), perform the
store to the word at address Rs and return TRUE in
Pd; otherwise return FALSE.
TRUE indicates that the LL and SC operations have
been performed atomically.

Rdd = memd_locked(Rs)

Load locked doubleword.
Reserve lock on doubleword at address Rs.

memd_locked(Rs,Pd) = Rtt

Store conditional doubleword.
If no other atomic operation has been performed at
the address (i.e., atomicity is ensured), perform the
store to the doubleword at address Rs and return
TRUE in Pd; otherwise return FALSE.
TRUE indicates that the LL and SC operations have
been performed atomically.

80-N2040-46 Rev. B

101

Hexagon V68 Programmer’s Reference Manual

Memory

Here is the recommended code sequence to acquire a mutex:
// assume mutex address is held in R0
// assume R1,R3,P0,P1 are scratch
lockMutex:
R3 = #1
lock_test_spin:
R1 = memw_locked(R0)
P1 = cmp.eq(R1,#0)
if (!P1) jump lock_test_spin
memw_locked(R0,P0) = r3
if (!P0) jump lock_test_spin

// do normal test to wait
// for lock to be available
// do store conditional (SC)
// was LL and SC done atomically?

Here is the recommended code sequence to release a mutex:
// assume mutex address is held in R0
// assume R1 is scratch
R1 = #0
memw(R0) = R1

Atomic memX_locked operations are supported for external accesses that use the AXI bus
and support atomic operations. To perform load-locked operations with external memory,
the operating system must define the memory page as uncacheable, otherwise the
processor behavior is undefined.
If a load locked operation is performed on an address that does not support atomic
operations, the behavior is undefined.
For atomic operations on cacheable memory, the page attributes must be set to cacheable
and write-back, otherwise the behavior is undefined. Cacheable memory must be used
when threads need to synchronize with each other.
NOTE

80-N2040-46 Rev. B

External memX_locked operations are not supported on the AHB bus. If they
are performed on the AHB bus, the behavior is undefined.

102

Conditional Execution

6

The Hexagon processor uses a conditional execution model based on compare instructions
that set predicate bits in one of four 8-bit predicate registers (P0-P3). These predicate bits
can conditionally execute certain instructions.
Conditional scalar operations examine only the least-significant bit in a predicate register,
while conditional vector operations examine multiple bits in the register.
Branch instructions are the main consumers of the predicate registers.

6.1

Scalar predicates
Scalar predicates are 8-bit values which are used in conditional instructions to represent
truth values:


0xFF represents true



0x00 represents false

The Hexagon processor provides the four 8-bit predicate registers P0-P3 to hold scalar
predicates (Section 2.2.5). These registers are assigned values by the predicate-generating
instructions, and examined by the predicate-consuming instructions.

80-N2040-46 Rev. B

103

Hexagon V68 Programmer’s Reference Manual

6.1.1

Conditional Execution

Generating scalar predicates
The following instructions generate scalar predicates:


Compare byte, halfword, word, doubleword



Compare single- and double-precision floating point



Classify floating-point value



Compare bitmask



Bounds check



TLB match



Store conditional

Table 6-1 lists the scalar predicate-generating instructions.
Table 6-1

Scalar predicate-generating instructions
Syntax

Operation

Pd = cmpb.eq(Rs,{Rt,#u8})
Pd = cmph.eq(Rs,{Rt,#s8})
Pd = [!]cmp.eq(Rs,{Rt,#s10})
Pd = cmp.eq(Rss,Rtt)
Pd = sfcmp.eq(Rs,Rt)
Pd = dfcmp.eq(Rss,Rtt)

Equal (signed).

Pd = cmpb.gt(Rs,{Rt,#s8}
Pd = cmph.gt(Rs,{Rt,#s8})
Pd = [!]cmp.gt(Rs,{Rt,#s10})
Pd = cmp.gt(Rss,Rtt)
Pd = sfcmp.gt(Rs,Rt)
Pd = dfcmp.gt(Rss,Rtt)

Greater than (signed).
Compare register Rs to Rt or a signed immediate for
signed greater than. Assign Pd the resulting truth
value.

Pd = cmpb.gtu(Rs,{Rt,#u7})
Pd = cmph.gtu(Rs,{Rt,#u7})
Pd = [!]cmp.gtu(Rs,{Rt,#u9})
Pd = cmp.gtu(Rss,Rtt)

Greater than (unsigned).

Pd = cmp.ge(Rs,#s8)
Pd = sfcmp.ge(Rs,Rt)
Pd = dfcmp.ge(Rss,Rtt)

Greater than or equal (signed).

Pd = cmp.geu(Rs,#u8)

Greater than or equal (unsigned).

Compare register Rs to Rt or a signed immediate for
equality. Assign Pd the resulting truth value.

Compare register Rs to Rt or an unsigned immediate
for unsigned greater than. Assign Pd the resulting
truth value.
Compare register Rs to Rt or a signed immediate for
signed greater than or equal. Assign Pd the resulting
truth value.
Compare register Rs to an unsigned immediate for
unsigned greater than or equal. Assign Pd the
resulting truth value.

Pd = cmp.lt(Rs,Rt)

Less than (signed).
Compare register Rs to Rt for signed less than.
Assign Pd the resulting truth value.

Pd = cmp.ltu(Rs,Rt)

Less than (unsigned).
Compare register Rs to Rt for unsigned less than.
Assign Pd the resulting truth value.

80-N2040-46 Rev. B

104

Hexagon V68 Programmer’s Reference Manual

Table 6-1

Conditional Execution

Scalar predicate-generating instructions (Continued)

Pd = sfcmp.uo(Rs,Rt)
Pd = dfcmp.uo(Rss,Rtt)

Unordered (signed).
Determine if register Rs or Rt is set to the value NaN.
Assign Pd the resulting truth value.

Pd=sfclass(Rs,#u5)
Pd=dfclass(Rss,#u5)

Classify value (signed).

Pd = [!]tstbit(Rs,{Rt,#u5})

Test if bit set.
Rt or an unsigned immediate specifies a bit position.

Determine if register Rs is set to any of the specified
classes. Assign Pd the resulting truth value.

Test if the bit in Rs that is specified by the bit position
is set. Assign Pd the resulting truth value.

Pd = [!]bitsclr(Rs,{Rt,#u6})

Test if bits clear.
Rt or an unsigned immediate specifies a bitmask.
Test if the bits in Rs that are specified by the bitmask
are all clear. Assign Pd the resulting truth value.

Pd = [!]bitsset(Rs,Rt)

Test if bits set.
Rt specifies a bitmask.
Test if the bits in Rs that are specified by the bitmask
are all set. Assign Pd the resulting truth value.

memw_locked(Rs,Pd) = Rt
memd_locked(Rs,Pd) = Rtt

Store conditional.

Pd = boundscheck(Rs,Rtt)

Bounds check.

If no other atomic operation has been performed at
the address (i.e., atomicity is ensured), perform the
store to the word at address Rs. Assign Pd the
resulting truth value.
Determine if Rs falls in the numeric range defined by
Rtt. Assign Pd the resulting truth value.

Pd = tlbmatch(Rss,Rt)

NOTE

80-N2040-46 Rev. B

Determine if TLB entry in Rss matches the ASID:PPN
specified in Rt. Assign Pd the resulting truth value.

One of the compare instructions (cmp.eq) includes a variant which stores a
binary predicate value (0 or 1) in a general register not a predicate register.

105

Hexagon V68 Programmer’s Reference Manual

6.1.2

Conditional Execution

Consuming scalar predicates
Certain instructions can be conditionally executed based on the value of a scalar predicate
(or alternatively specify a scalar predicate as an input to their operation).
The conditional instructions that consume scalar predicates examine only the leastsignificant bit of the predicate value. In the simplest case, this bit value directly determines
whether the instruction is executed:


1 indicates that the instruction is executed



0 indicates that the instruction is not executed

If a conditional instruction includes the operator ! in its predicate expression, the logical
negation of the bit value determines whether the instruction is executed.
Conditional instructions are expressed in assembly language with the instruction prefix
“if (pred_expr)”, where pred_expr specifies the predicate expression. For example:
if (P0) jump target
if (!P2) R2 = R5
if (P1) R0 = sub(R2,R3)
if (P2) R0 = memw(R2)

// jump if P0 is true
// assign register if !P2 is true
// conditionally subtract if P1
// conditionally load word if P2

The following instructions can be used as conditional instructions:


Jumps and calls (Section 8.3)



Many load and store instructions (Section 5.9)



Logical instructions (including AND/OR/XOR)



Shift halfword



32-bit add/subtract by register or short immediate



Sign and zero extend



32-bit register transfer and 64-bit combine word



Register transfer immediate



Deallocate frame and return

When a conditional load or store is executed and the predicate expression is false, the
instruction is cancelled (including any exceptions that might occur). For example, if a
conditional load uses an address with a memory permission violation, and the predicate
expression is false, the load does not execute and the exception is not raised.
The mux instruction accepts a predicate as one of its basic operands:
Rd = mux(Ps,Rs,Rt)
mux selects either Rs or Rt based on the least significant bit in Ps. If the least-significant
bit in Ps is a 1, Rd is set to Rs, otherwise it is set to Rt.

80-N2040-46 Rev. B

106

Hexagon V68 Programmer’s Reference Manual

6.1.3

Conditional Execution

Auto-AND predicates
If multiple compare instructions in a packet write to the same predicate register, the result
is the logical AND of the individual compare results. For example:
{
P0 = cmp(A)
P0 = cmp(B)
if (P0.new) jump:T taken_path
}

// if A && B then jump

To perform the corresponding OR operation, the following instructions can compute the
negation of an existing compare (using De Morgan’s law):


Pd = !cmp.{eq,gt}(Rs, {#s10,Rt} )



Pd = !cmp.gtu(Rs, {#u9,Rt} )



Pd = !tstbit(Rs, {#u5,Rt} )



Pd = !bitsclr(Rs, {#u6,Rt} )



Pd = !bitsset(Rs,Rt)

Auto-AND predicates have the following restrictions:






If a packet contains endloopN, it cannot perform an auto-AND with predicate
register P3.
If a packet contains a register transfer from a general register to a predicate
register, no other instruction in the packet can write to the same predicate register.
(As a result, a register transfer to P3:0 or C5:4 cannot be grouped with any other
predicate-writing instruction.)
The instructions spNloop0, decbin, tlbmatch, memw_locked, memd_locked,
add:carry, sub:carry, sfcmp, and dfcmp cannot be grouped with another
instruction that sets the same predicate register.

NOTE

80-N2040-46 Rev. B

A register transfer from a predicate register to a predicate register has the
same auto-AND behavior as a compare instruction.

107

Hexagon V68 Programmer’s Reference Manual

6.1.4

Conditional Execution

Dot-new predicates
The Hexagon processor can generate and use a scalar predicate in the same instruction
packet (Section 3.3). This feature is expressed in assembly language by appending the
suffix “.new” to the specified predicate register. For example:
if (P0.new) R3 = memw(R4)

To see how dot-new predicates are used, consider the following C statement and the
corresponding assembly code that is generated from it by the compiler:
C statement
if (R2 == 4)
R3 = *R4;
else
R5 = 5;

Assembly code
{
P0 = cmp.eq(R2,#4)
if (P0.new) R3 = memw(R4)
if (!P0.new) R5 = #5
}

In the assembly code, a scalar predicate is generated and then consumed twice within the
same instruction packet.
The following conditions apply to using dot-new predicates:




The predicate must be generated by an instruction in the same packet. The
assembler normally enforces this restriction, but if the processor executes a packet
that violates this restriction, the execution result is undefined.
A single packet can contain both the dot-new and normal forms of predicates. The
normal form examines the old value in the predicate register, rather than the
newly-generated value. For example:
{
P0 = cmp.eq(R2,#4)
if (P0.new) R3 = memw(R4)
if (P0) R5 = #5

// use newly-generated P0 value
// use previous P0 value

}

80-N2040-46 Rev. B

108

Hexagon V68 Programmer’s Reference Manual

6.1.5

Conditional Execution

Dependency constraints
Two instructions in an instruction packet should not write to the same destination register
(Section 3.3.5). An exception to this rule is if the two instructions are conditional, and
only one of them ever has the predicate expression value true when the packet is
executed.
For example, the following packet is valid as long as P2 and P3 never both evaluate to
true when the packet is executed:
{
if (P2) R3 = #4
if (P3) R3 = #7

// P2, P3, or both must be false

}

Because predicate values change at runtime, the programmer is responsible for ensuring
that such packets are always valid during program execution. If they are invalid, the
processor takes the following actions:

6.2



When writing to general registers, an error exception is raised.



When writing to predicate or control registers, the result is undefined.

Vector predicates
The predicate registers are also used for conditional vector operations. Unlike scalar
predicates, vector predicates contain multiple truth values which are generated by vector
predicate-generating operations.
For example, a vector compare instruction compares each element of a vector and assigns
the compare results to a predicate register. Each bit in the predicate vector contains a truth
value indicating the outcome of a separate compare performed by the vector instruction.
The vector mux instruction uses a vector predicate to selectively merge elements from two
separate vectors into a single destination vector. This operation is useful for enabling the
vectorization of loops with control flow (i.e., branches).
The vector instructions that use predicates are described in the following sections.

6.2.1

Vector compare
A vector compare instruction inputs two 64-bit vectors, performs separate compares for
each pair of vector elements, and generates a predicate value which contains a bit vector of
truth values.

80-N2040-46 Rev. B

109

Hexagon V68 Programmer’s Reference Manual

Conditional Execution

Figure 6-1 shows an example of a vector byte compare.
Rss
Rtt

cmp

cmp

cmp

cmp

cmp

cmp

1

1

1

1

0

0

0

cmp

Pd

0

7

cmp

0

Figure 6-1 Vector byte compare

In Figure 6-1 two 64-bit vectors of bytes (contained in Rss and Rtt) are being compared.
The result is assigned as a vector predicate to the destination register Pd.
In the example vector predicate shown in Figure 6-1, every other compare result in the
predicate is true (i.e., 1).
Figure 6-2 shows how a vector halfword compare generates a vector predicate.
Rss
Rtt

cmp

cmp

1

1

0

cmp

0

1

7

1

0

cmp

0

Pd

0

Figure 6-2 Vector halfword compare

In Figure 6-2 two 64-bit vectors of halfwords are being compared. The result is assigned
as a vector predicate to the destination register Pd.
Because a vector halfword compare yields only four truth values, each truth value is
encoded as two bits in the generated vector predicate.

80-N2040-46 Rev. B

110

Hexagon V68 Programmer’s Reference Manual

6.2.2

Conditional Execution

Vector mux instruction
A vector mux instruction conditionally selects the elements from two vectors. The
instruction takes as input two source vectors and a predicate register. For each byte in the
vector, the corresponding bit in the predicate register is used to choose from one of the two
input vectors. The combined result is written to the destination register.
Figure 6-3 shows the operation of the vector mux instruction.
Rss
Rtt

mux
mux
mux
P[7]
P[5]
P[6]

mux
P[4]

mux
mux
mux
mux
P[3]
P[2]
P[1]
P[0]

Rdd

Figure 6-3 Vector mux instruction

Table 6-2 defines the vector mux instruction.
Table 6-2

Vector mux instruction
Syntax

Rdd = vmux(Ps,Rss,Rtt)

Operation
Select bytes from Rss and Rtt

Changing the order of the source operands in a mux instruction enables formation of both
senses of the result. For example:
R1:0 = vmux(P0,R3:2,R5:4)
R1:0 = vmux(P0,R5:4,R3:2)
NOTE

80-N2040-46 Rev. B

// choose bytes from R3:2 if true
// choose bytes from R3:2 if false

By replicating the predicate bits generated by word or halfword compares, the
vector mux instruction can select words or halfwords.

111

Hexagon V68 Programmer’s Reference Manual

6.2.3

Conditional Execution

Using vector conditionals
Vector conditional support is used to vectorize loops with conditional statements.
Consider the following C statement:
for (i=0; i<8; i++) {
if (A[i]) {
B[i] = C[i];
}
}

Assuming arrays of bytes, this code can be vectorized as follows:
R1:0 = memd(R_A)
// R1:0 holds A[7]-A[0]
R3 = #0
// clear R3:2
R2 = #0
P0 = vcmpb.eq(R1:0,R3:2)
// compare bytes in A to zero
R5:4 = memd(R_B)
// R5:4 holds B[7]-B[0]
R7:6 = memd(R_C)
// R7:6 holds C[7]-C[0]
R3:2 = vmux(P0,R7:6,R5:4)
// if (A[i]) B[i]=C[i]
memd(R_B) = R3:2
// store B[7]-B[0]

80-N2040-46 Rev. B

112

Hexagon V68 Programmer’s Reference Manual

6.3

Conditional Execution

Predicate operations
The Hexagon processor provides a set of operations for manipulating and moving
predicate registers.
Table 6-3 lists the predicate register instructions.
Table 6-3

Predicate register instructions
Syntax

Operation

Pd = Ps

Transfer predicate Ps to Pd

Pd = Rs

Transfer register Rs to predicate Pd

Rd = Ps

Transfer predicate Ps to register Rd

Pd = and(Ps,[!]Pt)

Set Pd to bitwise AND of Ps and [NOT] Pt

Pd = or(Ps,[!]Pt)

Set Pd to bitwise OR of Ps and [NOT] Pt

Pd = and(Ps, and(Pt,[!]Pu)

Set Pd to AND of Ps and (AND of Pt and [NOT] Pu)

Pd = and(Ps, or(Pt,[!]Pu)

Set Pd to AND of Ps and (OR of Pt and [NOT] Pu)

Pd = or(Ps, and(Pt,[!]Pu)

Set Pd to OR of Ps and (AND of Pt and [NOT] Pu)

Pd = or(Ps, or(Pt,[!]Pu)

Set Pd to OR of Ps and (OR of Pt and [NOT] Pu)

Pd = not(Ps)

Set Pd to bitwise inversion of Ps

Pd = xor(Ps,Pt)

Set Pd to bitwise exclusive OR of Ps and Pt

Pd = any8(Ps)

Set Pd to 0xFF if any bit in Ps is 1, 0x00 otherwise

Pd = all8(Ps)

Set Pd to 0x00 if any bit in Ps is 0, 0xFF otherwise

NOTE

These instructions belong to instruction class CR.
Predicate registers can be transferred to and from the general registers either
individually or as register quadruples (Section 2.2.5).

80-N2040-46 Rev. B

113

7 Software Stack
The Hexagon processor includes dedicated registers and instructions to support a call
stack for subroutine execution.
The stack structure follows standard C conventions.

7.1

Stack structure
The stack is defined to grow from high addresses to low addresses. The stack pointer
register SP points to the data element that is currently on the top of the stack.

80-N2040-46 Rev. B

114

Hexagon V68 Programmer’s Reference Manual

Software Stack

Figure 7-1 shows the stack structure.
Stack in Memory
Saved LR
Saved FP

Higher Address
Procedure Local
Data on Stack
Stack frame

Saved LR
Saved FP

FP register

Procedure Local
Data on Stack
SP register

Lower Address

Unallocated Stack

Figure 7-1 Stack structure
NOTE

The Hexagon processor supports three dedicated stack instructions:
allocframe, deallocframe, and dealloc_return (Section 7.5).
The SP address must always remain 8-byte aligned for the stack instructions
to work properly.

7.2

Stack frames
The stack is used to store stack frames, which are data structures that store state
information on the active subroutines in a program (i.e., those that were called but have
not yet returned). Each stack frame corresponds to an active subroutine in the program.
A stack frame contains the following elements:

80-N2040-46 Rev. B

115

Hexagon V68 Programmer’s Reference Manual

Software Stack



The local variables and data used by the subroutine



The return address for the subroutine call (pushed from the link register LR)



The address of the previous stack frame allocated on the stack (pushed from the
frame pointer register FP)

The frame pointer register FP always contains the address of the saved frame pointer in
the current stack frame. It facilitates debugging by enabling a debugger to examine the
stack in memory and easily determine the call sequence, function parameters, etc.
NOTE

7.3

For leaf functions it is often unnecessary to save FP and LR. In this case FP
contains the frame pointer of the calling function, not the current function.

Stack protection
The Hexagon V6x processor supports the following features to protect the integrity of the
software stack:

7.3.1



Stack bounds checking



Stack smashing protection

Stack bounds checking
Stack bounds checking prevents a stack frame from being allocated past the lower
boundary of the software stack.
FRAMELIMIT is a 32-bit control register which stores a memory address that specifies the
lower bound of the memory area reserved for the software stack. When the allocframe
instruction allocates a new stack frame, it compares the new stack pointer value in SP with
the stack bound value in FRAMELIMIT. If SP is less than FRAMELIMIT, the Hexagon

processor raises exception 0x27 (Section 8.10).
NOTE

7.3.2

Stack bounds checking is performed when the processor is in User and Guest
modes, but not in Monitor mode.

Stack smashing protection
Stack smashing is a technique malicious code uses to gain control over an executing
program. Malicious code causes buffer overflows to occur in a procedure’s local data, with
the goal of modifying the subroutine return address stored in a stack frame so it points to
the malicious code instead of the intended return code.
Stack smashing protection prevents this from happening by scrambling the subroutine
return address when a new stack frame is allocated, and then unscrambling the return
address when the frame is deallocated. Because the value in FRAMEKEY changes regularly
and varies from device to device, it becomes difficult to precalculate a malicious return
address.

80-N2040-46 Rev. B

116

Hexagon V68 Programmer’s Reference Manual

Software Stack

FRAMEKEY is a 32-bit control register which scrambles return addresses stored on the

stack:




In the allocframe instruction, the 32-bit return address in link register LR is
XOR-scrambled with the value in FRAMEKEY before it is stored in the new stack
frame.
In deallocframe and dealloc_return, the return address loaded from the stack
frame is unscrambled with the value in FRAMEKEY before it is stored in LR.

After a processor reset, the default value of FRAMEKEY is 0. If this value is not changed,
stack smashing protection is effectively disabled.
NOTE

7.4

Each hardware thread has its own instance of the FRAMEKEY register.

Stack registers
Table 7-1 lists the stack registers.
Table 7-1

Stack registers

Register

Name

Description

Alias

SP

Stack pointer

Points to topmost stack element in memory

R29

FP

Frame pointer

Points to previous stack frame on stack

R30

LR

Link register

Contains return address of subroutine call

R31

FRAMELIMIT

Frame limit register

Contains lowest address of stack area

C16

FRAMEKEY

Frame key register

Contains scrambling key for return addresses

C17

NOTE

SP, FP, and LR are aliases of three general registers (Section 2.1). These

general registers are conventionally dedicated for use as stack registers.

80-N2040-46 Rev. B

117

Hexagon V68 Programmer’s Reference Manual

7.5

Software Stack

Stack instructions
The Hexagon processor includes the instructions allocframe and deallocframe to
efficiently allocate and deallocate stack frames on the call stack.
Table 7-2 describes these instructions.
Table 7-2

Stack instructions

Syntax

allocframe(#u11:3)

Operation
Allocate stack frame.
This instruction is used after a call. It first XORs the values in LR
and FRAMEKEY, and pushes the resulting scrambled return
address and FP to the top of stack.
Next, it subtracts an unsigned immediate from SP to allocate
room for local variables. If the resulting SP is less than
FRAMELIMIT, the processor raises exception 0x27. Otherwise,
SP is set to the new value, and FP is set to the address of the
old frame pointer on the stack.
The immediate operand as expressed in assembly syntax
specifies the byte offset. This value must be 8-byte aligned. The
valid range is from 0 to 16 KB.

deallocframe

Deallocate stack frame.
This instruction is used before a return to free a stack frame. It
first loads the saved FP and LR values from the address at FP,
and XORs the restored LR with the value in FRAMEKEY to
unscramble the return address. SP is then pointed back to the
previous frame.

dealloc_return

Subroutine return with stack frame deallocate.
Perform deallocframe operation, and then perform
subroutine return (Section 8.3.3) to the target address loaded
from LR by deallocframe.

NOTE

80-N2040-46 Rev. B

allocframe and deallocframe load and store the LR and FP registers on the
stack as a single aligned 64-bit register pair (i.e., LR:FP).

118

8 Program Flow
The Hexagon processor supports the following program flow facilities:


Conditional instructions



Hardware loops



Software branches



Pauses



Exceptions

Software branches include jumps, calls, and returns. Several types of jumps are supported:

8.1



Speculative jumps



Compare jumps



Register transfer jumps



Dual jumps

Conditional instructions
Many Hexagon processor instructions can be conditionally executed. For example:
if (P0) R0 = memw(R2)
if (!P1) jump label

// conditionally load word if P0
// conditionally jump if not P1

The following instructions can be specified as conditional:


Jumps and calls



Many load and store instructions



Logical instructions (including AND/OR/XOR)



Shift halfword



32-bit add/subtract by register or short immediate



Sign and zero extend



32-bit register transfer and 64-bit combine word



Register transfer immediate



Deallocate frame and return

For more information, see Section 5.9 and Chapter 6.

80-N2040-46 Rev. B

119

Hexagon V68 Programmer’s Reference Manual

8.2

Program Flow

Hardware loops
The Hexagon processor includes hardware loop instructions which can perform loop
branches with zero overhead. For example:
loop0(start,#3)
// loop 3 times
start:
{ R0 = mpyi(R0,R0) } :endloop0

Two sets of hardware loop instructions are provided – loop0 and loop1 – to next
hardware loops one level deep. For example:
// Sum the rows of a 100x200 matrix.
loop1(outer_start,#100)
outer_start:
R0 = #0
loop0(inner_start,#200)
inner_start:
R3 = memw(R1++#4)
{ R0 = add(R0,R3) }:endloop0
{ memw(R2++#4) = R0 }:endloop1

Use the hardware loop instructions as follows:


For non-nested loops, loop0 is used.



For nested loops, loop0 is used for the inner loop, and loop1 for the outer loop.

NOTE

If a program must create loops nested more than one level deep, the two
innermost loops can be implemented as hardware loops, with the remaining
outer loops implemented as software branches.

Each hardware loop is associated with a pair of dedicated loop registers:




The loop start address register SAn is set to the address of the first instruction in
the loop (which is typically expressed in assembly language as a label).
The loop count register LCn is set to a 32-bit unsigned value which specifies the
number of loop iterations to perform. When the PC reaches the end of the loop,
LCn is examined to determine whether the loop should repeat or exit.

The hardware loop setup instruction sets both of these registers at once – typically there is
no need to set them individually. However, because the loop registers completely specify
the hardware loop state, saving and restoring the registers (either automatically by a
processor interrupt or manually by the programmer) enables a suspended hardware loop to
resume normally once its loop registers are reloaded with the saved values.
The Hexagon processor provides two sets of loop registers for the two hardware loops:

80-N2040-46 Rev. B



SA0 and LC0 are used by loop0



SA1 and LC1 are used by loop1

120

Hexagon V68 Programmer’s Reference Manual

Program Flow

Table 8-1 lists the hardware loop instructions.
Table 8-1

Loop instructions

Syntax

loopN(start, Rs)

Description
Hardware loop with register loop count.
Set registers SAn and LCn for hardware loop N:
 SAn is assigned the specified start address of the loop.
LCn is assigned the value of general register Rs.
NOTE - The loop start operand is encoded as a PC-relative
immediate value.


loopN(start, #count)

Hardware loop with immediate loop count.
Set registers SAn and LCn for hardware loop N:
 SAn is assigned the specified start address of the loop.
LCn is assigned the specified immediate value (0-1023).
NOTE - The loop start operand is encoded as a PC-relative
immediate value.


:endloopN

Hardware loop end instruction.
Performs the following operation:

if (LCn > 1) {PC = SAn; LCn = LCn-1}
NOTE: This instruction appears in assembly as a suffix appended to the
last packet in the loop. It is encoded in the last packet.

8.2.1

SAn = Rs

Set loop start address to general register Rs

LCn = Rs

Set loop count to general register Rs

NOTE

The loop instructions are assigned to instruction class CR.

Loop setup
To set up a hardware loop, the loop registers SAn and LCn must be set to the proper values.
This can be done in two ways:


A loopN instruction



Register transfers to SAn and LCn

The loopN instruction performs all the work of setting SAn and LCn. For example:
loop0(start,#3)
// SA0=&start, LC0=3
start:
{ R0 = mpyi(R0,R0) } :endloop0

In this example the hardware loop (consisting of a single multiply instruction) is executed
three times. The loop0 instruction sets register SA0 to the address value of label start,
and LC0 to 3.

80-N2040-46 Rev. B

121

Hexagon V68 Programmer’s Reference Manual

Program Flow

Loop counts are limited to the range 0-1023 when they are expressed as immediate values
in loopN. If the desired loop count exceeds this range, it must be specified as a register
value. For example:
Using loopN:
R1 = #20000;
loop0(start,R1)
// LC0=20000, SA0=&start
start:
{ R0 = mpyi(R0,R0) } :endloop0

Using register transfers:
R1 = #20000
LC0 = R1
// LC0=20000
R1 = #start
SA0 = R1
// SA0=&start
start:
{ R0 = mpyi(R0,R0) } :endloop0

If a loopN instruction is located too far from its loop start address, the PC-relative offset
value that specifies the start address can exceed the maximum range of the instruction’s
start-address operand. If this occurs, either move the loopN instruction closer to the loop
start, or specify the loop start address as a 32-bit constant (Section 10.9).
For example, using 32-bit constants:
R1 = #20000;
loop0(##start,R1)
...

8.2.2

// LC0=20000, SA0=&start

Loop end
The loop end instruction indicates the last packet in a hardware loop. It is expressed in
assembly language by appending the packet with the symbol “:endloopN”, where N
specifies the hardware loop (0 or 1). For example:
loop0(start,#3)
start:
{ R0 = mpyi(R0,R0) } :endloop0

// last packet in loop

The last instruction in the loop must always be expressed in assembly language as a packet
(using curly braces), even if it is the only instruction in the packet.
Nested hardware loops can specify the same instruction as the end of both the inner and
outer loops. For example:
// Sum the rows of a 100x200 matrix.
// Software pipeline the outer loop.
p0 = cmp.gt(R0,R0)
loop1(outer_start,#100)
outer_start:
{ if (p0) memw(R2++#4) = R0
p0 = cmp.eq(R0,R0)

80-N2040-46 Rev. B

// p0 = false

// p0 = true

122

Hexagon V68 Programmer’s Reference Manual

Program Flow

R0 = #0
loop0(inner_start,#200) }
inner_start:
R3 = memw(R1++#4)
{ R0 = add(R0,R3) }:endloop0:endloop1
memw(R2++#4) = R0

Though endloopN behaves like a regular instruction (by implementing the loop test and
branch), it does not execute in any instruction slot, and does not count as an instruction in
the packet. Therefore a single instruction packet which is marked as a loop end can
perform up to six operations:


Four regular instructions (the normal limit for an instruction packet)



The endloop0 test and branch



The endloop1 test and branch

NOTE

8.2.3

The endloopN instruction is encoded in the instruction packet (Section 10.6).

Loop execution
After a hardware loop is set up, the loop body always executes at least once regardless of
the specified loop count (because the loop count is not examined until the last instruction
in the loop). Therefore, if a loop must be optionally executed zero times, it must be
preceded with an explicit conditional branch. For example:
loop0(start,R1)
P0 = cmp.eq(R1,#0)
if (P0) jump skip
start:
{ R0 = mpyi(R0,R0) } :endloop0
skip:

In this example a hardware loop is set up with the loop count in R1, but if the value in R1
is zero a software branch skips over the loop body.
After the loop end instruction of a hardware loop is executed, the Hexagon processor
examines the value in the corresponding loop count register:




If the value is greater than 1, the processor decrements the loop count register and
performs a zero-cycle branch to the loop start address.
If the value is less than or equal to 1, the processor resumes program execution at
the instruction immediately following the loop end instruction.

NOTE

80-N2040-46 Rev. B

Because nested hardware loops can share the same loop end instruction, the
processor may examine both loop count registers in a single operation.

123

Hexagon V68 Programmer’s Reference Manual

8.2.4

Program Flow

Pipelined hardware loops
Software pipelined loops are common for VLIW architectures such as the Hexagon
processor. They offer increased code performance in loops by overlapping multiple loop
iterations.

A software pipeline has three sections:


A prologue in which the loop is primed



A kernel (or steady-state) portion



An epilogue which drains the pipeline

This is best illustrated with a simple example, as shown in Table 8-2.
Table 8-2

Software pipelined loop

int foo(int *A, int *result)
{
int i;
for (i=0;i<100;i++) {
result[i]= A[i]*A[i];
}
}

foo:
{

R3 = R1
loop0(.kernel,#98)

// Decrease loop count by 2

}
{

R1 = memw(R0++#4)
R1 = memw(R0++#4)
R2 = mpyi(R1,R1)

// 1st prologue stage
// 2nd prologue stage

}
.falign
.kernel:
{
R1 = memw(R0++#4)
R2 = mpyi(R1,R1)
memw(R3++#4) = R2
}:endloop0
{
R2 = mpyi(R1,R1)
memw(R3++#4) = R2
}
memw(R3++#4) = R2
jumpr lr

// kernel

// 1st epilogue stage

// 2nd epilogue stage

In Table 8-2 the kernel section of the pipelined loop performs three iterations of the loop
in parallel:

80-N2040-46 Rev. B

124

Hexagon V68 Programmer’s Reference Manual



The load for iteration N+2



The multiply for iteration N+1



The store for iteration N

Program Flow

One drawback to software pipelining is the extra code necessary for the prologue and
epilogue sections of a pipelined loop.
To address this issue the Hexagon processor provides the spNloop0 instruction, where the
“N” in the instruction name indicates a digit in the range 1-3. For example:
P3 = sp2loop0(start,#10)

// Set up pipelined loop

spNloop0 is a variant of the loop0 instruction: it sets up a normal hardware loop using
SA0 and LC0, but also performs the following additional operations:




When the spNloop0 instruction is executed, it assigns the truth value false to the
predicate register P3.
After the associated loop has executed N times, P3 is automatically set to true.

This feature (which is known as automatic predicate control) enables the store instructions
in the kernel section of a pipelined loop to conditionally execute by P3 and thus – because
of the way spNloop0 controls P3 – not be executed during the pipeline warm-up. This can
reduce the code size of many software pipelined loops by eliminating the need for
prologue code.
spNloop0 cannot be used to eliminate the epilogue code from a pipelined loop; however,

in some cases it is possible to do this through the use of programming techniques.
Typically, the issue affecting the removal of epilogue code is load safety. If the kernel
section of a pipelined loop can safely access past the end of its arrays – either because it is
known as safe, or because the arrays have been padded at the end – epilogue code is
unnecessary. However, if load safety cannot be ensured, explicit epilogue code is required
to drain the software pipeline.
Table 8-3 shows how spNloop0 and load safety simplify the code shown in Table 8-2.

80-N2040-46 Rev. B

125

Hexagon V68 Programmer’s Reference Manual

Table 8-3

Program Flow

Software pipelined loop (using spNloop0)

int foo(int *A, int *result)
{
int i;
for (i=0;i<100;i++) {
result[i]= A[i]*A[i];
}
}

foo:
{ // load safety assumed
P3 = sp2loop0(.kernel,#102)
R3 = R1
}
.falign
.kernel:
{
R1 = memw(R0++#4)
R2 = mpyi(R1,R1)
if (P3) memw(R3++#4) = R2
}:endloop0

// set up pipelined loop

// kernel

jumpr lr

NOTE

8.2.5

The count value that spNloop0 uses to control the P3 setting is stored in the
user status register USR.LPCFG.

Loop restrictions
Hardware loops have the following restrictions:








The loop setup packet in loopN or spNloop0 (Section 8.2.4) cannot contain a
speculative indirect jump, new-value compare jump, or dealloc_return.
The last packet in a hardware loop cannot contain any program flow instructions
(including jumps or calls).
The loop end packet in loop0 cannot contain any instruction that changes SA0 or
LC0. Similarly, the loop end packet in loop1 cannot contain any instruction that
changes SA1 or LC1.
The loop end packet in spNloop0 cannot contain any instruction that changes P3.

NOTE

80-N2040-46 Rev. B

SA1 and LC1 can be changed at the end of loop0, while SA0 and LC0 can be
changed at the end of loop1.

126

Hexagon V68 Programmer’s Reference Manual

8.3

Program Flow

Software branches
Unlike hardware loops, software branches use an explicit instruction to perform a branch
operation. Software branches include the following instructions:


Jumps



Calls



Returns

The target address for branch instructions can be specified as register indirect or PCrelative offsets. PC-relative offsets are normally less than 32 bits, but can be specified as
32 bits by using the appropriate syntax in the target operand (Section 8.3.4).
Branch instructions can be unconditional or conditional, with the execution of conditional
instructions controlled by a predicate expression.
Table 8-4 summarizes the software branch instructions.
Table 8-4

80-N2040-46 Rev. B

Software branch instructions
Syntax

Operation

[if (pred_expr)] jump label
[if (pred_expr)] jumpr Rs

Branch to address specified by register Rs or PC-relative offset.
Can be conditionally executed.

[if (pred_expr)] call label
[if (pred_expr)] callr Rs

Branch to address specified by register Rs or PC-relative offset.
Store subroutine return address in link register LR.
Can be conditionally executed.

[if (pred_expr)] jumpr LR

Branch to subroutine return address contained in link register LR.
Can be conditionally executed.

127

Hexagon V68 Programmer’s Reference Manual

8.3.1

Program Flow

Jumps
Jump instructions change the program flow to a target address which can be specified by
either a register or a PC-relative immediate value. Jump instructions can be conditional
based on the value of a predicate expression.
Table 8-5 lists the jump instructions.
Table 8-5

Jump instructions

Syntax

Operation

jump label

Direct jump.
Branch to address specified by label.
Label is encoded as PC-relative signed immediate value.

jumpr Rs

Indirect jump.
Branch to address contained in general register Rs.

if ([!]Ps) jump label
if ([!]Ps) jumpr Rs
NOTE

8.3.2

Conditional jump.
Perform jump if predicate expression evaluates to true.

Conditional jumps can be specified as speculative (Section 8.4).

Calls
Call instructions jump to subroutines. The instruction performs a jump to the target
address and also stores the return address in the link register LR.
The forms of call are functionally similar to jump instructions and include both PCrelative and register indirect in both unconditional and conditional forms.
Table 8-6 lists the call instructions.
Table 8-6

Call instructions

Syntax

call label

Operation
Direct subroutine call.
Branch to address specified by label, and store return address in register
LR. Label is encoded as PC-relative signed immediate value.

80-N2040-46 Rev. B

callr Rs

Indirect subroutine call.
Branch to address contained in general register Rs, and store return
address in register LR.

if ([!]Ps) call label
if ([!]Ps) callr Rs

Conditional call.
If predicate expression evaluates to true, perform subroutine call to
specified target address.

128

Hexagon V68 Programmer’s Reference Manual

8.3.3

Program Flow

Returns
Return instructions return from a subroutine. The instruction performs an indirect jump to
the subroutine return address stored in link register LR.
Returns are implemented as jump register indirect instructions, and support both
unconditional and conditional forms.
Table 8-7 lists the return instructions.
Table 8-7

Return instructions
Syntax

Operation

jumpr LR

Subroutine return.
Branch to subroutine return address contained in link register
LR.

if ([!]Ps) jumpr LR

Conditional subroutine return.
If predicate expression evaluates to true, perform subroutine
return to specified target address.

dealloc_return

Subroutine return with stack frame deallocate.
Perform deallocframe operation (Section 7.5) and then
perform subroutine return to the target address loaded by
deallocframe from the link register.

if ([!]Ps) dealloc_return

NOTE

Conditional subroutine return with stack frame deallocate.
If predicate expression evaluates to true, perform
deallocframe and subroutine return to the target address
loaded by deallocframe from the link register.

The link register LR is an alias of general register R31. Therefore subroutine
returns can be performed with the instruction jumpr R31.
The conditional subroutine returns (including dealloc_return) can be
specified as speculative (Section 8.4).

80-N2040-46 Rev. B

129

Hexagon V68 Programmer’s Reference Manual

8.3.4

Program Flow

Extended branches
When a jump or call instruction specifies a PC-relative offset as the branch target, the
offset value is normally encoded in significantly less than 32 bits. This can limit the ability
for programs to specify “long” branches which span a large range of the processor’s
memory address space.
To support long branches, the jump and call instructions have special versions which
encode a full 32-bit value as the PC-relative offset.
NOTE

Such instructions use an extra word to store the 32-bit offset (Section 10.9).

The size of a PC-relative branch offset is expressed in assembly language by optionally
prefixing the target label with the symbol “##” or “#”:


“##” specifies that the assembler must use a 32-bit offset



“#” specifies that the assembler must not use a 32-bit offset



No “#” specifies that the assembler use a 32-bit offset only if necessary

For example:
jump ##label
call #label
jump label

8.3.5

// 32-bit offset
// non 32-bit offset
// offset size determined by assembler

Branches to and from packets
Instruction packets are atomic: even if they contain multiple instructions, they can be
referenced only by the address of the first instruction in the packet. Therefore, branches to
a packet can target only the packet’s first instruction.
Packets can contain up to two branches (Section 8.7). The branch destination can target
the current packet or the beginning of another packet.
A branch does not interrupt the execution of the current packet: all the instructions in the
packet are executed, even if they appear in the assembly source after the branch
instruction.
If a packet is at the end of a hardware loop, it cannot contain a branch instruction.

80-N2040-46 Rev. B

130

Hexagon V68 Programmer’s Reference Manual

8.4

Program Flow

Speculative jumps
Conditional instructions normally depend on predicates that are generated in a previous
instruction packet. However, dot-new predicates (Section 6.1.4) enable conditional
instructions to use a predicate generated in the same packet that contains the conditional
instruction.
When dot-new predicates are used with a conditional jump, the resulting instruction is
called a speculative jump. For example:
{
P0 = cmp.eq(R9,#16)
IF (P0.new) jumpr:t R11

// single-packet compare-and-jump
// ... enabled by use of P0.new

}

Speculative jumps require the programmer to specify a direction hint in the jump
instruction, indicating whether the conditional jump is expected.
The hint initializes the Hexagon processor’s dynamic branch predictor. Whenever the
predictor is wrong, the speculative jump instruction takes two cycles to execute instead of
one (due to a pipeline stall).
Hints can improve program performance by indicating how speculative jumps are
expected to execute over the course of a program: the more often the specified hint
indicates how the instruction actually executes, the better the performance.
Hints are expressed in assembly language by appending the suffix “:t” or “:nt” to the
jump instruction symbol. For example:


jump:t – The jump instruction is most often taken



jump:nt – The jump instruction is most often not taken

In addition to dot-new predicates, speculative jumps also accept conditional arithmetic
expressions (=0, !=0, >=0, <=0) involving the general register Rs.
Table 8-8 lists the speculative jump instructions.
Table 8-8

Speculative jump instructions
Syntax

80-N2040-46 Rev. B

Operation

if ([!]Ps.new) jump:t label
if ([!]Ps.new) jump:nt label

Speculative direct jump.

if ([!]Ps.new) jumpr:t Rs
if ([!]Ps.new) jumpr:nt Rs

Speculative indirect jump.

if (Rs == #0) jump:t label
if (Rs == #0) jump:nt label

Speculative direct jump.
If predicate Rs = 0 is true, jump to address specified by label.

if (Rs != #0) jump:t label
if (Rs != #0) jump:nt label

Speculative direct jump.
If predicate Rs != 0 is true, jump to address specified by label.

If predicate expression evaluates to true, jump to address
specified by label.
If predicate expression evaluates to true, jump to address in
register Rs.

131

Hexagon V68 Programmer’s Reference Manual

Table 8-8

Program Flow

Speculative jump instructions (Continued)
Syntax

Operation

if (Rs >= #0) jump:t label
if (Rs >= #0) jump:nt label

Speculative direct jump.
If predicate Rs >= 0 is true, jump to address specified by
label.

if (Rs <= #0) jump:t label
if (Rs <= #0) jump:nt label

Speculative direct jump.

NOTE

If predicate Rs <= 0 is true, jump to address specified by
label.

The hints :t and :nt interact with the predicate value to determine the
instruction cycle count.
Speculative indirect jumps are not supported with register Rs predicates.

8.5

Compare jumps
To reduce code size the Hexagon processor supports a compound instruction which
combines a compare with a speculative jump in a single 32-bit instruction.
For example:
{
p0 = cmp.eq (R2,R5)
if (p0.new) jump:nt target
}

// single-instr compare-and-jump
// enabled by compound instr

The register operands used in a compare jump are limited to R0-R7 or R16-R23
(Table 10-3).
The compare and jump instructions that can be used in a compare jump are limited to the
instructions listed in Table 8-9. The compare can use predicate P0 or P1, while the jump
must specify the same predicate that is set in the compare.
A compare jump instruction is expressed in assembly source as two independent compare
and jump instructions in a packet. The assembler translates the two instructions into a
single compound instruction.

80-N2040-46 Rev. B

132

Hexagon V68 Programmer’s Reference Manual

Table 8-9

Program Flow

Compare jump instructions

Compare Instruction

Pd = cmp.eq (Rs, Rt)
Pd = cmp.gt (Rs, Rt)
Pd = cmp.gtu (Rs, Rt)
Pd = cmp.eq (Rs,#U5)
Pd = cmp.gt (Rs,#U5)
Pd = cmp.gtu (Rs,#U5)
Pd = cmp.eq (Rs,#-1)
Pd = cmp.gt (Rs,#-1)
Pd = tstbit (Rs, #0)

8.5.1

Jump Instruction

IF (Pd.new) jump:t label
IF (Pd.new) jump:nt label
IF (!Pd.new) jump:t label
IF (!Pd.new) jump:nt label

New-value compare jumps
A compare jump instruction can access a register that is assigned a new value in the same
instruction packet (Section 3.3). This feature is expressed in assembly language by the
following changes:



Appending the suffix “.new” to the new-value register in the compare
Rewriting the compare jump so its constituent compare and jump operations
appear as a single conditional instruction

For example:
// load-compare-and-jump packet enabled by new-value compare jump
{
R0 = memw(R2+#8)
if (cmp.eq(R0.new,#0)) jump:nt target
}

New-value compare jump instructions have the following restrictions:

80-N2040-46 Rev. B

133

Hexagon V68 Programmer’s Reference Manual

Program Flow



They are limited to the instruction forms listed in Table 8-10.



They cannot be combined with another jump instruction in the same packet.







If an instruction produces a 64-bit result or performs a floating-point operation
(Section 1.3.4), its result registers cannot be used as the new-value register.
If an instruction uses auto-increment or absolute-set addressing mode
(Section 5.8), its address register cannot be used as the new-value register.
If the instruction that sets a new-value register is conditional (Section 6.1.2), it
must always be executed.

If the specified jump direction hint is wrong (Section 8.4), a new-value compare jump
takes three cycles to execute instead of one. While this penalty is one cycle longer than in
a regular speculative jump, the overall performance is still better than using a regular
speculative jump (which must execute an extra packet in all cases).
NOTE

New-value compare jump instructions are assigned to instruction class NV,
which can execute only in Slot 0. The instruction that assigns the new value
must execute in Slot 1, 2, or 3.

Table 8-10 New-value compare jump instructions
if ([!]cmp.eq (Rs.new, Rt)) jump:[hint] label
if ([!]cmp.gt (Rs.new, Rt)) jump:[hint] label
if ([!]cmp.gtu (Rs.new, Rt)) jump:[hint] label
if ([!]cmp.gt (Rs, Rt.new)) jump:[hint] label
if ([!]cmp.gtu (Rs, Rt.new)) jump:[hint] label
if ([!]cmp.eq (Rs.new, #u5)) jump:[hint] label
if ([!]cmp.gt (Rs.new, #u5)) jump:[hint] label
if ([!]cmp.gtu (Rs.new ,#u5)) jump:[hint] label
if ([!]cmp.eq (Rs.new, #-1)) jump:[hint] label
if ([!]cmp.gt (Rs.new, #-1)) jump:[hint] label
if ([!]tstbit (Rs.new, #0)) jump:[hint] label

8.6

Register transfer jumps
To reduce code size the Hexagon processor supports a compound instruction which
combines a register transfer with an unconditional jump in a single 32-bit instruction.
For example:
{
jump target
R1 = R2
}

80-N2040-46 Rev. B

// jump to label “target”
// assign contents of reg R2 to R1

134

Hexagon V68 Programmer’s Reference Manual

Program Flow

The source and target register operands in the register transfer are limited to R0-R7 or
R16-R23 (Table 10-3).
The target address in the jump is a scaled 9-bit PC-relative address value (as opposed to
the 22-bit value in the regular unconditional jump instruction).
A register transfer jump instruction is expressed in assembly source as two independent
instructions in a packet. The assembler translates the instructions into a single compound
instruction.
Table 8-11 lists the register transfer jump instructions.
Table 8-11

Register transfer jump instructions

Syntax

jump label; Rd=Rs

Operation
Register transfer jump.
Perform register transfer and branch to address specified by label.
Label is encoded as PC-relative 9-bit signed immediate value.

jump label; Rd=#u6

Register transfer immediate jump.
Perform register transfer (of 6-bit unsigned immediate value) and
branch to address specified by label.
Label is encoded as PC-relative 9-bit signed immediate value.

8.7

Dual jumps
Two software branch instructions (referred to here as “jumps”) can appear in the same
instruction packet, under the conditions listed in Table 8-12.
The first jump is defined as the jump instruction at the lower address, and the second jump
as the jump instruction at the higher address.
Unlike most packetized operations, dual jumps are not executed in parallel (Section 3.3.1).
Instead, the two jumps are processed in a well-defined order in a packet:
1. The predicate in the first jump is evaluated.
2. If the first jump is taken, the second jump is ignored.
3. If the first jump is not taken, the second jump is performed.
Table 8-12 Dual jump instructions
Instruction

80-N2040-46 Rev. B

Description

First jump
in packet?

Second jump
in packet?

jump

Direct jump

No

Yes

if ([!]Ps[.new]) jump

Conditional jump

Yes

Yes

call
if ([!]Ps) call

Direct calls

No

Yes

Pd=cmp.xx ; if ([!]Pd.new) jump

Compare jump

Yes

Yes

135

Hexagon V68 Programmer’s Reference Manual

Program Flow

Table 8-12 Dual jump instructions
Description

First jump
in packet?

Second jump
in packet?

if ([!]cmp.xx(Rs.new, Rt)) jump

New-value compare jump

No

No

jumpr
if ([!]Ps[.new]) jumpr
callr
if ([!]Ps) callr
dealloc_return
if ([!]Ps[.new]) dealloc_return

Indirect jumps
Indirect calls

No

No

endloopN

Hardware loop end

No

No

Instruction

NOTE

8.8

dealloc_return

If a call is ignored in a dual jump, the link register LR is not changed.

Hint indirect jump target
Because it obtains the jump target address from a register, the jumpr instruction
(Section 8.3.1) normally causes the processor to stall for one cycle.
To avoid the stall penalty caused by a jumpr instruction, the Hexagon processor supports
the jump hint instruction hintjr, which can be specified before the jumpr instruction.
The hintjr instruction indicates that the program is about to execute a jumpr to the
address contained in the specified register.
Table 8-13 lists the speculative jump instructions.
Table 8-13 Jump hint instruction
Syntax

hintjr(Rs)

NOTE

Operation
Informs the processor that the jumpr(Rs) instruction is about to
be performed.

To prevent a stall, the hintjr instruction must execute at least 2 packets
before the corresponding jumpr instruction.
The hintjr instruction is not needed for jumpr instructions used as returns
(Section 8.3.3), because in this case the Hexagon processor automatically
predicts the jump targets based on the most recent nested call instructions.

80-N2040-46 Rev. B

136

Hexagon V68 Programmer’s Reference Manual

8.9

Program Flow

Pauses
Pauses suspend the execution of a program for a period of time, and put it into low-power
mode. The program remains suspended for the duration specified in the instruction.
The pause instruction accepts an unsigned 8-bit immediate operand which specifies the
pause duration in terms of cycles. The maximum possible duration is 263 cycles (255+8).
Hexagon processor interrupts cause a program to exit the paused state before its specified
duration has elapsed.
The pause instruction is useful for implementing user-level low-power synchronization
operations (such as spin locks).
Table 8-14 lists the pause instruction.
Table 8-14 Pause instruction
Syntax

pause(#u8)

8.10

Operation
Suspend program in low-power mode for specified cycle
duration.

Exceptions
Exceptions are internally-generated disruptions to the program flow.
The Hexagon processor OS handles fatal exceptions by terminating the execution of the
application system. The user is responsible for fixing the problem and recompiling their
applications.
The error messages generated by exceptions include the following information to assist in
locating the problem:


Cause code – Hexadecimal value indicating the type of exception that occurred



User IP – PC value indicating the instruction executed when exception occurred



Bad VA – Virtual address indicating the data accessed when exception occurred

NOTE

The cause code, user IP, and Bad VA values are stored in the Hexagon
processor system control registers SSR[7:0], ELR, and BADVA respectively.

If multiple exceptions occur simultaneously, the exception with the lowest error code
value has the highest exception priority.
If a packet contains multiple loads, or a load and a store, and both operations have an
exception of any type, all Slot 1 exceptions are processed before any Slot 0 exception is
processed.
NOTE

80-N2040-46 Rev. B

V65 defines an additional event (with cause code 0x17) to indicate an
instruction-cache error.

137

Hexagon V68 Programmer’s Reference Manual

Program Flow

Table 8-15 lists the exceptions for the V67 processor.
Table 8-15 V67 exceptions
Cause
Code

80-N2040-46 Rev. B

Event Type

Event Description
Software thread reset.

Notes

0x0

Reset

Non-maskable,
Highest Priority

0x01

Precise,
Unrecoverable BIU error (bus error, timeout, L2 Non-maskable
Unrecoverable parity error, etc.).

0x03

Precise,
Double exception (exception occurs while
Unrecoverable SSR[EX]=1).

0x11

Precise

Privilege violation: User/Guest mode execute to Non-maskable
page with no execute permissions (X=0).

0x12

Precise

Privilege violation: User mode execute to a
page with no user permissions (X=1, U=0).

Non-maskable

0x15

Precise

Invalid packet.

Non-maskable

0x16

Precise

Illegal execution of coprocessor instruction.

Non-maskable

0x17

Precise

Instruction cache error.

Non-maskable

0x1A

Precise

Privilege violation: Executing a guest mode
instruction in user mode.

Non-maskable

0x1B

Precise

Privilege violation: Executing a supervisor
instruction in user/guest mode.

Non-maskable

0x1D

Precise,
Packet with multiple writes to the same
Unrecoverable destination register.

Non-maskable

0x1E

Precise,
Program counter values that are not properly
Unrecoverable aligned.

Non-maskable

0x20

Precise

Load to misaligned address.

Non-maskable

0x21

Precise

Store to misaligned address.

Non-maskable

0x22

Precise

Privilege violation: User/Guest mode Read to
page with no read permission (R=0).

Non-maskable

0x23

Precise

Privilege violation: User/Guest mode Write to
page with no write permissions (W=0).

Non-maskable

0x24

Precise

Privilege violation: User mode Read to page
with no user permission (R=1, U=0).

Non-maskable

0x25

Precise

Privilege violation: User mode Write to page
with no user permissions (W=1, U=0).

Non-maskable

0x26

Precise

Coprocessor VMEM address error.

Non-maskable

0x27

Precise

Stack overflow: Allocframe instruction exceeded Non-maskable,
FRAMELIMIT.

0x42

Imprecise

Data abort.

Non-maskable

0x43

Imprecise

NMI.

Non-maskable

0x44

Imprecise

Multiple TLB match.

Non-maskable

0x45

Imprecise

Livelock exception.

Non-maskable

0x60

TLB miss-X

Due to missing Fetch address on PC-page.

Non-maskable

Non-maskable

138

Hexagon V68 Programmer’s Reference Manual

Program Flow

Table 8-15 V67 exceptions (Continued)
Cause
Code

Event Type

Event Description

Notes

0x61

TLB miss-X

Due to missing Fetch on second page from
packet that spans pages.

Non-maskable

0x62

TLB miss-X

Due to icinva.

Non-maskable

Reserved
0x70

TLB miss-RW

Due to memory read.

Non-maskable

0x71

TLB miss-RW

Due to memory write.

Non-maskable

Reserved
#u8

Trap0

Software Trap0 instruction.

Non-maskable

#u8

Trap1

Software Trap1 instruction.

Non-maskable

Reserved
0x80

Debug

Single-step debug exception.

Reserved

80-N2040-46 Rev. B

0xBF

Floating-Point

Execution of Floating-Point instruction resulted
in exception.

Non-maskable

0xC0

Interrupt0

General external interrupt.

Maskable, highest
priority general
interrupt

0xC1

Interrupt 1

General external interrupt

Maskable

0xC2

Interrupt 2

General external interrupt

VIC0 Interface

0xC3

Interrupt 3

General external interrupt

VIC1 Interface

0xC4

Interrupt 4

General external interrupt

VIC2 Interface

0xC5

Interrupt 5

General external interrupt

VIC3 Interface

0xC6

Interrupt 6

General external interrupt

0xC7

Interrupt 7

General external interrupt

Lowest-priority
interrupt

139

9 PMU Events
The Hexagon processor can collect execution statistics on the applications it executes. The
statistics summarize the various types of Hexagon processor events that occurred while
the application was running.
Execution statistics can be collected in hardware or software:




Statistics can be collected in hardware with the Performance Monitor Unit (PMU),
which is defined as part of the Hexagon processor architecture.
Statistics can be collected in software using the Hexagon simulator. The simulator
statistics are presented in the same format used by the PMU.

Execution statistics are expressed in terms of processor events. This chapter defines the
event symbols, along with their associated numeric codes.
NOTE

80-N2040-46 Rev. B

Because the types of execution events vary across the Hexagon processor
versions, different types of statistics are collected for each version. This
chapter lists the event symbols defined for version V68.

140

Hexagon V68 Programmer’s Reference Manual

9.1

PMU Events

V68 processor event symbols
Table 9-1 defines the symbols that represent processor events for the V68 Hexagon
processor.

Table 9-1

V68 processor events symbols

Event

Symbol

Definition

0x01 COUNTER0_OVERFLOW

Can be used as the event detected by counter1 to build an
effective 64-bit counter.

0x02 COUNTER2_OVERFLOW

Can be used as the event detected by counter3 to build an
effective 64-bit counter.

0x03 COMMITTED_PKT_ANY

Thread committed a packet. Packets executed

0x04 COMMITTED_PKT_BSB

Packet committed two cycles after previous packet in same
thread.

0x05 COUNTER4_OVERFLOW

Can be used as the event detected by counter5 to build an
effective 64-bit counter.

0x06 COUNTER6_OVERFLOW

Can be used as the event detected by counter7 to build an
effective 64-bit counter.

0x07 COMMITTED_PKT_B2B

Packet committed one cycle after previous packet in same
thread.

0x08 COMMITTED_PKT_SMT

Two packets committed in the same cycle.

0x0a CYCLES_5_THREAD_RUNNING

Processor cycles that exactly five threads are running.
Running means not in Wait or Stop mode.

0x0b CYCLES_6_THREAD_RUNNING

Processor cycles that exactly six threads are running.
Running means not in Wait or Stop mode.

0x12 ICACHE_DEMAND_MISS

I-cache demand miss. Includes secondary miss.

0x13 DCACHE_DEMAND_MISS

D-cache cacheable demand primary or secondary miss.
Includes dczero stall.
Excludes uncacheables, prefetches, and no-allocate store
misses.

0x14 DCACHE_STORE_MISS

D-cache cacheable store miss.

0x17 CU_PKT_READY_NOT_DISPATCHED

Packets that were ready at the control unit scheduler but were
not scheduled because:



Its thread was not picked
Or, there was an inter-cluster resource conflict

0x18 COMMITTED_PKT_5_THREAD_RUNNING

Committed packets that five threads are running.
Not in Stop or Wait mode.

0x19 COMMITTED_PKT_6_THREAD_RUNNING

Committed packets that six threads are running.
Not in Stop or Wait mode.

0x1c

Instruction unit L1S load. Demand or prefetch

IU_L1S_ACCESS

0x1d IU_L1S_PREFETCH

Instruction unit L1S prefetch.

0x1e IU_L1S_AXIS_STALL

Instruction unit L1S stall because of an AXI slave.

0x1f

Instruction unit request to L1S and no grant from vector unit.

IU_L1S_NO_GRANT

80-N2040-46 Rev. B

141

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x20 ANY_IU_REPLAY

Any instruction unit stall other than an I-cache miss.
Includes jump register stall, fetchcross stall, ITLB miss stall,
and so on.
Excludes control unit replay.

0x21 ANY_DU_REPLAY

Any data unit replay. Bank conflict, store buffer full, etc.
Excludes stalls due to cache misses.

0x23 ISSUED_PACKETS

Speculatively issued packets delivered from an instruction
unit.

0x24 LOOPCACHE_PACKETS

Committed packets that were cloned from the packet queue
during a pinned hardware loop

0x25 COMMITTED_PKT_1_THREAD_RUNNING

Committed packets that one thread is running.
Not in Stop or Wait mode.

0x26 COMMITTED_PKT_2_THREAD_RUNNING

Committed packets that two threads are running.
Not in Stop or Wait mode.

0x27 COMMITTED_PKT_3_THREAD_RUNNING

Committed packets that three threads are running.
Not in Stop or Wait mode.

0x28 THREAD_LMH_THROTTLE

For a specific thread, the sustained power exceeds the limitsmanagement threshold and limits-budget threshold.
Result is throttling based on thread-priority.

0x29 LMH_THROTTLE

Throttling
Based on the value of the peak current that exceeds the
current limits of LMH

0x2a COMMITTED_INSTS

Committed instructions.
Increments by up to 8 per cycle. Duplex counts as two
instructions.
Does not include end loops.

0x2b COMMITTED_TC1_INSTS

Committed TC1 class instructions.
Increments by up to 8 per cycle. Duplex of two TC1
instructions counts as two TC1 instructions.

0x2c

COMMITTED_PRIVATE_INSTS

Committed instructions that have per-cluster (private)
execution resources.
Increments by up to 8 per cycle. Duplex of two private
instructions counts as two private instructions.

0x2d GLOBAL_POWERLIMITS_OVER

Sustained global power that exceeds the overall global limitsmanagement threshold and limits-budget threshold
Causes the thread-specific LMH to engage.

0x2f

Committed packets that four threads are running.
Not in Stop or Wait mode.

COMMITTED_PKT_4_THREAD_RUNNING

0x30 COMMITTED_LOADS

Committed load instructions.
Includes cached and uncached. Increments by 2 for dual
loads.
Excludes prefetches, memory operations, and coprocessor
loads.

80-N2040-46 Rev. B

142

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x31 COMMITTED_STORES

Committed store instructions.
Includes cached and uncached. Increments by 2 for dual
stores.
Excludes memory operations and coprocessor stores.

0x32 COMMITTED_MEMOPS

Committed memop instructions. Cached or uncached.

0x33 COMMITTED_NOPS

Committed nops.

0x34 ISSUED_INSTS

Speculatively issued instructions delivered from the IU.

0x35 DISPATCHED_PACKETS

Number of packets that the CU dispatched. Nop instructions
are squashed.

0x36 DISPATCHED_INSTS

Number of instructions that the CU dispatched.

0x37 COMMITTED_PROGRAM_FLOW_INSTS

Committed packet contains program flow instructions.
Includes CR jumps, endloop, J, JR, dealloc_return,
system/trap, superset of event 56. Dual jumps count as two.

0x38 COMMITTED_PKT_CHANGED_FLOW

Committed packet resulted in change of flow. Any taken jump.
Includes endloop and dealloc_return.

0x39 COMMITTED_PKT_ENDLOOP

Committed packet contains an endloop that was taken

0x3b CYCLES_1_THREAD_RUNNING

Processor cycles that exactly one thread is running.
Running means not in Wait or Stop mode.

0x3c

CYCLES_2_THREAD_RUNNING

Processor cycles that exactly two threads are running.
Running means not in Wait or Stop mode.

0x3d CYCLES_3_THREAD_RUNNING

Processor cycles that exactly three threads are running.
Running means not in Wait or Stop mode.

0x3e CYCLES_4_THREAD_RUNNING

Processor cycles that exactly four threads are running.
Running means not in Wait or Stop mode.

0x3f

128-byte line read requests issued by the primary AXI master.

AXI_LINE128_READ_REQUEST

0x40 AXI_READ_REQUEST

All read requests issued by the primary AXI master.
Includes full line and partial line.

0x41 AXI_LINE32_READ_REQUEST

32-byte line read requests issued by the primary AXI master

0x42 AXI_WRITE_REQUEST

All write requests issued by the primary AXI master.
Includes full line and partial line.

0x43 AXI_LINE32_WRITE_REQUEST

32-byte line write requests issued by the primary AXI master.
All bytes are valid.

0x44 AHB_READ_REQUEST

Read requests issued by the AHB master.

0x45 AHB_WRITE_REQUEST

Write requests issued by the AHB master.

0x46 AXI_LINE128_WRITE_REQUEST

128-byte line write requests issued by the primary AXI
master.
All bytes are valid.

0x47 AXI_SLAVE_MULTI_BEAT_ACCESS

AXI slave multi-beat access.

0x48 AXI_SLAVE_SINGLE_BEAT_ACCESS

AXI slave single-beat access.

80-N2040-46 Rev. B

143

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x49 AXI2_READ_REQUEST

All read requests issued by the secondary AXI master.
Includes full line and partial line.

0x4a AXI2_LINE32_READ_REQUEST

32-byte line read requests issued by the secondary AXI
master.

0x4b AXI2_WRITE_REQUEST

All write requests issued by the secondary AXI master.
Includes full line and partial line.

0x4c

32-byte line write requests issued by the secondary AXI
master.

AXI2_LINE32_WRITE_REQUEST

0x4d AXI2_CONGESTION

Secondary AXI command or data queue is full, and an
operation is stuck at the head of the secondary AXI master
command queue.

0x50 COMMITTED_FPS

Committed floating point instructions.
Increments by 2 for dual floating point operations.
Excludes conversions

0x51 REDIRECT_BIMODAL_MISPREDICT

Mispredict bimodal branch direction caused a control flow
redirect.

0x52 REDIRECT_TARGET_MISPREDICT

Mispredict branch target caused a control flow redirect.
Includes RAS mispredict.
Excludes indirect jumps and calls other than JUMPR R31
returns. Also excludes direction mispredicts.

0x53 REDIRECT_LOOP_MISPREDICT

Mispredict hardware loop end caused a control flow redirect.
Can only happen when the loop has relatively few packets
and the loop count is 2 or less.

0x54 REDIRECT_MISC

Control flow redirect for a reason other than events 0x51,
0x52, and 0x53.
Includes exceptions, traps, interrupts, non-R31 jumps,
multiple loop setup instructions, and others.

0x55 AXI_LINE256_WRITE_REQUEST

256-byte line write requests issued by the AXI master. All
bytes are valid.

0x56 NUM_PACKET_CRACKED

Number of packets that cracked.

0x58 JTLB_MISS

Instruction or data address translation request missed in the
JTLB.

0x5a COMMITTED_PKT_RETURN

Committed a return instruction.
Includes canceled returns.

0x5b COMMITTED_PKT_INDIRECT_JUMP

Committed an indirect jump or call instruction.
Includes canceled instructions.
Does not include JUMPR R31 returns.

0x5c

COMMITTED_BIMODAL_BRANCH_INSTS

Committed bimodal branch.
Includes .OLD and .NEW.
Increments by 2 for dual jumps.

0x5f

VTCM_FIFO_FULL_CYCLES

Cycles a cluster can issue because of VTCM FIFO full.

0x61 DU_L1S_LOAD_ACCESS

Scalar load access to L1S.

0x62 ICACHE_ACCESS

Number of I-cache line fetches.

80-N2040-46 Rev. B

144

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x63 BTB_HIT

Branch target buffer hit.

0x64 BTB_MISS

Branch target buffer miss.

0x65 IU_DEMAND_SECONDARY_MISS

I-cache secondary misses.

0x67 FAST_FETCH_KILLED

Fast fetch was killed (after an I-cache access).

0x69 FETCHED_PACKETS_DROPPED

Number of dropped packets because the instruction unit was
unable to deliver them to the control unit.

0x6b IU_PREFETCHES_SENT_TO_L2

Instruction unit prefetches sent to L2.
Counts cache lines not dropped by L2.
Excludes replayed prefetches, and only counts prefetches the
L2 accepts.

0x6c

ITLB_MISS

ITLB miss that goes to JTLB.

0x72 FETCH_2_CYCLE

Two-cycle actual fetch (returns, loop end, fall through, branch
target buffer).

0x73 FETCH_3_CYCLE

Three-cycle actual.

0x75 L2_IU_SECONDARY_MISS

L2 secondary misses from an instruction unit.

0x76 L2_IU_ACCESS

L2 cacheable access from an instruction unit.
Any access to the L2 cache that was the result of an IU
command, either demand or L1 prefetch access.
Excludes any prefetch generated in the L2. Also excludes
L2FETCH, TCM accesses, and uncacheables.
Address must target primary AXI

0x77 L2_IU_MISS

L2 misses from an instruction unit.
Of the events qualified by 0x76, the events that resulted in an
L2 miss (demand miss or L1 prefetch miss).
An L2 miss is any condition that prevents the immediate
return of data to the instruction unit, excluding pipeline
conflicts.

0x78 L2_IU_PREFETCH_ACCESS

Prefetch from an instruction unit to L2; any instruction unit
prefetch access sent to the L2 cache.
Access must be L2 cacheable and target primary AXI.
Does not include L2FETCH-generated accesses.

0x79 L2_IU_PREFETCH_MISS

L2 prefetch from an instruction unit miss.
Of the events qualified by 0x78, the events that resulted in an
L2 miss.

0x7c

L2_DU_READ_ACCESS

L2 cacheable read access from the data unit.
Any read access from the data unit that might cause a lookup
in the L2 cache.
Includes loads, L1 prefetch, DCFETCH.
Excludes initial L2FETCH command, uncacheables, TCM,
and coprocessor loads.
Must target AXI primary.

80-N2040-46 Rev. B

145

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x7d L2_DU_READ_MISS

L2 read miss from the data unit.
Of the events qualified by 0x7C, the events that resulted in an
L2 miss. For example, the line was not previously allocated in
the L2 cache and is fetched from backing memory.

0x7e L2FETCH_ACCESS

L2FETCH access from the data unit.
Any access to the L2 cache from the L2 prefetch engine that
was initiated by programing the L2FETCH engine.
Includes only the cache inquire and fetch if not present in
commands.

0x7f

L2FETCH_MISS

L2FETCH miss from a programed inquiry.
Of the events qualified by 0x7E, the events that resulted in an
L2 miss. For example, the line was not previously allocated in
the L2 cache and is fetched from backing memory.

0x81 L2_ACCESS

All requests to the L2.
Does not include internally generated accesses like
L2FETCH, however the programming of the L2FETCH
engine is counted.
Accesses target odd or even interleaves, and can be L2
cacheable or TCM.

0x82 L2_PIPE_CONFLICT

Request not taken by the L2 due to a pipe conflict.
The conflict can be a tag bank, data bank, or other pipeline
conflict.

0x83 L2_TAG_ARRAY_CONFLICT

Items caused by a conflict with the tag array.

0x87 TCM_DU_ACCESS

TCM access from the data unit.
Data unit access to the L2 TCM space.
Excludes HVX requests.

0x88 TCM_DU_READ_ACCESS

TCM read access from the data unit.
Data unit read access to the L2 TCM space.
Excludes HVX requests.

0x89 TCM_IU_ACCESS

TCM access from an instruction unit.
Instruction unit access to the L2 TCM space.

0x8a L2_CASTOUT

Triggers when L2 evicts a dirty line due to an allocation.
Not triggered on cache operations.

0x8b L2_DU_STORE_ACCESS

L2 cacheable store access from the data unit.
Any store access from the data unit that can cause a lookup
in the L2 cache.
Excludes cache operations, uncacheables, TCM, and
coprocessor stores.
Must target primary AXI

0x8c

L2 miss from the data unit.

L2_DU_STORE_MISS

Of the events qualified by 0x8B, the events that resulted in a
miss. Specifically, the cases where the line is not in cache or a
coalesce buffer.

80-N2040-46 Rev. B

146

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0x8d L2_DU_PREFETCH_ACCESS

L2 prefetch access from the data unit.
Of the events qualified by 0x7C, the events that are
DCFETCH and DHWPREFETCH. They are L2 cacheable
targeting the AXI primary.

0x8e L2_DU_PREFETCH_MISS

L2 prefetch miss from the data unit.
Of the events qualified by 0x8D, the events that missed the
L2 cache.

0x90 L2_DU_LOAD_SECONDARY_MISS

L2 load secondary miss from the data unit.
Hit a busy line in the scoreboard, preventing a return.
Busy condition can include pipeline bubbles caused by backto-back loads, as can be seen on L1UC loads.

0x91 L2FETCH_COMMAND

L2FETCH command. Excludes Stop command.

0x92 L2FETCH_COMMAND_KILLED

L2FETCH command was killed because a Stop command
was issued.
Increments once for each L2FETCH command that is killed.
If multiple commands are queued to the L2FETCH engine,
the kill of each one is recorded

0x93 L2FETCH_COMMAND_OVERWRITE

L2FETCH command is overwritten.
Kills an old L2FETCH command and replaces it with a new
one.

0x94 L2FETCH_ACCESS_CREDIT_FAIL

L2FETCH access cannot get a credit.
L2FETCH was blocked because of a missing L2FETCH or
L2evict credit.

0x95 AXI_SLAVE_READ_BUSY

AXI slave read access hit a busy line.

0x96 AXI_SLAVE_WRITE_BUSY

AXI slave write access hit a busy line.

0x97 L2_ACCESS_EVEN

Of the events in 0x81, the number of accesses made to the
even L2 cache.

0x98 CLADE_HIGH_PRIO_L2_ACCESS

Instruction unit or data unit request for a high priority CLADE
region.
Not counted for L2FETCH.

0x99 CLADE_LOW_PRIO_L2_ACCESS

Instruction unit or data unit request for a low priority CLADE
region.
Not counted for L2FETCH.

0x9a CLADE_HIGH_PRIO_L2_MISS

CLADE high-priority L2 access that missed in L2.

0x9b CLADE_LOW_PRIO_L2_MISS

CLADE low-priority L2 access that missed in L2.

0x9c

CLADE_HIGH_PRIO_EXCEPTION

CLADE high-priority decode that had an exception.

0x9d CLADE_LOW_PRIO_EXCEPTION

CLADE low-priority decode that had an exception.

0x9e AXI2_SLAVE_READ_BUSY

AXI secondary slave read access hit a busy line.

0x9f

AXI secondary slave write access hit a busy line.

AXI2_SLAVE_WRITE_BUSY

0xa0 ANY_DU_STALL

Any data unit stall.
Increments once when the thread has any Data unit stall
(dcache miss or DTLB miss).

80-N2040-46 Rev. B

147

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0xa1 DU_BANK_CONFLICT_REPLAY

DU bank conflict replay.
Dual memory access to the same bank but on different lines.

0xa2 DU_CREDIT_REPLAY

Number of time a packet took a replay because insufficient
QoS data unit credits were available.

0xa3 L2_FIFO_FULL_REPLAY

Counts L2 even/odd FIFO full replays.

0xa4 DU_STORE_BUFFER_FULL_REPLAY

First packet puts access in DU store buffer (memop,
store.new, load/store bank conflict, store/store bank conflict).
A later packet tries to use the store buffer before the first one
evicts, and thus it must replay so the store buffer can drain.

0xa7 DU_SNOOP_REQUEST

Data unit snoop requests that were accepted.

0xa8 DU_FILL_REPLAY

A fill has a index conflict with an instruction from the same
thread in a pipeline.
Fills and demands might be from different threads if:



0xab DU_EVICTIONS_SENT_TO_L2

There is a prefetch from the deferral queue
Or if a fill has not be acknowledged for too long and forces
itself into the pipeline

Number of dirty line evictions sent from the data unit to L2
FIFO.
Includes dirty line evictions caused by cache operations and
dczeroes.

0xac

DU_READ_TO_L2

Data unit read to L2. Total of everything that brings data from
L2.
Includes prefetches (DCFETCH and HWPREFETCH).
Excludes coprocessor loads.

0xad DU_WRITE_TO_L2

Data unit write to L2. Total of everything that is written out of
the data unit to the L2 array.
Includes dczeroa.
Excludes dcclean, dccleaninv, tag writes, and coprocessor
stores.

0xae DCZERO_DATA_WRITE_IN_PIPE_REPLAY Number of replays taken by a packet because a dczero zerowrite in progress is occupying the pipe
0xaf

DCZERO_COMMITTED

0xb0 L2ITCM_IU_READ

Committed a dczeroa instruction.
L2-ITCM access from an instruction unit.
Includes IU demands fetches and IU prefetches.
This event is not included in any other L2 events.

0xb1 L2ITCM_DU_READ

L2-ITCM read access from a data unit.
Includes all demands and prefetches.
This event is not included in any other L2 events.

0xb2 L2ITCM_DU_WRITE

L2-ITCM write accesses from a data unit.
Includes stores, and dczeroa events.
Does not include any cache operations.
This event is not included in any other L2 events.

80-N2040-46 Rev. B

148

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0xb3 DTLB_MISS

DTLB miss that goes to JTLB.
When both slots miss to different pages, increments by 2.
When both slots miss to the same page, only counts S1,
because S1 goes first and fills for S0.

0xb4 L2ITCM_BIMODAL_WRITES_SUCCESS

Number of successful bimodal writes into L2-ITCM.

0xb6 STORE_BUFFER_HIT_REPLAY

Store buffer hit is replayed because a packet with two stores
is going to the same bank but different cache lines, followed
by a load from an address that was pushed into the store
buffer.

0xb7 STORE_BUFFER_FORCE_REPLAY

Store buffer must drain, forcing the current packet to replay.
This typically happens on a cache index match between the
current packet and store buffer. Can also be a store buffer
timeout.

0xb8 TAG_WRITE_CONFLICT_REPLAY

Counts inter-cluster tag write conflicts.

0xb9 SMT_BANK_CONFLICT

Counts inter-thread SMT bank conflicts.

0xba PORT_CONFLICT_REPLAY

Counts all port conflict replays, including the same cluster
replays caused by high priority fills and store buffer force
drains, and also inter-cluster replays.

0xbb L2ITCM_BIMODAL_WRITES_DROPPED

Number of bimodal write into L2-ITCM that were dropped.

0xbc

L2ITCM_IU_PREFETCH_READ

L2-ITCM access from instruction unit prefetches.
Includes only prefetches from an instruction unit.
This events is included in event 176, L2ITCM_IU_READ. It is
not included in any other L2 events

0xbd PAGE_CROSS_REPLAY

Page cross replay. Page cross from valid packet that caused
replay.
Excludes PDKILL packets.
Counts twice if both slots cause a page cross.

0xbf

DU_DEMAND_SECONDARY_MISS

Data unit demand secondary miss.

0xc0

DU_MISC_REPLAY

All data unit replays not counted by other replay events.
This event counts every time ANY_DU_REPLAY counts and
no other data unit replay event counts.

0xc1

GUARDBUF_SETMATCH_CRACKING_REP Number of replays taken by a younger access due to an index
LAY
match with a guard buffer entry.
If the younger access hits in D$, only the guard buffer entry of
the other thread is checked. Otherwise, an index match with
either thread's guard buffer entry results in this replay.

0xc2

GUARDBUF_STATEWRITE_FINALCRACK_ Number of replays taken by the final crack of a thread if the
REPLAY
first crack was doing a write-back store to a clean line
(including store misses causing allocation).

0xc3

DCFETCH_COMMITTED

DCFETCH committed.
Includes hit and dropped. Does not include convert-toprefetches.

0xc4

DCFETCH_HIT

DCFETCH hit in dcache.
Includes hit valid or reserved line

80-N2040-46 Rev. B

149

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0xc5

DCFETCH_MISS

Dcfetch missed in L1. Counts the dcfetches issued to L2
FIFO.

0xc6

DCACHE_EVICTION_IN_PIPE_REPLAY

Number of replays taken by a packet because an eviction in
progress is occupying the pipe.

0xc7

STBUF_MATCH_PARTIAL_CRACK_REPLA Number of replays taken by a partial crack store due to a
Y
dword match with an existing store buffer entry.

0xc8

DU_LOAD_UNCACHEABLE

Uncacheable load in L1 cache.
Counts twice for dual uncachable loads.

0xc9

DU_DUAL_LOAD_UNCACHEABLE

Dual uncacheable loads in L1 cache.

0xca

DU_STORE_UNCACHEABLE

Uncacheable store in L1 cache.
Counts twice for dual uncachable stores.
Excludes uncached memory operations.

0xcb

DU_STORE_RELEASE_CREDIT_STALL

Stall due to not enough credits for a store release.

0xcd

AXI_LINE256_READ_REQUEST

256-byte line read requests issued by the AXI master. All
bytes are valid.

0xce

AXI_LINE64_READ_REQUEST

64-byte line read requests issued by the primary AXI master.

0xcf

AXI_LINE64_WRITE_REQUEST

64-byte line write requests issued by the primary AXI master.
All bytes are valid.

0xd1 AHB_8_READ_REQUEST

An 8 byte AHB read was made.

0xd3 L2FETCH_COMMAND_PAGE_TERMINATI
ON

L2FETCH command terminated because it cannot get a page
translation from virtual address to physical address.
Includes termination dues to permission errors. For example,
an address translation fails because the virtual address to
physical address is not in the TLB. Or the properties in the
translation are not acceptable and the command terminates.

0xd5 L2_DU_STORE_COALESCE

Events from 0x8b that were coalesced.

0xd6 L2_STORE_LINK

Counts the number of times a new store links to something
else in the scoreboard.

0xd7 L2_SCOREBOARD_70_PERCENT_FULL

Increments once for every cycle that the L2 scoreboard is at
least 70% full.
For a 32-entry scoreboard, 23 or more entries are consumed.
This event continues to count even if the scoreboard is more
than 80% full.
For more than one interleave, this event only considers the
scoreboard that has the most entries consumed.

0xd8 L2_SCOREBOARD_80_PERCENT_FULL

Increments once for every cycle that the L2 scoreboard is at
least 80% full.
For a 32-entry scoreboard, 26 or more entries are consumed.
This event continues to count even if the scoreboard is more
than 90% full.
For more than one interleave, this event only considers the
scoreboard that has the most entries consumed.

80-N2040-46 Rev. B

150

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

0xd9 L2_SCOREBOARD_90_PERCENT_FULL

PMU Events

Definition
Increments once for every cycle that the L2 scoreboard is at
least 90% full.
For a 32-entry scoreboard, 29 or more entries are consumed.
For more than one interleave, this event only considers the
scoreboard that has the most entries consumed.

0xda L2_SCOREBOARD_FULL_REJECT

L2 scoreboard is too full to accept a selector request, and the
selector has a request.

0xdc

Counts every cycle when all eviction buffers in any interleave
are occupied.

L2_EVICTION_BUFFERS_FULL

0xdd AHB_MULTI_BEAT_READ_REQUEST

32-byte multi-beat AHB read was made.

0xdf

Of the events in 0x90, the events where the primary miss was
a DCFETCH or L2FETCH.

L2_DU_LOAD_SECONDARY_MISS_ON_S
W_PREFETCH

0xe0 L2FETCH_DROP

L2FETCH data was dropped because a prior eviction has not
completed

0xe5 THREAD_OFF_PVIEW_CYCLES

Cycles cluster cannot commit because a thread is in Off or
Wait mode.

0xe6 ARCH_LOCK_PVIEW_CYCLES

Cycles cluster cannot commit due to a kernel lock or TLB
lock.

0xe7 REDIRECT_PVIEW_CYCLES

Cycles cluster cannot commit due to redirects such as a
branch mispredict.

0xe8 IU_NO_PKT_PVIEW_CYCLES

Cycles cluster cannot commit because the issue queue is
empty.

0xe9 DU_CACHE_MISS_PVIEW_CYCLES

Cycles cluster cannot commit due to a D-cache cacheable
miss.

0xea DU_BUSY_OTHER_PVIEW_CYCLES

Cycles cluster cannot commit due to a data unit replay or
bubble, or a DTLB miss.

0xeb CU_BUSY_PVIEW_CYCLES

Cycles cluster cannot commit because of a register interlock,
register port conflict, bubbles due to a timing class such as
tc_3stall, no branch target buffer HVX, or HVX FIFO full.

0xec

Cycles cluster cannot commit because of a data unit resource
conflict.

SMT_DU_CONFLICT_PVIEW_CYCLES

0xed COPROC_BUSY_PVIEW_CYCLES

Cycles cluster cannot commit because the coprocessor is
busy.

0xee DU_UNCACHED_PVIEW_CYCLES

Cycles cluster cannot commit because of a D-cache
uncacheable access.

0xef

SYSTEM_BUSY_PVIEW_CYCLES

Cycles cluster cannot commit because of system-level stalls
including DMA synchronization, ETM full, Qtimer read not
ready, AXI bus busy, and global cache operation
synchronization.

0xf1

AXI_LINE128_READ_REQUEST_EVEN

128-byte line read requests issued by the even interleaved
AXI.

0xf2

AXI_READ_REQUEST_EVEN

All read requests issued by the even interleaved AXI.

0xf3

AXI_LINE32_READ_REQUEST_EVEN

32-byte line read requests issued by the even interleaved AXI
master.

0xf4

AXI_WRITE_REQUEST_EVEN

All write requests issued by the even interleaved AXI master.

80-N2040-46 Rev. B

151

Hexagon V68 Programmer’s Reference Manual

Table 9-1

V68 processor events symbols

Event

Symbol

PMU Events

Definition

0xf5

AXI_LINE32_WRITE_REQUEST_EVEN

32-byte line write requests issued by the even interleaved AXI
master. All bytes are valid.

0xf6

AXI_LINE128_WRITE_REQUEST_EVEN

128-byte line write requests issued by the even interleaved
AXI master. All bytes are valid.

0xf8

AXI_LINE64_READ_REQUEST_EVEN

64-byte line read requests issued by the even interleaved AXI
master

0xf9

AXI_LINE64_WRITE_REQUEST_EVEN

64-byte line write requests issued by the even interleaved AXI
master. All bytes are valid.

0xfa

AXI_WR_CONGESTION_EVEN

Even interleaved AXI write command or data queue is full. An
operation is stuck at the head of the even interleaved AXI
master command queue.

0xfb

AXI_INCOMPLETE_WRITE_REQUEST_EV
EN

An L2 line-sized write was made to the even AXI, but not all
bytes were valid. This includes segmented writes and
excludes WT stores.
The intent of this event is to capture the number of writes
coalesced at a line level.

0xfc

AXI_LINE256_READ_REQUEST_EVEN

256-byte line read requests issued by the even AXI master.
All bytes are valid.

0xfd

AXI_LINE256_WRITE_REQUEST_EVEN

256-byte line write requests issued by the even AXI master.
All bytes are valid.

0xfe

CYCLES_3_COPROC_THREADS_ONE_CL Cycles a cluster with three active coprocessor threads
USTER
(XE=1).

80-N2040-46 Rev. B

152

10 Instruction Encoding
This chapter describes the binary encoding of Hexagon processor instructions and
instruction packets.

10.1

Instructions
All Hexagon processor instructions are encoded in a 32-bit instruction word. The
instruction word format varies according to the instruction type.
The instruction words contain two types of bit fields:




Common fields appear in every processor instruction, and are defined the same in
all instructions.
Instruction-specific fields appear only in some instructions, or vary in definition
across the instruction set.

Table 10-1 lists the instruction bit fields.
Table 10-1 Instruction fields
Name

80-N2040-46 Rev. B

Description

ICLASS

Instruction class

Parse

Packet / loop bits

Type
Common

153

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Table 10-1 Instruction fields
Name

Description

MajOp
Maj

Major opcode

MinOp
Min

Minor opcode

RegType

Register type (32-bit, 64-bit)

Type

Operand type (byte, halfword, etc.)

Amode

Addressing mode

dn

Destination register operand

sn

Source register operand

tn

Source register operand #2

xn

Source and destination register operand

un

Predicate or modifier register operand

sH

Source register bit field (Rs.H or Rs.L)

tH

Source register #2 bit field (Rt.H or Rt.L)

UN

Unsigned operand

Rs

No source register read

P

Predicate expression

PS

Predicate sense (Pu or !Pu)

DN

Dot-new predicate

PT

Predict taken

sm80-N2040-46
Rev. B

Supervisor mode only

NOTE

Type
Instructionspecific

In some cases, instruction-specific fields encode instruction attributes other
than the ones described for the fields in Table 10-1.

Reserved bits

Some instructions contain reserved bits that do not currently encode instruction attributes.
Always set these bits to 0 to ensure compatibility with any future changes in the
instruction encoding.
NOTE

10.2

Reserved bits appear as ‘-’ characters in the instruction encoding tables.

Sub-instructions
To reduce code size the Hexagon processor supports the encoding of certain pairs of
instructions in a single 32-bit container. Instructions encoded this way are called subinstructions, and the containers are called duplexes (Section 10.3).
Sub-instructions are limited to certain commonly-used instructions:

80-N2040-46 Rev. B

154

Hexagon V68 Programmer’s Reference Manual



Arithmetic and logical operations



Register transfer



Loads and stores



Stack frame allocation/deallocation



Subroutine return

Instruction Encoding

Table 10-2 lists the sub-instructions along with the group identifiers that encode them in
duplexes.
Sub-instructions can access only a subset of the general registers (R0-R7, R16-R23).
Table 10-3 lists the sub-instruction register encodings.
NOTE

Certain sub-instructions implicitly access registers such as SP (R29).

Table 10-2 Sub-instructions
Group

Instruction

Description

L1

Rd = memw(Rs+#u4:2)

Word load

L1

Rd = memub(Rs+#u4:0)

Unsigned byte load

Group

Instruction

Instruction

L2

Rd = memh/memuh(Rs+#u3:1)

Halfword loads

L2

Rd = memb(Rs+#u3:0)

Signed byte load

L2

Rd = memw(r29+#u5:2)

Load word from stack

L2

Rdd = memd(r29+#u5:3)

Load pair from stack

L2

deallocframe

Dealloc stack frame

L2

if ([!]P0) dealloc_return
if ([!]P0.new) dealloc_return:nt

Dealloc stack frame and return

L2

jumpr R31
if ([!]P0) jumpr R31
if ([!]P0.new) jumpr:nt R31

Return

Group

Instruction

Instruction

S1

memw(Rs+#u4:2) = Rt

Store word

S1

memb(Rs+#u4:0) = Rt

Store byte

Group

Instruction

Instruction

S2

memh(Rs+#u3:1) = Rt

Store halfword

S2

memw(r29+#u5:2) = Rt

Store word to stack

S2

memd(r29+#s6:3) = Rtt

Store pair to stack

S2

memw(Rs+#u4:2) = #U1

Store immediate word #0 or #1

S2

memb(Rs+#u4) = #U1

Store immediate byte #0 or #1

S2

allocframe(#u5:3)

Allocate stack frame

Group

Instruction

Instruction

A

Rx = add(Rx,#s7)

Add immediate

A

Rd = Rs

Transfer

80-N2040-46 Rev. B

155

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Table 10-2 Sub-instructions (Continued)
Group

Instruction

Description

A

Rd = #u6

Set to unsigned immediate

A

Rd = #-1

Set to -1

A

if ([!]P0[.new]) Rd = #0

Conditional clear

A

Rd = add(r29,#u6:2)

Add immediate to stack pointer

A

Rx = add(Rx,Rs)

Register add

A

P0 = cmp.eq(Rs,#u2)

Compare register equal immed

A

Rdd = combine(#0,Rs)

Combine zero and register into pair

A

Rdd = combine(Rs,#0)

Combine register and zero into pair

A

Rdd = combine(#u2,#U2)

Combine immediates into pair

A

Rd = add(Rs,#1)
Rd = add(Rs,#-1)

Add and Subtract 1

A

Rd = sxth/sxtb/zxtb/zxth(Rs)

Sign- and zero-extends

A

Rd = and(Rs,#1)

And with 1

Table 10-3 Sub-instruction registers
Register

80-N2040-46 Rev. B

Encoding

Rs,Rt,Rd,Rx

0000 = R0
0001 = R1
0010 = R2
0011 = R3
0100 = R4
0101 = R5
0110 = R6
0111 = R7
1000 = R16
1001 = R17
1010 = R18
1011 = R19
1100 = R20
1101 = R21
1110 = R22
1111 = R23

Rdd,Rtt

000 = R1:0
001 = R3:2
010 = R5:4
011 = R7:6
100 = R17:16
101 = R19:18
110 = R21:20
111 = R23:22

156

Hexagon V68 Programmer’s Reference Manual

10.3

Instruction Encoding

Duplexes
A duplex is encoded as a 32-bit instruction with bits [15:14] set to 00. The sub-instructions
(Section 10.2) that comprise a duplex are encoded as 13-bit fields in the duplex.
Table 10-4 shows the encoding details for a duplex.
An instruction packet can contain one duplex and up to two other (non-duplex)
instructions. The duplex must always appear as the last word in a packet.
The sub-instructions in a duplex are always executed in Slot 0 and Slot 1.
Table 10-4 Duplex instruction
Bits

Name

Description

15:14

Parse Bits

00 = Duplex type, ends the packet and indicates that
word contains two sub-instructions

12:0

Sub-insn low

Encodes Slot 0 sub-instruction

28:16

Sub-insn high

Encodes Slot 1 sub-instruction

31:29, 13

4-bit ICLASS

Indicates which group the low and high sub-instructions
below to.

Table 10-5 lists the duplex ICLASS field values, which specify the group of each subinstruction in a duplex.
Table 10-5 Duplex ICLASS field

80-N2040-46 Rev. B

ICLASS

Low Slot 0 subinsn type

High Slot 1 subinsn type

0x0

L1-type

L1-type

0x1

L2-type

L1-type

0x2

L2-type

L2-type

0x3

A-type

A-type

0x4

L1-type

A-type

0x5

L2-type

A-type

0x6

S1-type

A-type

0x7

S2-type

A-type

0x8

S1-type

L1-type

0x9

S1-type

L2-type

0xA

S1-type

S1-type

0xB

S2-type

S1-type

0xC

S2-type

L1-type

0xD

S2-type

L2-type

0xE

S2-type

S2-type

0xF

Reserved

Reserved

157

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Duplexes have the following grouping constraints:


Constant extenders expand the range of an instruction’s immediate operand to 32
bits (Section 10.9). The following sub-instructions can be expanded with a
constant extender:
•

Rx = add(Rx,#s7)

•

Rd = #u6

A duplex can contain only one constant-extended instruction, and it must appear
in the Slot 1 position.




If a duplex contains two instructions with the same sub-instruction group, the
instructions must be ordered in the duplex as follows: when the sub-instructions
are treated as 13-bit unsigned integer values, the instruction corresponding to the
numerically smaller value must be encoded in the Slot 1 position of the duplex.1
Sub-instructions must conform to any slot assignment grouping rules that apply to
the individual instructions, even if a duplex pattern exists which violates those
assignments. One exception to this rule exists:
•

jumpr R31 must appear in the Slot 0 position

1 The sub-instruction register and immediate fields are assumed to be 0 when performing this

comparison.

80-N2040-46 Rev. B

158

Hexagon V68 Programmer’s Reference Manual

10.4

Instruction Encoding

Instruction classes
The instruction class (Section 3.2) is encoded in the four most-significant bits of the
instruction word (31:28). These bits are referred to as the instruction’s ICLASS field.
Table 10-6 lists the encoding values for the instruction classes. The Slots column indicates
which slots can receive the instruction class.
Table 10-6 Instruction class encoding
Encoding

Instruction Class

Slots

0000

Constant extender (Section 10.9)

–

0001

J

2,3

0010

J

2,3

0011

LD
ST

0,1

0100

LD
ST

0,1

(conditional or GP-relative)

0101

J

2,3

0110

CR

3

0111

ALU32

0,1,2,3

1000

XTYPE

2,3

1001

LD

0,1

1010

ST

0

1011

ALU32

0,1,2,3

1100

XTYPE

2,3

1101

XTYPE

2,3

1110

XTYPE

2,3

1111

ALU32

0,1,2,3

For details on encoding the individual class types see Chapter 11.

80-N2040-46 Rev. B

159

Hexagon V68 Programmer’s Reference Manual

10.5

Instruction Encoding

Instruction packets
Instruction packets are encoded using two bits of the instruction word (15:14), which are
referred to as the instruction word’s Parse field. The field values have the following
definitions:


‘11’ indicates that an instruction is the last instruction in a packet (i.e., the
instruction word at the highest address).



‘01’ or ‘10’ indicate that an instruction is not the last instruction in a packet.



‘00’indicates a duplex (Section 10.3)

If any sequence of four consecutive instructions occurs without one of them containing
‘11’ or ‘00’, the processor raises an error exception (illegal opcode).
Figure 10-1 shows the location of the Parse field in an instruction word.
31

16

15

0

P

P

Packet / Loop Parse Bits:
01, 10 = not end of packet
11 = end of packet
00 = duplex

Figure 10-1 Instruction packet encoding

The following examples show how to use the Parse field to encode instruction packets:

80-N2040-46 Rev. B

{ A ; B}
01 11

// Parse fields of instrs A,B

{ A ; B ; C}
01 01 11

// Parse fields of instrs A,B,C

{ A ; B ; C ; D}
01 01 01 11

// Parse fields of instrs A,B,C,D

160

Hexagon V68 Programmer’s Reference Manual

10.6

Instruction Encoding

Loop packets
In addition to encoding the last instruction in a packet, the instruction word’s Parse field
(Section 10.5) encodes the last packet in a hardware loop.
The Hexagon processor supports two hardware loops, labeled 0 and 1 (Section 8.2). The
last packet in these loops is subject to the following restrictions:


The last packet in a hardware loop 0 must contain two or more instruction words.



The last packet in a hardware loop 1 must contain three or more instruction words.

If the last packet in a loop is expressed in assembly language with fewer than the required
number of words, the assembler automatically adds one or two NOP instructions to the
encoded packet so it contains the minimum required number of instruction words.
The Parse fields in a packet’s first and second instruction words (i.e., the words at the
lowest addresses) encode whether the packet is the last packet in a hardware loop.
Table 10-7 shows how the Parse fields encode loop packets.
Table 10-7 Loop packet encoding
Parse Field in
First Instruction

Parse Field in
Second Instruction

Not last in loop

01 or 11

01 or 11 1

Last in loop 0

10

01 or 11

Last in loop 1

01

10

Last in loops 0 & 1

10

10

Packet

1

Not applicable for single-instruction packets.

The following examples show how to use the Parse field to encode loop packets:

80-N2040-46 Rev. B

{ A
10

B}:endloop0
11

// Parse fields of instrs A,B

{ A
10

B
01

C}:endloop0
11

// Parse fields of instrs A,B,C

{ A
10

B
01

C
01

{ A
01

B
10

C}:endloop1
11

// Parse fields of instrs A,B,C

{ A
01

B
10

C
01

D}:endloop1
11

// Parse fields of instrs A,B,C,D

{ A
10

B
10

C}:endloop0:endloop1
11

// Parse fields of instrs A,B,C

{ A
10

B
10

C
01

D}:endloop0
11

// Parse fields of instrs A,B,C,D

D}:endloop0:endloop1
11
// Parse fields of instrs A,B,C,D

161

Hexagon V68 Programmer’s Reference Manual

10.7

Instruction Encoding

Immediate values
To conserve encoding space, the Hexagon processor often stores immediate values in
instruction fields that are smaller (in bit size) than the values actually needed in the
instruction operation.
When an instruction operates on one of its immediate operands, the processor
automatically extends the immediate value to the bit size required by the operation:

10.8



Signed immediate values are sign-extended



Unsigned immediate values are zero-extended

Scaled immediates
To minimize the number of bits used in instruction words to store certain immediate
values, the Hexagon processor stores the values as scaled immediates. Scaled immediate
values are used when an immediate value must represent integral multiples of a power of 2
in a specific range.
For example, consider an instruction operand whose possible values are the following:
-32, -28, -24, -20, -16, -12, -8, -4, 0, 4, 8, 12, 16, 20, 24, 28
Encoding the full range of integers -32..28 would normally require 6 bits. However, if the
operand is stored as a scaled immediate, it can first be shifted right by two bits, with only
the four remaining bits being stored in the instruction word. When the operand is fetched
from the instruction word, the processor automatically shifts the value left by two bits to
recreate the original operand value.
NOTE

The scaled immediate value in the example above is represented notationally
as #s4:2. For more information see Section 1.4.

Scaled immediate values commonly encode address offsets which apply to data types of
varying size. For example, Table 10-8 shows how to use the byte offsets in immediatewith-offset addressing mode are stored as 11-bit scaled immediate values. This enables the
offsets to span the same range of data elements regardless of the data type.
Table 10-8 Scaled immediate encoding (indirect offsets)
Offset Size
(Stored)

Scale
Bits

Offset Size
(Effective)

Offset Range
(Bytes)

Offset Range
(Elements)

byte

11

0

11

-1024 ... 1023

-1024 ... 1023

halfword

11

1

12

-2048 ... 2046

-1024 ... 1023

word

11

2

13

-4096 ... 4092

-1024 ... 1023

doubleword

11

3

14

-8192 ... 8184

-1024 ... 1023

Data Type

80-N2040-46 Rev. B

162

Hexagon V68 Programmer’s Reference Manual

10.9

Instruction Encoding

Constant extenders
To support the use of 32-bit operands in a number of instructions, the Hexagon processor
defines an instruction word which exists solely to extend the bit range of an immediate or
address operand that is contained in an adjacent instruction in a packet. These instruction
words are called constant extenders.
For example, the absolute addressing mode specifies a 32-bit constant value as the
effective address. Instructions using this addressing mode are encoded in a single packet
containing both the normal instruction word and a second word with a constant extender
that increases the range of the instruction’s normal constant operand to a full 32 bits.
NOTE

Constant extended operands can encode symbols.

A constant extender is encoded as a 32-bit instruction with the 4-bit ICLASS field set to 0
and the 2-bit Parse field set to its usual value (Section 10.5). The remaining 26 bits in the
instruction word store the data bits that are prepended to an operand as small as 6 bits to
create a full 32-bit value.
Table 10-9 shows the encoding details.
Table 10-9 Constant extender encoding
Bits

Name

Description

31:28

ICLASS

Instruction class = 0000

27:16

Extender high

High 12 bits of 26-bit constant extension

15:14

Parse

Parse bits

13:0

Extender low

Low 14 bits of 26-bit constant extension

Within a packet, a constant extender must be positioned immediately before the
instruction that it extends: in terms of memory addresses, the extender word must reside at
address (<instr_address> - 4).
The constant extender effectively serves as a prefix for an instruction: it is not executed in
a slot, nor does it consume any slot resources. All packets must contain four or fewer
words, and the constant extender occupies one word.
If the instruction operand to extend is longer than 6 bits, the overlapping bits in the base
instruction must be encoded as zeros. The value in the constant extender always supplies
the upper 26 bits.
Table 10-10 lists the instructions that work with constant extenders.
The Regclass field in the table lists the values to set bits [27:24] to in the instruction
word to identify the instruction as one that may include a constant extender.
NOTE

When the base instruction encodes two constant operands, the extended
immediate is the one specified in the table.
Constant extenders appear in disassembly listings as Hexagon instructions
with the name immext.

80-N2040-46 Rev. B

163

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Table 10-10 Constant extender instructions
ICLASS

Regclass

Instructions

LD

---1

Rd = mem{b,ub,h,uh,w,d}(##U32)
if ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (Rs + ##U32)
// predicated loads

LD

----

Rd = mem{b,ub,h,uh,w,d} (Rs + ##U32)
Rd = mem{b,ub,h,uh,w,d} (Re=##U32)
Rd = mem{b,ub,h,uh,w,d} (Rt<<#u2 + ##U32)
if ([!]Pt[.new]) Rd = mem{b,ub,h,uh,w,d} (##U32)

ST

---0

mem{b,h,w,d}(##U32) = Rs[.new]
// GP-stores
if ([!]Pt[.new]) mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
// predicated stores

ST

----

mem{b,h,w,d}(Rs + ##U32) = Rt[.new]
mem{b,h,w,d}(Rd=##U32) = Rt[.new]
mem{b,h,w,d}(Ru<<#u2 + ##U32) = Rt[.new]
if ([!]Pt[.new]) mem{b,h,w,d}(##U32) = Rt[.new]

MEMOP

----

[if [!]Ps] memw(Rs + #u6) = ##U32
memw(Rs + Rt<<#u2) = ##U32

NV

----

if (cmp.xx(Rs.new,##U32)) jump:hint target

ALU32

----

Rd = ##u32
Rdd = combine(Rs,##u32)
Rdd = combine(##u32,Rs)
Rdd = combine(##u32,#s8)
Rdd = combine(#s8,##u32)
Rd = mux (Pu, Rs,##u32)
Rd = mux (Pu, ##u32, Rs)
Rd = mux(Pu,##u32,#s8)
if ([!]Pu[.new]) Rd = add(Rs,##u32)
if ([!]Pu[.new]) Rd = ##u32
Pd = [!]cmp.eq (Rs,##u32)
Pd = [!]cmp.gt (Rs,##u32)
Pd = [!]cmp.gtu (Rs,##u32)
Rd = [!]cmp.eq(Rs,##u32)
Rd = and(Rs,##u32)
Rd = or(Rs,##u32)
Rd = sub(##u32,Rs)

ALU32

----

Rd = add(Rs,##s32)

XTYPE

00--

Rd = mpyi(Rs,##u32)
Rd += mpyi(Rs,##u32)
Rd -= mpyi(Rs,##u32)
Rx += add(Rs,##u32)
Rx -= add(Rs,##u32)

ALU32

---- 1

Rd = ##u32
Rd = add(Rs,##s32)

J

1---

jump (PC + ##s32)
call (PC + ##s32)
if ([!]Pu) call (PC + ##s32)

80-N2040-46 Rev. B

// constant store
// constant store

164

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Table 10-10 Constant extender instructions (Continued)
ICLASS

Regclass

Instructions

CR

----

Pd = spNloop0(PC+##s32,Rs/#U10)
loop0/1 (PC+##s32,#Rs/#U10)

XTYPE

1---

Rd = add(pc,##s32)
Rd = add(##u32,mpyi(Rs,#u6))
Rd = add(##u32,mpyi(Rs,Rt))
Rd = add(Rs,add(Rt,##u32))
Rd = add(Rs,sub(##u32,Rt))
Rd = sub(##u32,add(Rs,Rt))
Rd = or(Rs,and(Rt,##u32))
Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,#U5))
Rx = add/sub/and/or (##u32,asl/asr/lsr(Rs,Rx))
Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,Rs))
Pd = cmpb/h.{eq,gt,gtu} (Rs,##u32)

1

Constant extension is only for a Slot 1 sub-instruction.

NOTE

If a constant extender is encoded in a packet for an instruction that does not
accept a constant extender, the execution result is undefined. The assembler
normally ensures that only valid constant extenders are generated.

Encoding 32-bit address operands in load/stores

Two methods exist for encoding a 32-bit absolute address in a load or store instruction:
1) For unconditional load/stores, the GP-relative load/store instruction is used. The
assembler encodes the absolute 32-bit address as follows:



The upper 26 bits are encoded in a constant extender
The lower 6 bits are encoded in the 6 operand bits contained in the GP-relative
instruction

In this case the 32-bit value encoded must be a plain address, and the value stored in the
GP register is ignored.
NOTE

When a constant extender is explicitly specified with a GP-relative load/store,
the processor ignores the value in GP and creates the effective address directly
from the 32-bit constant value.

2) For conditional load/store instructions that have their base address encoded only by a 6bit immediate operand, a constant extender must be explicitly specified; otherwise, the
execution result is undefined. The assembler ensures that these instructions always include
a constant extender.
This case applies also to instructions that use the absolute-set addressing mode or
absolute-plus-register-offset addressing mode.

80-N2040-46 Rev. B

165

Hexagon V68 Programmer’s Reference Manual

Instruction Encoding

Encoding 32-bit immediate operands

The immediate operands of certain instructions use scaled immediates (Section 10.8) to
increase their addressable range. When constant extenders are used, scaled immediates are
not scaled by the processor. Instead, the assembler must encode the full 32-bit unscaled
value as follows:





The upper 26 bits are encoded in the constant extender
The lower 6 bits are encoded in the base instruction in the least-significant bit
positions of the immediate operand field.
Any overlapping bits in the base instruction are encoded as zeros.

Encoding 32-bit jump/call target addresses

When a jump/call has a constant extender, the resulting target address is forced to a 32-bit
alignment (i.e., bits 1:0 in the address are cleared by hardware). The resulting jump/call
operation never causes an alignment violation.

10.10

New-value operands
Instructions that include a new-value register operand specify in their encodings which
instruction in the packet has its destination register accessed as the new-value register.
New-value consumers include a 3-bit instruction field named Nt which specifies this
information.




Nt[0] is reserved and should always be encoded as zero. A non-zero value
produces undefined results.
Nt[2:1] encodes the distance (in instructions) from the producer to the consumer,
as follows:


Nt[2:1] = 00

// reserved



Nt[2:1] = 01

// producer is +1 instruction ahead of consumer



Nt[2:1] = 10

// producer is +2 instructions ahead of consumer



Nt[2:1] = 11

// producer is +3 instructions ahead of consumer

“ahead” is defined here as the instruction encoded at a lower memory address than the
consumer instruction, not counting empty slots or constant extenders. For example, the
following producer/consumer relationship would be encoded with Nt[2:1] set to 01.
...
<producer instruction word>
<consumer constant extender word>
<consumer instruction word>
...
NOTE

80-N2040-46 Rev. B

Instructions with 64-bit register pair destinations cannot produce new-values.
The assembler flags this case with an error, as the result is undefined.

166

Hexagon V68 Programmer’s Reference Manual

10.11

Instruction Encoding

Instruction mapping
Some Hexagon processor instructions are encoded by the assembler as variants of other
instructions. This is done for operations that are functionally equivalent to other
instructions, but are still defined as separate instructions because of their programming
utility as common operations.
Table 10-11 lists some of the instructions that are mapped to other instructions.
Table 10-11 Instruction mapping
Instruction

80-N2040-46 Rev. B

Mapping

Rd = not(Rs)

Rd = sub(#-1,Rs)

Rd = neg(Rs)

Rd = sub(#0,Rs)

Rdd = Rss

Rdd = combine(Rss.H32, Rss.L32)

167

11 Instruction Set
This chapter describes the instruction set for version 6 of the Hexagon processor.
The instructions are listed alphabetically within instruction categories. The following
information is provided for each instruction:
■

Instruction name

■

A brief description of the instruction

■

A high-level functional description (syntax and behavior) with all possible
operand types

■

Instruction class and slot information for grouping instructions in packets

■

Notes on miscellaneous issues

■

Any C intrinsic functions that provide access to the instruction

■

Instruction encoding

Table 11-1 lists the symbols that specify the instruction syntax.

Table 11-1

80-N2040-46 Rev. B

Instruction syntax symbols

Symbol

Example

Meaning

=

R2 = R3;

Assignment of RHS to LHS

;

R2 = R3;

Marks the end of an instruction or group of
instructions

{…}

{R2 = R3; R5 = R6;}

Indicates a group of parallel instructions.

#

#100

Immediate constant value

##

##2147483647

32-bit immediate constant value

0x

R2 = #0x1fe;

Indicates hexadecimal number

MEMxx

R2 = MEMxx(R3)

Access memory. xx specifies the size and
type of access.

:sat

R2 = add(r1,r2):sat

Perform optional saturation

:rnd

R2 = mpy(r1.h,r2.h):rnd

Perform optional rounding

:<<16

R2 = add(r1.l,r2.l):<<16

Shift left by a halfword

168

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Table 11-2 lists the symbols that specify instruction operands.
Table 11-2

Instruction operand symbols

Symbol

Example

Meaning

#uN

R2 = #u16

Unsigned N-bit immediate value

#sN

R2 = add(R3,#s16)

Signed N-bit immediate value

#mN

Rd = mpyi(Rs,#m9)

Signed N-bit immediate value

#uN:S

R2 = memh(#u16:1)

Unsigned N-bit immediate value representing
integral multiples of 2S in specified range

#sN:S

Rd = memw(Rs++#s4:2)

Signed N-bit immediate value representing
integral multiples of 2S in specified range

#rN:S

call #r22:2

Same as #sN:S, but value is offset from PC of
current packet

##

call ##32

Same as #, but associated value (u,s,m,r) is 32
bits

When an instruction contains more than one immediate operand, the operand symbols are
specified in upper and lower case (e.g., #uN and #UN) to indicate where they appear in the
instruction encodings.
Specify the instruction behavior using a superset of the C language. Table 11-3 lists
symbols not defined in C that specify the instruction behavior.
Table 11-3

Instruction behavior symbols

Symbol

Example

Meaning

usat_N

usat_16(Rs)

Saturate a value to an unsigned N-bit

sat_N

sat_16(Rs)

Saturate a value to a signed N-bit number

sxt x->y

sxt32->64(Rs)

Sign-extend value from x to y bits

zxt x->y

zxt32->64(Rs)

Zero-extend value from x to y bits

>>>

Rss >>> offset

Logical right shift

80-N2040-46 Rev. B

169

Hexagon V68 Programmer’s Reference Manual

11.1

Instruction Set

ALU32
The ALU32 instruction class includes instructions which perform arithmetic and logical
operations on 32-bit data.
ALU32 instructions are executable on any slot.

11.1.1

ALU32/ALU
The ALU32/ALU instruction subclass includes instructions which perform arithmetic and
logical operations on individual 32-bit items.

Add
Adds a source register either to another source register or to a signed 16-bit immediate
value. Store result in destination register. Source and destination registers are 32 bits. If the
result overflows 32 bits, it wraps around. Optionally saturate result to a signed value
between 0x80000000 and 0x7fffffff.
For 64-bit versions of this operation, see the XTYPE add instructions.
Syntax

Behavior

Rd=add(Rs,#s16)

apply_extension(#s);
Rd=Rs+#s;

Rd=add(Rs,Rt)

Rd=Rs+Rt;

Rd=add(Rs,Rt):sat

Rd=sat_32(Rs+Rt);

Class: ALU32 (slots 0,1,2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rd=add(Rs,#s16)

Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)

Rd=add(Rs,Rt)

Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)

Rd=add(Rs,Rt):sat

Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)

170

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

s5
1

ICLASS

i

i

P

i

i

i

MajOp

i

i

s

s

MinOp

s

8

7

6

5

4

3

i

i

i

i

d

d

Parse
s

s

s5

P

P

2

1

0

d

d Rd=add(Rs,#s16)

d5
i

i

i

Parse

i

i

t5

d
d5

1

1

1

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=add(Rs,Rt)

1

1

1

1

0

1

1

0

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=add(Rs,Rt):sat

Field name
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

171

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical operations
Performs bitwise logical operations (AND, OR, XOR, NOT) either on two source
registers or on a source register and a signed 10-bit immediate value. Stores the result in
the destination register. Source and destination registers are 32 bits.
For 64-bit versions of these operations, see the XTYPE logical instructions.
Syntax

Behavior

Rd=and(Rs,#s10)

apply_extension(#s);
Rd=Rs&#s;

Rd=and(Rs,Rt)

Rd=Rs&Rt;

Rd=and(Rt,~Rs)

Rd = (Rt & ~Rs);

Rd=not(Rs)

Assembler mapped to: "Rd=sub(#-1,Rs)"

Rd=or(Rs,#s10)

apply_extension(#s);
Rd=Rs|#s;

Rd=or(Rs,Rt)

Rd=Rs|Rt;

Rd=or(Rt,~Rs)

Rd = (Rt | ~Rs);

Rd=xor(Rs,Rt)

Rd=Rs^Rt;

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=and(Rs,#s10)

Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)

Rd=and(Rs,Rt)

Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)

Rd=and(Rt,~Rs)

Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)

Rd=not(Rs)

Word32 Q6_R_not_R(Word32 Rs)

Rd=or(Rs,#s10)

Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)

Rd=or(Rs,Rt)

Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)

Rd=or(Rt,~Rs)

Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)

Rd=xor(Rs,Rt)

Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

1

0

1

1

0

0

0

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=and(Rs,#s10)

0

1

1

1

0

1

1

0

1

0

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=or(Rs,#s10)

ICLASS

P

MajOp

80-N2040-46 Rev. B

MinOp

s5

Parse

t5

d5

172

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

1

1

1

0

0

0

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=and(Rs,Rt)

1

1

1

1

0

0

0

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=or(Rs,Rt)

1

1

1

1

0

0

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=xor(Rs,Rt)

1

1

1

1

0

0

0

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=and(Rt,~Rs)

1

1

1

1

0

0

0

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=or(Rt,~Rs)

Field name
MajOp
MinOp
Rs
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

173

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Negate
Performs arithmetic negation on a source register. Stores the result in the destination
register. Source and destination registers are 32 bits.
For 64-bit and saturating versions of this instruction, see the XTYPE-class negate
instructions.
Syntax

Behavior

Rd=neg(Rs)

Assembler mapped to: "Rd=sub(#0,Rs)"

Class: N/A
Intrinsics
Rd=neg(Rs)

80-N2040-46 Rev. B

Word32 Q6_R_neg_R(Word32 Rs)

174

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Nop
Performs no operation. This instruction is used for padding and alignment.
Within a packet, it can be positioned in any slot 0-3.
Syntax

Behavior

nop

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

Rs
1

1

MajOp
1

1

1

-

-

Field name
MajOp
Rs
ICLASS
Parse

80-N2040-46 Rev. B

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

Parse
-

-

-

-

-

-

P

P

-

-

-

-

-

nop

Description
Major Opcode
No Rs read
Instruction Class
Packet/Loop parse bits

175

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Subtract
Subtracts a source register from either another source register or from a signed 10-bit
immediate value. Stores the result in the destination register. Source and destination
registers are 32 bits. If the result underflows 32 bits, it wraps around. Optionally, saturates
the result to a signed value between 0x8000_0000 and 0x7fff_ffff.
For 64-bit versions of this operation, see the XTYPE subtract instructions.
Syntax

Behavior

Rd=sub(#s10,Rs)

apply_extension(#s);
Rd=#s-Rs;

Rd=sub(Rt,Rs)

Rd=Rt-Rs;

Rd=sub(Rt,Rs):sat

Rd=sat_32(Rt - Rs);

Class: ALU32 (slots 0,1,2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=sub(#s10,Rs)

Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)

Rd=sub(Rt,Rs)

Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)

Rd=sub(Rt,Rs):sat

Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

Rs
1

ICLASS

0

MajOp
1

P

1

0

MinOp
0

MajOp

1

s5
i

s

s

MinOp

s

8

7

6

5

4

3

Parse
s

s

s5

P

P

2

1

0

d

d Rd=sub(#s10,Rs)

d5
i

i

i

Parse

i

i

i

i

i

i

d

d

t5

d
d5

1

1

1

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=sub(Rt,Rs)

1

1

1

1

0

1

1

0

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=sub(Rt,Rs):sat

Field name
MajOp
MinOp
Rs
MajOp
MinOp
P
ICLASS

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Minor Opcode
Predicated
Instruction Class

176

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

177

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Sign extend
Sign-extends the least-significant byte or halfword from the source register and places the
32-bit result in the destination register.
Rd=sxth(Rs)

Rd=sxtb(Rs)
Rs

Rs

Sign-extend

Sign-extend

Rd

Syntax

Behavior

Rd=sxtb(Rs)

Rd = sxt8->32(Rs);

Rd=sxth(Rs)

Rd = sxt16->32(Rs);

Rd

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=sxtb(Rs)

Word32 Q6_R_sxtb_R(Word32 Rs)

Rd=sxth(Rs)

Word32 Q6_R_sxth_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

Parse C

2

1

0

d5

0

1

1

1

0

0

0

0

1

0

1

s

s

s

s

s

P

P 0

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=sxtb(Rs)

0

1

1

1

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=sxth(Rs)

Field name
MajOp
MinOp
Rs
C
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

178

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Transfer immediate
Assigns an immediate value to a 32-bit destination register.
Two types of assignment are supported. The first sign-extends a 16-bit signed immediate
value to 32 bits. The second assigns a 16-bit unsigned immediate value to either the upper
or lower 16 bits of the destination register, leaving the other 16 bits unchanged.
Rd=#s16
Sign-Extend

16-bit immediate
Rx.H=#u16

16-bit immediate

Unchanged
Rx.L=#u16

Unchanged

16-bit immediate

Syntax

Behavior

Rd=#s16

apply_extension(#s);
Rd=#s;

Rdd=#s8

if ("#s8<0") {
Assembler mapped to: "Rdd=combine(#-1,#s8)";
} else {
Assembler mapped to: "Rdd=combine(#0,#s8)";
}

Rx.[HL]=#u16

Rx.h[01]=#u;

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=#s16

Word32 Q6_R_equals_I(Word32 Is16)

Rdd=#s8

Word64 Q6_P_equals_I(Word32 Is8)

Rx.H=#u16

Word32 Q6_Rh_equals_I(Word32 Rx, Word32 Iu16)

Rx.L=#u16

Word32 Q6_Rl_equals_I(Word32 Rx, Word32 Iu16)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

x5

8

7

6

5

4

3

2

1

0

Parse

0

1

1

1

0

0

0

1

i

i

1

x

x

x

x

x

P

P

i

i

i

i

i

i

i

i

i

i

i

i

i

i

Rx.L=#u16

0

1

1

1

0

0

1

0

i

i

1

x

x

x

x

x

P

P

i

i

i

i

i

i

i

i

i

i

i

i

i

i

Rx.H=#u16

d

d Rd=#s16

ICLASS
0

1

1

Rs
1

1

MajOp
0

80-N2040-46 Rev. B

0

0

MinOp
i

i

Parse
-

i

i

i

i

i

P

P

d5
i

i

i

i

i

i

i

i

i

d

d

d

179

Hexagon V68 Programmer’s Reference Manual

Field name
MajOp
MinOp
Rs
ICLASS
Parse
d5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Major Opcode
Minor Opcode
No Rs read
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register x

180

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Transfer register
Transfers a source register to a destination register. Source and destination registers are
either 32 bits or 64 bits.
Syntax

Behavior

Rd=Rs

Rd=Rs;

Rdd=Rss

Assembler mapped to:
"Rdd=combine(Rss.H32,Rss.L32)"

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=Rs

Word32 Q6_R_equals_R(Word32 Rs)

Rdd=Rss

Word64 Q6_P_equals_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

Rs
1

0

MajOp
0

0

0

MinOp
0

1

Field name
MajOp
MinOp
Rs
C
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

1

s5
s

s

s

8

7

6

5

4

3

Parse C
s

s

P

P 0

2

1

0

d

d Rd=Rs

d5
-

-

-

-

-

-

-

-

d

d

d

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

181

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add halfwords
Adds the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rt. The results are
optionally saturated to signed or unsigned 16-bit values.
Syntax

Behavior

Rd=vaddh(Rs,Rt)[:sat]

for (i=0;i<2;i++) {
Rd.h[i]=[sat_16](Rs.h[i]+Rt.h[i]);
}

Rd=vadduh(Rs,Rt):sat

for (i=0;i<2;i++) {
Rd.h[i]=usat_16(Rs.uh[i]+Rt.uh[i]);
}

Class: ALU32 (slots 0,1,2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=vaddh(Rs,Rt)

Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)

Rd=vaddh(Rs,Rt):sat

Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32 Rt)

Rd=vadduh(Rs,Rt):sat

Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

1

1

1

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vaddh(Rs,Rt)

1

1

1

1

0

1

1

0

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vaddh(Rs,Rt):sat

1

1

1

1

0

1

1

0

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vadduh(Rs,Rt):sat

Field name
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

182

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector average halfwords
VAVGH adds the two 16-bit halfwords of Rs to the two 16-bit halfwords of Rd, and shifts
the result right by 1 bit. Optionally, a rounding constant is added before shifting.
VNAVGH subtracts the two 16-bit halfwords of Rt from the two 16-bit halfwords of Rs,
and shifts the result right by 1 bit. For vector negative average with rounding, see the
XTYPE VNAVGH instruction.
Syntax

Behavior

Rd=vavgh(Rs,Rt)

for (i=0;i<2;i++) {
Rd.h[i]=((Rs.h[i]+Rt.h[i])>>1);
}

Rd=vavgh(Rs,Rt):rnd

for (i=0;i<2;i++) {
Rd.h[i]=((Rs.h[i]+Rt.h[i]+1)>>1);
}

Rd=vnavgh(Rt,Rs)

for (i=0;i<2;i++) {
Rd.h[i]=((Rt.h[i]-Rs.h[i])>>1);
}

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=vavgh(Rs,Rt)

Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)

Rd=vavgh(Rs,Rt):rnd

Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32 Rt)

Rd=vnavgh(Rt,Rs)

Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

1

1

1

1

0

1

1

1

-

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vavgh(Rs,Rt)

1

1

1

1

0

1

1

1

-

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vavgh(Rs,Rt):rnd

1

1

1

1

0

1

1

1

-

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vnavgh(Rt,Rs)

Field name
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

183

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector subtract halfwords
Subtracts each of the two halfwords in 32-bit vector Rs from the corresponding halfword
in vector Rt. Optionally, saturates each 16-bit addition to either a signed or unsigned 16-bit
value.
Applying saturation to the VSUBH instruction clamps the result to the signed range
0x8000 to 0x7fff, whereas applying saturation to VSUBUH ensures that the unsigned
result is in the range 0 to 0xffff. When saturation is not needed, VSUBH should be used.
Syntax

Behavior

Rd=vsubh(Rt,Rs)[:sat]

for (i=0;i<2;i++) {
Rd.h[i]=[sat_16](Rt.h[i]-Rs.h[i]);
}

Rd=vsubuh(Rt,Rs):sat

for (i=0;i<2;i++) {
Rd.h[i]=usat_16(Rt.uh[i]-Rs.uh[i]);
}

Class: ALU32 (slots 0,1,2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=vsubh(Rt,Rs)

Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)

Rd=vsubh(Rt,Rs):sat

Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32 Rs)

Rd=vsubuh(Rt,Rs):sat

Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

1

1

1

1

0

1

1

0

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vsubh(Rt,Rs)

1

1

1

1

0

1

1

0

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vsubh(Rt,Rs):sat

1

1

1

1

0

1

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=vsubuh(Rt,Rs):sat

Field name
MajOp
MinOp
P
ICLASS
Parse

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits

184

Hexagon V68 Programmer’s Reference Manual

Field name
d5
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register d
Field to encode register s
Field to encode register t

185

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Zero extend
Zero-extend the least significant byte or halfword from Rs and place the 32-bit result in
Rd.
Rd=zxth(Rs)

Rd=zxtb(Rs)
Rs

0x0000

Rs

0x000000

Rd

Rd

Syntax

Behavior

Rd=zxtb(Rs)

Assembler mapped to: "Rd=and(Rs,#255)"

Rd=zxth(Rs)

Rd = zxt16->32(Rs);

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=zxtb(Rs)

Word32 Q6_R_zxtb_R(Word32 Rs)

Rd=zxth(Rs)

Word32 Q6_R_zxth_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

Rs
1

0

MajOp
0

0

0

MinOp
1

1

Field name
MajOp
MinOp
Rs
C
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

-

-

-

-

d

d

Parse C
s

s

P

P 0

2

1

0

d

d Rd=zxth(Rs)

d5
-

-

-

-

d

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

186

Hexagon V68 Programmer’s Reference Manual

11.1.2

Instruction Set

ALU32/PERM
The ALU32/PERM instruction subclass includes instructions which rearrange or perform
format conversion on vector data types.

Combine words into doubleword
Combine halfwords or words into larger values.
In a halfword combine, either the high or low halfword of the first source register is
transferred to the most-significant halfword of the destination register, while either the
high or low halfword of the second source register is transferred to the least-significant
halfword of the destination register. Source and destination registers are 32 bits.
In a word combine, the first source register is transferred to the most-significant word of
the destination register, while the second source register is transferred to the leastsignificant word of the destination register. Source registers are 32 bits and the destination
register is 64 bits.
In a variant of word combine, signed 8-bit immediate values (instead of registers) are
transferred to the most- and least-significant words of the 64-bit destination register.
Optionally one of the immediate values can be 32 bits.
Rd=combine(Rt.[HL],Rs.[HL])
Rt.H

Rt.L

Rs.H

Rs.L
Rdd=combine(Rs,Rt)

Mux

Mux

Rs

Rt

Rd

80-N2040-46 Rev. B

Syntax

Behavior

Rd=combine(Rt.[HL],Rs.[HL])

Rd = (Rt.uh[01]<<16) | Rs.uh[01];

Rdd=combine(#s8,#S8)

apply_extension(#s);
Rdd.w[0]=#S;
Rdd.w[1]=#s;

Rdd=combine(#s8,#U6)

apply_extension(#U);
Rdd.w[0]=#U;
Rdd.w[1]=#s;

Rdd=combine(#s8,Rs)

apply_extension(#s);
Rdd.w[0]=Rs;
Rdd.w[1]=#s;

Rdd=combine(Rs,#s8)

apply_extension(#s);
Rdd.w[0]=#s;
Rdd.w[1]=Rs;

Rdd

187

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=combine(Rs,Rt)

Rdd.w[0]=Rt;
Rdd.w[1]=Rs;

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=combine(Rt.H,Rs.H)

Word32 Q6_R_combine_RhRh(Word32 Rt, Word32 Rs)

Rd=combine(Rt.H,Rs.L)

Word32 Q6_R_combine_RhRl(Word32 Rt, Word32 Rs)

Rd=combine(Rt.L,Rs.H)

Word32 Q6_R_combine_RlRh(Word32 Rt, Word32 Rs)

Rd=combine(Rt.L,Rs.L)

Word32 Q6_R_combine_RlRl(Word32 Rt, Word32 Rs)

Rdd=combine(#s8,#S8)

Word64 Q6_P_combine_II(Word32 Is8, Word32 IS8)

Rdd=combine(#s8,Rs)

Word64 Q6_P_combine_IR(Word32 Is8, Word32 Rs)

Rdd=combine(Rs,#s8)

Word64 Q6_P_combine_RI(Word32 Rs, Word32 Is8)

Rdd=combine(Rs,Rt)

Word64 Q6_P_combine_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

1

0

0

1

1

-

0

0

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=combine(Rs,#s8)

0

1

1

1

0

0

1

1

-

0

1

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=combine(#s8,Rs)

ICLASS

Rs

MajOp

MinOp

Parse

d5

0

1

1

1

1

1

0

0

0

I

I

I

I

I

I

I

P

P

I

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=combine(#s8,#S8)

0

1

1

1

1

1

0

0

1

-

-

I

I

I

I

I

P

P

I

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=combine(#s8,#U6)

ICLASS

P

MajOp

MinOp

s5

Parse

t5

d5

1

1

1

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=combine(Rt.H,Rs.H)

1

1

1

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=combine(Rt.H,Rs.L)

1

1

1

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=combine(Rt.L,Rs.H)

1

1

1

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=combine(Rt.L,Rs.L)

1

1

1

1

0

1

0

1

0

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rdd=combine(Rs,Rt)

Field name
MajOp
MinOp
Rs
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

188

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Mux
Select between two source registers based on the least-significant bit of a predicate
register. If the bit is 1, transfer the first source register to the destination register;
otherwise, transfer the second source register. Source and destination registers are 32 bits.
In a variant of mux, signed 8-bit immediate values can be used instead of registers for
either or both source operands.
For 64-bit versions of this instruction, see the XTYPE vmux instruction.
Syntax

Behavior

Rd=mux(Pu,#s8,#S8)

PREDUSE_TIMING;
apply_extension(#s);
(Pu[0]) ? (Rd=#s):(Rd=#S);

Rd=mux(Pu,#s8,Rs)

PREDUSE_TIMING;
apply_extension(#s);
(Pu[0]) ? (Rd=#s):(Rd=Rs);

Rd=mux(Pu,Rs,#s8)

PREDUSE_TIMING;
apply_extension(#s);
(Pu[0]) ? (Rd=Rs):(Rd=#s);

Rd=mux(Pu,Rs,Rt)

PREDUSE_TIMING;
(Pu[0]) ? (Rd=Rs):(Rd=Rt);

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=mux(Pu,#s8,#S8)

Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8, Word32
IS8)

Rd=mux(Pu,#s8,Rs)

Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8, Word32
Rs)

Rd=mux(Pu,Rs,#s8)

Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs, Word32
Is8)

Rd=mux(Pu,Rs,Rt)

Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs, Word32
Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

u2

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

1

0

0

1

1

0

u

u

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=mux(Pu,Rs,#s8)

0

1

1

1

0

0

1

1

1

u

u

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=mux(Pu,#s8,Rs)

0

1

u

I

I

I

I

I

I

I

i

i

i

i

i

i

i

i

d

d

d

d Rd=mux(Pu,#s8,#S8)

d

d Rd=mux(Pu,Rs,Rt)

ICLASS
0

1

1

Rs
1

ICLASS
1

1

1

1

u1

P
1

0

Parse

u

MajOp
1

80-N2040-46 Rev. B

0

0

s5
-

-

-

s

s

s

P

P

d5
I

Parse
s

s

P

P

t5
-

t

t

t

u2
t

t

-

u

u

d
d5

d

d

d

189

Hexagon V68 Programmer’s Reference Manual

Field name
MajOp
MinOp
Rs
MajOp
P
ICLASS
Parse
d5
s5
t5
u1
u2

80-N2040-46 Rev. B

Instruction Set

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u

190

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift word by 16
ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
halfword). The lower 16 bits of the destination are zero-filled.

Rs

0x0000

Rd

ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
halfword). The upper 16 bits of the destination are sign-extended.

Rs

Sign-extend

Rd

Syntax

Behavior

Rd=aslh(Rs)

Rd=Rs<<16;

Rd=asrh(Rs)

Rd=Rs>>16;

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=aslh(Rs)

Word32 Q6_R_aslh_R(Word32 Rs)

Rd=asrh(Rs)

Word32 Q6_R_asrh_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

Parse C

2

1

0

d5

0

1

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P 0

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=aslh(Rs)

0

1

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P 0

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=asrh(Rs)

Field name
MajOp
MinOp
Rs
C

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Conditional

191

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

192

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Pack high and low halfwords
Pack together the most-significant halfwords from Rs and Rt into the most-significant
word of register pair Rdd, and the least-significant halfwords from Rs and Rt into the
least-significant halfword of Rdd.
Rt

Rs

Rdd
Syntax

Behavior

Rdd=packhl(Rs,Rt)

Rdd.h[0]=Rt.h[0];
Rdd.h[1]=Rs.h[0];
Rdd.h[2]=Rt.h[1];
Rdd.h[3]=Rs.h[1];

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)

Rdd=packhl(Rs,Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

P
1

0

MajOp
1

0

1

MinOp
1

-

Field name
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P

8

7

6

5

4

3

t5
-

t

t

t

2

1

0

d

d Rdd=packhl(Rs,Rt)

d5
t

t

-

-

-

d

d

d

Description
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

193

Hexagon V68 Programmer’s Reference Manual

11.1.3

Instruction Set

ALU32/PRED
The ALU32/PRED instruction subclass includes instructions which perform conditional
arithmetic and logical operations based on the values stored in a predicate register, and
which produce predicate results. They are executable on any slot.

Conditional add
If the least-significant bit of predicate Pu is set, add a 32-bit source register to either
another register or an immediate value. The result is placed in 32-bit destination register. If
the predicate is false, the instruction does nothing.
Syntax

Behavior

if ([!]Pu[.new]) Rd=add(Rs,#s8)

if([!]Pu[.new][0]){
apply_extension(#s);
Rd=Rs+#s;
} else {
NOP;
}

if ([!]Pu[.new]) Rd=add(Rs,Rt)

if([!]Pu[.new][0]){
Rd=Rs+Rt;
} else {
NOP;
}

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

PS

u2

8

7

6

5

4

3

D
Parse N

s5

2

1

0

d5

0

1

1

1

0

1

0

0

0

u

u

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d if (Pu) Rd=add(Rs,#s8)

0

1

1

1

0

1

0

0

0

u

u

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d if (Pu.new) Rd=add(Rs,#s8)

0

1

1

1

0

1

0

0

1

u

u

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d if (!Pu) Rd=add(Rs,#s8)

0

1

1

1

0

1

0

0

1

u

u

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

(!Pu.new)
d ifRd=add(Rs,#s8)

ICLASS

P

MajOp

MinOp

Parse D
N

s5

t5

PS

u2

d5

1

1

1

1

1

0

1

1

0

-

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rd=add(Rs,Rt)

1

1

1

1

1

0

1

1

0

-

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu) Rd=add(Rs,Rt)

1

1

1

1

1

0

1

1

0

-

0

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu.new) Rd=add(Rs,Rt)

1

1

1

1

1

0

1

1

0

-

0

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu.new) Rd=add(Rs,Rt)

Field name
MajOp
MinOp
Rs
DN
PS

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Dot-new
Predicate sense

194

Hexagon V68 Programmer’s Reference Manual

Field name
DN
MajOp
MinOp
P
PS
ICLASS
Parse
d5
s5
t5
u2

80-N2040-46 Rev. B

Instruction Set

Description
Dot-new
Major Opcode
Minor Opcode
Predicated
Predicate sense
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

195

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional shift halfword
Conditionally shift a halfword.
ASLH performs an arithmetic left shift of the 32-bit source register by 16 bits (one
halfword). The lower 16 bits of the destination are zero-filled.

Rs

0x0000

Rd

ASRH performs an arithmetic right shift of the 32-bit source register by 16 bits (one
halfword). The upper 16 bits of the destination are sign-extended.

Rs

Sign-extend

Rd

Syntax

Behavior

if ([!]Pu[.new]) Rd=aslh(Rs)

if([!]Pu[.new][0]){
Rd=Rs<<16;
} else {
NOP;
}

if ([!]Pu[.new]) Rd=asrh(Rs)

if([!]Pu[.new][0]){
Rd=Rs>>16;
} else {
NOP;
}

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

Parse C

S dn

8

7

6

5

4

3

u2

2

1

0

d5

0

1

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=aslh(Rs)

0

1

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=aslh(Rs)

0

1

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=aslh(Rs)

80-N2040-46 Rev. B

196

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=aslh(Rs)

0

1

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=asrh(Rs)

0

1

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=asrh(Rs)

0

1

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=asrh(Rs)

0

1

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=asrh(Rs)

Field name
MajOp
MinOp
Rs
C
S
dn
ICLASS
Parse
d5
s5
u2

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Predicate sense
Dot-new
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register u

197

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional combine
If the least-significant bit of predicate Pu is set, the most-significant word of destination
Rdd is taken from the first source register Rs, while the least-significant word is taken
from the second source register Rt. If the predicate is false, this instruction does nothing.
Syntax

Behavior

if ([!]Pu[.new])
Rdd=combine(Rs,Rt)

if ([!]Pu[.new][0]) {
Rdd.w[0]=Rt;
Rdd.w[1]=Rs;
} else {
NOP;
}

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

D
Parse N

s5

8

t5

7

6

5

PS

u2

4

3

2

1

0

d5

1

1

1

1

1

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rdd=combine(Rs,Rt)

1

1

1

1

1

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

if (!Pu)
d Rdd=combine(Rs,Rt)

1

1

1

1

1

1

0

1

0

0

0

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

(Pu.new)
d ifRdd=combine(Rs,Rt)

1

1

1

1

1

1

0

1

0

0

0

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

(!Pu.new)
d ifRdd=combine(Rs,Rt)

Field name
DN
MajOp
MinOp
P
PS
ICLASS
Parse
d5
s5
t5
u2

80-N2040-46 Rev. B

Description
Dot-new
Major Opcode
Minor Opcode
Predicated
Predicate sense
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

198

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional logical operations
If the least-significant bit of predicate Pu is set, do a logical operation on the source
values. The result is placed in 32-bit destination register. If the predicate is false, the
instruction does nothing.
Syntax

Behavior

if ([!]Pu[.new]) Rd=and(Rs,Rt)

if([!]Pu[.new][0]){
Rd=Rs&Rt;
} else {
NOP;
}

if ([!]Pu[.new]) Rd=or(Rs,Rt)

if([!]Pu[.new][0]){
Rd=Rs|Rt;
} else {
NOP;
}

if ([!]Pu[.new]) Rd=xor(Rs,Rt)

if([!]Pu[.new][0]){
Rd=Rs^Rt;
} else {
NOP;
}

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

D
Parse N

s5

8

t5

7

6

5

PS

u2

4

3

2

1

0

d5

1

1

1

1

1

0

0

1

-

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rd=and(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu) Rd=and(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

0

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu.new) Rd=and(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

0

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu.new) Rd=and(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rd=or(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu) Rd=or(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

1

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu.new) Rd=or(Rs,Rt)

1

1

1

1

1

0

0

1

-

0

1

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu.new) Rd=or(Rs,Rt)

1

1

1

1

1

0

0

1

-

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rd=xor(Rs,Rt)

1

1

1

1

1

0

0

1

-

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu) Rd=xor(Rs,Rt)

1

1

1

1

1

0

0

1

-

1

1

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu.new) Rd=xor(Rs,Rt)

1

1

1

1

1

0

0

1

-

1

1

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu.new) Rd=xor(Rs,Rt)

Field name
DN
MajOp
MinOp
P
PS
ICLASS

80-N2040-46 Rev. B

Description
Dot-new
Major Opcode
Minor Opcode
Predicated
Predicate sense
Instruction Class

199

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
t5
u2

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

200

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional subtract
If the least-significant bit of predicate Pu is set, subtract a 32-bit source register Rt from
register Rs. The result is placed in a 32-bit destination register. If the predicate is false, the
instruction does nothing.
Syntax

Behavior

if ([!]Pu[.new]) Rd=sub(Rt,Rs)

if([!]Pu[.new][0]){
Rd=Rt-Rs;
} else {
NOP;
}

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

P

MajOp

MinOp

Parse D
N

s5

8

t5

7

6

5

PS

u2

4

3

2

1

0

d5

1

1

1

1

1

0

1

1

0

-

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu) Rd=sub(Rt,Rs)

1

1

1

1

1

0

1

1

0

-

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu) Rd=sub(Rt,Rs)

1

1

1

1

1

0

1

1

0

-

1

s

s

s

s

s

P

P 1

t

t

t

t

t

0

u

u

d

d

d

d

d if (Pu.new) Rd=sub(Rt,Rs)

1

1

1

1

1

0

1

1

0

-

1

s

s

s

s

s

P

P 1

t

t

t

t

t

1

u

u

d

d

d

d

d if (!Pu.new) Rd=sub(Rt,Rs)

Field name
DN
MajOp
MinOp
P
PS
ICLASS
Parse
d5
s5
t5
u2

80-N2040-46 Rev. B

Description
Dot-new
Major Opcode
Minor Opcode
Predicated
Predicate sense
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

201

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional sign extend
Conditionally sign-extend the least-significant byte or halfword from Rs and put the 32-bit
result in Rd.
Rd=sxth(Rs)

Rd=sxtb(Rs)
Rs

Rs

Sign-extend

Sign-extend

Rd

Syntax

Behavior

if ([!]Pu[.new]) Rd=sxtb(Rs)

if([!]Pu[.new][0]){
Rd=sxt8->32(Rs);
} else {
NOP;
}

if ([!]Pu[.new]) Rd=sxth(Rs)

if([!]Pu[.new][0]){
Rd=sxt16->32(Rs);
} else {
NOP;
}

Rd

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

Parse C

S dn

8

7

6

5

4

3

u2

2

1

0

d5

0

1

1

1

0

0

0

0

1

0

1

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=sxtb(Rs)

0

1

1

1

0

0

0

0

1

0

1

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=sxtb(Rs)

0

1

1

1

0

0

0

0

1

0

1

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=sxtb(Rs)

0

1

1

1

0

0

0

0

1

0

1

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=sxtb(Rs)

0

1

1

1

0

0

0

0

1

1

1

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=sxth(Rs)

0

1

1

1

0

0

0

0

1

1

1

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=sxth(Rs)

0

1

1

1

0

0

0

0

1

1

1

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=sxth(Rs)

0

1

1

1

0

0

0

0

1

1

1

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=sxth(Rs)

Field name
MajOp
MinOp
Rs
C
S
dn
ICLASS

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Predicate sense
Dot-new
Instruction Class

202

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
u2

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register u

203

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional transfer
If the LSB of predicate Pu is set, transfer register Rs or a signed immediate into
destination Rd. If the predicate is false, this instruction does nothing.
Syntax

Behavior

if ([!]Pu[.new]) Rd=#s12

apply_extension(#s);
if ([!]Pu[.new][0]) Rd=#s;
else NOP;

if ([!]Pu[.new]) Rd=Rs

Assembler mapped to: "if ([!]Pu[.new])
Rd=add(Rs,#0)"

if ([!]Pu[.new]) Rdd=Rss

Assembler mapped to: "if ([!]Pu[.new])
Rdd=combine(Rss.H32,Rss.L32)"

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

PS

8

7

6

5

4

3

D
Parse N

u2

2

1

0

d5

0

1

1

1

1

1

1

0

0

u

u 0

i

i

i

i

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d if (Pu) Rd=#s12

0

1

1

1

1

1

1

0

0

u

u 0

i

i

i

i

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d if (Pu.new) Rd=#s12

0

1

1

1

1

1

1

0

1

u

u 0

i

i

i

i

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d if (!Pu) Rd=#s12

0

1

1

1

1

1

1

0

1

u

u 0

i

i

i

i

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d if (!Pu.new) Rd=#s12

Field name
MajOp
MinOp
Rs
DN
PS
ICLASS
Parse
d5
u2

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Dot-new
Predicate sense
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register u

204

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Conditional zero extend
Conditionally zero-extend the least-significant byte or halfword from Rs and put the 32-bit
result in Rd.
Rd=zxth(Rs)

Rd=zxtb(Rs)
Rs

Rs

0x0000

0x000000

Rd

Syntax

Behavior

if ([!]Pu[.new]) Rd=zxtb(Rs)

if([!]Pu[.new][0]){
Rd=zxt8->32(Rs);
} else {
NOP;
}

if ([!]Pu[.new]) Rd=zxth(Rs)

if([!]Pu[.new][0]){
Rd=zxt16->32(Rs);
} else {
NOP;
}

Rd

Class: ALU32 (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

Parse C

S dn

8

7

6

5

4

3

u2

2

1

0

d5

0

1

1

1

0

0

0

0

1

0

0

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=zxtb(Rs)

0

1

1

1

0

0

0

0

1

0

0

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=zxtb(Rs)

0

1

1

1

0

0

0

0

1

0

0

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=zxtb(Rs)

0

1

1

1

0

0

0

0

1

0

0

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=zxtb(Rs)

0

1

1

1

0

0

0

0

1

1

0

s

s

s

s

s

P

P 1

-

0

0

u

u

-

-

-

d

d

d

d

d if (Pu) Rd=zxth(Rs)

0

1

1

1

0

0

0

0

1

1

0

s

s

s

s

s

P

P 1

-

0

1

u

u

-

-

-

d

d

d

d

d if (Pu.new) Rd=zxth(Rs)

0

1

1

1

0

0

0

0

1

1

0

s

s

s

s

s

P

P 1

-

1

0

u

u

-

-

-

d

d

d

d

d if (!Pu) Rd=zxth(Rs)

0

1

1

1

0

0

0

0

1

1

0

s

s

s

s

s

P

P 1

-

1

1

u

u

-

-

-

d

d

d

d

d if (!Pu.new) Rd=zxth(Rs)

Field name
MajOp
MinOp
Rs
C
S
dn
ICLASS

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Conditional
Predicate sense
Dot-new
Instruction Class

205

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
u2

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register u

206

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare
The register form compares two 32-bit registers for unsigned greater than, greater than, or
equal.
The immediate form compares a register against a signed or unsigned immediate value.
The 8-bit predicate register Pd is set to all 1's or all 0's depending on the result. For 64-bit
versions of this instruction, see the XTYPE compare instructions.
Syntax

Behavior

Pd=[!]cmp.eq(Rs,#s10)

apply_extension(#s);
Pd=Rs[!]=#s ? 0xff : 0x00;

Pd=[!]cmp.eq(Rs,Rt)

Pd=Rs[!]=Rt ? 0xff : 0x00;

Pd=[!]cmp.gt(Rs,#s10)

apply_extension(#s);
Pd=Rs<=#s ? 0xff : 0x00;

Pd=[!]cmp.gt(Rs,Rt)

Pd=Rs<=Rt ? 0xff : 0x00;

Pd=[!]cmp.gtu(Rs,#u9)

apply_extension(#u);
Pd=Rs.uw[0]<=#u.uw[0] ? 0xff : 0x00;

Pd=[!]cmp.gtu(Rs,Rt)

Pd=Rs.uw[0]<=Rt.uw[0] ? 0xff : 0x00;

Pd=cmp.ge(Rs,#s8)

Assembler mapped to: "Pd=cmp.gt(Rs,#s8-1)"

Pd=cmp.geu(Rs,#u8)

if ("#u8==0") {
Assembler mapped to: "Pd=cmp.eq(Rs,Rs)";
} else {
Assembler mapped to: "Pd=cmp.gtu(Rs,#u8-1)";
}

Pd=cmp.lt(Rs,Rt)

Assembler mapped to: "Pd=cmp.gt(Rt,Rs)"

Pd=cmp.ltu(Rs,Rt)

Assembler mapped to: "Pd=cmp.gtu(Rt,Rs)"

Class: ALU32 (slots 0,1,2,3)
Intrinsics

80-N2040-46 Rev. B

Pd=!cmp.eq(Rs,#s10)

Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32 Is10)

Pd=!cmp.eq(Rs,Rt)

Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32 Rt)

Pd=!cmp.gt(Rs,#s10)

Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32 Is10)

Pd=!cmp.gt(Rs,Rt)

Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32 Rt)

Pd=!cmp.gtu(Rs,#u9)

Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32 Iu9)

Pd=!cmp.gtu(Rs,Rt)

Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32 Rt)

Pd=cmp.eq(Rs,#s10)

Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)

Pd=cmp.eq(Rs,Rt)

Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)

Pd=cmp.ge(Rs,#s8)

Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)

Pd=cmp.geu(Rs,#u8)

Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)

Pd=cmp.gt(Rs,#s10)

Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)

207

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Pd=cmp.gt(Rs,Rt)

Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)

Pd=cmp.gtu(Rs,#u9)

Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)

Pd=cmp.gtu(Rs,Rt)

Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)

Pd=cmp.lt(Rs,Rt)

Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)

Pd=cmp.ltu(Rs,Rt)

Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

2

1

Parse

0
d2

0

1

1

1

0

1

0

1

0

0

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

0

0

0

d

d Pd=cmp.eq(Rs,#s10)

0

1

1

1

0

1

0

1

0

0

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

1

0

0

d

d Pd=!cmp.eq(Rs,#s10)

0

1

1

1

0

1

0

1

0

1

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

0

0

0

d

d Pd=cmp.gt(Rs,#s10)

0

1

1

1

0

1

0

1

0

1

i

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

1

0

0

d

d Pd=!cmp.gt(Rs,#s10)

0

1

1

1

0

1

0

1

1

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

0

0

0

d

d Pd=cmp.gtu(Rs,#u9)

0

1

1

1

0

1

0

1

1

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

1

0

0

d

d Pd=!cmp.gtu(Rs,#u9)

ICLASS

P

MajOp

MinOp

s5

Parse

t5

d2

1

1

1

1

0

0

1

0

-

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

0

0

0

d

d Pd=cmp.eq(Rs,Rt)

1

1

1

1

0

0

1

0

-

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

1

0

0

d

d Pd=!cmp.eq(Rs,Rt)

1

1

1

1

0

0

1

0

-

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

0

0

0

d

d Pd=cmp.gt(Rs,Rt)

1

1

1

1

0

0

1

0

-

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

1

0

0

d

d Pd=!cmp.gt(Rs,Rt)

1

1

1

1

0

0

1

0

-

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

0

0

0

d

d Pd=cmp.gtu(Rs,Rt)

1

1

1

1

0

0

1

0

-

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

1

0

0

d

d Pd=!cmp.gtu(Rs,Rt)

Field name
MajOp
MinOp
Rs
MajOp
MinOp
P
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

208

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare to general register
The register form compares two 32-bit registers for unsigned greater than, greater than, or
equal. The immediate form compares a register against a signed or unsigned immediate
value. The resulting zero or one is placed in a general register.
Syntax

Behavior

Rd=[!]cmp.eq(Rs,#s8)

apply_extension(#s);
Rd=(Rs[!]=#s);

Rd=[!]cmp.eq(Rs,Rt)

Rd=(Rs[!]=Rt);

Class: ALU32 (slots 0,1,2,3)
Intrinsics
Rd=!cmp.eq(Rs,#s8)

Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32 Is8)

Rd=!cmp.eq(Rs,Rt)

Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32 Rt)

Rd=cmp.eq(Rs,#s8)

Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32 Is8)

Rd=cmp.eq(Rs,Rt)

Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Rs

MajOp

MinOp

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

1

0

0

1

1

-

1

0

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=cmp.eq(Rs,#s8)

0

1

1

1

0

0

1

1

-

1

1

s

s

s

s

s

P

P 1

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=!cmp.eq(Rs,#s8)

ICLASS

P

MajOp

MinOp

s5

Parse

t5

d5

1

1

1

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=cmp.eq(Rs,Rt)

1

1

1

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=!cmp.eq(Rs,Rt)

Field name
MajOp
MinOp
Rs
MajOp
MinOp
P
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Major Opcode
Minor Opcode
No Rs read
Major Opcode
Minor Opcode
Predicated
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

209

Hexagon V68 Programmer’s Reference Manual

11.2

Instruction Set

CR
The CR instruction class includes instructions which manage control registers, including
hardware looping, modulo addressing, and status flags.
CR instructions are executable on slot 3.

End loop instructions
The endloop instructions mark the end of a hardware loop. If the Loop Count (LC) register
indicates that a loop should continue to iterate, the LC register is decremented and the
program flow changes to the address in the Start Address (SA) register.
The endloopN instruction is actually a pseudo-instruction encoded in bits 15:14 of each
instruction. Therefore, no distinct 32-bit encoding exists for this instruction.
Syntax

Behavior

endloop0

if (USR.LPCFG) {
if (USR.LPCFG==1) {
P3=0xff;
}
USR.LPCFG=USR.LPCFG-1;
}
if (LC0>1) {
PC=SA0;
LC0=LC0-1;
}

endloop01

if (USR.LPCFG) {
if (USR.LPCFG==1) {
P3=0xff;
}
USR.LPCFG=USR.LPCFG-1;
}
if (LC0>1) {
PC=SA0;
LC0=LC0-1;
} else {
if (LC1>1) {
PC=SA1;
LC1=LC1-1;
}
}

endloop1

if (LC1>1) {
PC=SA1;
LC1=LC1-1;
}

Class: N/A
Notes
■

80-N2040-46 Rev. B

This instruction cannot be grouped in a packet with any program flow
instructions.

210

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

■

The Next PC value is the address immediately following the last instruction in the
packet containing this instruction.

■

The PC value is the address of the start of the packet

211

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Corner detection acceleration
The fastcorner9 instruction takes the Ps and Pt values and treats them as a circular bit
string. If any contiguous nine bits are set around the circle, the result is true, false
otherwise. The sense may be optionally inverted. This instruction accelerates fast corner
detection.
Syntax

Behavior

Pd=[!]fastcorner9(Ps,Pt)

PREDUSE_TIMING;
tmp.h[0]=(Ps<<8)|Pt;
tmp.h[1]=(Ps<<8)|Pt;
for (i = 1; i < 9; i++) {
tmp &= tmp >> 1;
}
Pd = tmp == 0 ? 0xff : 0x00;

Class: CR (slot 2,3)
Notes
■

This instruction can execute on either slot2 or slot3, even though it is a CR-type

Intrinsics
Pd=!fastcorner9(Ps,Pt)

Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte Pt)

Pd=fastcorner9(Ps,Pt)

Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s2

Parse

8

7

6

5

4

3

2

t2

1

0
d2

0

1

1

0

1

0

1

1

0

0

0

0

-

-

s

s

P

P 1

-

-

-

t

t

1

-

-

1

-

-

d

d Pd=fastcorner9(Ps,Pt)

0

1

1

0

1

0

1

1

0

0

0

1

-

-

s

s

P

P 1

-

-

-

t

t

1

-

-

1

-

-

d

d Pd=!fastcorner9(Ps,Pt)

Field name
sm
ICLASS
Parse
d2
s2
t2

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

212

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical reductions on predicates
The any8 instruction sets a destination predicate register to 0xff if any of the low 8 bits in
source predicate register Ps are set. Otherwise, the predicate is set to 0x00.
The all8 instruction sets a destination predicate register to 0xff if all of the low 8 bits in the
source predicate register Ps are set. Otherwise, the predicate is set to 0x00.
Syntax

Behavior

Pd=all8(Ps)

PREDUSE_TIMING;
(Ps==0xff) ? (Pd=0xff) : (Pd=0x00);

Pd=any8(Ps)

PREDUSE_TIMING;
Ps ? (Pd=0xff) : (Pd=0x00);

Class: CR (slot 2,3)
Notes
■

This instruction can execute on either slot2 or slot3, even though it is a CR-type

Intrinsics
Pd=all8(Ps)

Byte Q6_p_all8_p(Byte Ps)

Pd=any8(Ps)

Byte Q6_p_any8_p(Byte Ps)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s2

8

7

6

5

4

3

2

Parse

1

0
d2

0

1

1

0

1

0

1

1

1

0

0

0

-

-

s

s

P

P 0

-

-

-

-

-

-

-

-

-

-

-

d

d Pd=any8(Ps)

0

1

1

0

1

0

1

1

1

0

1

0

-

-

s

s

P

P 0

-

-

-

-

-

-

-

-

-

-

-

d

d Pd=all8(Ps)

Field name
sm
ICLASS
Parse
d2
s2

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

213

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Looping instructions
loopN is a single instruction which sets up a hardware loop. The N in the instruction name
indicates the set of loop registers to use. Loop0 is the innermost loop, while loop1 is the
outer loop.The loopN instruction first sets the Start Address (SA) register based on a PCrelative immediate add. The relative immediate is added to the PC and stored in SA. The
Loop Count (LC) register is set to either an unsigned immediate or to a register value.
Syntax

Behavior

loop0(#r7:2,#U10)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=#U;
USR.LPCFG=0;

loop0(#r7:2,Rs)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=Rs;
USR.LPCFG=0;

loop1(#r7:2,#U10)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA1=PC+#r;
LC1=#U;

loop1(#r7:2,Rs)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA1=PC+#r;
LC1=Rs;

Class: CR (slot 3)
Notes
■

This instruction cannot execute in the last address of a hardware loop.

■

The Next PC value is the address immediately following the last instruction in the
packet containing this instruction.

■

The PC value is the address of the start of the packet

■

A PC-relative address is formed by taking the decoded immediate value and
adding it to the current PC value.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s5

8

7

6

5

4

3

2

1

0

Parse

0

1

1

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

-

-

-

i

i

-

-

-

loop0(#r7:2,Rs)

0

1

1

0

0

0

0

0

0

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

-

-

-

i

i

-

-

-

loop1(#r7:2,Rs)

ICLASS

sm

Parse

0

1

1

0

1

0

0

1

0

0

0

I

I

I

I

I

P

P

-

i

i

i

i

i

I

I

I

i

i

-

I

I

loop0(#r7:2,#U10)

0

1

1

0

1

0

0

1

0

0

1

I

I

I

I

I

P

P

-

i

i

i

i

i

I

I

I

i

i

-

I

I

loop1(#r7:2,#U10)

80-N2040-46 Rev. B

214

Hexagon V68 Programmer’s Reference Manual

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

Instruction Set

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

215

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Add to PC
Add an immediate value to the Program Counter (PC) and place the result in a destination
register. This instruction is typically used with a constant extender to add a 32-bit
immediate value to PC.
Syntax

Behavior

Rd=add(pc,#u6)

Rd=PC+apply_extension(#u);

Class: CR (slot 3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

1

8

7

6

5

4

3

Parse

0

1

0

0

1

Field name
sm
ICLASS
Parse
d5

80-N2040-46 Rev. B

0

0

1

0

0

1

P

P

2

1

0

d

d Rd=add(pc,#u6)

d5
-

i

i

i

i

i

i

-

-

d

d

d

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d

216

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Pipelined loop instructions
spNloop0 is a single instruction that sets up a hardware loop with automatic predicate
control. This features saves code size by generating many software pipelined loops
without prologue code. Upon executing this instruction, the P3 register is automatically
cleared. After the loop executes N times (where N is selectable from 1-3), the P3 register
is set. The intent is that store instructions in the loop are predicated with P3 and thus not
enabled during the pipeline warm-up.
The spNloop0 instruction uses the loop 0 (inner-loop) registers. This instruction sets the
Start Address (SA0) register based on a PC-relative immediate add. Add the relative
immediate to the PC and store it in SA0. Set the Loop Count (LC0) to either an unsigned
immediate or to a register value. Clear the predicate P3. The USR.LPCFG bits are set
based on the N value.

80-N2040-46 Rev. B

Syntax

Behavior

p3=sp1loop0(#r7:2,#U10)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=#U;
USR.LPCFG=1;
P3=0;

p3=sp1loop0(#r7:2,Rs)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=Rs;
USR.LPCFG=1;
P3=0;

p3=sp2loop0(#r7:2,#U10)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=#U;
USR.LPCFG=2;
P3=0;

p3=sp2loop0(#r7:2,Rs)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=Rs;
USR.LPCFG=2;
P3=0;

p3=sp3loop0(#r7:2,#U10)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=#U;
USR.LPCFG=3;
P3=0;

p3=sp3loop0(#r7:2,Rs)

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
SA0=PC+#r;
LC0=Rs;
USR.LPCFG=3;
P3=0;

217

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: CR (slot 3)
Notes
■

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically AND’d with another predicate.

■

This instruction cannot execute in the last address of a hardware loop.

■

The Next PC value is the address immediately following the last instruction in the
packet containing this instruction.

■

The PC value is the address of the start of the packet

■

A PC-relative address is formed by taking the decoded immediate value and
adding it to the current PC value.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

0

0

0

1

0

1

s

s

s

8

7

6

5

4

3

2

1

0

i

-

-

-

i

i

-

-

-

p3=sp1loop0(#r7:2,Rs)

Parse
s

s

P

P

-

i

i

i

i

0

1

1

0

0

0

0

0

1

1

0

s

s

s

s

s

P

P

-

i

i

i

i

i

-

-

-

i

i

-

-

-

p3=sp2loop0(#r7:2,Rs)

0

1

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P

-

i

i

i

i

i

-

-

-

i

i

-

-

-

p3=sp3loop0(#r7:2,Rs)

ICLASS

sm

Parse

0

1

1

0

1

0

0

1

1

0

1

I

I

I

I

I

P

P

-

i

i

i

i

i

I

I

I

i

i

-

I

I

p3=sp1loop0(#r7:2,#U10)

0

1

1

0

1

0

0

1

1

1

0

I

I

I

I

I

P

P

-

i

i

i

i

i

I

I

I

i

i

-

I

I

p3=sp2loop0(#r7:2,#U10)

0

1

1

0

1

0

0

1

1

1

1

I

I

I

I

I

P

P

-

i

i

i

i

i

I

I

I

i

i

-

I

I

p3=sp3loop0(#r7:2,#U10)

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

218

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical operations on predicates
Perform bitwise logical operations on predicate registers.
Syntax

Behavior

Pd=Ps

Assembler mapped to: "Pd=or(Ps,Ps)"

Pd=and(Ps,and(Pt,[!]Pu))

PREDUSE_TIMING;
Pd = Ps & Pt & (~Pu);

Pd=and(Ps,or(Pt,[!]Pu))

PREDUSE_TIMING;
Pd = Ps & (Pt | (~Pu));

Pd=and(Pt,[!]Ps)

PREDUSE_TIMING;
Pd=Pt & (~Ps);

Pd=not(Ps)

PREDUSE_TIMING;
Pd=~Ps;

Pd=or(Ps,and(Pt,[!]Pu))

PREDUSE_TIMING;
Pd = Ps | (Pt & (~Pu));

Pd=or(Ps,or(Pt,[!]Pu))

PREDUSE_TIMING;
Pd = Ps | Pt | (~Pu);

Pd=or(Pt,[!]Ps)

PREDUSE_TIMING;
Pd=Pt | (~Ps);

Pd=xor(Ps,Pt)

PREDUSE_TIMING;
Pd=Ps ^ Pt;

Class: CR (slot 2,3)
Notes
■

This instruction may execute on either slot2 or slot3, even though it is a CR-type

Intrinsics

80-N2040-46 Rev. B

Pd=Ps

Byte Q6_p_equals_p(Byte Ps)

Pd=and(Ps,and(Pt,!Pu))

Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Ps,and(Pt,Pu))

Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Ps,or(Pt,!Pu))

Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Ps,or(Pt,Pu))

Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Pt,!Ps)

Byte Q6_p_and_pnp(Byte Pt, Byte Ps)

Pd=and(Pt,Ps)

Byte Q6_p_and_pp(Byte Pt, Byte Ps)

Pd=not(Ps)

Byte Q6_p_not_p(Byte Ps)

Pd=or(Ps,and(Pt,!Pu))

Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,and(Pt,Pu))

Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte Pu)

219

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Pd=or(Ps,or(Pt,!Pu))

Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,or(Pt,Pu))

Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Pt,!Ps)

Byte Q6_p_or_pnp(Byte Pt, Byte Ps)

Pd=or(Pt,Ps)

Byte Q6_p_or_pp(Byte Pt, Byte Ps)

Pd=xor(Ps,Pt)

Byte Q6_p_xor_pp(Byte Ps, Byte Pt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

1

ICLASS
0

1

1

1

1

0

1

0

1

1

1

1

1

0

1

0

1

1

1

1

1

0

0

-

-

s

0

1

0

1

0

1

1

0

0

0

1

-

-

s

1

1

0

0

1

0

-

-

s

s

1

1

0

0

1

1

-

-

s

1

1

0

1

0

0

-

-

s

s

1

1

0

1

0

1

-

-

s

1

1

0

1

1

0

-

-

s

sm

-

t

P 0

P

P 0

P

P 0

P

P 0

s

P

P 0

-

-

-

t

-

-

-

t

s2

P

P 0

5

4

3

2

1

t

-

-

-

-

-

-

d

u2

-

-

t

-

-

-

t

u

u

-

-

-

-

d

t

-

-

-

-

-

-

d

u2

-

t

-

-

-

t

u

u

-

-

-

-

d

t

-

-

-

-

-

-

d

d Pd=and(Ps,or(Pt,Pu))

d2

u2

d Pd=xor(Ps,Pt)

d2

t

u

u

-

-

-

-

d

t

-

-

-

-

-

-

d

t2

Parse

d Pd=or(Pt,Ps)

d2

t

t2
-

d Pd=and(Ps,and(Pt,Pu))

d2

t2

-

d Pd=and(Pt,Ps)

d2

t

t2
-

0
d2

t2

Parse
s

6

t2

Parse

s2

0

-

Parse
s

s2

0

P

7

t2
-

Parse

s2

0

P 0

Parse
s

s2

0

P

Parse

s2

0

sm

ICLASS

Parse
s

s2

sm

ICLASS
0

0

sm

ICLASS
0

0

sm

ICLASS
0

1

sm

ICLASS
0

1

sm

ICLASS
0

s2

0

8

d Pd=or(Ps,and(Pt,Pu))

d2

t2

u2

d Pd=and(Pt,!Ps)

d2

0

1

1

0

1

0

1

1

0

1

1

1

-

-

s

s

P

P 0

-

-

-

t

t

u

u

-

-

-

-

d

d Pd=or(Ps,or(Pt,Pu))

0

1

1

0

1

0

1

1

1

0

0

1

-

-

s

s

P

P 0

-

-

-

t

t

u

u

-

-

-

-

d

d Pd=and(Ps,and(Pt,!Pu))

0

1

1

0

1

0

1

1

1

0

1

1

-

-

s

s

P

P 0

-

-

-

t

t

u

u

-

-

-

-

d

d Pd=and(Ps,or(Pt,!Pu))

ICLASS
0

1

1

sm
0

1

0

1

ICLASS
0

1

1

1

1

1

1

1

1

1

1

0

0

-

-

s

1

1

1

1

0

1

-

-

s

0

1

0

1

Parse
s

s2

0
sm

ICLASS
0

0
sm

ICLASS
0

s2

1

1

1

1

1

0

-

-

s

1

1

1

1

1

1

-

-

s

sm

Field name
sm
ICLASS
Parse
d2
s2
t2
u2

80-N2040-46 Rev. B

-

-

-

-

P

P 0

-

-

-

t

s

P

P 0

P

P 0

-

t

u

-

-

-

-

-

d

u

-

-

-

-

d

u2

-

-

-

t

-

-

-

t

d Pd=not(Ps)

d2

t2

Parse
s

t2

Parse

s2

0

P 0

Parse
s

s2

0

P

d2

d Pd=or(Ps,and(Pt,!Pu))

d2
t

-

t

u

t2

-

-

-

-

-

d

u

-

-

-

-

d

u2

d Pd=or(Pt,!Ps)

d2
d Pd=or(Ps,or(Pt,!Pu))

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

220

Hexagon V68 Programmer’s Reference Manual

Instruction Set

User control register transfer
Move 32- or 64-bit values between a user control register and a general register. The user
control registers include SA, LC, Predicates, M, USR, PC, UGP, GP, and CS, and
UPCYCLE. The figure shows the user control registers and their register field encodings.
Registers can be moved as singles or as aligned 64-bit pairs.
The PC register is not writable. Use a program flow instruction to change the PC value.

0

SA0

8

USR

1

LC0

9

PC

2

SA1

10

UGP

3

LC1

11

GP

4

P3:0

12

CS0

5

Reserved

13

CS1

6

M0

14

UPCYCLELO

7

M1

24

16

Reserved

UPCYCLEHI

15

Reserved

23

Syntax

Behavior

Cd=Rs

Cd=Rs;

Cdd=Rss

Cdd=Rss;

Rd=Cs

Rd=Cs;

Rdd=Css

Rdd=Css;

31

Class: CR (slot 3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

0

0

0

1

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Cd=Rs

0

1

1

0

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Cdd=Rss

0

1

1

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rdd=Css

0

1

1

0

1

0

1

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=Cs

Field name
sm
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

221

Hexagon V68 Programmer’s Reference Manual

11.3

Instruction Set

JR
The JR instruction class includes instructions to change the program flow to a new
location contained in a register.
JR instructions are executable on slot 2.

Call subroutine from register
Change the program flow to a subroutine. This instruction first transfers the Next Program
Counter (NPC) value into the link register, and then jumps to a target address contained in
a register.
This instruction can only appear in slot 2.
Syntax

Behavior

callr Rs

LR=NPC;
PC=Rs;
;

if ([!]Pu) callr Rs

;
if ([!]Pu[0]) {
LR=NPC;
PC=Rs;
;
}

Class: JR (slot 2)
Notes
■

This instruction can be conditionally executed based on the value of a predicate
register. If the instruction is preceded by 'if Pn', the instruction only executes if the
least-significant bit of the predicate register is 1. Similarly, if the instruction is
preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
Pn is 0.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

s5
1

0

0

0

0

1

0

1

s

s

ICLASS

s

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

callr Rs

Parse
s

s

s5

P

P

-

-

-

-

Parse

u2

0

1

0

1

0

0

0

1

0

0

0

s

s

s

s

s

P

P

-

-

-

-

u

u

-

-

-

-

-

-

-

-

if (Pu) callr Rs

0

1

0

1

0

0

0

1

0

0

1

s

s

s

s

s

P

P

-

-

-

-

u

u

-

-

-

-

-

-

-

-

if (!Pu) callr Rs

Field name
ICLASS

80-N2040-46 Rev. B

Description
Instruction Class

222

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
s5
u2

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register s
Field to encode register u

223

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Hint an indirect jump address
Provides a hint indicating an upcoming indirect JUMPR to the address specified in Rs.
Syntax

Behavior

hintjr(Rs)

;

Class: JR (slot 2)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

s5
1

0

0

1

0

1

0

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

1

s

s

s

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

hintjr(Rs)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

224

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Jump to address from register
Change the program flow to a target address. This instruction changes the Program
Counter to a target address contained in a register.
This instruction can appear only in slot 2.
Syntax

Behavior

if ([!]Pu) jumpr Rs

Assembler mapped to: "if ([!]Pu) ""jumpr"":nt
""Rs"

if ([!]Pu[.new]) jumpr:<hint> Rs }
{
if([!]Pu[.new][0]){
PC=Rs;
;
}
jumpr Rs

PC=Rs;

Class: JR (slot 2)
Notes
■

This instruction can be conditionally executed based on the value of a predicate
register. If the instruction is preceded by 'if Pn', the instruction only executes if the
least-significant bit of the predicate register is 1. Similarly, if the instruction is
preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
Pn is 0.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

s5
1

0

0

1

0

1

0

0

s

s

ICLASS

s

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

jumpr Rs

Parse
s

s

s5

P

P

-

-

-

-

Parse

u2

0

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

0

0

-

u

u

-

-

-

-

-

-

-

-

if (Pu) jumpr:nt Rs

0

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

0

1

-

u

u

-

-

-

-

-

-

-

-

if (Pu.new) jumpr:nt Rs

0

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

1

0

-

u

u

-

-

-

-

-

-

-

-

if (Pu) jumpr:t Rs

0

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

1

1

-

u

u

-

-

-

-

-

-

-

-

if (Pu.new) jumpr:t Rs

0

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

0

0

-

u

u

-

-

-

-

-

-

-

-

if (!Pu) jumpr:nt Rs

0

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

0

1

-

u

u

-

-

-

-

-

-

-

-

if (!Pu.new) jumpr:nt Rs

0

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

1

0

-

u

u

-

-

-

-

-

-

-

-

if (!Pu) jumpr:t Rs

0

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

1

1

-

u

u

-

-

-

-

-

-

-

-

if (!Pu.new) jumpr:t Rs

Field name
ICLASS
Parse
s5
u2

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register u

225

Hexagon V68 Programmer’s Reference Manual

11.4

Instruction Set

J
The J instruction class includes branch instructions (jumps and calls) that obtain the target
address from a (PC-relative) immediate address value.
J instructions are executable on slot 2 and slot 3.

Call subroutine
Change the program flow to a subroutine. This instruction first transfers the Next Program
Counter (NPC) value into the link register, and then jumps to the target address.
This instruction can appear in slots 2 or 3.
Syntax

Behavior

call #r22:2

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
LR=NPC;
PC=PC+#r;
;

if ([!]Pu) call #r15:2

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
;
if ([!]Pu[0]) {
LR=NPC;
PC=PC+#r;
;
}

Class: J (slots 2,3)
Notes

80-N2040-46 Rev. B

■

This instruction can be conditionally executed based on the value of a predicate
register. If the instruction is preceded by 'if Pn', the instruction only executes if the
least-significant bit of the predicate register is 1. Similarly, if the instruction is
preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
Pn is 0.

■

The Next PC value is the address immediately following the last instruction in the
packet containing this instruction.

■

The PC value is the address of the start of the packet

■

A PC-relative address is formed by taking the decoded immediate value and
adding it to the current PC value.

226

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

i

i

i

i

i

i

i

i

0

call #r22:2

Parse
1

1

0

1

i

i

i

i

i

i

i

i

i

ICLASS

P

P

i

i

i

i

D
N

Parse

i
u2

0

1

0

1

1

1

0

1

i

i

0

i

i

i

i

i

P

P

i

-

0

-

u

u

i

i

i

i

i

i

i

-

if (Pu) call #r15:2

0

1

0

1

1

1

0

1

i

i

1

i

i

i

i

i

P

P

i

-

0

-

u

u

i

i

i

i

i

i

i

-

if (!Pu) call #r15:2

Field name
ICLASS
DN
Parse
u2

80-N2040-46 Rev. B

Description
Instruction Class
Dot-new
Packet/Loop parse bits
Field to encode register u

227

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare and jump
Compare two registers, or a register and immediate value, and write a predicate with the
result. Then use the predicate result to conditionally jump to a PC-relative target address.
The registers available as operands are restricted to R0-R7 and R16-R23. The predicate
destination is restricted to P0 and P1.
In assembly syntax, this instruction appears as two instructions in the packet: a compare
and a separate conditional jump. The assembler may convert adjacent compare and jump
instructions into compound compare-jump form.

80-N2040-46 Rev. B

Syntax

Behavior

p[01]=cmp.eq(Rs,#-1); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs==-1) ? 0xff : 0x00 if
([!]P[01].new[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.eq(Rs,#U5); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs==#U) ? 0xff : 0x00 if
([!]P[01].new[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.eq(Rs,Rt); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs==Rt) ? 0xff : 0x00 if
([!]P[01].new[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.gt(Rs,#-1); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs>-1) ? 0xff : 0x00 if ([!]P[01].new[0])
{
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.gt(Rs,#U5); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs>#U) ? 0xff : 0x00 if ([!]P[01].new[0])
{
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.gt(Rs,Rt); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs>Rt) ? 0xff : 0x00 if ([!]P[01].new[0])
{
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=cmp.gtu(Rs,#U5); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs.uw[0]>#U) ? 0xff : 0x00 if
([!]P[01].new[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

228

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

p[01]=cmp.gtu(Rs,Rt); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs.uw[0]>Rt) ? 0xff : 0x00 if
([!]P[01].new[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

p[01]=tstbit(Rs,#0); if
([!]p[01].new) jump:<hint>
#r9:2

P[01]=(Rs & 1) ? 0xff : 0x00 if ([!]P[01].new[0])
{
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

Class: J (slots 0,1,2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s4

8

7

6

5

4

3

2

1

0

Parse

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

0

0

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#-1); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

0

1

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#-1); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

1

1

i

i

i

i

i

i

i

-

p0=tstbit(Rs,#0); if (p0.new)
jump:nt #r9:2

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

0

0

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#-1); if
(p0.new) jump:t #r9:2

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

0

1

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#-1); if
(p0.new) jump:t #r9:2

0

0

0

1

0

0

0

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

1

1

i

i

i

i

i

i

i

-

p0=tstbit(Rs,#0); if (p0.new)
jump:t #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

0

0

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#-1); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

0

1

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#-1); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

1

1

i

i

i

i

i

i

i

-

p0=tstbit(Rs,#0); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

0

0

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#-1); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

0

1

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#-1); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

0

0

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

1

1

i

i

i

i

i

i

i

-

p0=tstbit(Rs,#0); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

0

0

0

0

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#U5); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

0

0

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#U5); if
(p0.new) jump:t #r9:2

0

0

0

1

0

0

0

0

0

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#U5); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

0

0

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,#U5); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

0

0

0

1

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#U5); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

0

1

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#U5); if
(p0.new) jump:t #r9:2

0

0

0

1

0

0

0

0

1

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#U5); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

0

1

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,#U5); if
(!p0.new) jump:t #r9:2

80-N2040-46 Rev. B

229

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

0

0

1

0

0

0

1

0

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,#U5); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

0

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,#U5); if
(p0.new) jump:t #r9:2

0

0

0

1

0

0

0

1

0

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,#U5); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

0

0

1

0

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,#U5); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

0

0

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#-1); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

0

1

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#-1); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 0

-

-

-

1

1

i

i

i

i

i

i

i

-

p1=tstbit(Rs,#0); if (p1.new)
jump:nt #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

0

0

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#-1); if
(p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

0

1

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#-1); if
(p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

1

0

i

i

s

s

s

s

P

P 1

-

-

-

1

1

i

i

i

i

i

i

i

-

p1=tstbit(Rs,#0); if (p1.new)
jump:t #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

0

0

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#-1); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

0

1

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#-1); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 0

-

-

-

1

1

i

i

i

i

i

i

i

-

p1=tstbit(Rs,#0); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

0

0

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#-1); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

0

1

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#-1); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

1

1

i

i

s

s

s

s

P

P 1

-

-

-

1

1

i

i

i

i

i

i

i

-

p1=tstbit(Rs,#0); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

0

1

0

0

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#U5); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

0

0

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#U5); if
(p1.new) jump:t #r9:2

0

0

0

1

0

0

1

0

0

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#U5); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

0

0

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,#U5); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

0

1

0

1

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#U5); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

0

1

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#U5); if
(p1.new) jump:t #r9:2

0

0

0

1

0

0

1

0

1

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#U5); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

0

1

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,#U5); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

0

0

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,#U5); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

0

0

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,#U5); if
(p1.new) jump:t #r9:2

0

0

0

1

0

0

1

1

0

1

i

i

s

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,#U5); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

0

1

1

0

1

i

i

s

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,#U5); if
(!p1.new) jump:t #r9:2

ICLASS

s4

Parse

t4

0

0

0

1

0

1

0

0

0

0

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,Rt); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

0

0

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,Rt); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

0

0

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,Rt); if
(p0.new) jump:t #r9:2

80-N2040-46 Rev. B

230

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

0

0

1

0

1

0

0

0

0

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,Rt); if
(p1.new) jump:t #r9:2

0

0

0

1

0

1

0

0

0

1

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,Rt); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

0

1

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,Rt); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

0

1

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.eq(Rs,Rt); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

1

0

0

0

1

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.eq(Rs,Rt); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

1

0

0

1

0

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,Rt); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

1

0

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,Rt); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

1

0

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,Rt); if
(p0.new) jump:t #r9:2

0

0

0

1

0

1

0

0

1

0

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,Rt); if
(p1.new) jump:t #r9:2

0

0

0

1

0

1

0

0

1

1

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,Rt); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

1

1

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,Rt); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

0

1

1

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gt(Rs,Rt); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

1

0

0

1

1

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gt(Rs,Rt); if
(!p1.new) jump:t #r9:2

0

0

0

1

0

1

0

1

0

0

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,Rt); if
(p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

1

0

0

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,Rt); if
(p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

1

0

0

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,Rt); if
(p0.new) jump:t #r9:2

0

0

0

1

0

1

0

1

0

0

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,Rt); if
(p1.new) jump:t #r9:2

0

0

0

1

0

1

0

1

0

1

i

i

s

s

s

s

P

P 0

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,Rt); if
(!p0.new) jump:nt #r9:2

0

0

0

1

0

1

0

1

0

1

i

i

s

s

s

s

P

P 0

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,Rt); if
(!p1.new) jump:nt #r9:2

0

0

0

1

0

1

0

1

0

1

i

i

s

s

s

s

P

P 1

0

t

t

t

t

i

i

i

i

i

i

i

-

p0=cmp.gtu(Rs,Rt); if
(!p0.new) jump:t #r9:2

0

0

0

1

0

1

0

1

0

1

i

i

s

s

s

s

P

P 1

1

t

t

t

t

i

i

i

i

i

i

i

-

p1=cmp.gtu(Rs,Rt); if
(!p1.new) jump:t #r9:2

Field name
ICLASS
Parse
s4
t4

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

231

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Jump to address
Change the program flow to a target address. This instruction changes the Program
Counter to a target address which is relative to the PC address. The offset from the current
PC address is contained in the instruction encoding.
A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
expected value of the conditional expression. If the actual generated value of the predicate
differs from this expected value, the jump instruction incurs a performance penalty.
This instruction can appear in slots 2 or 3.
Syntax

Behavior

if ([!]Pu) jump #r15:2

Assembler mapped to: "if ([!]Pu) ""jump"":nt
""#r15:2"

if ([!]Pu) jump:<hint> #r15:2

;
if ([!]Pu[0]) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
;
}

jump #r22:2

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;

Class: J (slots 0,1,2,3)
Notes

This instruction can be conditionally executed based on the value of a predicate
register. If the instruction is preceded by 'if Pn', the instruction only executes if the
least-significant bit of the predicate register is 1. Similarly, if the instruction is
preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
Pn is 0.

■

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

i

i

i

i

i

i

i

i

-

jump #r22:2

Parse
1

1

0

0

i

i

i

i

i

i

i

i

i

ICLASS

P

P

i

i

i

i

D
PT N

Parse

i
u2

0

1

0

1

1

1

0

0

i

i

0

i

i

i

i

i

P

P

i

0

0

-

u

u

i

i

i

i

i

i

i

-

if (Pu) jump:nt #r15:2

0

1

0

1

1

1

0

0

i

i

0

i

i

i

i

i

P

P

i

1

0

-

u

u

i

i

i

i

i

i

i

-

if (Pu) jump:t #r15:2

0

1

0

1

1

1

0

0

i

i

1

i

i

i

i

i

P

P

i

0

0

-

u

u

i

i

i

i

i

i

i

-

if (!Pu) jump:nt #r15:2

0

1

0

1

1

1

0

0

i

i

1

i

i

i

i

i

P

P

i

1

0

-

u

u

i

i

i

i

i

i

i

-

if (!Pu) jump:t #r15:2

80-N2040-46 Rev. B

232

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
DN
PT
Parse
u2

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Dot-new
Predict-taken
Packet/Loop parse bits
Field to encode register u

233

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Jump to address conditioned on new predicate
Perform speculated jump.
Jump if the LSB of the newly-generated predicate is true. The predicate must be generated
in the same packet as the speculated jump instruction.
A speculated jump instruction includes a hint ("taken" or "not taken") which specifies the
expected value of the conditional expression. If the actual generated value of the predicate
differs from this expected value, the jump instruction incurs a performance penalty.
This instruction can appear in slots 2 or 3.
Syntax

Behavior

if ([!]Pu.new) jump:<hint>
#r15:2

}
{
if([!]Pu.new[0]){
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
;
}

Class: J (slots 0,1,2,3)
Notes

This instruction can be conditionally executed based on the value of a predicate
register. If the instruction is preceded by 'if Pn', the instruction only executes if the
least-significant bit of the predicate register is 1. Similarly, if the instruction is
preceded by 'if !Pn', the instruction is executed only if the least-significant bit of
Pn is 0.

■

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

D
PT N

Parse

8

7

6

5

4

3

2

1

0

u2

0

1

0

1

1

1

0

0

i

i

0

i

i

i

i

i

P

P

i

0

1

-

u

u

i

i

i

i

i

i

i

-

0

1

0

1

1

1

0

0

i

i

0

i

i

i

i

i

P

P

i

1

1

-

u

u

i

i

i

i

i

i

i

-

if (Pu.new) jump:t #r15:2

0

1

0

1

1

1

0

0

i

i

1

i

i

i

i

i

P

P

i

0

1

-

u

u

i

i

i

i

i

i

i

-

if (!Pu.new) jump:nt #r15:2

0

1

0

1

1

1

0

0

i

i

1

i

i

i

i

i

P

P

i

1

1

-

u

u

i

i

i

i

i

i

i

-

if (!Pu.new) jump:t #r15:2

Field name
ICLASS
DN
PT
Parse
u2

80-N2040-46 Rev. B

if (Pu.new) jump:nt #r15:2

Description
Instruction Class
Dot-new
Predict-taken
Packet/Loop parse bits
Field to encode register u

234

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Jump to address condition on register value
Perform register-conditional jump.
Jump if the specified register expression is true.
A register-conditional jump includes a hint ("taken" or "not taken") which specifies the
expected value of the register expression. If the actual generated value of the expression
differs from this expected value, the jump instruction incurs a performance penalty.
This instruction can appear only in slot 3.
Syntax

Behavior

if (Rs!=#0) jump:nt #r13:2

if (Rs != 0) {
PC=PC+#r;
}

if (Rs!=#0) jump:t #r13:2

if (Rs != 0) {
PC=PC+#r;
}

if (Rs<=#0) jump:nt #r13:2

if (Rs<=0) {
PC=PC+#r;
}

if (Rs<=#0) jump:t #r13:2

if (Rs<=0) {
PC=PC+#r;
}

if (Rs==#0) jump:nt #r13:2

if (Rs == 0) {
PC=PC+#r;
}

if (Rs==#0) jump:t #r13:2

if (Rs == 0) {
PC=PC+#r;
}

if (Rs>=#0) jump:nt #r13:2

if (Rs>=0) {
PC=PC+#r;
}

if (Rs>=#0) jump:t #r13:2

if (Rs>=0) {
PC=PC+#r;
}

Class: J (slot 3)
Notes
■

80-N2040-46 Rev. B

This instruction will be deprecated in a future version.

235

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s5

8

7

6

5

4

3

2

1

0

Parse

0

1

1

0

0

0

0

1

0

0

i

s

s

s

s

s

P

P

i

0

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs!=#0) jump:nt #r13:2

0

1

1

0

0

0

0

1

0

0

i

s

s

s

s

s

P

P

i

1

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs!=#0) jump:t #r13:2

0

1

1

0

0

0

0

1

0

1

i

s

s

s

s

s

P

P

i

0

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs>=#0) jump:nt #r13:2

0

1

1

0

0

0

0

1

0

1

i

s

s

s

s

s

P

P

i

1

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs>=#0) jump:t #r13:2

0

1

1

0

0

0

0

1

1

0

i

s

s

s

s

s

P

P

i

0

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs==#0) jump:nt #r13:2

0

1

1

0

0

0

0

1

1

0

i

s

s

s

s

s

P

P

i

1

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs==#0) jump:t #r13:2

0

1

1

0

0

0

0

1

1

1

i

s

s

s

s

s

P

P

i

0

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs<=#0) jump:nt #r13:2

0

1

1

0

0

0

0

1

1

1

i

s

s

s

s

s

P

P

i

1

i

i

i

i

i

i

i

i

i

i

i

-

if (Rs<=#0) jump:t #r13:2

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

236

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Transfer and jump
Move an unsigned immediate or register value into a destination register and
unconditionally jump. In assembly syntax, this instruction appears as two instructions in
the packet, a transfer and a separate jump. The assembler may convert adjacent transfer
and jump instructions into compound transfer-jump form.
Syntax

Behavior

Rd=#U6 ; jump #r9:2

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
Rd=#U;
PC=PC+#r;

Rd=Rs ; jump #r9:2

apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
Rd=Rs;
PC=PC+#r;

Class: J (slots 2,3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

0

d4
1

0

1

1

0

-

-

i

i

d

d

ICLASS
0

0

0

d

d

s4
1

0

1

1

1

-

-

Field name
ICLASS
Parse
d4
s4

80-N2040-46 Rev. B

i

i

s

s

8

7

6

5

4

3

2

1

0

I

I

i

i

i

i

i

i

i

-

Rd=#U6 ; jump #r9:2

d

d

i

i

i

i

i

i

i

-

Rd=Rs ; jump #r9:2

Parse
P

P

I

I

I

Parse
s

s

P

P

I
d4

-

-

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

237

Hexagon V68 Programmer’s Reference Manual

11.5

Instruction Set

LD
The LD instruction class includes load instructions, which load values into registers.
LD instructions are executable on slot 0 and slot 1.

Load doubleword
Load a 64-bit doubleword from memory and place in a destination register pair.
Syntax

Behavior

Rdd=memd(Re=#U6)

apply_extension(#U);
EA=#U;
Rdd = *EA;
Re=#U;

Rdd=memd(Rs+#s11:3)

apply_extension(#s);
EA=Rs+#s;
Rdd = *EA;

Rdd=memd(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rdd = *EA;

Rdd=memd(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rdd = *EA;

Rdd=memd(Rx++#s4:3)

EA=Rx;
Rx=Rx+#s;
Rdd = *EA;

Rdd=memd(Rx++#s4:3:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rdd = *EA;

Rdd=memd(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<3,MuV);
Rdd = *EA;

Rdd=memd(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rdd = *EA;

Rdd=memd(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rdd = *EA;

Rdd=memd(gp+#u16:3)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rdd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rdd=memd(Rx++#s4:3:circ(Mu))

Word32 Q6_R_memd_IM_circ(void** StartAddress,
Word32 Is4_3, Word32 Mu, void* BaseAddress)

Rdd=memd(Rx++I:circ(Mu))

Word32 Q6_R_memd_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

238

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

1

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

1

0

Type

U
N

1

0

1

Amode

1

s

1

0

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rdd=memd(Rs+Rt<<#u2)

d

d Rdd=memd(gp+#u16:3)

d

d Rdd=memd(Rs+#s11:3)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rdd=memd(Rx++#s4:3:circ
(Mu))

1

0

0

1

1

0

0

1

1

1

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

1

1

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rdd=memd(Rx++I:circ(Mu)
)

d

d Rdd=memd(Re=#U6)

d

d Rdd=memd(Rx++#s4:3)

d

d Rdd=memd(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

1

1

1

1

Amode

1

e

e

0

1

0

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

0

e5

U
N

Type

Amode
1

U
N

Type

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

1

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rdd=memd(Rx++Mu)

1

0

0

1

1

1

1

1

1

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rdd=memd(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

239

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load-acquire doubleword
Load a 64-bit doubleword from memory and place in a destination register pair. The loadacquire memory operation is observed before any following memory operations (in
program order) have been observed at the local point of serialization. A different order
may be observed at the global point of serialization. (see Ordering and Synchronization).
Syntax

Behavior

Rdd=memd_aq(Rs)

EA=Rs;
Rdd = *EA

Class: LD (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

0

0

1

U
N

Type
0

0

0

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

Parse
s

s

P

P 0

2

1

0

d

d Rdd=memd_aq(Rs)

d5
1

1

-

-

-

0

0

0

d

d

d

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s

240

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load doubleword conditionally
Load a 64-bit doubleword from memory and place in a destination register pair.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rdd=memd(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rdd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rdd=memd(Rs+#u6:3)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rdd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rdd=memd(Rx++#s4:3)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rdd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rdd=memd(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rdd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv)
d ifRdd=memd(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv)
d Rdd=memd(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRdd=memd(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv.new)
d ifRdd=memd(Rs+Rt<<#u2)

Type

U
N

1

0

d

(Pt)
d ifRdd=memd(Rs+#u6:3)

Pr
Se ed
ns Ne
e w

ICLASS

0

1

0

0

0

0

80-N2040-46 Rev. B

0

1

1

s5

s

s

s

Parse

s

s

P

P 0

t2

t

d5

t

i

i

i

i

i

i

d

d

d

241

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rdd=memd(Rs+#u6:3)

0

1

0

0

0

1

0

1

1

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rdd=memd(Rs+#u6:3)

0

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rdd=memd(Rs+#u6:3)

if (Pt)
Rdd=memd(Rx++#s4:3)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d if (!Pt)
Rdd=memd(Rx++#s4:3)

1

0

0

1

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rdd=memd(Rx++#s4:3)

1

0

0

1

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rdd=memd(Rx++#s4:3)

ICLASS

Amode

U
N

Type

Parse

t2

d5

1

0

0

1

1

1

1

1

1

1

0

i

i

i

i

i

P

P 1

0

0

t

t

i

1

-

-

d

d

d

d

d if (Pt) Rdd=memd(#u6)

1

0

0

1

1

1

1

1

1

1

0

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rdd=memd(#u6)

1

0

0

1

1

1

1

1

1

1

0

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rdd=memd(#u6)

1

0

0

1

1

1

1

1

1

1

0

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

(!Pt.new)
d ifRdd=memd(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

242

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load byte
Load a signed byte from memory. The byte at the effective address in memory is placed in
the least-significant 8 bits of the destination register. The destination register is then signextended from 8 bits to 32.
Syntax

Behavior

Rd=memb(Re=#U6)

apply_extension(#U);
EA=#U;
Rd = *EA;
Re=#U;

Rd=memb(Rs+#s11:0)

apply_extension(#s);
EA=Rs+#s;
Rd = *EA;

Rd=memb(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rd = *EA;

Rd=memb(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rd = *EA;

Rd=memb(Rx++#s4:0)

EA=Rx;
Rx=Rx+#s;
Rd = *EA;

Rd=memb(Rx++#s4:0:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rd = *EA;

Rd=memb(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<0,MuV);
Rd = *EA;

Rd=memb(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rd = *EA;

Rd=memb(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rd = *EA;

Rd=memb(gp+#u16:0)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rd=memb(Rx++#s4:0:circ(Mu))

Word32 Q6_R_memb_IM_circ(void** StartAddress,
Word32 Is4_0, Word32 Mu, void* BaseAddress)

Rd=memb(Rx++I:circ(Mu))

Word32 Q6_R_memb_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

243

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

0

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

0

0

Type

U
N

0

0

0

Amode

0

s

0

0

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rd=memb(Rs+Rt<<#u2)

d

d Rd=memb(gp+#u16:0)

d

d Rd=memb(Rs+#s11:0)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rd=memb(Rx++#s4:0:circ(
Mu))

1

0

0

1

1

0

0

1

0

0

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

0

0

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memb(Rx++I:circ(Mu))

d

d Rd=memb(Re=#U6)

d

d Rd=memb(Rx++#s4:0)

d

d Rd=memb(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

Type
1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

0

0

1

0

0

Amode

0

e

e

0

0

0

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

0

e5

U
N

Type

Amode
1

U
N

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

0

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memb(Rx++Mu)

1

0

0

1

1

1

1

1

0

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memb(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

244

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load byte conditionally
Load a signed byte from memory. The byte at the effective address in memory is placed in
the least-significant 8 bits of the destination register. The destination register is then signextended from 8 bits to 32.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rd=memb(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memb(Rs+#u6:0)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memb(Rx++#s4:0)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rd=memb(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (Pv)
d Rd=memb(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv)
d ifRd=memb(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRd=memb(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv.new)
d Rd=memb(Rs+Rt<<#u2)

Type

U
N

ICLASS

Pr
Se ed
ns Ne
e w

80-N2040-46 Rev. B

s5

Parse

t2

d5

245

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d if (Pt) Rd=memb(Rs+#u6:0)

0

1

0

0

0

0

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memb(Rs+#u6:0)

0

1

0

0

0

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memb(Rs+#u6:0)

0

1

0

0

0

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rd=memb(Rs+#u6:0)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d if (Pt)
Rd=memb(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d if (!Pt)
Rd=memb(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d if (Pt.new)
Rd=memb(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

d

d

d if (Pt) Rd=memb(#u6)

ICLASS
1

0

0

Amode
1

1

1

1

U
N

Type
1

0

0

0

Parse
i

i

i

i

i

P

P 1

t2
0

0

t

if (!Pt.new)
Rd=memb(Rx++#s4:0)

d5
t

i

1

-

-

d

d

d

1

0

0

1

1

1

1

1

0

0

0

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rd=memb(#u6)

1

0

0

1

1

1

1

1

0

0

0

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rd=memb(#u6)

1

0

0

1

1

1

1

1

0

0

0

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt.new) Rd=memb(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

246

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load byte into shifted vector
Shift a 64-bit vector right by one byte. Insert a byte from memory into the vacated upper
byte of the vector.
Mem
Ryy

Ryy

80-N2040-46 Rev. B

Syntax

Behavior

Ryy=memb_fifo(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;
Re=#U;

Ryy=memb_fifo(Rs)

Assembler mapped to: "Ryy=memb_fifo""(Rs+#0)"

Ryy=memb_fifo(Rs+#s11:0)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Ryy=memb_fifo(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Ryy=memb_fifo(Rx++#s4:0)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Ryy=memb_fifo(Rx++#s4:0:circ(Mu
))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

247

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Ryy=memb_fifo(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<0,MuV);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Ryy=memb_fifo(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Ryy=memb_fifo(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);
}
;

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

ICLASS

0

i

i

U
N

Type
0

Amode

1

0

0

s5
s

s

U
N

Type

s

8

7

6

5

4

3

Parse
s

s

x5

P

P

2

1

0

y

y Ryy=memb_fifo(Rs+#s11:0
)

y5
i

i

i

i

i

i

i

i

i

y

y

Parse u1

y
y5

1

0

0

1

1

0

0

0

1

0

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

y

y

y

y

Ryy=memb_fifo(Rx++#s4:0
y :circ(Mu))

1

0

0

1

1

0

0

0

1

0

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

y

y

y

y

y Ryy=memb_fifo(Rx++I:circ(
Mu))

y

y Ryy=memb_fifo(Re=#U6)

y

Ryy=memb_fifo(Rx++#s4:0
y )

y

y Ryy=memb_fifo(Rt<<#u2+#
U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

0

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

0

0

1

0

Amode

1

e

e

0

0

0

x

x

e

e

x

t

t

t

P

y5

P 0

1

I

I

I

I

-

I

I

y

y

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
0

0

e5

U
N

Type

Amode
1

U
N

Type

P

y5

P 0

0

-

-

-

i

i

i

i

y

y

Parse
t

t

x5

P

P

y

y
y5

i

1

I

I

I

I

i

I

I

y

y

Parse u1

y
y5

1

0

0

1

1

1

0

0

1

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

y

y

y

y

y Ryy=memb_fifo(Rx++Mu)

1

0

0

1

1

1

1

0

1

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

y

y

y

y

Ryy=memb_fifo(Rx++Mu:br
y ev)

80-N2040-46 Rev. B

248

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Amode
Type
UN
Parse
e5
s5
t5
u1
x5
y5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x
Field to encode register y

249

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load half into shifted vector
Shift a 64-bit vector right by one halfword. Insert a halfword from memory into the
vacated upper halfword of the vector.
Mem
Ryy

Ryy

80-N2040-46 Rev. B

Syntax

Behavior

Ryy=memh_fifo(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;
Re=#U;

Ryy=memh_fifo(Rs)

Assembler mapped to: "Ryy=memh_fifo""(Rs+#0)"

Ryy=memh_fifo(Rs+#s11:1)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Ryy=memh_fifo(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Ryy=memh_fifo(Rx++#s4:1)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Ryy=memh_fifo(Rx++#s4:1:circ(Mu
))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

250

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Ryy=memh_fifo(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Ryy=memh_fifo(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Ryy=memh_fifo(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);
}
;

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

ICLASS

0

i

i

U
N

Type
0

Amode

0

1

0

s5
s

s

U
N

Type

s

8

7

6

5

4

3

Parse
s

s

x5

P

P

2

1

0

y

y Ryy=memh_fifo(Rs+#s11:1
)

y5
i

i

i

i

i

i

i

i

i

y

y

Parse u1

y
y5

1

0

0

1

1

0

0

0

0

1

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

y

y

y

y

Ryy=memh_fifo(Rx++#s4:1
y :circ(Mu))

1

0

0

1

1

0

0

0

0

1

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

y

y

y

y

y Ryy=memh_fifo(Rx++I:circ(
Mu))

y

y Ryy=memh_fifo(Re=#U6)

y

Ryy=memh_fifo(Rx++#s4:1
y )

y

y Ryy=memh_fifo(Rt<<#u2+#
U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

0

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

0

1

0

0

1

Amode

0

e

e

0

1

0

x

x

e

e

x

t

t

t

P

y5

P 0

1

I

I

I

I

-

I

I

y

y

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
0

0

e5

U
N

Type

Amode
1

U
N

Type

P

y5

P 0

0

-

-

-

i

i

i

i

y

y

Parse
t

t

x5

P

P

y

y
y5

i

1

I

I

I

I

i

I

I

y

y

Parse u1

y
y5

1

0

0

1

1

1

0

0

0

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

y

y

y

y

y Ryy=memh_fifo(Rx++Mu)

1

0

0

1

1

1

1

0

0

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

y

y

y

y

Ryy=memh_fifo(Rx++Mu:br
y ev)

80-N2040-46 Rev. B

251

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Amode
Type
UN
Parse
e5
s5
t5
u1
x5
y5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x
Field to encode register y

252

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load halfword
Load a signed halfword from memory. The 16-bit halfword at the effective address in
memory is placed in the least-significant 16 bits of the destination register. The destination
register is then sign-extended from 16 bits to 32.
Syntax

Behavior

Rd=memh(Re=#U6)

apply_extension(#U);
EA=#U;
Rd = *EA;
Re=#U;

Rd=memh(Rs+#s11:1)

apply_extension(#s);
EA=Rs+#s;
Rd = *EA;

Rd=memh(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rd = *EA;

Rd=memh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rd = *EA;

Rd=memh(Rx++#s4:1)

EA=Rx;
Rx=Rx+#s;
Rd = *EA;

Rd=memh(Rx++#s4:1:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rd = *EA;

Rd=memh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
Rd = *EA;

Rd=memh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rd = *EA;

Rd=memh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rd = *EA;

Rd=memh(gp+#u16:1)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rd=memh(Rx++#s4:1:circ(Mu))

Word32 Q6_R_memh_IM_circ(void** StartAddress,
Word32 Is4_1, Word32 Mu, void* BaseAddress)

Rd=memh(Rx++I:circ(Mu))

Word32 Q6_R_memh_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

253

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

0

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

1

0

Type

U
N

0

0

1

Amode

0

s

1

0

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rd=memh(Rs+Rt<<#u2)

d

d Rd=memh(gp+#u16:1)

d

d Rd=memh(Rs+#s11:1)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rd=memh(Rx++#s4:1:circ(
Mu))

1

0

0

1

1

0

0

1

0

1

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

0

1

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memh(Rx++I:circ(Mu))

d

d Rd=memh(Re=#U6)

d

d Rd=memh(Rx++#s4:1)

d

d Rd=memh(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

Type
1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

0

1

1

0

1

Amode

0

e

e

0

1

0

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

0

e5

U
N

Type

Amode
1

U
N

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

0

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memh(Rx++Mu)

1

0

0

1

1

1

1

1

0

1

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memh(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

254

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load halfword conditionally
Load a signed halfword from memory. The 16-bit halfword at the effective address in
memory is placed in the least-significant 16 bits of the destination register. The destination
register is then sign-extended from 16 bits to 32.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rd=memh(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memh(Rs+#u6:1)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memh(Rx++#s4:1)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rd=memh(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (Pv)
d Rd=memh(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv)
d ifRd=memh(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRd=memh(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv.new)
d Rd=memh(Rs+Rt<<#u2)

Type

U
N

ICLASS

Pr
Se ed
ns Ne
e w

80-N2040-46 Rev. B

s5

Parse

t2

d5

255

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d if (Pt) Rd=memh(Rs+#u6:1)

0

1

0

0

0

0

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memh(Rs+#u6:1)

0

1

0

0

0

1

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memh(Rs+#u6:1)

0

1

0

0

0

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rd=memh(Rs+#u6:1)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d if (Pt)
Rd=memh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d if (!Pt)
Rd=memh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d if (Pt.new)
Rd=memh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

d

d

d if (Pt) Rd=memh(#u6)

ICLASS
1

0

0

Amode
1

1

1

1

U
N

Type
1

0

1

0

Parse
i

i

i

i

i

P

P 1

t2
0

0

t

if (!Pt.new)
Rd=memh(Rx++#s4:1)

d5
t

i

1

-

-

d

d

d

1

0

0

1

1

1

1

1

0

1

0

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rd=memh(#u6)

1

0

0

1

1

1

1

1

0

1

0

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rd=memh(#u6)

1

0

0

1

1

1

1

1

0

1

0

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt.new) Rd=memh(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

256

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load unsigned byte
Load an unsigned byte from memory. The byte at the effective address in memory is
placed in the least-significant 8 bits of the destination register. The destination register is
then zero-extended from 8 bits to 32.
Syntax

Behavior

Rd=memub(Re=#U6)

apply_extension(#U);
EA=#U;
Rd = *EA;
Re=#U;

Rd=memub(Rs+#s11:0)

apply_extension(#s);
EA=Rs+#s;
Rd = *EA;

Rd=memub(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rd = *EA;

Rd=memub(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rd = *EA;

Rd=memub(Rx++#s4:0)

EA=Rx;
Rx=Rx+#s;
Rd = *EA;

Rd=memub(Rx++#s4:0:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rd = *EA;

Rd=memub(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<0,MuV);
Rd = *EA;

Rd=memub(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rd = *EA;

Rd=memub(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rd = *EA;

Rd=memub(gp+#u16:0)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rd=memub(Rx++#s4:0:circ(Mu))

Word32 Q6_R_memub_IM_circ(void** StartAddress,
Word32 Is4_0, Word32 Mu, void* BaseAddress)

Rd=memub(Rx++I:circ(Mu))

Word32 Q6_R_memub_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

257

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

0

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

0

1

Type

U
N

0

1

0

Amode

0

s

0

1

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rd=memub(Rs+Rt<<#u2)

d

d Rd=memub(gp+#u16:0)

d

d Rd=memub(Rs+#s11:0)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rd=memub(Rx++#s4:0:circ
(Mu))

1

0

0

1

1

0

0

1

0

0

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

0

0

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memub(Rx++I:circ(Mu)
)

d

d Rd=memub(Re=#U6)

d

d Rd=memub(Rx++#s4:0)

d

d Rd=memub(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

0

0

1

0

0

Amode

0

e

e

1

0

1

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

1

e5

U
N

Type

Amode
1

U
N

Type

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

0

0

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memub(Rx++Mu)

1

0

0

1

1

1

1

1

0

0

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memub(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

258

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load unsigned byte conditionally
Load an unsigned byte from memory. The byte at the effective address in memory is
placed in the least-significant 8 bits of the destination register. The destination register is
then zero-extended from 8 bits to 32.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rd=memub(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memub(Rs+#u6:0)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memub(Rx++#s4:0)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rd=memub(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

0

0

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (Pv)
d Rd=memub(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

0

0

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv)
d ifRd=memub(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

0

0

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRd=memub(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv.new)
d Rd=memub(Rs+Rt<<#u2)

Type

U
N

ICLASS

Pr
Se ed
ns Ne
e w

80-N2040-46 Rev. B

s5

Parse

t2

d5

259

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

0

1

0

0

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt)
Rd=memub(Rs+#u6:0)

0

1

0

0

0

0

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memub(Rs+#u6:0)

0

1

0

0

0

1

0

1

0

0

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memub(Rs+#u6:0)

0

1

0

0

0

1

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

if (!Pt.new)
d Rd=memub(Rs+#u6:0)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

0

0

1

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt)
Rd=memub(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

1

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memub(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

1

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memub(Rx++#s4:0)

1

0

0

1

1

0

1

1

0

0

1

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

if (!Pt.new)
d Rd=memub(Rx++#s4:0)

ICLASS

Amode

U
N

Type

Parse

t2

d5

1

0

0

1

1

1

1

1

0

0

1

i

i

i

i

i

P

P 1

0

0

t

t

i

1

-

-

d

d

d

d

d if (Pt) Rd=memub(#u6)

1

0

0

1

1

1

1

1

0

0

1

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rd=memub(#u6)

1

0

0

1

1

1

1

1

0

0

1

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rd=memub(#u6)

1

0

0

1

1

1

1

1

0

0

1

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

if (!Pt.new)
d Rd=memub(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

260

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load unsigned halfword
Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
memory is placed in the least-significant 16 bits of the destination register. The destination
register is zero-extended from 16 bits to 32.
Syntax

Behavior

Rd=memuh(Re=#U6)

apply_extension(#U);
EA=#U;
Rd = *EA;
Re=#U;

Rd=memuh(Rs+#s11:1)

apply_extension(#s);
EA=Rs+#s;
Rd = *EA;

Rd=memuh(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rd = *EA;

Rd=memuh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rd = *EA;

Rd=memuh(Rx++#s4:1)

EA=Rx;
Rx=Rx+#s;
Rd = *EA;

Rd=memuh(Rx++#s4:1:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rd = *EA;

Rd=memuh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
Rd = *EA;

Rd=memuh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rd = *EA;

Rd=memuh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rd = *EA;

Rd=memuh(gp+#u16:1)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rd=memuh(Rx++#s4:1:circ(Mu))

Word32 Q6_R_memuh_IM_circ(void** StartAddress,
Word32 Is4_1, Word32 Mu, void* BaseAddress)

Rd=memuh(Rx++I:circ(Mu))

Word32 Q6_R_memuh_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

261

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

0

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

1

1

Type

U
N

0

1

1

Amode

0

s

1

1

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rd=memuh(Rs+Rt<<#u2)

d

d Rd=memuh(gp+#u16:1)

d

d Rd=memuh(Rs+#s11:1)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rd=memuh(Rx++#s4:1:circ
(Mu))

1

0

0

1

1

0

0

1

0

1

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

0

1

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memuh(Rx++I:circ(Mu)
)

d

d Rd=memuh(Re=#U6)

d

d Rd=memuh(Rx++#s4:1)

d

d Rd=memuh(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

0

1

1

0

1

Amode

0

e

e

1

1

1

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

1

e5

U
N

Type

Amode
1

U
N

Type

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

0

1

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memuh(Rx++Mu)

1

0

0

1

1

1

1

1

0

1

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memuh(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

262

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load unsigned halfword conditionally
Load an unsigned halfword from memory. The 16-bit halfword at the effective address in
memory is placed in the least-significant 16 bits of the destination register. The destination
register is zero-extended from 16 bits to 32.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rd=memuh(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memuh(Rs+#u6:1)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memuh(Rx++#s4:1)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rd=memuh(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (Pv)
d Rd=memuh(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv)
d ifRd=memuh(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRd=memuh(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv.new)
d Rd=memuh(Rs+Rt<<#u2)

Type

U
N

ICLASS

Pr
Se ed
ns Ne
e w

80-N2040-46 Rev. B

s5

Parse

t2

d5

263

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

0

1

0

1

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt)
Rd=memuh(Rs+#u6:1)

0

1

0

0

0

0

1

1

0

1

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memuh(Rs+#u6:1)

0

1

0

0

0

1

0

1

0

1

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memuh(Rs+#u6:1)

0

1

0

0

0

1

1

1

0

1

1

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

if (!Pt.new)
d Rd=memuh(Rs+#u6:1)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt)
Rd=memuh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memuh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memuh(Rx++#s4:1)

1

0

0

1

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

if (!Pt.new)
d Rd=memuh(Rx++#s4:1)

ICLASS

Amode

U
N

Type

Parse

t2

d5

1

0

0

1

1

1

1

1

0

1

1

i

i

i

i

i

P

P 1

0

0

t

t

i

1

-

-

d

d

d

d

d if (Pt) Rd=memuh(#u6)

1

0

0

1

1

1

1

1

0

1

1

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rd=memuh(#u6)

1

0

0

1

1

1

1

1

0

1

1

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rd=memuh(#u6)

1

0

0

1

1

1

1

1

0

1

1

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

if (!Pt.new)
d Rd=memuh(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

264

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load word
Load a 32-bit word from memory and place in a destination register.
Syntax

Behavior

Rd=memw(Re=#U6)

apply_extension(#U);
EA=#U;
Rd = *EA;
Re=#U;

Rd=memw(Rs+#s11:2)

apply_extension(#s);
EA=Rs+#s;
Rd = *EA;

Rd=memw(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
Rd = *EA;

Rd=memw(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
Rd = *EA;

Rd=memw(Rx++#s4:2)

EA=Rx;
Rx=Rx+#s;
Rd = *EA;

Rd=memw(Rx++#s4:2:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
Rd = *EA;

Rd=memw(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<2,MuV);
Rd = *EA;

Rd=memw(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
Rd = *EA;

Rd=memw(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
Rd = *EA;

Rd=memw(gp+#u16:2)

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
Rd = *EA;

Class: LD (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

Rd=memw(Rx++#s4:2:circ(Mu))

Word32 Q6_R_memw_IM_circ(void** StartAddress,
Word32 Is4_2, Word32 Mu, void* BaseAddress)

Rd=memw(Rx++I:circ(Mu))

Word32 Q6_R_memw_M_circ(void** StartAddress,
Word32 Mu, void* BaseAddress)

265

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

0

1

ICLASS
0

1

0

0

ICLASS
1

0

0

1

i

i

1

Amode
1

ICLASS

0

i

i

0

0

Type

U
N

1

0

0

Amode

1

s

0

0

i

i

Parse
s

s

i

i

i

s5
s

s

U
N

Type

s

P

P

7

6

5

4

3

t

i

-

-

d

d

t5
i

t

t

t

s

P

P

s

x5

P

P

1

0

d

d

d Rd=memw(Rs+Rt<<#u2)

d

d Rd=memw(gp+#u16:2)

d

d Rd=memw(Rs+#s11:2)

d5
i

i

i

i

i

i

i

i

i

d

d

Parse
s

2
d5

t

Parse

U
N

Type
1

s

8

d
d5

i

i

i

i

i

i

i

i

i

d

d

Parse u1

d
d5

Rd=memw(Rx++#s4:2:circ(
Mu))

1

0

0

1

1

0

0

1

1

0

0

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

1

1

0

0

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memw(Rx++I:circ(Mu))

d

d Rd=memw(Re=#U6)

d

d Rd=memw(Rx++#s4:2)

d

d Rd=memw(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

0

1

Type
1

Amode
1

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

0

1

1

0

Amode

1

e

e

0

0

0

x

x

e

e

x

t

t

t

P

d5

P 0

1

I

I

I

I

-

I

I

d

d

Parse
x

x

t5

U
N

Type

e

Parse

x5

U
N

Type
1

0

e5

U
N

Type

Amode
1

U
N

P

d5

P 0

0

-

-

-

i

i

i

i

d

d

Parse
t

t

x5

P

P

d

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

1

1

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memw(Rx++Mu)

1

0

0

1

1

1

1

1

1

0

0

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=memw(Rx++Mu:brev)

Field name
ICLASS
Amode
Type
UN
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

266

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load-acquire word
Load a 32-bit word from memory and place in a destination register. The load-acquire
memory operation is observed before any following memory operations (in program
order) have been observed at the local point of serialization. A different order may be
observed at the global point of serialization. (see Ordering and Synchronization).
Syntax

Behavior

Rd=memw_aq(Rs)

EA=Rs;
Rd = *EA

Class: LD (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

0

0

1

U
N

Type
0

0

0

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

Parse
s

s

P

P 0

2

1

0

d

d Rd=memw_aq(Rs)

d5
0

1

-

-

-

0

0

0

d

d

d

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s

267

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load word conditionally
Load a 32-bit word from memory and place in a destination register.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pt[.new]) Rd=memw(#u6)

apply_extension(#u);
EA=#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memw(Rs+#u6:2)

apply_extension(#u);
EA=Rs+#u;
if ([!]Pt[.new][0]) {
Rd = *EA;
} else {
NOP;
}

if ([!]Pt[.new])
Rd=memw(Rx++#s4:2)

EA=Rx;
if([!]Pt[.new][0]){
Rx=Rx+#s;
Rd = *EA;
} else {
NOP;
}

if ([!]Pv[.new])
Rd=memw(Rs+Rt<<#u2)

EA=Rs+(Rt<<#u);
if ([!]Pv[.new][0]) {
Rd = *EA;
} else {
NOP;
}

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

0

0

1

1

0

0

0

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv)
d ifRd=memw(Rs+Rt<<#u2)

0

0

1

1

0

0

0

1

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

if (!Pv)
d Rd=memw(Rs+Rt<<#u2)

0

0

1

1

0

0

1

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(Pv.new)
d ifRd=memw(Rs+Rt<<#u2)

0

0

1

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

v

v

d

d

d

d

(!Pv.new)
d ifRd=memw(Rs+Rt<<#u2)

Type

U
N

1

0

d

(Pt)
d ifRd=memw(Rs+#u6:2)

Pr
Se ed
ns Ne
e w

ICLASS

0

1

0

0

0

0

80-N2040-46 Rev. B

0

1

0

s5

s

s

s

Parse

s

s

P

P 0

t2

t

d5

t

i

i

i

i

i

i

d

d

d

268

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memw(Rs+#u6:2)

0

1

0

0

0

1

0

1

1

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt)
Rd=memw(Rs+#u6:2)

0

1

0

0

0

1

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

i

i

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rd=memw(Rs+#u6:2)

if (Pt)
Rd=memw(Rx++#s4:2)

ICLASS

Amode

U
N

Type

x5

Parse

t2

d5

1

0

0

1

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

0

0

t

t

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

0

1

t

t

i

i

i

i

d

d

d

d

d if (!Pt)
Rd=memw(Rx++#s4:2)

1

0

0

1

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

1

0

t

t

i

i

i

i

d

d

d

d

d

if (Pt.new)
Rd=memw(Rx++#s4:2)

1

0

0

1

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

1

1

t

t

i

i

i

i

d

d

d

d

d

if (!Pt.new)
Rd=memw(Rx++#s4:2)

ICLASS

Amode

U
N

Type

Parse

t2

d5

1

0

0

1

1

1

1

1

1

0

0

i

i

i

i

i

P

P 1

0

0

t

t

i

1

-

-

d

d

d

d

d if (Pt) Rd=memw(#u6)

1

0

0

1

1

1

1

1

1

0

0

i

i

i

i

i

P

P 1

0

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt) Rd=memw(#u6)

1

0

0

1

1

1

1

1

1

0

0

i

i

i

i

i

P

P 1

1

0

t

t

i

1

-

-

d

d

d

d

d if (Pt.new) Rd=memw(#u6)

1

0

0

1

1

1

1

1

1

0

0

i

i

i

i

i

P

P 1

1

1

t

t

i

1

-

-

d

d

d

d

d if (!Pt.new) Rd=memw(#u6)

Field name
ICLASS
Amode
Type
UN
Type
UN
PredNew
Sense
Parse
d5
s5
t2
t5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Type
Unsigned
PredNew
Sense
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register t
Field to encode register v
Field to encode register x

269

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Deallocate stack frame
Deallocate a stack frame from the call stack. The instruction first loads the saved FP and
saved LR values from the address at FP. It then points SP back to the previous frame.
The stack layout is seen in the following figure.
Stack in Memory
Saved LR
Saved FP

Higher Address
Procedure Local
Data on Stack
Stack frame

Saved LR
Saved FP

FP register

Procedure Local
Data on Stack
SP register

Lower Address

Unallocated Stack

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=deallocframe(Rs):raw

EA=Rs;
tmp = *EA;
Rdd = frame_unscramble(tmp);
SP=EA+8;

deallocframe

Assembler mapped to:
"r31:30=deallocframe(r30):raw"

270

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

0

0

0

U
N

Type
0

0

0

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

Parse
s

s

P

P 0

2

1

0

d

d Rdd=deallocframe(Rs):raw

d5
-

-

-

-

-

-

-

-

d

d

d

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s

271

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Deallocate frame and return
Return from a function with a stack frame. This instruction is equivalent to deallocframe
followed by jumpr R31.

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=dealloc_return(Rs):raw

EA=Rs;
tmp = *EA;
Rdd = frame_unscramble(tmp);
SP=EA+8;
PC=Rdd.w[1];

dealloc_return

Assembler mapped to:
"r31:30=dealloc_return(r30):raw"

if ([!]Pv)
Rdd=dealloc_return(Rs):raw

;
EA=Rs;
if ([!]Pv[0]) {
tmp = *EA;
Rdd = frame_unscramble(tmp);
SP=EA+8;
PC=Rdd.w[1];
} else {
NOP;
}

if ([!]Pv) dealloc_return

Assembler mapped to: "if ([!]Pv"")
r31:30=dealloc_return(r30)"":raw"

if ([!]Pv.new)
Rdd=dealloc_return(Rs):nt:raw

;
EA=Rs;
if ([!]Pv.new[0]) {
tmp = *EA;
Rdd = frame_unscramble(tmp);
SP=EA+8;
PC=Rdd.w[1];
} else {
NOP;
}

if ([!]Pv.new)
Rdd=dealloc_return(Rs):t:raw

;
EA=Rs;
if ([!]Pv.new[0]) {
tmp = *EA;
Rdd = frame_unscramble(tmp);
SP=EA+8;
PC=Rdd.w[1];
} else {
NOP;
}

if ([!]Pv.new)
dealloc_return:nt

Assembler mapped to: "if ([!]Pv"".new"")
r31:30=dealloc_return(r30)"":nt"":raw"

if ([!]Pv.new) dealloc_return:t

Assembler mapped to: "if ([!]Pv"".new"")
r31:30=dealloc_return(r30)"":t"":raw"

272

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: LD (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

Parse

2

1

0

d5
Rdd=dealloc_return(Rs):ra
w

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 0

0

0

0

-

-

-

-

-

d

d

d

d

d

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 0

0

1

0

v

v

-

-

-

d

d

d

d

if (Pv.new)
d Rdd=dealloc_return(Rs):nt:
raw

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 0

1

0

0

v

v

-

-

-

d

d

d

d

if (Pv)
d Rdd=dealloc_return(Rs):ra
w

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 0

1

1

0

v

v

-

-

-

d

d

d

d

if (Pv.new)
d Rdd=dealloc_return(Rs):t:r
aw

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 1

0

1

0

v

v

-

-

-

d

d

d

d

if (!Pv.new)
d Rdd=dealloc_return(Rs):nt:
raw

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 1

1

0

0

v

v

-

-

-

d

d

d

d

if (!Pv)
d Rdd=dealloc_return(Rs):ra
w

1

0

0

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P 1

1

1

0

v

v

-

-

-

d

d

d

d

if (!Pv.new)
d Rdd=dealloc_return(Rs):t:r
aw

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5
v2

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register v

273

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load and unpack bytes to halfwords
Load contiguous bytes from memory and vector unpack them into halfwords.
Rdd=memubh(amode)
mem

zero

zero

zero

zero

Rdd

Rd=memubh(amode)
mem

zero

80-N2040-46 Rev. B

zero

Rdd

Syntax

Behavior

Rd=membh(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;
Re=#U;

Rd=membh(Rs)

Assembler mapped to: "Rd=membh""(Rs+#0)"

Rd=membh(Rs+#s11:1)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=membh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

274

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rd=membh(Rx++#s4:1)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=membh(Rx++#s4:1:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=membh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=membh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=membh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.b[i];
}
}
;

Rd=memubh(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;
Re=#U;

275

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rd=memubh(Rs+#s11:1)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rd=memubh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rd=memubh(Rx++#s4:1)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rd=memubh(Rx++#s4:1:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rd=memubh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rd=memubh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

276

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rd=memubh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<2;i++) {
Rd.h[i]=tmpV.ub[i];
}
}
;

Rdd=membh(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;
Re=#U;

Rdd=membh(Rs)

Assembler mapped to: "Rdd=membh""(Rs+#0)"

Rdd=membh(Rs+#s11:2)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=membh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=membh(Rx++#s4:2)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=membh(Rx++#s4:2:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

277

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rdd=membh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<2,MuV);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=membh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=membh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.b[i];
}
}
;

Rdd=memubh(Re=#U6)

apply_extension(#U);
EA=#U;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;
Re=#U;

Rdd=memubh(Rs+#s11:2)

apply_extension(#s);
EA=Rs+#s;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

Rdd=memubh(Rt<<#u2+#U6)

apply_extension(#U);
EA=#U+(Rt<<#u);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

278

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rdd=memubh(Rx++#s4:2)

EA=Rx;
Rx=Rx+#s;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

Rdd=memubh(Rx++#s4:2:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

Rdd=memubh(Rx++I:circ(Mu))

EA=Rx;
Rx=Rx=circ_add(Rx,I<<2,MuV);
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

Rdd=memubh(Rx++Mu)

EA=Rx;
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

Rdd=memubh(Rx++Mu:brev)

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
{
tmpV = *EA;
for (i=0;i<4;i++) {
Rdd.h[i]=tmpV.ub[i];
}
}
;

279

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: LD (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

Parse

2

1

0

d5

1

0

0

1

0

i

i

0

0

0

1

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=membh(Rs+#s11:1)

1

0

0

1

0

i

i

0

0

1

1

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=memubh(Rs+#s11:1)

1

0

0

1

0

i

i

0

1

0

1

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=memubh(Rs+#s11:2)

1

0

0

1

0

i

i

0

1

1

1

s

s

s

s

s

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=membh(Rs+#s11:2)

ICLASS

Amode

U
N

Type

x5

Parse u1

d5
Rd=membh(Rx++#s4:1:circ
(Mu))

1

0

0

1

1

0

0

0

0

0

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d

1

0

0

1

1

0

0

0

0

0

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=membh(Rx++I:circ(Mu)
)

1

0

0

1

1

0

0

0

0

1

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

Rd=memubh(Rx++#s4:1:cir
d c(Mu))

1

0

0

1

1

0

0

0

0

1

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rd=memubh(Rx++I:circ(Mu
))

1

0

0

1

1

0

0

0

1

0

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d Rdd=memubh(Rx++#s4:2:c
irc(Mu))

1

0

0

1

1

0

0

0

1

0

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

Rdd=memubh(Rx++I:circ(M
d u))

1

0

0

1

1

0

0

0

1

1

1

x

x

x

x

x

P

P

u 0

-

-

0

i

i

i

i

d

d

d

d

d Rdd=membh(Rx++#s4:2:cir
c(Mu))

1

0

0

1

1

0

0

0

1

1

1

x

x

x

x

x

P

P

u 0

-

-

1

-

0

-

-

d

d

d

d

d Rdd=membh(Rx++I:circ(Mu
))

d

d Rd=membh(Re=#U6)

d

d Rd=membh(Rx++#s4:1)

d

d Rd=memubh(Re=#U6)

d

d Rd=memubh(Rx++#s4:1)

d

d Rdd=memubh(Re=#U6)

d

d Rdd=memubh(Rx++#s4:2)

d

d Rdd=membh(Re=#U6)

d

d Rdd=membh(Rx++#s4:2)

d

d Rd=membh(Rt<<#u2+#U6)

ICLASS
1

0

0

Amode
1

ICLASS
1

0

0

0

0

1

0

0

1

0

0

1

0

0

1

0

0

1

0

0

1

0

0

ICLASS

0

1

0

1

1

0

1

1

0

1

1

0

1

1

0

1

1

1

0

1

0

1

1

0

Amode

80-N2040-46 Rev. B

0

0

0

0

0

1

1

1

1

1

0

1

0

0
Type

x

1

1

1

1

1

1

e

e

1

x

x

1
U
N

x

e

x

e

e

e

x

x

x

x

e

e

e

e

x

x

x

x

e

e

t

t
x5

I

I

I

-

I

I

d

d

P

P

P

P

x

x

P

P 0

0

-

-

-

i

i

i

i

d

d

e

P

P 0

1

I

I

I

I

-

I

I

d

d

x

P

P 0

0

-

-

-

i

i

i

i

d

d

t

P

P 0

1

I

I

I

I

-

I

I

d

d

d
d5

P 0

0

-

-

-

i

i

i

i

d

d

d
d5

P 0

1

I

I

I

I

-

I

I

d

d

d
d5

P 0

P

d
d5

0

-

-

-

i

i

i

i

d

d

Parse
t

d
d5

Parse
x

d
d5

Parse
e

d
d5

Parse

t5
t

I

Parse

x5
x

1

Parse

e5
e

P 0

Parse

x5
x

P

d5

Parse

e5

U
N
0

e

x5

U
N
1

e

e5

U
N

Type
0

x

U
N

Type
0

1

e

Parse

x5

U
N

Type
0

e

U
N

Type
0

e

U
N

Type
0

1

e5

U
N

Type

Amode
1

0

Type

Amode

ICLASS
1

1

Amode

ICLASS
1

0

Amode

ICLASS
1

1

0
Type

Amode

ICLASS
1

0

Amode

ICLASS
1

1

Amode

ICLASS
1

0

Amode

ICLASS
1

1

U
N

Type

d
d5

i

Parse u1

1

I

I

I

I

i

I

I

d

d

d
d5

280

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

-

0

-

-

d

d

d

d

d Rd=membh(Rx++Mu)

d

d

d

d Rd=memubh(Rx++Mu)

d

d

d

d Rdd=memubh(Rx++Mu)

d

Rdd=membh(Rt<<#u2+#U
d 6)

0

0

1

ICLASS
1

0

0

0

0

1

0

0

1

0

0

1

0

0

1

1

0

1

1

0

1

1

0

1

1

1

0

0

ICLASS

1

1

0

0

0

0

0

1

1

1

1

0

Amode

1

1

1

1

0

1

t

t

1

x

x

x

t

x

t

t

t

t

t

x

x

x

x

t

t

u 0

-

-

-

P

P

d5
i

1

I

I

I

I

i

I

I

d

d

P

P

t

t

P

P

u 0

-

-

-

-

0

-

-

d

d

x

P

P

i

1

I

I

I

I

i

I

I

d

d

t

x5

P

P

d

d

Rdd=memubh(Rt<<#u2+#
U6)

d5

u 0

-

-

-

-

0

-

-

d

d

Parse
t

Rd=memubh(Rt<<#u2+#U
6)

d5

Parse u1
x

d
d5

Parse

t5
t

P

Parse u1

x5
x

P

Parse

t5

U
N

Type

x

x5

U
N
1

x
t5

U
N

Type
0

x

U
N

Type
0

x

U
N

Type
0

1
U
N

Type

Amode
1

0
Type

Amode

ICLASS
1

0

Amode

ICLASS
1

0

Amode

ICLASS
1

1

Amode

ICLASS
1

1

d
d5

i

1

I

I

I

I

i

I

I

d

d

Parse u1

d
d5

1

0

0

1

1

1

0

0

1

1

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rdd=membh(Rx++Mu)

1

0

0

1

1

1

1

0

0

0

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rd=membh(Rx++Mu:brev)

1

0

0

1

1

1

1

0

0

1

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

Rd=memubh(Rx++Mu:brev
d )

1

0

0

1

1

1

1

0

1

0

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rdd=memubh(Rx++Mu:bre
v)

1

0

0

1

1

1

1

0

1

1

1

x

x

x

x

x

P

P

u 0

-

-

-

-

0

-

-

d

d

d

d

d Rdd=membh(Rx++Mu:brev
)

Field name
ICLASS
Amode
Type
UN
Parse
d5
e5
s5
t5
u1
x5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

281

Hexagon V68 Programmer’s Reference Manual

11.6

Instruction Set

MEMOP
The MEMOP instruction class includes simple operations on values in memory.
MEMOP instructions are executable on slot 0.

Operation on memory byte
Perform ALU or bit operation on the memory byte at the effective address.
Syntax

Behavior

memb(Rs+#u6:0)=clrbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp &= (~(1<<#U));
*EA = tmp;

memb(Rs+#u6:0)=setbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp |= (1<<#U);
*EA = tmp;

memb(Rs+#u6:0)[+-]=#U5

apply_extension(#u);
EA=Rs[+-]#u;
tmp = *EA;
tmp [+-]= #U;
*EA = tmp;

memb(Rs+#u6:0)[+-|&]=Rt

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp [+-|&]= Rt;
*EA = tmp;

Class: MEMOP (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

8

7

6

5

4

3

Parse

2

1

0

t5

0

0

1

1

1

1

1

0

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

t

t

t

t

t

memb(Rs+#u6:0)+=Rt

0

0

1

1

1

1

1

0

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

t

t

t

t

t

memb(Rs+#u6:0)-=Rt

0

0

1

1

1

1

1

0

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

t

t

t

t

t

memb(Rs+#u6:0)&=Rt

0

1

1

1

1

1

0

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

t

t

t

t

t

memb(Rs+#u6:0)|=Rt

0

ICLASS

s5

Parse

0

0

1

1

1

1

1

1

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

I

I

I

I

I

memb(Rs+#u6:0)+=#U5

0

0

1

1

1

1

1

1

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

I

I

I

I

I

memb(Rs+#u6:0)-=#U5

0

0

1

1

1

1

1

1

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

I

I

I

I

I

memb(Rs+#u6:0)=clrbit(#U
5)

0

0

1

1

1

1

1

1

-

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

I

I

I

I

I

memb(Rs+#u6:0)=setbit(#
U5)

80-N2040-46 Rev. B

282

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

283

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Operation on memory halfword
Perform ALU or bit operation on the memory halfword at the effective address.
Syntax

Behavior

memh(Rs+#u6:1)=clrbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp &= (~(1<<#U));
*EA = tmp;

memh(Rs+#u6:1)=setbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp |= (1<<#U);
*EA = tmp;

memh(Rs+#u6:1)[+-]=#U5

apply_extension(#u);
EA=Rs[+-]#u;
tmp = *EA;
tmp [+-]= #U;
*EA = tmp;

memh(Rs+#u6:1)[+-|&]=Rt

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp [+-|&]= Rt;
*EA = tmp;

Class: MEMOP (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

8

7

6

5

4

3

Parse

2

1

0

t5

0

0

1

1

1

1

1

0

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

t

t

t

t

t

memh(Rs+#u6:1)+=Rt

0

0

1

1

1

1

1

0

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

t

t

t

t

t

memh(Rs+#u6:1)-=Rt

0

0

1

1

1

1

1

0

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

t

t

t

t

t

memh(Rs+#u6:1)&=Rt

0

1

1

1

1

1

0

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

t

t

t

t

t

memh(Rs+#u6:1)|=Rt

0

ICLASS

s5

Parse

0

0

1

1

1

1

1

1

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

I

I

I

I

I

memh(Rs+#u6:1)+=#U5

0

0

1

1

1

1

1

1

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

I

I

I

I

I

memh(Rs+#u6:1)-=#U5

0

0

1

1

1

1

1

1

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

I

I

I

I

I

memh(Rs+#u6:1)=clrbit(#U
5)

0

0

1

1

1

1

1

1

-

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

I

I

I

I

I

memh(Rs+#u6:1)=setbit(#
U5)

Field name
ICLASS
Parse
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

284

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Operation on memory word
Perform ALU or bit operation on the memory word at the effective address.
Syntax

Behavior

memw(Rs+#u6:2)=clrbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp &= (~(1<<#U));
*EA = tmp;

memw(Rs+#u6:2)=setbit(#U5)

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp |= (1<<#U);
*EA = tmp;

memw(Rs+#u6:2)[+-]=#U5

apply_extension(#u);
EA=Rs[+-]#u;
tmp = *EA;
tmp [+-]= #U;
*EA = tmp;

memw(Rs+#u6:2)[+-|&]=Rt

apply_extension(#u);
EA=Rs+#u;
tmp = *EA;
tmp [+-|&]= Rt;
*EA = tmp;

Class: MEMOP (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

8

7

6

5

4

3

Parse

2

1

0

t5

0

0

1

1

1

1

1

0

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

t

t

t

t

t

memw(Rs+#u6:2)+=Rt

0

0

1

1

1

1

1

0

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

t

t

t

t

t

memw(Rs+#u6:2)-=Rt

0

0

1

1

1

1

1

0

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

t

t

t

t

t

memw(Rs+#u6:2)&=Rt

0

1

1

1

1

1

0

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

t

t

t

t

t

memw(Rs+#u6:2)|=Rt

0

ICLASS

s5

Parse

0

0

1

1

1

1

1

1

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

0

I

I

I

I

I

memw(Rs+#u6:2)+=#U5

0

0

1

1

1

1

1

1

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

0

1

I

I

I

I

I

memw(Rs+#u6:2)-=#U5

0

0

1

1

1

1

1

1

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

0

I

I

I

I

I

memw(Rs+#u6:2)=clrbit(#U
5)

0

0

1

1

1

1

1

1

-

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

i

1

1

I

I

I

I

I

memw(Rs+#u6:2)=setbit(#
U5)

Field name
ICLASS
Parse
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

285

Hexagon V68 Programmer’s Reference Manual

11.7

Instruction Set

NV
The NV instruction class includes instructions that take the register source operand from
another instruction in the same packet.
NV instructions are executable on slot 0.

11.7.1

NV/J
The NV/J instruction subclass includes jump instructions that take the register source
operand from another instruction in the same packet.

Jump to address condition on new register value
Compare a register or constant against the value produced by a slot 1 instruction. If the
comparison is true, the program counter is changed to a target address, relative to the
current PC.
This instruction is executable only on slot 0.

80-N2040-46 Rev. B

Syntax

Behavior

if ([!]cmp.eq(Ns.new,#-1))
jump:<hint> #r9:2

;
if ((Ns.new[!]=(-1))) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.eq(Ns.new,#U5))
jump:<hint> #r9:2

;
if ((Ns.new[!]=(#U))) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.eq(Ns.new,Rt))
jump:<hint> #r9:2

;
if ((Ns.new[!]=Rt)) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gt(Ns.new,#-1))
jump:<hint> #r9:2

;
if ([!](Ns.new>(-1))) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gt(Ns.new,#U5))
jump:<hint> #r9:2

;
if ([!](Ns.new>(#U))) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

286

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

if ([!]cmp.gt(Ns.new,Rt))
jump:<hint> #r9:2

;
if ([!](Ns.new>Rt)) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gt(Rt,Ns.new))
jump:<hint> #r9:2

;
if ([!](Rt>Ns.new)) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gtu(Ns.new,#U5))
jump:<hint> #r9:2

;
if ([!](Ns.new.uw[0]>(#U))) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gtu(Ns.new,Rt))
jump:<hint> #r9:2

;
if ([!](Ns.new.uw[0]>Rt.uw[0])) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]cmp.gtu(Rt,Ns.new))
jump:<hint> #r9:2

;
if ([!](Rt.uw[0]>Ns.new.uw[0])) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

if ([!]tstbit(Ns.new,#0))
jump:<hint> #r9:2

;
if ([!]((Ns.new) & 1)) {
apply_extension(#r);
#r=#r & ~PCALIGN_MASK;
PC=PC+#r;
}

Class: NV (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s3

Parse

8

7

6

5

4

3

2

1

0

t5

0

0

1

0

0

0

0

0

0

0

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

0

0

0

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,Rt))
jump:t #r9:2

0

0

1

0

0

0

0

0

0

1

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

0

0

1

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,Rt))
jump:t #r9:2

0

0

1

0

0

0

0

0

1

0

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

0

1

0

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,Rt))
jump:t #r9:2

80-N2040-46 Rev. B

287

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

0

1

0

0

0

0

0

1

1

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

0

1

1

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,Rt))
jump:t #r9:2

0

0

1

0

0

0

0

1

0

0

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gtu(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

1

0

0

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gtu(Ns.new,Rt))
jump:t #r9:2

0

0

1

0

0

0

0

1

0

1

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gtu(Ns.new,Rt))
jump:nt #r9:2

0

0

1

0

0

0

0

1

0

1

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gtu(Ns.new,Rt))
jump:t #r9:2

0

0

1

0

0

0

0

1

1

0

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gt(Rt,Ns.new))
jump:nt #r9:2

0

0

1

0

0

0

0

1

1

0

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gt(Rt,Ns.new))
jump:t #r9:2

0

0

1

0

0

0

0

1

1

1

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gt(Rt,Ns.new))
jump:nt #r9:2

0

0

1

0

0

0

0

1

1

1

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gt(Rt,Ns.new))
jump:t #r9:2

0

0

1

0

0

0

1

0

0

0

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gtu(Rt,Ns.new))
jump:nt #r9:2

0

0

1

0

0

0

1

0

0

0

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (cmp.gtu(Rt,Ns.new))
jump:t #r9:2

0

0

1

0

0

0

1

0

0

1

i

i

-

s

s

s

P

P 0

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gtu(Rt,Ns.new))
jump:nt #r9:2

0

0

1

0

0

0

1

0

0

1

i

i

-

s

s

s

P

P 1

t

t

t

t

t

i

i

i

i

i

i

i

-

if (!cmp.gtu(Rt,Ns.new))
jump:t #r9:2

ICLASS

s3

Parse

0

0

1

0

0

1

0

0

0

0

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

0

0

0

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

0

0

1

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

0

0

1

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

0

1

0

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

0

1

0

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

0

1

1

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

0

1

1

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

1

0

0

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.gtu(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

1

0

0

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (cmp.gtu(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

1

0

1

i

i

-

s

s

s

P

P 0

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.gtu(Ns.new,#U5))
jump:nt #r9:2

0

0

1

0

0

1

0

1

0

1

i

i

-

s

s

s

P

P 1

I

I

I

I

I

i

i

i

i

i

i

i

-

if (!cmp.gtu(Ns.new,#U5))
jump:t #r9:2

0

0

1

0

0

1

0

1

1

0

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (tstbit(Ns.new,#0))
jump:nt #r9:2

0

0

1

0

0

1

0

1

1

0

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (tstbit(Ns.new,#0)) jump:t
#r9:2

0

0

1

0

0

1

0

1

1

1

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!tstbit(Ns.new,#0))
jump:nt #r9:2

0

0

1

0

0

1

0

1

1

1

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!tstbit(Ns.new,#0)) jump:t
#r9:2

0

0

1

0

0

1

1

0

0

0

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,#-1))
jump:nt #r9:2

80-N2040-46 Rev. B

288

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

0

1

0

0

1

1

0

0

0

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (cmp.eq(Ns.new,#-1))
jump:t #r9:2

0

0

1

0

0

1

1

0

0

1

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,#-1))
jump:nt #r9:2

0

0

1

0

0

1

1

0

0

1

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!cmp.eq(Ns.new,#-1))
jump:t #r9:2

0

0

1

0

0

1

1

0

1

0

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,#-1))
jump:nt #r9:2

0

0

1

0

0

1

1

0

1

0

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (cmp.gt(Ns.new,#-1))
jump:t #r9:2

0

0

1

0

0

1

1

0

1

1

i

i

-

s

s

s

P

P 0

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,#-1))
jump:nt #r9:2

0

0

1

0

0

1

1

0

1

1

i

i

-

s

s

s

P

P 1

-

-

-

-

-

i

i

i

i

i

i

i

-

if (!cmp.gt(Ns.new,#-1))
jump:t #r9:2

Field name
ICLASS
Parse
s3
t5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

289

Hexagon V68 Programmer’s Reference Manual

11.7.2

Instruction Set

NV/ST
The NV/ST instruction subclass includes store instructions which take the register source
operand from another instruction in the same packet.

Store new-value byte
Store the least-significant byte in a source register in memory at the effective address.
Syntax

Behavior

memb(Re=#U6)=Nt.new

apply_extension(#U);
EA=#U;
*EA = Nt.new.b[0];
Re=#U;

memb(Rs+#s11:0)=Nt.new

apply_extension(#s);
EA=Rs+#s;
*EA = Nt.new.b[0];

memb(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
*EA = Nt.new.b[0];

memb(Ru<<#u2+#U6)=Nt.new

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Nt.new.b[0];

memb(Rx++#s4:0)=Nt.new

EA=Rx;
Rx=Rx+#s;
*EA = Nt.new.b[0];

memb(Rx++#s4:0:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Nt.new.b[0];

memb(Rx++I:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,I<<0,MuV);
*EA = Nt.new.b[0];

memb(Rx++Mu)=Nt.new

EA=Rx;
Rx=Rx+MuV;
*EA = Nt.new.b[0];

memb(Rx++Mu:brev)=Nt.new

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Nt.new.b[0];

memb(gp+#u16:0)=Nt.new

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Nt.new.b[0];

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

290

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

1

0

1

i

i

0

1

ICLASS
0

1

0

0

1

1

s

s

s

s

s

1

i

i

i

i

i

Type

ICLASS
1

0

Parse

Amode
0

ICLASS

0

i

i

0

1

Amode

1

0

1

s5
s

s

U
N

Type

P

s

P

P

i

u

u

u

i

0

0

t

s

x5

P

P

6

5

4

3

2

1

0

t3
u

u

i

-

-

0

0

t

t

t

memb(Rs+Ru<<#u2)=Nt.n
ew

t

i

i

i

i

i

i

i

i

memb(gp+#u16:0)=Nt.new

t

i

i

i

i

i

i

i

i

memb(Rs+#s11:0)=Nt.new

t3

Parse
s

7

u5

Parse

U
N

Type

P

8

t
t3

i

0

0

t

Parse u1

t
t3

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 0

0

t

t

t

0

-

-

-

-

-

1

-

memb(Rx++I:circ(Mu))=Nt.
new

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 0

0

t

t

t

0

i

i

i

i

-

0

-

memb(Rx++#s4:0:circ(Mu))
=Nt.new

t

1

-

I

I

I

I

I

I

memb(Re=#U6)=Nt.new

t

0

i

i

i

i

-

0

-

memb(Rx++#s4:0)=Nt.new

t

1

i

I

I

I

I

I

I

memb(Ru<<#u2+#U6)=Nt.
new

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

1

1

Amode
0

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

0

1

1

0

Amode

1

e

e

1

0

1

x

x

e

e

x

u

u

u

P

t3

P 0

0

0

t

Parse
x

x

u5

U
N

Type

e

Parse

x5

U
N

Type
1

1

e5

U
N

Type

Amode
0

U
N

Type

P

t3

P 0

0

0

t

Parse
u

u

x5

P

P

t

t
t3

i

0

0

t

Parse u1

t
t3

1

0

1

0

1

1

0

1

1

0

1

x

x

x

x

x

P

P

u 0

0

t

t

t

0

-

-

-

-

-

-

-

memb(Rx++Mu)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

x

x

x

x

x

P

P

u 0

0

t

t

t

0

-

-

-

-

-

-

-

memb(Rx++Mu:brev)=Nt.n
ew

Field name
ICLASS
Type
Parse
e5
s5
t3
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

291

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store new-value byte conditionally
Store the least-significant byte in a source register in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pv[.new])
memb(#u6)=Nt.new

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new].b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rs+#u6:0)=Nt.new

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new].b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Nt[.new].b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rx++#s4:0)=Nt.new

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Nt[.new].b[0];
} else {
NOP;
}

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

292

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

2

u5

1

0

t3

0

0

1

1

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

0

t

t

t

if (Pv)
memb(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

0

t

t

t

if (!Pv)
memb(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

0

t

t

t

if (Pv.new)
memb(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

0

t

t

t

if (!Pv.new)
memb(Rs+Ru<<#u2)=Nt.n
ew

Pr
Se
ed
ns Ne
e w

ICLASS

Type

s5

Parse

t3

0

1

0

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

i

0

0

t

t

t

i

i

i

i

i

0

v

(Pv)
v ifmemb(Rs+#u6:0)=Nt.new

0

1

0

0

0

0

1

0

1

0

1

s

s

s

s

s

P

P

i

0

0

t

t

t

i

i

i

i

i

0

v

if (Pv.new)
v memb(Rs+#u6:0)=Nt.new

0

1

0

0

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

0

0

t

t

t

i

i

i

i

i

0

v

(!Pv)
v ifmemb(Rs+#u6:0)=Nt.new

0

1

0

0

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

0

0

t

t

t

i

i

i

i

i

0

v

(!Pv.new)
v ifmemb(Rs+#u6:0)=Nt.new

ICLASS

Amode

U
N

Type

x5

Parse

t3

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

0

t

t

t

0

i

i

i

i

0

v

(Pv)
v ifmemb(Rx++#s4:0)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

0

t

t

t

0

i

i

i

i

1

v

(!Pv)
v ifmemb(Rx++#s4:0)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

0

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memb(Rx++#s4:0)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

0

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemb(Rx++#s4:0)=Nt.new

ICLASS

Amode

U
N

Type

Parse

t3

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

0

0

t

t

t

1

i

i

i

i

0

v

v if (Pv) memb(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

0

0

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memb(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

0

0

t

t

t

1

i

i

i

i

0

v

(Pv.new)
v ifmemb(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

0

0

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemb(#u6)=Nt.new

Field name
ICLASS
Type
PredNew
Sense
Parse
s5
t3
u5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x

293

Hexagon V68 Programmer’s Reference Manual

Field name
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Amode
Type
Unsigned

294

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store new-value halfword
Store the upper or lower 16-bits of a source register in memory at the effective address.
Syntax

Behavior

memh(Re=#U6)=Nt.new

apply_extension(#U);
EA=#U;
*EA = Nt.new.h[0];
Re=#U;

memh(Rs+#s11:1)=Nt.new

apply_extension(#s);
EA=Rs+#s;
*EA = Nt.new.h[0];

memh(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
*EA = Nt.new.h[0];

memh(Ru<<#u2+#U6)=Nt.new

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Nt.new.h[0];

memh(Rx++#s4:1)=Nt.new

EA=Rx;
Rx=Rx+#s;
*EA = Nt.new.h[0];

memh(Rx++#s4:1:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Nt.new.h[0];

memh(Rx++I:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
*EA = Nt.new.h[0];

memh(Rx++Mu)=Nt.new

EA=Rx;
Rx=Rx+MuV;
*EA = Nt.new.h[0];

memh(Rx++Mu:brev)=Nt.new

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Nt.new.h[0];

memh(gp+#u16:1)=Nt.new

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Nt.new.h[0];

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

295

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

1

0

1

i

i

0

1

ICLASS
0

1

0

0

1

1

s

s

s

s

s

1

i

i

i

i

i

Type

ICLASS
1

0

Parse

Amode
0

ICLASS

0

i

i

0

1

Amode

1

0

1

s5
s

s

U
N

Type

P

s

P

P

i

u

u

u

i

0

1

t

s

x5

P

P

6

5

4

3

2

1

0

t3
u

u

i

-

-

0

1

t

t

t

memh(Rs+Ru<<#u2)=Nt.n
ew

t

i

i

i

i

i

i

i

i

memh(gp+#u16:1)=Nt.new

t

i

i

i

i

i

i

i

i

memh(Rs+#s11:1)=Nt.new

t3

Parse
s

7

u5

Parse

U
N

Type

P

8

t
t3

i

0

1

t

Parse u1

t
t3

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 0

1

t

t

t

0

-

-

-

-

-

1

-

memh(Rx++I:circ(Mu))=Nt.
new

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 0

1

t

t

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1:circ(Mu))
=Nt.new

t

1

-

I

I

I

I

I

I

memh(Re=#U6)=Nt.new

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1)=Nt.new

t

1

i

I

I

I

I

I

I

memh(Ru<<#u2+#U6)=Nt.
new

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

1

1

Amode
0

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

0

1

1

0

Amode

1

e

e

1

0

1

x

x

e

e

x

u

u

u

P

t3

P 0

0

1

t

Parse
x

x

u5

U
N

Type

e

Parse

x5

U
N

Type
1

1

e5

U
N

Type

Amode
0

U
N

Type

P

t3

P 0

0

1

t

Parse
u

u

x5

P

P

t

t
t3

i

0

1

t

Parse u1

t
t3

1

0

1

0

1

1

0

1

1

0

1

x

x

x

x

x

P

P

u 0

1

t

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

x

x

x

x

x

P

P

u 0

1

t

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu:brev)=Nt.n
ew

Field name
ICLASS
Type
Parse
e5
s5
t3
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

296

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store new-value halfword conditionally
Store the upper or lower 16-bits of a source register in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pv[.new])
memh(#u6)=Nt.new

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new].h[0];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+#u6:1)=Nt.new

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new].h[0];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Nt[.new].h[0];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rx++#s4:1)=Nt.new

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Nt[.new].h[0];
} else {
NOP;
}

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

297

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

2

u5

1

0

t3

0

0

1

1

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

1

t

t

t

if (Pv)
memh(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

1

t

t

t

if (!Pv)
memh(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

1

t

t

t

if (Pv.new)
memh(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 0

1

t

t

t

if (!Pv.new)
memh(Rs+Ru<<#u2)=Nt.n
ew

Pr
Se
ed
ns Ne
e w

ICLASS

Type

s5

Parse

t3

0

1

0

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

i

0

1

t

t

t

i

i

i

i

i

0

v

(Pv)
v ifmemh(Rs+#u6:1)=Nt.new

0

1

0

0

0

0

1

0

1

0

1

s

s

s

s

s

P

P

i

0

1

t

t

t

i

i

i

i

i

0

v

if (Pv.new)
v memh(Rs+#u6:1)=Nt.new

0

1

0

0

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

0

1

t

t

t

i

i

i

i

i

0

v

(!Pv)
v ifmemh(Rs+#u6:1)=Nt.new

0

1

0

0

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

0

1

t

t

t

i

i

i

i

i

0

v

(!Pv.new)
v ifmemh(Rs+#u6:1)=Nt.new

ICLASS

Amode

U
N

Type

x5

Parse

t3

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

1

t

t

t

0

i

i

i

i

0

v

(Pv)
v ifmemh(Rx++#s4:1)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

1

t

t

t

0

i

i

i

i

1

v

(!Pv)
v ifmemh(Rx++#s4:1)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

1

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memh(Rx++#s4:1)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

0

1

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemh(Rx++#s4:1)=Nt.new

ICLASS

Amode

U
N

Type

Parse

t3

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

0

1

t

t

t

1

i

i

i

i

0

v

v if (Pv) memh(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

0

1

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memh(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

0

1

t

t

t

1

i

i

i

i

0

v

(Pv.new)
v ifmemh(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

0

1

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemh(#u6)=Nt.new

Field name
ICLASS
Type
PredNew
Sense
Parse
s5
t3
u5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x

298

Hexagon V68 Programmer’s Reference Manual

Field name
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Amode
Type
Unsigned

299

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store new-value word
Store a 32-bit register in memory at the effective address.
Syntax

Behavior

memw(Re=#U6)=Nt.new

apply_extension(#U);
EA=#U;
*EA = Nt.new;
Re=#U;

memw(Rs+#s11:2)=Nt.new

apply_extension(#s);
EA=Rs+#s;
*EA = Nt.new;

memw(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
*EA = Nt.new;

memw(Ru<<#u2+#U6)=Nt.new

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Nt.new;

memw(Rx++#s4:2)=Nt.new

EA=Rx;
Rx=Rx+#s;
*EA = Nt.new;

memw(Rx++#s4:2:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Nt.new;

memw(Rx++I:circ(Mu))=Nt.new

EA=Rx;
Rx=Rx=circ_add(Rx,I<<2,MuV);
*EA = Nt.new;

memw(Rx++Mu)=Nt.new

EA=Rx;
Rx=Rx+MuV;
*EA = Nt.new;

memw(Rx++Mu:brev)=Nt.new

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Nt.new;

memw(gp+#u16:2)=Nt.new

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Nt.new;

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

300

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

1

0

1

i

i

0

1

ICLASS
0

1

0

0

1

1

s

s

s

s

s

1

i

i

i

i

i

Type

ICLASS
1

0

Parse

Amode
0

ICLASS

0

i

i

0

1

Amode

1

0

1

s5
s

s

U
N

Type

P

s

P

P

i

u

u

u

i

1

0

t

s

x5

P

P

6

5

4

3

2

1

0

t3
u

u

i

-

-

1

0

t

t

t

memw(Rs+Ru<<#u2)=Nt.n
ew

t

i

i

i

i

i

i

i

i

memw(gp+#u16:2)=Nt.new

t

i

i

i

i

i

i

i

i

memw(Rs+#s11:2)=Nt.new

t3

Parse
s

7

u5

Parse

U
N

Type

P

8

t
t3

i

1

0

t

Parse u1

t
t3

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 1

0

t

t

t

0

-

-

-

-

-

1

-

memw(Rx++I:circ(Mu))=Nt.
new

1

0

1

0

1

0

0

1

1

0

1

x

x

x

x

x

P

P

u 1

0

t

t

t

0

i

i

i

i

-

0

-

memw(Rx++#s4:2:circ(Mu)
)=Nt.new

t

1

-

I

I

I

I

I

I

memw(Re=#U6)=Nt.new

t

0

i

i

i

i

-

0

-

memw(Rx++#s4:2)=Nt.new

t

1

i

I

I

I

I

I

I

memw(Ru<<#u2+#U6)=Nt.
new

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

1

1

Amode
0

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

0

1

1

0

Amode

1

e

e

1

0

1

x

x

e

e

x

u

u

u

P

t3

P 0

1

0

t

Parse
x

x

u5

U
N

Type

e

Parse

x5

U
N

Type
1

1

e5

U
N

Type

Amode
0

U
N

Type

P

t3

P 0

1

0

t

Parse
u

u

x5

P

P

t

t
t3

i

1

0

t

Parse u1

t
t3

1

0

1

0

1

1

0

1

1

0

1

x

x

x

x

x

P

P

u 1

0

t

t

t

0

-

-

-

-

-

-

-

memw(Rx++Mu)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

x

x

x

x

x

P

P

u 1

0

t

t

t

0

-

-

-

-

-

-

-

memw(Rx++Mu:brev)=Nt.n
ew

Field name
ICLASS
Type
Parse
e5
s5
t3
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

301

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store new-value word conditionally
Store a 32-bit register in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pv[.new])
memw(#u6)=Nt.new

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new];
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rs+#u6:2)=Nt.new

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Nt[.new];
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rs+Ru<<#u2)=Nt.new

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Nt[.new];
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rx++#s4:2)=Nt.new

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Nt[.new];
} else {
NOP;
}

Class: NV (slots 0)
Notes

80-N2040-46 Rev. B

■

Forms of this instruction which use a new-value operand produced in the packet
must execute on slot 0.

■

This instruction can execute only in slot 0, even though it is an ST instruction.

302

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

2

u5

1

0

t3

0

0

1

1

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 1

0

t

t

t

if (Pv)
memw(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 1

0

t

t

t

if (!Pv)
memw(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 1

0

t

t

t

if (Pv.new)
memw(Rs+Ru<<#u2)=Nt.n
ew

0

0

1

1

0

1

1

1

1

0

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v 1

0

t

t

t

if (!Pv.new)
memw(Rs+Ru<<#u2)=Nt.n
ew

Pr
Se
ed
ns Ne
e w

ICLASS

Type

s5

Parse

t3

0

1

0

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

i

1

0

t

t

t

i

i

i

i

i

0

v

(Pv)
v ifmemw(Rs+#u6:2)=Nt.new

0

1

0

0

0

0

1

0

1

0

1

s

s

s

s

s

P

P

i

1

0

t

t

t

i

i

i

i

i

0

v

if (Pv.new)
v memw(Rs+#u6:2)=Nt.new

0

1

0

0

0

1

0

0

1

0

1

s

s

s

s

s

P

P

i

1

0

t

t

t

i

i

i

i

i

0

v

(!Pv)
v ifmemw(Rs+#u6:2)=Nt.new

0

1

0

0

0

1

1

0

1

0

1

s

s

s

s

s

P

P

i

1

0

t

t

t

i

i

i

i

i

0

v

(!Pv.new)
v ifmemw(Rs+#u6:2)=Nt.new

ICLASS

Amode

U
N

Type

x5

Parse

t3

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

1

0

t

t

t

0

i

i

i

i

0

v

(Pv)
v ifmemw(Rx++#s4:2)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

1

0

t

t

t

0

i

i

i

i

1

v

(!Pv)
v ifmemw(Rx++#s4:2)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

1

0

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memw(Rx++#s4:2)=Nt.new

1

0

1

0

1

0

1

1

1

0

1

x

x

x

x

x

P

P 1

1

0

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemw(Rx++#s4:2)=Nt.new

ICLASS

Amode

U
N

Type

Parse

t3

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

1

0

t

t

t

1

i

i

i

i

0

v

v if (Pv) memw(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 0

1

0

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memw(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

1

0

t

t

t

1

i

i

i

i

0

v

(Pv.new)
v ifmemw(#u6)=Nt.new

1

0

1

0

1

1

1

1

1

0

1

-

-

-

i

i

P

P 1

1

0

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemw(#u6)=Nt.new

Field name
ICLASS
Type
PredNew
Sense
Parse
s5
t3
u5
v2
x5

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x

303

Hexagon V68 Programmer’s Reference Manual

Field name
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Amode
Type
Unsigned

304

Hexagon V68 Programmer’s Reference Manual

11.8

Instruction Set

ST
The ST instruction class includes store instructions that store values in memory.
ST instructions are executable on slot 0 and slot 1.

Store doubleword
Store a 64-bit register pair in memory at the effective address.

80-N2040-46 Rev. B

Syntax

Behavior

memd(Re=#U6)=Rtt

apply_extension(#U);
EA=#U;
*EA = Rtt;
Re=#U;

memd(Rs+#s11:3)=Rtt

apply_extension(#s);
EA=Rs+#s;
*EA = Rtt;

memd(Rs+Ru<<#u2)=Rtt

EA=Rs+(Ru<<#u);
*EA = Rtt;

memd(Ru<<#u2+#U6)=Rtt

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Rtt;

memd(Rx++#s4:3)=Rtt

EA=Rx;
Rx=Rx+#s;
*EA = Rtt;

memd(Rx++#s4:3:circ(Mu))=Rtt

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Rtt;

memd(Rx++I:circ(Mu))=Rtt

EA=Rx;
Rx=Rx=circ_add(Rx,I<<3,MuV);
*EA = Rtt;

memd(Rx++Mu)=Rtt

EA=Rx;
Rx=Rx+MuV;
*EA = Rtt;

memd(Rx++Mu:brev)=Rtt

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Rtt;

memd(gp+#u16:3)=Rtt

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Rtt;

305

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: ST (slots 0,1)
Intrinsics
memd(Rx++#s4:3:circ(Mu))=Rtt

void Q6_memd_IMP_circ(void** StartAddress,
Word32 Is4_3, Word32 Mu, Word64 Rtt, void*
BaseAddress)

memd(Rx++I:circ(Mu))=Rtt

void Q6_memd_MP_circ(void** StartAddress, Word32
Mu, Word64 Rtt, void* BaseAddress)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

1

ICLASS
0

1

0

0

1

0

s

s

s

s

s

Type
0

ICLASS
1

1

Parse

1

i

i

0

Amode
0

ICLASS

0

i

i

1

1

1

Amode

1

1

0

i

i

0

i

i

i

s5
s

s

U
N

Type

P

i

u

u

Parse

U
N

Type

P

s

P

P

s

x5

P

P

7

6

5

4

3

u

2

1

0

t5
u

u

i

-

-

t

t

t

t

t

memd(Rs+Ru<<#u2)=Rtt

t

t

i

i

i

i

i

i

i

i

memd(gp+#u16:3)=Rtt

t

t

i

i

i

i

i

i

i

i

memd(Rs+#s11:3)=Rtt

t5
i

t

t

Parse
s

8

u5

t
t5

i

t

t

Parse u1

t
t5

1

0

1

0

1

0

0

1

1

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

1

-

memd(Rx++I:circ(Mu))=Rtt

1

0

1

0

1

0

0

1

1

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

i

i

i

i

-

0

-

memd(Rx++#s4:3:circ(Mu))
=Rtt

t

t

1

-

I

I

I

I

I

I

memd(Re=#U6)=Rtt

t

t

0

i

i

i

i

-

0

-

memd(Rx++#s4:3)=Rtt

t

t

1

i

I

I

I

I

I

I

memd(Ru<<#u2+#U6)=Rtt

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

1

1

Amode
0

ICLASS
1

1

1

0

1

ICLASS

1

1

0

1

1

1

1

1

Amode

1

e

e

0

1

0

x

x

e

e

x

u

u

u

P

t5

P 0

t

t

Parse
x

x

u5

U
N

Type

e

Parse

x5

U
N

Type
1

0

e5

U
N

Type

Amode
0

U
N

Type

P

t5

P 0

t

t

Parse
u

u

x5

P

P

t

t
t5

i

t

t

Parse u1

t
t5

1

0

1

0

1

1

0

1

1

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memd(Rx++Mu)=Rtt

1

0

1

0

1

1

1

1

1

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memd(Rx++Mu:brev)=Rtt

Field name
ICLASS
Type
Parse
e5
s5
t5
u1
u5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x

306

Hexagon V68 Programmer’s Reference Manual

Field name
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Amode
Type
Unsigned

307

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store-release doubleword
Store a 64-bit register pair in memory at the effective address. The store-release memory
operation is observed after all preceding memory operations have been observed at the
local point of serialization. A different order may be observed at the global point of
serialization. (see Ordering and Synchronization).
When the :st (same thread) option is specified, the preceding memory operations are those
that precede this instruction in program order.
When the :at (all threads) option is specified, the preceding memory operations are those
that were committed on any thread before this instruction was committed.
The Store release address is limited to certain memory regions. The following are
excluded memory regions: AHB memory space, AXI M2 memory space, Hexagon
memory cut-out is excluded with the exception of addressible TCM and VTCM memory,
and memory with the CCCC types 2, 3, or 4 are excluded.
Syntax

Behavior

memd_rl(Rs):at=Rtt

EA=Rs;
*EA = Rtt

memd_rl(Rs):st=Rtt

EA=Rs;
*EA = Rtt

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

Parse

8

7

6

5

4

3

2

t5

1

0
d2

1

0

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

0

0

1

0

d

d memd_rl(Rs):at=Rtt

1

0

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

1

0

1

0

d

d memd_rl(Rs):st=Rtt

Field name
ICLASS
Parse
d2
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

308

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store doubleword conditionally
Store a 64-bit register pair in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.
Syntax

Behavior

if ([!]Pv[.new]) memd(#u6)=Rtt

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Rtt;
} else {
NOP;
}

if ([!]Pv[.new])
memd(Rs+#u6:3)=Rtt

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Rtt;
} else {
NOP;
}

if ([!]Pv[.new])
memd(Rs+Ru<<#u2)=Rtt

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Rtt;
} else {
NOP;
}

if ([!]Pv[.new])
memd(Rx++#s4:3)=Rtt

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Rtt;
} else {
NOP;
}

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

u5

2

1

0

t5

0

0

1

1

0

1

0

0

1

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv)
memd(Rs+Ru<<#u2)=Rtt

0

0

1

1

0

1

0

1

1

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv)
memd(Rs+Ru<<#u2)=Rtt

0

0

1

1

0

1

1

0

1

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv.new)
memd(Rs+Ru<<#u2)=Rtt

0

0

1

1

0

1

1

1

1

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv.new)
memd(Rs+Ru<<#u2)=Rtt

t

t

i

i

i

i

i

0

v

(Pv)
v ifmemd(Rs+#u6:3)=Rtt

Pr
Se ed
ns Ne
e w

ICLASS

0

1

0

0

0

0

80-N2040-46 Rev. B

0

Type

0

1

1

s5

0

s

s

s

Parse

s

s

P

P

t5

i

t

t

t

309

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

0

1

0

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (Pv.new)
memd(Rs+#u6:3)=Rtt

0

1

0

0

0

1

0

0

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (!Pv)
memd(Rs+#u6:3)=Rtt

0

1

0

0

0

1

1

0

1

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (!Pv.new)
memd(Rs+#u6:3)=Rtt

if (Pv)
memd(Rx++#s4:3)=Rtt

ICLASS

Amode

U
N

Type

x5

Parse

t5

1

0

1

0

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

0

v

v

1

0

1

0

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

1

v

v if (!Pv)
memd(Rx++#s4:3)=Rtt

1

0

1

0

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v

if (Pv.new)
memd(Rx++#s4:3)=Rtt

1

0

1

0

1

0

1

1

1

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v

if (!Pv.new)
memd(Rx++#s4:3)=Rtt

ICLASS

Amode

U
N

Type

Parse

t5

1

0

1

0

1

1

1

1

1

1

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv) memd(#u6)=Rtt

1

0

1

0

1

1

1

1

1

1

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memd(#u6)=Rtt

1

0

1

0

1

1

1

1

1

1

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv.new) memd(#u6)=Rtt

1

0

1

0

1

1

1

1

1

1

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv.new) memd(#u6)=Rtt

Field name
ICLASS
Type
PredNew
Sense
Parse
s5
t5
u5
v2
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x
Amode
Type
Unsigned

310

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store byte
Store the least-significant byte in a source register at the effective address.
Syntax

Behavior

memb(Re=#U6)=Rt

apply_extension(#U);
EA=#U;
*EA = Rt.b[0];
Re=#U;

memb(Rs+#s11:0)=Rt

apply_extension(#s);
EA=Rs+#s;
*EA = Rt.b[0];

memb(Rs+#u6:0)=#S8

EA=Rs+#u;
apply_extension(#S);
*EA = #S;

memb(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
*EA = Rt.b[0];

memb(Ru<<#u2+#U6)=Rt

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Rt.b[0];

memb(Rx++#s4:0)=Rt

EA=Rx;
Rx=Rx+#s;
*EA = Rt.b[0];

memb(Rx++#s4:0:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Rt.b[0];

memb(Rx++I:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,I<<0,MuV);
*EA = Rt.b[0];

memb(Rx++Mu)=Rt

EA=Rx;
Rx=Rx+MuV;
*EA = Rt.b[0];

memb(Rx++Mu:brev)=Rt

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Rt.b[0];

memb(gp+#u16:0)=Rt

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Rt.b[0];

Class: ST (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

memb(Rx++#s4:0:circ(Mu))=Rt

void Q6_memb_IMR_circ(void** StartAddress,
Word32 Is4_0, Word32 Mu, Word32 Rt, void*
BaseAddress)

memb(Rx++I:circ(Mu))=Rt

void Q6_memb_MR_circ(void** StartAddress, Word32
Mu, Word32 Rt, void* BaseAddress)

311

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

0

0

0

s

s

ICLASS
0

0

1

1

0

1

0

1

0

1

1

0

-

1

0
0

1
1

0

0

1

0
0

0

1

0

-

0

1

0

0

0

i

i

1
1

0

0

0

0

1

0

1

0

1

0

1

1

ICLASS

1

1

0

0

0

s

s

s

0

0

1

0

1

0

0

0

0

0

0

Amode

0

0

0

s

s

s

s

0
0

0

0

0

i

i

i

s

x
x

x
x

x
x

s

s

u

u

P

P

I

i

i

e

e

x
x

x
x

x

x

e

e

u

u

P

i

t

t

4

3

2

1

0

t5

u

u

u

i

-

-

t

t

t

t

t

memb(Rs+Ru<<#u2)=Rt

i

i

i

i

I

I

I

I

I

I

I

memb(Rs+#u6:0)=#S8

t

t

i

i

i

i

i

i

i

i

memb(gp+#u16:0)=Rt

P

P

t

t

i

i

i

i

i

i

i

i

memb(Rs+#s11:0)=Rt

P
P

P

t

t

0

-

-

-

-

-

1

-

memb(Rx++I:circ(Mu))=Rt

P

P

x

x

P

i

t

t

u
u

u

x5

P

t
t

t
t

t
t

t

t

0

i

i

i

i

-

0

-

memb(Rx++#s4:0:circ(Mu))
=Rt

t

t

1

-

I

I

I

I

I

I

memb(Re=#U6)=Rt

t

t

0

i

i

i

i

-

0

-

memb(Rx++#s4:0)=Rt

t

t

1

i

I

I

I

I

I

I

memb(Ru<<#u2+#U6)=Rt

t5

P 0

t

t

t
t5

P 0

P

t
t5

t

t

Parse
u

t
t5

Parse

u5
u

P

Parse

x5
x

5

t5

Parse u1

e5
e

6

u5
i

Parse

x5

U
N

Type

P

7

Parse

s5

U
N

Type
1

i

U
N

Type
1

i

U
N

Type
1

0

U
N
0

P

Parse

U
N

Type

Amode
0

0
Type

Amode

ICLASS
1

i

Amode

ICLASS
1

i

Amode

ICLASS
1

1

Amode

ICLASS
1

s

Type

ICLASS
1

Parse
s

s5

ICLASS
0

s

8

t
t5

i

t

t

Parse u1

t
t5

1

0

1

0

1

1

0

1

0

0

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memb(Rx++Mu)=Rt

1

0

1

0

1

1

1

1

0

0

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memb(Rx++Mu:brev)=Rt

Field name
ICLASS
Type
Parse
e5
s5
t5
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

312

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store byte conditionally
Store the least-significant byte in a source register at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.

80-N2040-46 Rev. B

Syntax

Behavior

if ([!]Pv[.new]) memb(#u6)=Rt

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Rt.b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rs+#u6:0)=#S6

EA=Rs+#u;
if ([!]Pv[.new][0]){
apply_extension(#S);
*EA = #S;
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rs+#u6:0)=Rt

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Rt.b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Rt.b[0];
} else {
NOP;
}

if ([!]Pv[.new])
memb(Rx++#s4:0)=Rt

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Rt.b[0];
} else {
NOP;
}

313

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

u5

2

1

0

t5

0

0

1

1

0

1

0

0

0

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv)
memb(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

0

1

0

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv)
memb(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

0

0

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv.new)
memb(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

1

0

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv.new)
memb(Rs+Ru<<#u2)=Rt

ICLASS

s5

Parse

0

0

1

1

1

0

0

0

0

0

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv)
memb(Rs+#u6:0)=#S6

0

0

1

1

1

0

0

0

1

0

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv)
memb(Rs+#u6:0)=#S6

0

0

1

1

1

0

0

1

0

0

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv.new)
memb(Rs+#u6:0)=#S6

0

0

1

1

1

0

0

1

1

0

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv.new)
memb(Rs+#u6:0)=#S6

Pr
Se ed
ns Ne
e w

ICLASS

Type

s5

Parse

t5

0

1

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v if (Pv) memb(Rs+#u6:0)=Rt

0

1

0

0

0

0

1

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(Pv.new)
v ifmemb(Rs+#u6:0)=Rt

0

1

0

0

0

1

0

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(!Pv)
v ifmemb(Rs+#u6:0)=Rt

0

1

0

0

0

1

1

0

0

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

if (!Pv.new)
v memb(Rs+#u6:0)=Rt

ICLASS

Amode

U
N

Type

x5

Parse

t5

1

0

1

0

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

0

v

(Pv)
v ifmemb(Rx++#s4:0)=Rt

1

0

1

0

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

1

v

if (!Pv)
v memb(Rx++#s4:0)=Rt

1

0

1

0

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

(Pv.new)
v ifmemb(Rx++#s4:0)=Rt

1

0

1

0

1

0

1

1

0

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemb(Rx++#s4:0)=Rt

ICLASS

Amode

U
N

Type

Parse

t5

1

0

1

0

1

1

1

1

0

0

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv) memb(#u6)=Rt

1

0

1

0

1

1

1

1

0

0

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memb(#u6)=Rt

1

0

1

0

1

1

1

1

0

0

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv.new) memb(#u6)=Rt

1

0

1

0

1

1

1

1

0

0

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv.new) memb(#u6)=Rt

Field name
ICLASS
Type
PredNew
Sense
Parse

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits

314

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
u5
v2
x5
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x
Amode
Type
Unsigned

315

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store halfword
Store the upper or lower 16-bits of a source register at the effective address.

80-N2040-46 Rev. B

Syntax

Behavior

memh(Re=#U6)=Rt.H

apply_extension(#U);
EA=#U;
*EA = Rt.h[1];
Re=#U;

memh(Re=#U6)=Rt

apply_extension(#U);
EA=#U;
*EA = Rt.h[0];
Re=#U;

memh(Rs+#s11:1)=Rt.H

apply_extension(#s);
EA=Rs+#s;
*EA = Rt.h[1];

memh(Rs+#s11:1)=Rt

apply_extension(#s);
EA=Rs+#s;
*EA = Rt.h[0];

memh(Rs+#u6:1)=#S8

EA=Rs+#u;
apply_extension(#S);
*EA = #S;

memh(Rs+Ru<<#u2)=Rt.H

EA=Rs+(Ru<<#u);
*EA = Rt.h[1];

memh(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
*EA = Rt.h[0];

memh(Ru<<#u2+#U6)=Rt.H

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Rt.h[1];

memh(Ru<<#u2+#U6)=Rt

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Rt.h[0];

memh(Rx++#s4:1)=Rt.H

EA=Rx;
Rx=Rx+#s;
*EA = Rt.h[1];

memh(Rx++#s4:1)=Rt

EA=Rx;
Rx=Rx+#s;
*EA = Rt.h[0];

memh(Rx++#s4:1:circ(Mu))=Rt.H

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Rt.h[1];

memh(Rx++#s4:1:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Rt.h[0];

memh(Rx++I:circ(Mu))=Rt.H

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
*EA = Rt.h[1];

memh(Rx++I:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,I<<1,MuV);
*EA = Rt.h[0];

316

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

memh(Rx++Mu)=Rt.H

EA=Rx;
Rx=Rx+MuV;
*EA = Rt.h[1];

memh(Rx++Mu)=Rt

EA=Rx;
Rx=Rx+MuV;
*EA = Rt.h[0];

memh(Rx++Mu:brev)=Rt.H

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Rt.h[1];

memh(Rx++Mu:brev)=Rt

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Rt.h[0];

memh(gp+#u16:1)=Rt.H

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Rt.h[1];

memh(gp+#u16:1)=Rt

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Rt.h[0];

Class: ST (slots 0,1)
Intrinsics
memh(Rx++#s4:1:circ(Mu))=Rt.H

void Q6_memh_IMRh_circ(void** StartAddress,
Word32 Is4_1, Word32 Mu, Word32 Rt, void*
BaseAddress)

memh(Rx++#s4:1:circ(Mu))=Rt

void Q6_memh_IMR_circ(void** StartAddress,
Word32 Is4_1, Word32 Mu, Word32 Rt, void*
BaseAddress)

memh(Rx++I:circ(Mu))=Rt.H

void Q6_memh_MRh_circ(void** StartAddress,
Word32 Mu, Word32 Rt, void* BaseAddress)

memh(Rx++I:circ(Mu))=Rt

void Q6_memh_MR_circ(void** StartAddress, Word32
Mu, Word32 Rt, void* BaseAddress)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

u5

2

1

0

t5

0

0

1

1

1

0

1

1

0

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

-

-

t

t

t

t

t

memh(Rs+Ru<<#u2)=Rt

0

0

1

1

1

0

1

1

0

1

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

-

-

t

t

t

t

t

memh(Rs+Ru<<#u2)=Rt.H

I

i

i

i

i

i

i

I

I

I

I

I

I

I

memh(Rs+#u6:1)=#S8

ICLASS
0

0

1

s5
1

1

1

0

-

-

ICLASS

0

Parse

1

s

s

s

s

s

Type

P

P

Parse

t5

0

1

0

0

1

i

i

0

0

1

0

i

i

i

i

i

P

P

i

t

t

t

t

t

i

i

i

i

i

i

i

i

memh(gp+#u16:1)=Rt

0

1

0

0

1

i

i

0

0

1

1

i

i

i

i

i

P

P

i

t

t

t

t

t

i

i

i

i

i

i

i

i

memh(gp+#u16:1)=Rt.H

ICLASS

Amode

U
N

Type

s5

Parse

t5

1

0

1

0

0

i

i

1

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

i

i

i

memh(Rs+#s11:1)=Rt

1

0

1

0

0

i

i

1

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

i

i

i

memh(Rs+#s11:1)=Rt.H

80-N2040-46 Rev. B

317

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

x5

Parse u1

8

7

6

5

4

3

2

1

0

t5

1

0

1

0

1

0

0

1

0

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

1

-

memh(Rx++I:circ(Mu))=Rt

1

0

1

0

1

0

0

1

0

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1:circ(Mu))
=Rt

1

0

1

0

1

0

0

1

0

1

1

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

1

-

memh(Rx++I:circ(Mu))=Rt.
H

1

0

1

0

1

0

0

1

0

1

1

x

x

x

x

x

P

P

u

t

t

t

t

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1:circ(Mu))
=Rt.H

t

t

1

-

I

I

I

I

I

I

memh(Re=#U6)=Rt

t

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1)=Rt

t

t

1

-

I

I

I

I

I

I

memh(Re=#U6)=Rt.H

t

t

0

i

i

i

i

-

0

-

memh(Rx++#s4:1)=Rt.H

t

t

1

i

I

I

I

I

I

I

memh(Ru<<#u2+#U6)=Rt

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu)=Rt

t

t

1

i

I

I

I

I

I

I

memh(Ru<<#u2+#U6)=Rt.
H

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

0

1

0

0

1

0

0

1

0

0

1

0

1

1

1

0

1

1

0

1

1

1

0

0

1

1

0

ICLASS

1

1

0

0

1

0

1

0

1

0

1

0

1

Amode

0

0

1

1

1

0

x

x

0

e

e

1

x

x

x

e

x

u

u

u

x

x

x

x

e

e

u

u

t

t

P

P

x

x

P

P 0

t

t

u

P

P 0

t

t

t

t

x

P

P

i

t

t

u

u

x5

P

P

t
t5

t

t

Parse
u

t
t5

Parse u1
x

t
t5

P 0

P

t
t5

Parse
u

t
t5

Parse

u5
u

P 0

Parse

x5
x

P

t5

Parse

u5

U
N

Type

e

x5

U
N
1

e

e5

U
N
1

e

Parse

x5

U
N

Type
1

e

U
N

Type
1

e

U
N

Type
1

0

e5

U
N

Type

Amode
0

1

Type

Amode

ICLASS
1

1

0
Type

Amode

ICLASS
1

1

Amode

ICLASS
1

1

Amode

ICLASS
1

0

Amode

ICLASS
1

1

U
N

Type

t
t5

i

t

t

Parse u1

t
t5

1

0

1

0

1

1

0

1

0

1

1

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu)=Rt.H

1

0

1

0

1

1

1

1

0

1

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu:brev)=Rt

1

0

1

0

1

1

1

1

0

1

1

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memh(Rx++Mu:brev)=Rt.H

Field name
ICLASS
Type
Parse
e5
s5
t5
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

318

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store halfword conditionally
Store the upper or lower 16-bits of a source register in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.

80-N2040-46 Rev. B

Syntax

Behavior

if ([!]Pv[.new]) memh(#u6)=Rt.H

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Rt.h[1];
} else {
NOP;
}

if ([!]Pv[.new]) memh(#u6)=Rt

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Rt.h[0];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+#u6:1)=#S6

EA=Rs+#u;
if ([!]Pv[.new][0]){
apply_extension(#S);
*EA = #S;
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+#u6:1)=Rt.H

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Rt.h[1];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+#u6:1)=Rt

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Rt.h[0];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+Ru<<#u2)=Rt.H

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Rt.h[1];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Rt.h[0];
} else {
NOP;
}

319

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

if ([!]Pv[.new])
memh(Rx++#s4:1)=Rt.H

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Rt.h[1];
} else {
NOP;
}

if ([!]Pv[.new])
memh(Rx++#s4:1)=Rt

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Rt.h[0];
} else {
NOP;
}

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

u5

2

1

0

t5

0

0

1

1

0

1

0

0

0

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv)
memh(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

0

0

0

1

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv)
memh(Rs+Ru<<#u2)=Rt.H

0

0

1

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv)
memh(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv)
memh(Rs+Ru<<#u2)=Rt.H

0

0

1

1

0

1

1

0

0

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv.new)
memh(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

0

0

1

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv.new)
memh(Rs+Ru<<#u2)=Rt.H

0

0

1

1

0

1

1

1

0

1

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv.new)
memh(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

1

0

1

1

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv.new)
memh(Rs+Ru<<#u2)=Rt.H

ICLASS

s5

Parse

0

0

1

1

1

0

0

0

0

0

1

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv)
memh(Rs+#u6:1)=#S6

0

0

1

1

1

0

0

0

1

0

1

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv)
memh(Rs+#u6:1)=#S6

0

0

1

1

1

0

0

1

0

0

1

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv.new)
memh(Rs+#u6:1)=#S6

0

0

1

1

1

0

0

1

1

0

1

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv.new)
memh(Rs+#u6:1)=#S6

Pr
Se ed
ns Ne
e w

ICLASS

Type

s5

Parse

t5

0

1

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v if (Pv) memh(Rs+#u6:1)=Rt

0

1

0

0

0

0

0

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

if (Pv)
v memh(Rs+#u6:1)=Rt.H

0

1

0

0

0

0

1

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(Pv.new)
v ifmemh(Rs+#u6:1)=Rt

0

1

0

0

0

0

1

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(Pv.new)
v ifmemh(Rs+#u6:1)=Rt.H

0

1

0

0

0

1

0

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

if (!Pv)
v memh(Rs+#u6:1)=Rt

80-N2040-46 Rev. B

320

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

0

1

0

0

0

1

0

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (!Pv)
memh(Rs+#u6:1)=Rt.H

0

1

0

0

0

1

1

0

0

1

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (!Pv.new)
memh(Rs+#u6:1)=Rt

0

1

0

0

0

1

1

0

0

1

1

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

v

if (!Pv.new)
memh(Rs+#u6:1)=Rt.H

if (Pv)
memh(Rx++#s4:1)=Rt

ICLASS

Amode

U
N

Type

x5

Parse

t5

1

0

1

0

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

0

v

v

1

0

1

0

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

1

v

v if (!Pv)
memh(Rx++#s4:1)=Rt

1

0

1

0

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v

if (Pv.new)
memh(Rx++#s4:1)=Rt

1

0

1

0

1

0

1

1

0

1

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v

if (!Pv.new)
memh(Rx++#s4:1)=Rt

1

0

1

0

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

0

v

if (Pv)
v memh(Rx++#s4:1)=Rt.H

1

0

1

0

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

1

v

(!Pv)
v ifmemh(Rx++#s4:1)=Rt.H

1

0

1

0

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memh(Rx++#s4:1)=Rt.H

1

0

1

0

1

0

1

1

0

1

1

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemh(Rx++#s4:1)=Rt.H

ICLASS

Amode

U
N

Type

Parse

t5

1

0

1

0

1

1

1

1

0

1

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv) memh(#u6)=Rt

1

0

1

0

1

1

1

1

0

1

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memh(#u6)=Rt

1

0

1

0

1

1

1

1

0

1

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv.new) memh(#u6)=Rt

1

0

1

0

1

1

1

1

0

1

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv.new) memh(#u6)=Rt

1

0

1

0

1

1

1

1

0

1

1

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv) memh(#u6)=Rt.H

1

0

1

0

1

1

1

1

0

1

1

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memh(#u6)=Rt.H

1

0

1

0

1

1

1

1

0

1

1

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memh(#u6)=Rt.H

1

0

1

0

1

1

1

1

0

1

1

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemh(#u6)=Rt.H

Field name
ICLASS
Type
PredNew
Sense
Parse
s5
t5
u5
v2
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x
Amode
Type
Unsigned

321

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Release
The release memory operation is observed after all preceding memory operations have
been observed at the local point of serialization. A different order may be observed at the
global point of serialization. (see Ordering and Synchronization). No data is modified by
this instruction.
When the :st (same thread) option is specified, the preceding memory operations are those
that precede this instruction in program order.
When the :at (all threads) option is specified, the preceding memory operations are those
that were committed on any thread before this instruction was committed.
The Store release address is limited to certain memory regions. The following are
excluded memory regions: AHB memory space, AXI M2 memory space, Hexagon
memory cut-out is excluded with the exception of addressible TCM and VTCM memory,
and memory with the CCCC types 2, 3, or 4 are excluded.
Syntax

Behavior

release(Rs):at

EA=Rs;
*EA = Rs

release(Rs):st

EA=Rs;
*EA = Rs

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

Parse

8

7

6

5

4

3

2

t5

1

0
d2

1

0

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

0

0

1

1

d

d release(Rs):at

1

0

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

1

0

1

1

d

d release(Rs):st

Field name
ICLASS
Parse
d2
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

322

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store word
Store a 32-bit register in memory at the effective address.
Syntax

Behavior

memw(Re=#U6)=Rt

apply_extension(#U);
EA=#U;
*EA = Rt;
Re=#U;

memw(Rs+#s11:2)=Rt

apply_extension(#s);
EA=Rs+#s;
*EA = Rt;

memw(Rs+#u6:2)=#S8

EA=Rs+#u;
apply_extension(#S);
*EA = #S;

memw(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
*EA = Rt;

memw(Ru<<#u2+#U6)=Rt

apply_extension(#U);
EA=#U+(Ru<<#u);
*EA = Rt;

memw(Rx++#s4:2)=Rt

EA=Rx;
Rx=Rx+#s;
*EA = Rt;

memw(Rx++#s4:2:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,#s,MuV);
*EA = Rt;

memw(Rx++I:circ(Mu))=Rt

EA=Rx;
Rx=Rx=circ_add(Rx,I<<2,MuV);
*EA = Rt;

memw(Rx++Mu)=Rt

EA=Rx;
Rx=Rx+MuV;
*EA = Rt;

memw(Rx++Mu:brev)=Rt

EA=Rx.h[1] | brev(Rx.h[0]);
Rx=Rx+MuV;
*EA = Rt;

memw(gp+#u16:2)=Rt

apply_extension(#u);
EA=(Constant_extended ? (0) : GP)+#u;
*EA = Rt;

Class: ST (slots 0,1)
Intrinsics

80-N2040-46 Rev. B

memw(Rx++#s4:2:circ(Mu))=Rt

void Q6_memw_IMR_circ(void** StartAddress,
Word32 Is4_2, Word32 Mu, Word32 Rt, void*
BaseAddress)

memw(Rx++I:circ(Mu))=Rt

void Q6_memw_MR_circ(void** StartAddress, Word32
Mu, Word32 Rt, void* BaseAddress)

323

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

0

1

s5
1

1

0

1

1

1

0

0

s

s

ICLASS
0

0

1

1

0

1

0

1

0

1

1

0

-

1

0
0

1
1

0

0

1

0
0

0

1

0

-

0

1

0

1

0

i

i

1
1

0

0

0

0

1

0

1

0

1

0

1

1

ICLASS

1

1

0

0

0

s

s

s

1

0

1

1

1

1

0

1

0

1

0

Amode

1

0

0

s

s

s

s

0
0

0

0

0

i

i

i

s

x
x

x
x

x
x

s

s

u

u

P

P

I

i

i

e

e

x
x

x
x

x

x

e

e

u

u

P

i

t

t

4

3

2

1

0

t5

u

u

u

i

-

-

t

t

t

t

t

memw(Rs+Ru<<#u2)=Rt

i

i

i

i

I

I

I

I

I

I

I

memw(Rs+#u6:2)=#S8

t

t

i

i

i

i

i

i

i

i

memw(gp+#u16:2)=Rt

P

P

t

t

i

i

i

i

i

i

i

i

memw(Rs+#s11:2)=Rt

P
P

P

t

t

0

-

-

-

-

-

1

-

memw(Rx++I:circ(Mu))=Rt

P

P

x

x

P

i

t

t

u
u

u

x5

P

t
t

t
t

t
t

t

t

0

i

i

i

i

-

0

-

memw(Rx++#s4:2:circ(Mu)
)=Rt

t

t

1

-

I

I

I

I

I

I

memw(Re=#U6)=Rt

t

t

0

i

i

i

i

-

0

-

memw(Rx++#s4:2)=Rt

t

t

1

i

I

I

I

I

I

I

memw(Ru<<#u2+#U6)=Rt

t5

P 0

t

t

t
t5

P 0

P

t
t5

t

t

Parse
u

t
t5

Parse

u5
u

P

Parse

x5
x

5

t5

Parse u1

e5
e

6

u5
i

Parse

x5

U
N

Type

P

7

Parse

s5

U
N

Type
1

i

U
N

Type
1

i

U
N

Type
1

0

U
N
0

P

Parse

U
N

Type

Amode
0

1
Type

Amode

ICLASS
1

i

Amode

ICLASS
1

i

Amode

ICLASS
1

1

Amode

ICLASS
1

s

Type

ICLASS
1

Parse
s

s5

ICLASS
0

s

8

t
t5

i

t

t

Parse u1

t
t5

1

0

1

0

1

1

0

1

1

0

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memw(Rx++Mu)=Rt

1

0

1

0

1

1

1

1

1

0

0

x

x

x

x

x

P

P

u

t

t

t

t

t

0

-

-

-

-

-

-

-

memw(Rx++Mu:brev)=Rt

Field name
ICLASS
Type
Parse
e5
s5
t5
u1
u5
x5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register u
Field to encode register x
Amode
Type
Unsigned

324

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store-release word
Store a 32-bit register in memory at the effective address. The store-release memory
operation is observed after all preceding memory operations have been observed at the
local point of serialization. A different order may be observed at the global point of
serialization. (see Ordering and Synchronization).
When the :st (same thread) option is specified, the preceding memory operations are those
that precede this instruction in program order.
When the :at (all threads) option is specified, the preceding memory operations are those
that were committed on any thread before this instruction was committed.
The Store release address is limited to certain memory regions. The following are
excluded memory regions: AHB memory space, AXI M2 memory space, Hexagon
memory cut-out is excluded with the exception of addressible TCM and VTCM memory,
and memory with the CCCC types 2, 3, or 4 are excluded.
Syntax

Behavior

memw_rl(Rs):at=Rt

EA=Rs;
*EA = Rt

memw_rl(Rs):st=Rt

EA=Rs;
*EA = Rt

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

Parse

8

7

6

5

4

3

2

t5

1

0
d2

1

0

1

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

0

0

1

0

d

d memw_rl(Rs):at=Rt

1

0

1

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

1

0

1

0

d

d memw_rl(Rs):st=Rt

Field name
ICLASS
Parse
d2
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

325

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store word conditionally
Store a 32-bit register in memory at the effective address.
This instruction is conditional based on a predicate value. If the predicate is true, the
instruction is performed, otherwise it is treated as a NOP.

80-N2040-46 Rev. B

Syntax

Behavior

if ([!]Pv[.new]) memw(#u6)=Rt

apply_extension(#u);
EA=#u;
if ([!]Pv[.new][0]) {
*EA = Rt;
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rs+#u6:2)=#S6

EA=Rs+#u;
if ([!]Pv[.new][0]){
apply_extension(#S);
*EA = #S;
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rs+#u6:2)=Rt

apply_extension(#u);
EA=Rs+#u;
if ([!]Pv[.new][0]) {
*EA = Rt;
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rs+Ru<<#u2)=Rt

EA=Rs+(Ru<<#u);
if ([!]Pv[.new][0]) {
*EA = Rt;
} else {
NOP;
}

if ([!]Pv[.new])
memw(Rx++#s4:2)=Rt

EA=Rx;
if ([!]Pv[.new][0]){
Rx=Rx+#s;
*EA = Rt;
} else {
NOP;
}

326

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: ST (slots 0,1)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

u5

2

1

0

t5

0

0

1

1

0

1

0

0

1

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv)
memw(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

0

1

1

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv)
memw(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

0

1

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (Pv.new)
memw(Rs+Ru<<#u2)=Rt

0

0

1

1

0

1

1

1

1

0

0

s

s

s

s

s

P

P

i

u

u

u

u

u

i

v

v

t

t

t

t

t

if (!Pv.new)
memw(Rs+Ru<<#u2)=Rt

ICLASS

s5

Parse

0

0

1

1

1

0

0

0

0

1

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv)
memw(Rs+#u6:2)=#S6

0

0

1

1

1

0

0

0

1

1

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv)
memw(Rs+#u6:2)=#S6

0

0

1

1

1

0

0

1

0

1

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (Pv.new)
memw(Rs+#u6:2)=#S6

0

0

1

1

1

0

0

1

1

1

0

s

s

s

s

s

P

P

I

i

i

i

i

i

i

v

v

I

I

I

I

I

if (!Pv.new)
memw(Rs+#u6:2)=#S6

Pr
Se ed
ns Ne
e w

ICLASS

Type

s5

Parse

t5

0

1

0

0

0

0

0

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(Pv)
v ifmemw(Rs+#u6:2)=Rt

0

1

0

0

0

0

1

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

if (Pv.new)
v memw(Rs+#u6:2)=Rt

0

1

0

0

0

1

0

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(!Pv)
v ifmemw(Rs+#u6:2)=Rt

0

1

0

0

0

1

1

0

1

0

0

s

s

s

s

s

P

P

i

t

t

t

t

t

i

i

i

i

i

0

v

(!Pv.new)
v ifmemw(Rs+#u6:2)=Rt

ICLASS

Amode

U
N

Type

x5

Parse

t5

1

0

1

0

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

0

v

(Pv)
v ifmemw(Rx++#s4:2)=Rt

1

0

1

0

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

0

i

i

i

i

1

v

if (!Pv)
v memw(Rx++#s4:2)=Rt

1

0

1

0

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

if (Pv.new)
v memw(Rx++#s4:2)=Rt

1

0

1

0

1

0

1

1

1

0

0

x

x

x

x

x

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

(!Pv.new)
v ifmemw(Rx++#s4:2)=Rt

ICLASS

Amode

U
N

Type

Parse

t5

1

0

1

0

1

1

1

1

1

0

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv) memw(#u6)=Rt

1

0

1

0

1

1

1

1

1

0

0

-

-

-

i

i

P

P 0

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv) memw(#u6)=Rt

1

0

1

0

1

1

1

1

1

0

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

0

v

v if (Pv.new) memw(#u6)=Rt

1

0

1

0

1

1

1

1

1

0

0

-

-

-

i

i

P

P 1

t

t

t

t

t

1

i

i

i

i

1

v

v if (!Pv.new) memw(#u6)=Rt

Field name
ICLASS
Type
PredNew
Sense
Parse

80-N2040-46 Rev. B

Description
Instruction Class
Type
PredNew
Sense
Packet/Loop parse bits

327

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
u5
v2
x5
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register v
Field to encode register x
Amode
Type
Unsigned

328

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Allocate stack frame
Allocate a stack frame on the call stack. This instruction first pushes LR and FP to the top
of stack. It then subtracts an unsigned immediate from SP to allocate room for local
variables. FP is set to the address of the old frame pointer on the stack.
The following figure shows the stack layout.
Stack in Memory
Saved LR
Saved FP

Higher Address
Procedure Local
Data on Stack
Stack frame

Saved LR
Saved FP

FP register

Procedure Local
Data on Stack
SP register

Lower Address

Unallocated Stack

80-N2040-46 Rev. B

Syntax

Behavior

allocframe(#u11:3)

Assembler mapped to:
"allocframe(r29,#u11:3):raw"

allocframe(Rx,#u11:3):raw

EA=Rx+-8;
*EA = frame_scramble((LR << 32) | FP);
FP=EA;
frame_check_limit(EA-#u);
Rx = EA-#u;

329

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: ST (slots 0)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

0

0

0

U
N

Type
0

1

0

Field name
ICLASS
Parse
x5
Amode
Type
UN

80-N2040-46 Rev. B

0

x5
x

x

x

8

7

6

5

4

3

2

1

0

i

i

i

i

i

i

i

i

i

Parse
x

x

P

P 0

0

0

i

i

allocframe(Rx,#u11:3):raw

Description
Instruction Class
Packet/Loop parse bits
Field to encode register x
Amode
Type
Unsigned

330

Hexagon V68 Programmer’s Reference Manual

11.9

Instruction Set

SYSTEM
The SYSTEM instruction class includes instructions for managing system resources.

11.9.1

SYSTEM/GUEST
The SYSTEM/GUEST instruction subclass includes instructions for Guest mode.

Guest control register transfer
These instructions move registers between the guest control and general register files.
The following figure shows the guest control registers and their register field encodings.
Registers can be moved as singles or as aligned 64-bit pairs.
G0
G1
G2
G3

0
1
2
3

16

ISDBMBXIN

17

ISDBMBXOUT

Reserved

Reserved

15

24

GPCYCLELO

25

GPCYCLEHI

26

GPMUCNT0

27

GPMUCNT1

28

GPMUCNT2

29

GPMUCNT3

30

Reserved

31

Reserved

Syntax

Behavior

Gd=Rs

Gd=Rs;

Gdd=Rss

Gdd=Rss;

Rd=Gs

Rd=Gs;

Rdd=Gss

Rdd=Gss;

Class: SYSTEM (slot 3)
Notes
■

80-N2040-46 Rev. B

This is a guest-level feature. If performed in User mode, a privilege error
exception occurs.

331

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

1

0

0

0

1

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Gd=Rs

0

1

1

0

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Gdd=Rss

0

1

1

0

1

0

0

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rdd=Gss

0

1

1

0

1

0

1

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=Gs

Field name
sm
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

332

Hexagon V68 Programmer’s Reference Manual

11.9.2

Instruction Set

SYSTEM/MONITOR
The SYSTEM/MONITOR instruction subclass includes instructions for Monitor mode.

Clear interrupt auto disable
Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
For bits set in Rs, the corresponding bit in IAD is cleared. This re-enables the interrupt.
For bits cleared in Rs, the corresponding bit in IAD is unaffected.
Syntax

Behavior

ciad(Rs)

IAD &= ~Rs;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

0

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

1

1

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

ciad(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

333

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Swap SGP control register
CRSWAP swaps the contents of a general register with one of the Supervisor General
Pointer registers, either SGP0 or SGP1.
For example, these registers can hold a supervisor or exception stack pointer, or other
general pointers for fast exception processing. A pair swap form exists to swap both SGP
registers with an align ed pair of general registers.
Syntax

Behavior

crswap(Rx,sgp)

Assembler mapped to: "crswap(Rx,sgp0)"

crswap(Rx,sgp0)

tmp = Rx;
Rx = SGP0;
SGP0 = tmp;

crswap(Rx,sgp1)

tmp = Rx;
Rx = SGP1;
SGP1 = tmp;

crswap(Rxx,sgp1:0)

tmp = Rxx;
Rxx=SGP;
SGP = tmp;

Class: SYSTEM (slot 3)
Notes
■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

x5

8

7

6

5

4

3

2

1

0

Parse

0

1

1

0

0

1

0

1

0

0

0

x

x

x

x

x

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

0

1

1

0

0

1

0

1

0

0

1

x

x

x

x

x

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

crswap(Rx,sgp1)

0

1

1

0

1

1

0

1

1

0

-

x

x

x

x

x

P

P

-

-

-

-

-

-

-

-

-

0

0

0

0

0

crswap(Rxx,sgp1:0)

Field name
sm
ICLASS
Parse
x5

80-N2040-46 Rev. B

crswap(Rx,sgp0)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register x

334

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Cancel pending interrupts
Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
CSWI cancels any pending interrupts indicated in the mask by clearing the interrupt from
the IPEND register.
Syntax

Behavior

cswi(Rs)

IPEND &= ~Rs;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

0

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

1

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

cswi(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

335

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Data cache kill
DCKILL invalidates the entire contents of the data cache. On power-up, the caches are not
guaranteed to contain valid data.
This instruction establishes an initial clean cache state. All dirty data in the data cache that
has not yet been written back to memory is lost when DCKILL is executed. Clean out data
to save using DCLEAN instructions before executing DCKILL.
Because the caches are shared between all threads, perform this instruction only while
ensuring that no other thread is using the caches. The best option is using this instruction
when only one thread is powered on and others are powered off.
Syntax

Behavior

dckill

dcache_inv_all();

Class: SYSTEM (slots 0)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

0

0

1

U
N

Type
0

0

0

Field name
ICLASS
Parse
Amode
Type
UN

80-N2040-46 Rev. B

0

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

Parse
-

-

-

-

-

P

P

-

-

-

-

-

dckill

Description
Instruction Class
Packet/Loop parse bits
Amode
Type
Unsigned

336

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Data cache maintenance monitor instructions
Perform maintenance operations on the data cache.
DCCLEANINVIDX looks at index Rs in the data cache. If this line has dirty data, the data
is flushed out to memory. The line is invalidated. The set is provided in Rs[10:5] and the
way in Rs[1:0]. This instruction can only be grouped with X-type or A-type instructions.
DCCLEANIDX looks at index Rs in the data cache. If this line has dirty data, the data is
flushed out to memory. The set is provided in Rs[10:5] and the way in Rs[1:0]. This
instruction can only be grouped with X-type or A-type instructions.
DCINVIDX invalidates the line at index Rs. The set is provided in Rs[10:5] and the way
in Rs[1:0]. This instruction can only be grouped with X-type or A-type instructions.
DCTAGR reads the tag at indicated by Rs and returns the data into Rd. The set is provided
Rs[10:5], and the Way is provided in Rs[1:0]. The tag is returned in Rd[23:0], and the state
is returned in Rd[30:29]. This instruction can only be grouped with X-type or A-type
instructions.
DCTAGW uses register Rs and Rt. Register Rs contains the set in [10:5] and way in [1:0]
while the Rt value contains the Tag in [23:0] and the state in [30:29]. For WT D$, dctagw
that writes state=2'b11 is mapped to 2'b01. The DCTAGW instruction is single-thread
only. All other threads must be in Stop or Debug mode with no outstanding transactions.
This instruction is SOLO and must not appear in a packet with other instructions.
The state bits are encoded as follows:
00 = Invalid
01 = Valid & clean
10 = Reserved
11 = Not used for WT D$
Syntax

Behavior

Rd=dctagr(Rs)

dcache_tag_read(Rs);

dccleanidx(Rs)

dcache_clean_idx(Rs);

dccleaninvidx(Rs)

dcache_cleaninv_idx(Rs);

dcinvidx(Rs)

dcache_inv_idx(Rs);

dctagw(Rs,Rt)

dcache_tag_write(Rs,Rt);

Class: SYSTEM (slots 0)
Notes
■

80-N2040-46 Rev. B

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

337

Hexagon V68 Programmer’s Reference Manual

Instruction Set

■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

2

1

0

Parse

1

0

1

0

0

0

1

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dccleanidx(Rs)

1

0

1

0

0

0

1

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dcinvidx(Rs)

1

0

1

0

0

0

1

0

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dccleaninvidx(Rs)

t

t

-

-

-

-

-

-

-

-

dctagw(Rs,Rt)

d

d Rd=dctagr(Rs)

ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

Type
0

Amode
0

0

1

0

U
N

0

0

0

0

Field name
ICLASS
Parse
d5
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

s

s

U
N

Type
0

0

s5

1

s

Parse
s

s

s5
s

s

s

P

P

t5
-

t

t

t

Parse
s

s

P

P

d5
-

-

-

-

-

-

-

-

-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

338

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Read the interrupt mask for a thread
Each thread contains an IMASK register that holds the interrupt enable/disable for
individual interrupts 0-31.
GETIMASK reads the IMASK for the thread indicated by the low bits of Rs. The result is
returned in Rd. For Rs values outside of [0-NUM_THREADS-1], the results are
undefined.
Syntax

Behavior

Rd=getimask(Rs)

Rd = IMASK[Rs & thread->processor_ptr>thread_system_mask];

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

1

0

0

0

Field name
sm
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

Parse
s

s

P

P

2

1

0

d

d Rd=getimask(Rs)

d5
-

-

-

-

-

-

-

-

-

d

d

d

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

339

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Acquire hardware lock
If the lock bit is set, sleep until the lock bit is clear. The packet with the lock instruction
only completes once the lock is set and acquired by this thread. When multiple threads are
waiting for the lock, the hardware guarantees round-robin fairness such that no thread is
starved.
TLBLOCK is acquired automatically whenever a thread raises a TLB miss-RW or TLBmiss-X exception.
Syntax

Behavior

k0lock

if (can_aquire_k0_lock) {
SYSCFG.K0LOCK = 1;
} else {
sleep_until_available;
}

tlblock

if (can_aquire_tlb_lock) {
SYSCFG.TLBLOCK = 1;
} else {
sleep_until_available;
}

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

8

7

6

5

4

3

2

1

0

Parse

0

1

1

0

1

1

0

0

0

0

1

-

-

-

-

-

P

P

-

-

-

-

-

-

0

0

1

-

-

-

-

-

tlblock

0

1

1

0

1

1

0

0

0

0

1

-

-

-

-

-

P

P

-

-

-

-

-

-

0

1

1

-

-

-

-

-

k0lock

Field name
sm
ICLASS
Parse

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits

340

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Release hardware lock
This instruction releases a hardware lock.
Syntax

Behavior

k0unlock

SYSCFG.K0LOCK = 0;

tlbunlock

SYSCFG.TLBLOCK = 0;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

8

7

6

5

4

3

2

1

0

Parse

0

1

1

0

1

1

0

0

0

0

1

-

-

-

-

-

P

P

-

-

-

-

-

-

0

1

0

-

-

-

-

-

tlbunlock

0

1

1

0

1

1

0

0

0

0

1

-

-

-

-

-

P

P

-

-

-

-

-

-

1

0

0

-

-

-

-

-

k0unlock

Field name
sm
ICLASS
Parse

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits

341

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Interrupt to thread assignment read
Each thread contains an IMASK register that holds the interrupt enable/disable for
individual interrupts 0-31.
For a given interrupt, IASSIGNR reads the corresponding bit in the IMASK register of
each thread. The upper halfword of source register Rs contains the interrupt number from
0-31 (0 is the highest priority interrupt, 31 the lowest). The low bits of the destination
register Rd contain a bit mask where bit 0 contains the corresponding IMASK value for
thread 0, bit 1 the value for thread 1, etc.
The number of defined bits depends on the number of hardware threads provided in the
core. All bits beyond the number of threads provided are cleared. For example, if the
interrupt number is set to 0, Rd[0] is the value of IMASK[0] for thread 0, Rd[1] is the
value of IMASK[0] for thread 1, etc.
31

16 15

0

Int#

Rs

Interrupt number [0-31]
0=highest priority
interrupt
31=lowest priority

31

0

Rd

Thread 0:
Value of IMASK[int#]

Thread 5 assignment
Syntax

Behavior

Rd=iassignr(Rs)

Rd=IASSIGNR(Rs);

Class: SYSTEM (slot 3)
Notes
■

80-N2040-46 Rev. B

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

342

Hexagon V68 Programmer’s Reference Manual

■

Instruction Set

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

1

0

0

1

Field name
sm
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

1

s

s

s

8

7

6

5

4

3

Parse
s

s

P

P

2

1

0

d

d Rd=iassignr(Rs)

d5
-

-

-

-

-

-

-

-

-

d

d

d

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

343

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Interrupt to thread assignment write
Each thread contains an IMASK register that holds the interrupt enable/disable for
individual interrupts 0-31.
For a given interrupt, IASSIGNW sets or clears the corresponding bit the IMASK register
of each thread. This allows for easy reassignment of interrupts to selected threads.
Source register Rs contains two fields. The upper halfword contains the interrupt number
from 0-31 (0 is the highest priority interrupt, 31 the lowest). The low bits contain a bit
mask where bit 0 contains the corresponding IMASK value for thread 0, bit 1 the value for
thread 1, etc. For example, if the interrupt number is set to 0, and the bit mask is set to
0x03, the IMASK[0] for threads 0 and 1 is set and the IMASK[0] for all other threads is
cleared. This means that threads 0 and 1 do not accept this interrupt, whereas other threads
do accept it.
31

16 15

0

Int#

Rs
Thread 0 assignment:
1=Set Thread0:IMASK[Int#]
(interrupt disabled)

Interrupt number [0-31]
0=highest priority
interrupt
31=lowest priority

0=Clear Thread0:IMASK[Int#]
(interrupt enabled for T0)
Thread 5 assignment

Syntax

Behavior

iassignw(Rs)

IASSIGNW(Rs);

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

1

80-N2040-46 Rev. B

s5
0

0

0

0

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

1

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

iassignw(Rs)

344

Hexagon V68 Programmer’s Reference Manual

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

Instruction Set

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

345

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Instruction cache maintenance supervisor operations
Perform maintenance operations on the instruction cache.
ICTAGR reads the tag at set Rs[12:5] for 32 Kb I$ or Rs[11:5] for 16 Kb I$, and way
Rs[0]. The tag value is returned in Rd[31:10] for 32k caches, or Rd[31:9] for 16k caches.
The Valid bit in Rs[1], and the Reserved bit in Rd[0].
ICDATAR reads the data word at set Rs[13:5], word Rs[4:2], and way Rs[0]. The data
value is returned in Rd[31:0].
ICINVIDX invalidates the instruction cache index indicated by Rs[13:6] for 32 Kb I$ and
Rs[12:6] for 16 Kb I$.
Syntax

Behavior

Rd=icdatar(Rs)

icache_data_read(Rs);

Rd=ictagr(Rs)

icache_tag_read(Rs);

icinvidx(Rs)

icache_inv_idx(Rs);

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

8

7

6

5

4

3

Parse

2

1

0

d5

0

1

0

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=icdatar(Rs)

0

1

0

1

0

1

0

1

1

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=ictagr(Rs)

1

0

1

1

0

1

1

0

s

s

s

s

P 0

0

1

-

-

-

-

-

-

-

-

-

-

-

ICLASS
0

1

0

s5

Field name
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

s

Parse
P

icinvidx(Rs)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

346

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Instruction cache maintenance operations (single-thread)
Perform maintenance operations on the instruction cache.
ICKILL invalidates the instruction cache.
ICTAGW updates specified tag entry with contents of Rt. Rs[13:5] for 32 Kb I$ or
Rs[12:5] for 16 Kb I$ selects index and Rs[0] selects cache way. Rt must have the Tag
information in bits 20:0 for 32 Kb I$ or 21:0 for 16 Kb I$, the Valid bit in Rt[30] and the
Reserved bit in Rt[31].
ICDATAW is available only on cores that support ECC.
These instructions are single-thread only. All other threads must be in Stop or Debug mode
with no outstanding transactions.
Syntax

Behavior

icdataw(Rs,Rt)

icache_data_write(Rs,Rt);

ickill

icache_inv_all();

ictagw(Rs,Rt)

icache_tag_write(Rs,Rt);

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

s5

Parse

8

7

6

5

4

3

2

1

0

t5

0

1

0

1

0

1

0

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

-

-

-

-

-

-

ictagw(Rs,Rt)

0

1

0

1

0

1

0

1

1

1

0

s

s

s

s

s

P

P 1

t

t

t

t

t

-

-

-

-

-

-

-

-

icdataw(Rs,Rt)

1

0

-

-

-

-

-

-

-

-

-

-

-

ickill

ICLASS
0

1

0

Parse
1

0

1

1

0

1

1

Field name
ICLASS
Parse
s5
t5

80-N2040-46 Rev. B

0

-

-

-

-

-

P

P 0

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

347

Hexagon V68 Programmer’s Reference Manual

Instruction Set

L2 cache operations by index
These instructions operate on a specified line in L2 cache.
The clean operation pushed dirty data out to the system. The invalidate operation marks
the line as invalidate, and the cleaninv operation first cleans the line and then invalidates
it.
The index is provided in Rs[S:8] and the way is in Rs[2:0], where the number of sets in the
L2 cache determines S. For segmented L2 caches, the granule bit is provided in Rs[3].
This bit is ignored if the cache is not segmented.
Different versions of Hexagon can have different L2 cache sizes. For more information,
see the section on Core Versions.
Syntax

Behavior

l2cleanidx(Rs)

l2cache_clean_idx(Rs);

l2cleaninvidx(Rs)

l2cache_clean_invalidate_idx(Rs);

l2invidx(Rs)

l2cache_inv_idx(Rs);

Class: SYSTEM (slots 0)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

2

1

0

Parse

1

0

1

0

0

1

1

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

l2cleanidx(Rs)

1

0

1

0

0

1

1

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

l2invidx(Rs)

1

0

1

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

l2cleaninvidx(Rs)

Field name
ICLASS
Parse
s5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Amode
Type
Unsigned

348

Hexagon V68 Programmer’s Reference Manual

Instruction Set

L2 cache global operations
Performs maintenance operations over the entire L2 cache.
The instructions commit and set the SYSCFG:L2GCA bit to indicate that the Global
Cache state machine is Active. Once the state machine is started, it processes every L2
cache line in the background. After all cache lines have been processed, the
SYSCFG:L2GCA status bit is cleared.
L2KILL invalidates every line. This instruction must execute prior to using L2 after a
power-on reset, as the cache starts in an unknown state.
L2GCLEAN forces a clean (flush) operation for all dirty L2 cache lines.
L2GCLEANINV forces a clean (flush) for dirty L2 lines and then invalidates them.
L2GUNLOCK clears the lock bit for all L2 cache lines.
The L2GCLEAN and L2GCLEANINV are available with PA range and mask option. In
this form, the Rtt register contains a mask in the lower word and match value in the upper
word. If the Physical Page Number of the cache line AND’d with the mask is equal to the
match value, perform the cache operation. Otherwise, the cache line remains unchanged.
For every cache line in L2, the semantics are: if (Rtt[23:0] & PA[35:12]) == Rtt[55:32]),
do clean/cleaninv on the cache line.
Syntax

Behavior

l2gclean

l2cache_global_clean();

l2gclean(Rtt)

l2cache_global_clean_range(Rtt);

l2gcleaninv

l2cache_global_clean_inv();

l2gcleaninv(Rtt)

l2cache_global_clean_inv_range(Rtt);

l2gunlock

l2cache_global_unlock();

l2kill

l2cache_inv_all();

Class: SYSTEM (slots 0)
Notes

80-N2040-46 Rev. B

■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

349

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

Parse

8

7

6

5

4

3

2

1

0

t5

1

0

1

0

0

1

1

0

1

0

1

-

-

-

-

-

P

P

-

t

t

t

t

t

-

-

-

-

-

-

-

-

l2gclean(Rtt)

1

0

1

0

0

1

1

0

1

1

0

-

-

-

-

-

P

P

-

t

t

t

t

t

-

-

-

-

-

-

-

-

l2gcleaninv(Rtt)

-

0

0

0

-

-

-

-

-

-

-

-

-

-

l2kill

ICLASS
1

0

1

Amode
0

1

0

0

U
N

Type
0

0

0

1

Parse
-

-

-

-

-

P

P

1

0

1

0

1

0

0

0

0

0

1

-

-

-

-

-

P

P

-

0

1

0

-

-

-

-

-

-

-

-

-

-

l2gunlock

1

0

1

0

1

0

0

0

0

0

1

-

-

-

-

-

P

P

-

1

0

0

-

-

-

-

-

-

-

-

-

-

l2gclean

1

0

1

0

1

0

0

0

0

0

1

-

-

-

-

-

P

P

-

1

1

0

-

-

-

-

-

-

-

-

-

-

l2gcleaninv

Field name
ICLASS
Parse
t5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register t
Amode
Type
Unsigned

350

Hexagon V68 Programmer’s Reference Manual

Instruction Set

L2 cache operations by address
L2locka first allocates a line in L2 based on the address provided in Rs. It then sets the
lock bit so the line is not replaced in the future, unless explicitly unlocked. A fetch is
initiated for the data. Finally, the instruction returns a status result to the destination
predicate.
The predicate is set to 0xff if the operation was successful, or 0x00 if the operation did not
succeed. The failure state can be returned either because all the L2 cache ways are already
locked, or because of some internal transient conditions. The software should resolve
transient conditions by retrying L2locka with a large number of attempts (1000
recommended).
The L2unlocka instruction clears the lock bit on an L2 cache line that holds the provided
address.
Syntax

Behavior

Pd=l2locka(Rs)

EA=Rs;
Pd=l2locka(EA);

l2unlocka(Rs)

EA=Rs;
l2unlocka(EA);

Class: SYSTEM (slots 0)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

The predicate generated by this instruction cannot be used as a .new predicate, nor
can it be automatically AND’d with another predicate.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

0

0

Type
0

Amode
0

0

1

1

U
N

1

1

0

1

Field name
ICLASS
Parse
d2
s5

80-N2040-46 Rev. B

s

s

U
N

Type
0

1

s5

1

s

s

s

7

6

5

4

3

2

1

Parse
s

s

s5
s

8

P

0
d2

P 1

-

-

-

-

-

-

-

-

-

-

-

d

d Pd=l2locka(Rs)

-

-

-

-

-

-

-

-

-

-

-

-

-

Parse
s

s

P

P

-

l2unlocka(Rs)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

351

Hexagon V68 Programmer’s Reference Manual

Field name
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Amode
Type
Unsigned

352

Hexagon V68 Programmer’s Reference Manual

Instruction Set

L2 tag read/write
L2TAGR reads the tag as indicated by Rs and returns the data into Rd. This instruction can
be grouped with A-type and X-type instructions. The L2TAGW instruction should not be
group ed in a packet.
Register Rs is formatted as follows:
Rs[31:8] = Set
Rs[7:0] = Way

Return register Rd is formatted as follows:
Rd[31] = A1
Rd[30] = A0
Rd[28:8] = Tag address bits 35:15
Rd[4] = Lock bit
Rd[3] = Reserve bit
Rd[2:0] = State[2:0]

The state bits are defined as follows:
0 = Invalid
1,3 = Reserved
4 = Valid & Clean
6 = Valid & Dirty
Syntax

Behavior

Rd=l2tagr(Rs)

l2cache_tag_read(Rs);

l2tagw(Rs,Rt)

l2cache_tag_write(Rs,Rt);

Class: SYSTEM (slots 0)
Notes

80-N2040-46 Rev. B

■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

Results are undefined if a tag read or write addresses a non-present set or way.

■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

353

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

0

1

0

0

Amode
0

0

1

0

U
N

Type
0

1

0

1

Field name
ICLASS
Parse
d5
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

s

s

U
N

Type
0

0

s5

1

s

Parse
s

s

s5
s

s

s

P

8

7

6

5

4

3

2

1

0

t

-

-

-

-

-

-

-

-

d

d Rd=l2tagr(Rs)

t5

P 0

t

t

t

t

Parse
s

s

P

P

l2tagw(Rs,Rt)

d5
-

-

-

-

-

-

-

-

-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

354

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Load from physical address
MEMW_PHYS performs a word load using the 36-bit physical address held in source
registers Rt:Rs. Rs holds PA[10:0] and Rt holds PA[35:11] in the least-significant bits.
This instruction first looks in the L1 and L2 caches for the data. If found, the data is
returned. If the access misses in cache, it is treated as a non-allocating (uncached) load.
The hardware forces the two least-significant bits to zero, and thus never results in an
alignment violation.
The monitor software uses this instruction to walk Guest mode page tables, and for easier
debugging.
Syntax

Behavior

Rd=memw_phys(Rs,Rt)

Rd = *((Rs&0x7ff) | (Rt<<11));

Class: SYSTEM (slots 0)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

0

0

1

U
N

Type
0

0

0

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5
t5

80-N2040-46 Rev. B

0

s5
s

s

s

Parse
s

s

P

P 1

8

7

6

5

4

3

t5
t

t

t

2

1

0

d

d Rd=memw_phys(Rs,Rt)

d5
t

t

-

0

0

d

d

d

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

355

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Raise NMI on threads
The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
of defined bits depends on the how many hardware threads are supported.
NMI raises a non-maskable NMI interrupt for all threads specified in the mask. This
interrupt causes the thread jump to the NMI vector at the address specified in EVB.
Syntax

Behavior

nmi(Rs)

Raise NMI on threads;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

1

s

s

s

8

7

6

5

4

3

2

1

0

-

0

1

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

nmi(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

356

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Resume from Wait mode
The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
of defined bits depends on the how many hardware threads are supported.
RESUME causes all threads specified in the mask which are in Wait mode to exit Wait
mode back to either Supervisor or User mode (whichever was active when the thread
entered Wait mode). If the thread to resume is off (Stop mode) or already running (User or
Supervisor mode), the resume instruction has no affect.
Syntax

Behavior

resume(Rs)

resume(Rs);

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

1

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

resume(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

357

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Return from exception
RTE returns from an interrupt or exception handler. This instruction clears the EX bit in
SSR and jumps to the location specified in the ELR register.
This instruction also clears the SYSCFG.TLBLOCK bit, thus releasing the TLB lock and
allowing other threads to acquire the lock if needed. RTE should never be grouped with
another exception-causing instruction. If RTE is grouped with any other instruction that
causes an exception, the behavior is undefined.
Syntax

Behavior

rte

SSR.SSR_EX = 0;
PC=ELR;

Class: SYSTEM (slot 2)
Notes
■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
1

0

1

1

1

1

1

Field name
ICLASS
Parse

80-N2040-46 Rev. B

1

-

-

-

-

-

P

P 0

0

-

-

-

rte

Description
Instruction Class
Packet/Loop parse bits

358

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Set the interrupt mask for a thread
Each thread contains an IMASK register that holds the interrupt enable/disable for
individual interrupts 0-31.
SETIMASK writes the IMASK for the thread indicated by the low bits of predicate Pt.
Register Rs contains the 32-bit mask value to write. For Pt values outside of [0NUM_THREADS-1], the results are undefined.
Syntax

Behavior

setimask(Pt,Rs)

PREDUSE_TIMING;
IMASK[Pt & thread->processor_ptr>thread_system_mask]=Rs;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

1

0

Field name
sm
ICLASS
Parse
s5
t2

80-N2040-46 Rev. B

0

s

s

s

Parse
s

s

P

P

8

7

6

5

4

3

2

1

0

t

0

0

0

-

-

-

-

-

t2
-

-

-

-

t

setimask(Pt,Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

359

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Set the priority for a thread
Each thread contains an STID register that holds the software thread id (STID) and the
priority (PRIO). This instruction writes the PRIO field for the thread indicated by the low
bits of predicate Pt. The register Rs contains the 32-bit mask value to write. For Pt values
outside of [0-NUM_THREADS-1], the results are undefined.
Syntax

Behavior

setprio(Pt,Rs)

PREDUSE_TIMING;
TID[Pt & thread->processor_ptr>thread_system_mask].PRIO=Rs;

Class: SYSTEM (slot 3)
Notes
■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

1

0

Field name
sm
ICLASS
Parse
s5
t2

80-N2040-46 Rev. B

0

s

s

s

Parse
s

s

P

P

8

7

6

5

4

3

2

1

0

t

0

0

1

-

-

-

-

-

t2
-

-

-

-

t

setprio(Pt,Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

360

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Set interrupt auto disable
Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
For bits set in Rs, the corresponding bit in IAD is set. This disables the interrupt. For bits
cleared in Rs, the corresponding bit in IAD is unaffected.
Syntax

Behavior

siad(Rs)

IAD |= Rs;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

1

0

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

1

1

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

siad(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

361

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Start threads
The low bits of Rs specify a thread mask, where bit 0 corresponds to thread 0. The number
of defined bits depends on the how many hardware threads are supported.
START raises a non-maskable software reset interrupt for all threads specified in the
mask. This interrupt causes the thread to clear all writable bits in the Supervisor Status
register and then jump to the start vector at the address specified in EVB. Typically,
START powers up threads after they have been disabled by the STOP instruction.
Syntax

Behavior

start(Rs)

start(Rs);

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

1

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

1

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

start(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

362

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Stop threads
STOP causes the calling thread to enter Stop mode.
Stop mode is a power-off mode where all register contents for that thread should be
assumed lost. The only way out of Stop mode is through a reset interrupt. The reset
interrupt can be from another thread executing the START instruction, or from an external
hardware reset signal.
The instruction does not use the source register Rs. It exists for backwards compatibility.
Syntax

Behavior

stop(Rs)

if (!in_debug_mode) modectl[TNUM] = 0;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

1

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

stop(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

363

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Software interrupt
Register Rs specifies a 32-bit mask, where bit 0 corresponds to the highest-priority
interrupt 0, and register bit 31 refers to the lowest-priority interrupt 31.
SWI raises the interrupts indicated in the mask. This instruction is provided so that threads
can very quickly interrupt one another.
Syntax

Behavior

swi(Rs)

IPEND |= Rs;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

0

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

swi(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

364

Hexagon V68 Programmer’s Reference Manual

Instruction Set

TLB read/write/probe operations
Manages the software programmable Translation Lookaside Buffer (TLB).
The TLB Read (TLBR) instruction returns the 64-bit TLB entry at the location specified in
register Rs. The result is written into the 64-bit destination register pair.
The TLB Write (TLBW) operation writes the 64-bit TLB entry specified by register Rt
with the contents of register pair Rss.
The TLB Probe (TLBP) operation looks up the TLB based on the virtual page number
contained in register Rs[19:0] together with the 7-bit ASID provided in Rs[26:20]. If the
entry is found and marked valid, its ind ex is placed in Rd, otherwise Rd is set to
0x8000_0000.
The TLB Invalidate ASID (TLBINVASID) instruction invalidates all TLB entries with the
Global bit NOT set and with the ASID matching the Rs[26:20] operand.
The Conditional TLB Write (CTLBW) instruction first checks if the new entry would
overlap the virtual address range of any other entry in the TLB. The overlap check
considers page size and ASID. In the overlap check, the Global bit of the incoming Rss
entry is forced to zero and the Valid bit is forced to 1. If there is no overlap, the entry is
written and the destination register is set to 0x8000_0000. Otherwise, if an overlap occurs,
no TLB entry is written and the index on the overlapping entry is placed in Rd. If multiple
entries overlap, the value 0xffff_ffff is returned.
The TLB Overlap Check (TLBOC) operation looks up the TLB based on the VPN, page
size, and ASID contained in register Rss (in the same format as TLBW). The overlap
check considers page size and ASID. In the overlap check, the Global bit of the incoming
Rss entry is forced to zero and the Valid bit is forced to 1. If the Rss entry overlaps virtual
address range of any another entry in the TLB, the index of the overlapping entry is placed
in Rd, otherwise Rd is set to 0x8000_0000. If multiple entries overlap, the value
0xffff_ffff is returned.
For both TLBOC and CTLBW, if the PPN[5:0] are all zero, the behavior is undefined.

80-N2040-46 Rev. B

Syntax

Behavior

Rd=ctlbw(Rss,Rt)

if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
Rd=GET_OVERLAPPING_IDX((1LL<<63) | Rss);
} else {
TLB[Rt] = Rss;
Rd=0x80000000;
}

Rd=tlboc(Rss)

if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {
Rd=GET_OVERLAPPING_IDX((1LL<<63) | Rss);
} else {
Rd=0x80000000;
}

Rd=tlbp(Rs)

Rd=search_TLB(Rs);

Rdd=tlbr(Rs)

Rdd = TLB[Rs];

365

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

tlbinvasid(Rs)

for (i = 0; i < NUM_TLB_ENTRIES; i++) {
if ((TLB[i].PTE_G == 0) && (TLB[i].PTE_ASID
== Rs[26:20])) {
TLB[i] = TLB[i] & ~(1ULL << 63);
}
}

tlbw(Rss,Rt)

TLB[Rt] = Rss;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

1

ICLASS
0
0

1

1

0

1

1

1

0

1

1

1

1

1

0

1

1

1

0

0

0

s

s

0

1

1

0

0

0

1

0

s

s

1

0

0

1

0

0

s

s

1

Parse
s

s

1

0

0

1

0

1

s

s

s

s

s

s

s

s

s

0

0

1

1

0

s

s

s

s

s

0

0

1

1

Field name
sm
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

1

s

s

s

5

4

3

t

-

-

-

-

-

2

1

0

-

-

-

t5

P 0

t

t

t

t

tlbw(Rss,Rt)

d5

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rdd=tlbr(Rs)

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=tlbp(Rs)

-

-

-

-

-

-

-

-

-

-

-

-

-

-

d

d Rd=ctlbw(Rss,Rt)

d

d Rd=tlboc(Rss)

P

P

Parse
s

s

s5

1

6

Parse

s5

1

P

7

Parse

s5

sm
0

s
s5

sm

ICLASS
0

0

sm

ICLASS
0

0

sm

ICLASS
0

s5

1

8

P

t5

P 0

t

t

t

t

t

-

-

-

d

d

Parse
s

s

P

P

tlbinvasid(Rs)

d5
d
d5

-

-

-

-

-

-

-

-

-

d

d

d

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

366

Hexagon V68 Programmer’s Reference Manual

Instruction Set

System control register transfer
Move data between supervisor control registers and general registers.
Registers can be moved as 32-bit singles or as 64-bit aligned pairs. The figure shows the
system control registers and their register field encodings.

0

SGP0

16

EVB

32

ISDBST

48

PMUCNT0

1

SGP1

17

MODECTL

33

ISDBCFG0

49

PMUCNT1

2

STID

18

SYSCFG

34

ISDBCFG1

50

PMUCNT2

3

ELR

19

-

35

-

51

PMUCNT3

4

BADVA0

20

IPEND

36

BRKPTPC0

52

PMUEVTCFG

5

BADVA1

21

VID

37

BRKPTCFG0

53

PMUCFG

6

SSR

22

IAD

38

BRKPTPC1

54

7

CCR

23

-

39

BRKPTCFG1

8

HTID

24

IEL

40

ISDBMBXIN

9

BADVA

25

-

41

ISDBMBXOUT

10

IMASK

26

IAHL

42

ISDBEN

27

CFGBASE

43

ISDBGPR

28

DIAG

29

REV

30

PCYCLELO

31

PCYCLEHI

Reserved

11

Reserved

15

Syntax

Behavior

Rd=Ss

Rd=Ss;

Rdd=Sss

Rdd=Sss;

Sd=Rs

Sd=Rs;

Sdd=Rss

Sdd=Rss;

Reserved

47

63

Class: SYSTEM (slot 3)
Notes
■

80-N2040-46 Rev. B

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

367

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

sm

s5

8

7

6

5

4

Parse

3

2

1

0

d7

0

1

1

0

0

1

1

1

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

-

d

d

d

d

d

d

d Sd=Rs

0

1

1

0

1

1

0

1

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

-

d

d

d

d

d

d

d Sdd=Rss

ICLASS

sm

s7

Parse

d5

0

1

1

0

1

1

1

0

1

s

s

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rd=Ss

0

1

1

0

1

1

1

1

0

s

s

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

d

d

d

d

d Rdd=Sss

Field name
sm
ICLASS
Parse
d5
d7
s5
s7

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register d
Field to encode register s
Field to encode register s

368

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Transition threads to Wait mode
WAIT causes the calling thread to enter Wait mode.
Wait mode is a low-power mode where the thread idles. The thread does not fetch or
execute instructions in Wait mode.
When a thread executes WAIT, the PC is set to the packet after the WAIT instruction.
To exit Wait mode, a waiting thread can either receive an interrupt, or another thread can
execute the RESUME instruction for the waiting thread. When a thread is woken up by an
interrupt, at the time the interrupt service routine completes and executes a RTE
instruction, the thread remains running.
The source register Rs is not used in the instruction. It exists for backwards compatibility.
Syntax

Behavior

wait(Rs)

if (!in_debug_mode) modectl[(TNUM+16)] = 1;
;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

1

0

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

wait(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

369

Hexagon V68 Programmer’s Reference Manual

11.9.3

Instruction Set

SYSTEM/USER
The SYSTEM/USER instruction subclass includes instructions that allow user access to
system resources.

Load locked
This memory lock instruction performs a word or double-word locked load.
This instruction returns the contents of the memory at address Rs and also reserves a lock
reservation at that address. For more information, see the section on Atomic Operations.
Syntax

Behavior

Rd=memw_locked(Rs)

EA=Rs;
Rd = *EA;

Rdd=memd_locked(Rs)

EA=Rs;
Rdd = *EA;

Class: SYSTEM (slots 0)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

Parse

2

1

0

d5

1

0

0

1

0

0

1

0

0

0

0

s

s

s

s

s

P

P 0

0

0

-

-

-

0

0

0

d

d

d

d

d Rd=memw_locked(Rs)

1

0

0

1

0

0

1

0

0

0

0

s

s

s

s

s

P

P 0

1

0

-

-

-

0

0

0

d

d

d

d

d Rdd=memd_locked(Rs)

Field name
ICLASS
Amode
Type
UN
Parse
d5
s5

80-N2040-46 Rev. B

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register d
Field to encode register s

370

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Store conditional
This memory lock instruction performs a word or double-word conditional store
operation.
If the address reservation is held by this thread and there have been no intervening
accesses to the memory location, the store is performed and the predicate is set to true.
Otherwise, the store is not performed and the predicate returns false. For more
information, see the section on Atomic Operations.
Syntax

Behavior

memd_locked(Rs,Pd)=Rtt

EA=Rs;
if (lock_valid) {
*EA = Rtt;
Pd = 0xff;
lock_valid = 0;
} else {
Pd = 0;
}

memw_locked(Rs,Pd)=Rt

EA=Rs;
if (lock_valid) {
*EA = Rt;
Pd = 0xff;
lock_valid = 0;
} else {
Pd = 0;
}

Class: SYSTEM (slots 0)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

■

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically AND’d with another predicate.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

Parse

8

7

6

5

4

3

2

t5

1

0
d2

1

0

1

0

0

0

0

0

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

0

0

d

d memw_locked(Rs,Pd)=Rt

1

0

1

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

-

-

-

-

0

0

d

d memd_locked(Rs,Pd)=Rtt

Field name
ICLASS
Parse
d2
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

371

Hexagon V68 Programmer’s Reference Manual

Field name
t5
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register t
Amode
Type
Unsigned

372

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Zero a cache line
DCZEROA clears 32 bytes of memory.
If the memory is marked write-back cacheable, a cache line is allocated in the data cache
and 32 bytes are cleared.
If the memory is write-through or write-back, 32 bytes of zeros are sent to memory.
This instruction is useful for efficiently handling write-only data by pre-allocating lines in
the cache.
The address must be 32-byte aligned. If not, an unaligned error exception is raised.
If this instruction appears in a packet, slot 1 must be A-type or empty.
Syntax

Behavior

dczeroa(Rs)

EA=Rs;
dcache_zero_addr(EA);

Class: SYSTEM (slots 0)
Notes
■

A packet containing this instruction must have slot 1 either empty or executing an
ALU32 instruction.

Intrinsics
dczeroa(Rs)

void Q6_dczeroa_A(Address a)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

0

0

0

U
N

Type
0

1

1

Field name
ICLASS
Parse
s5
Amode
Type
UN

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

Parse
s

s

P

P 0

-

-

-

-

dczeroa(Rs)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Amode
Type
Unsigned

373

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Memory barrier
BARRIER establishes a memory barrier to ensure proper ordering between accesses
before the barrier instruction and accesses after the barrier instruction.
All accesses before the barrier are globally observable before any access after the barrier
can be observed.
The use of this instruction is system-dependent.
Syntax

Behavior

barrier

memory_barrier;

Class: SYSTEM (slots 0)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

1

0

0

U
N

Type
0

0

0

Field name
ICLASS
Parse
Amode
Type
UN

80-N2040-46 Rev. B

0

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
-

-

-

-

-

P

P

-

-

-

-

-

barrier

Description
Instruction Class
Packet/Loop parse bits
Amode
Type
Unsigned

374

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Breakpoint
BRKPT causes the program to enter Debug mode if enabled by ISDB.
Execution control is handed to ISDB and the program does not proceed until directed by
the debugger.
If ISDB is disabled, this instruction is treated as a NOP.
Syntax

Behavior

brkpt

Enter Debug mode;

Class: SYSTEM (slot 3)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

1

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse

1

0

0

0

0

Field name
sm
ICLASS
Parse

80-N2040-46 Rev. B

1

-

-

-

-

-

P

P

-

-

-

-

-

brkpt

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits

375

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Data cache prefetch
DCFETCH prefetches the data at address Rs + unsigned immediate.
This instruction is a hint to the memory system, and is handled in an implementationdependent manner.
Syntax

Behavior

dcfetch(Rs)

Assembler mapped to: "dcfetch(Rs+#0)"

dcfetch(Rs+#u11:3)

EA=Rs+#u;
dcache_fetch(EA);

Class: SYSTEM (slots 0)
Intrinsics
void Q6_dcfetch_A(Address a)

dcfetch(Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

Amode
1

0

1

0

U
N

Type
0

0

0

Field name
ICLASS
Amode
Type
UN
Parse
s5

80-N2040-46 Rev. B

0

s5
s

s

s

8

7

6

5

4

3

2

1

0

i

i

i

i

i

i

i

i

i

Parse
s

s

P

P 0

-

-

i

i

dcfetch(Rs+#u11:3)

Description
Instruction Class
Amode
Type
Unsigned
Packet/Loop parse bits
Field to encode register s

376

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Data cache maintenance user operations
Perform maintenance operations on the data cache.
DCCLEANINVA looks up the data cache at address Rs. If this address is in the cache and
has dirty data, the data is flushed out to memory and the line is then invalidated.
DCCLEANA looks up the data cache at address Rs. If this address is in the cache and has
dirty data, the data is flushed out to memory.
DCINVA looks up the data cache at address Rs. If this address is in the cache, the line
containing the data is invalidated.
If an instruction appears in a packet, slot 1 must be A-type or empty.
In implementations that support L2 cache, these instructions operate on both L1 data and
L2 caches.
Syntax

Behavior

dccleana(Rs)

EA=Rs;
dcache_clean_addr(EA);

dccleaninva(Rs)

EA=Rs;
dcache_cleaninv_addr(EA);

dcinva(Rs)

EA=Rs;
dcache_cleaninv_addr(EA);

Class: SYSTEM (slots 0)
Notes
■

A packet containing this instruction must have slot 1 either empty or executing an
ALU32 instruction.

Intrinsics
dccleana(Rs)

void Q6_dccleana_A(Address a)

dccleaninva(Rs)

void Q6_dccleaninva_A(Address a)

dcinva(Rs)

void Q6_dcinva_A(Address a)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

8

7

6

5

4

3

2

1

0

Parse

1

0

1

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dccleana(Rs)

1

0

1

0

0

0

0

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dcinva(Rs)

1

0

1

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

-

-

-

-

-

-

-

-

dccleaninva(Rs)

80-N2040-46 Rev. B

377

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
s5
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Amode
Type
Unsigned

378

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Send value to DIAG trace

Syntax

Behavior

diag(Rs)
diag0(Rss,Rtt)
diag1(Rss,Rtt)

Class: SYSTEM (slot 3)
Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

ICLASS

s5

0

1

0

0

1

0

s

s

sm

s

8

7

6

5

4

3

2

1

0

-

-

0

0

1

-

-

-

-

-

diag(Rs)

Parse
s

s

s5

P

P

-

-

-

Parse

t5

0

1

1

0

0

0

1

0

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

-

-

-

-

-

diag0(Rss,Rtt)

0

1

1

0

0

0

1

0

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

-

-

-

-

-

diag1(Rss,Rtt)

Field name
sm
ICLASS
Parse
s5
t5

80-N2040-46 Rev. B

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t

379

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Instruction cache maintenance user operations
ICINVA looks up the address in Rs in the instruction cache.
If the address is found, the instruction invalidates the corresponding cache line.
If the user does not have proper permissions to the page to be invalidated, the instruction is
converted to a NOP.
Syntax

Behavior

icinva(Rs)

EA=Rs;
icache_inv_addr(EA);

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

s5
1

0

1

1

0

1

1

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

-

-

-

-

-

-

-

-

Parse
s

s

P

P 0

0

0

-

-

icinva(Rs)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

380

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Instruction synchronization
ISYNC ensures that all previous instructions have committed before continuing to the next
instruction.
This instruction should be executed after the following events (when subsequent
instructions must observe the results of the event):
■

After modifying the TLB with a TLBW instruction

■

After modifying the SSR register

■

After modifying the SYSCFG register

■

After any instruction cache maintenance operation

■

After modifying the TID register

Syntax

Behavior

isync

instruction_sync;

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

0

0

0

0

0

0

0

1

0

Parse
1

0

1

1

1

1

1

Field name
ICLASS
Parse

80-N2040-46 Rev. B

0

0

0

0

0

0

P

P 0

-

-

-

0

isync

Description
Instruction Class
Packet/Loop parse bits

381

Hexagon V68 Programmer’s Reference Manual

Instruction Set

L2 cache prefetch
L2FETCH initiates background prefetching into the L2 cache.
Rs specifies the 32-bit virtual start address. There are two forms of this instruction.
In the first form, the dimensions of the area to prefetch are encoded in source register Rt as
follows:
Rt[15:8] = Width of a fetch block in bytes.
Rt[7:0] = Height: the number of Width-sized blocks to fetch.
Rt[31:16] = Stride: an unsigned byte offset which increments the pointer after fetching
each Width-sized block.
In the second form, the operands are encoded in register pair Rtt as follows:
Rtt[31:16] = Width of a fetch block in bytes.
Rtt[15:0] = Height: the number of Width-sized blocks to fetch.
Rtt[47:32] = Stride: an unsigned byte offset which increments the pointer after each
Width-sized block is fetched.
Rtt[48] = Direction. If clear, perform the prefetches in row major form, meaning all cache
lines in a row should be fetched before proceeding to the next row. If the bit is set, prefetch
in column major form, meaning fetch all cache lines in a column before proceeding to the
next column.

80-N2040-46 Rev. B

382

Hexagon V68 Programmer’s Reference Manual

Instruction Set

The following figure shows two examples of using the L2FETCH instruction.
L2FETCH for large linear prefetch

L2FETCH for box prefetch
31

Rt

8 7

16 15

Stride

Width

31

0

Rt

Height

128

Rs

Start Address

Rs

8 7

16 15

128

0

Lines

Start Address

Stride

Width

Height

Prefetch
Area

128* Lines

In the box prefetch, a 2-D range of memory is defined within a larger frame. The second
example shows prefetch for a large linear area of memory which has size Lines * 128.
L2FETCH is non-blocking. After the instruction is initiated, the program continues on to
the next instruction while the prefetching is performed in the background. L2fetch can
bring in either code or data to the L2 cache. If the lines of interest are already in the L2, no
action is performed. If the lines are missing from the L2$, the hardware attempts to fetch
them from the system memory.
The hardware prefetch engine continues to request all lines in the programmed memory
range. The prefetching hardware makes a best-effort to prefetch the requested data, and
attempts to perform prefetching at a lower priority than demand fetches. This prevents
prefetch from adding traffic while the system is under heavy load.
If a program initiates a new L2FETCH while an older L2FETCH operation is still
pending, the new request is queued, up to deep. If three L2FETCHes are already pending,
the oldest request is dropped. During the time a L2 prefetch is active for a thread, the
USR:PFA status bit is set to indicate that prefetches are in-progress. The programmer can
use this bit to decide whether to start a new L2FETCH before the previous one completes.
Executing an L2fetch with any subfield programmed as zero cancels all pending
prefetches by the calling thread.
The implementation is free to drop prefetches when needed.

80-N2040-46 Rev. B

Syntax

Behavior

l2fetch(Rs,Rt)

l2fetch(Rs,INFO);

l2fetch(Rs,Rtt)

l2fetch(Rs,INFO);

383

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: SYSTEM (slots 0)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

Intrinsics
l2fetch(Rs,Rt)

void Q6_l2fetch_AR(Address a, Word32 Rt)

l2fetch(Rs,Rtt)

void Q6_l2fetch_AP(Address a, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

Amode

U
N

Type

s5

Parse

8

7

6

5

4

3

2

1

0

t5

1

0

1

0

0

1

1

0

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

-

-

-

-

-

l2fetch(Rs,Rt)

1

0

1

0

0

1

1

0

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

-

-

l2fetch(Rs,Rtt)

Field name
ICLASS
Parse
s5
t5
Amode
Type
UN

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Amode
Type
Unsigned

384

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Pause
The PAUSE instruction pauses execution for a specified period of time.
During the pause duration, the program enters a low-power state and does not fetch and
execute instructions. The instruction provides a short immediate that indicates the pause
duration. The program pauses for at most the number of cycles specified in the immediate
plus 8. The minimum pause is 0 cycles, and the maximum pause is implementation
defined.
An interrupt to the program exits the paused state.
System events, such as hardware or DMA completion, can trigger exits from Pause mode.
An implementation is free to pause for durations shorter than (immediate+8), but not
longer.
This instruction is useful for implementing user-level low-power synchronization
operations, such as spin locks or wait-for-event signaling.
Syntax

Behavior

pause(#u8)

Pause for #u cycles;

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

i

-

-

-

i

i

i

-

-

Parse
1

0

1

0

0

0

1

Field name
ICLASS
Parse

80-N2040-46 Rev. B

-

-

-

-

-

-

P

P

-

i

i

i

i

pause(#u8)

Description
Instruction Class
Packet/Loop parse bits

385

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Memory thread synchronization
The SYNCHT instruction synchronizes memory.
All outstanding memory operations, including cached and uncached loads and stores, are
completed before the processor continues to the next instruction. This ensures that certain
memory operations are performed in the desired order (for example, when accessing I/O
devices).
After performing a SYNCHT operation, the processor ceases fetching and executing
instructions from the program until all outstanding memory operations of that program are
completed.
In multi-threaded or multi-core environments, SYNCHT is not concerned with other
execution contexts.
The use of this instruction is system-dependent.
Syntax

Behavior

Rd=dmsyncht

Rd = DM0;

syncht

memory_synch;

Class: SYSTEM (slots 0)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

■

This is a monitor-level feature. If performed in User or Guest mode, a privilege
error exception occurs.

Intrinsics
Word32 Q6_R_dmsyncht()

Rd=dmsyncht

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

1

Amode
0

ICLASS
1

0

1

1

0

0

0

Amode
0

1

0

80-N2040-46 Rev. B

0

U
N

Type
0

0

0

1

0

7

6

5

4

3

Parse
-

-

-

-

-

U
N

Type
0

0

8

P

P

2

1

0

d5
-

-

-

-

-

0

1

1

1

d

d

d

d

d Rd=dmsyncht

-

-

-

-

-

-

-

-

-

-

-

-

-

-

Parse
-

-

-

-

-

P

P

syncht

386

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
Amode
Type
UN

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Amode
Type
Unsigned

387

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Send value to ETM trace
TRACE takes the value of register Rs and emits it to the ETM trace.
The ETM block must be enabled, and the thread must have permissions to perform
tracing. The contents of Rs are user-defined.
Syntax

Behavior

trace(Rs)

Send value to ETM trace;

Class: SYSTEM (slot 3)
Notes
■

This instruction can only be grouped with ALU32 or non-floating-point XTYPE
instructions.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

1

sm
0

0

s5

0

1

0

0

1

Field name
sm
ICLASS
Parse
s5

80-N2040-46 Rev. B

0

s

s

s

8

7

6

5

4

3

2

1

0

-

0

0

0

-

-

-

-

-

Parse
s

s

P

P

-

-

-

-

-

trace(Rs)

Description
Supervisor mode only
Instruction Class
Packet/Loop parse bits
Field to encode register s

388

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Trap
TRAP causes a precise exception.
Executing a TRAP instruction sets the EX bit in SSR to 1, which disables interrupts and
enables Supervisor mode. The program then jumps to the vector location (either TRAP0
or TRAP1). The instruction specifies a n 8-bit immediate field. This field is copied into the
system status register cause field.
Upon returning from the service routine with a RTE, execution resumes at the packet after
the TRAP instruction.
These instructions are generally intended for user code to request services from the
operating system. Two TRAP instructions are provided so the OS can optimize for fast
service routines and slower service routines.
Syntax

Behavior

trap0(#u8)

SSR.CAUSE = #u;
TRAP "0";

trap1(#u8)

Assembler mapped to: "trap1(R0,#u8)"

trap1(Rx,#u8)

if (!can_handle_trap1_virtinsn(#u)) {
SSR.CAUSE = #u;
TRAP "1";
} else if (#u == 1) {
VMRTE;
} else if (#u == 3) {
VMSETIE;
} else if (#u == 4) {
VMGETIE;
} else if (#u == 6) {
VMSPSWAP;

Class: SYSTEM (slot 2)
Notes
■

This is a solo instruction. It must not be grouped with other instructions in a
packet.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
0

1

0

1

0

1

0

0

0

0

-

-

-

ICLASS
0

1

0

8

7

6

5

4

3

2

1

0

Parse
-

-

-

x5
1

0

1

80-N2040-46 Rev. B

0

0

1

0

-

x

x

x

P

P

-

i

i

i

i

i

-

-

-

i

i

i

-

-

trap0(#u8)

-

i

i

i

i

i

-

-

-

i

i

i

-

-

trap1(Rx,#u8)

Parse
x

x

P

P

389

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
x5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register x

390

Hexagon V68 Programmer’s Reference Manual

11.10

Instruction Set

XTYPE
The XTYPE instruction class includes instructions that perform most of the data
processing done by the Hexagon processor.
XTYPE instructions are executable on slot 2 or slot 3.

11.10.1

XTYPE/ALU
The XTYPE/ALU instruction subclass includes instructions that perform arithmetic and
logical operations.

Absolute value doubleword
Take the absolute value of the 64-bit source register and place it in the destination register.
Syntax

Behavior

Rdd=abs(Rss)

Rdd = ABS(Rss);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=abs(Rss)

Word64 Q6_P_abs_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

0

0

MajOp
0

1

0

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

-

1

Parse
s

s

P

P

6

5

4

3

d

d

MinOp
-

-

-

-

-

1

0

2

1

0

d

d Rdd=abs(Rss)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

391

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Absolute value word
Take the absolute value of the source register and place it in the destination register.
The 32-bit absolute value is available with optional saturation. The single case of
saturation is when the source register is equal to 0x8000_0000, the destination saturates to
0x7fff_ffff.
Syntax

Behavior

Rd=abs(Rs)[:sat]

Rd = [sat_32](ABS(sxt32->64(Rs)));

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=abs(Rs)

Word32 Q6_R_abs_R(Word32 Rs)

Rd=abs(Rs):sat

Word32 Q6_R_abs_R_sat(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

1

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=abs(Rs)

1

0

0

0

1

1

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rd=abs(Rs):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

392

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Add and accumulate
Add Rs and Rt or a signed immediate, then add or subtract the resulting value. The result
is saved in Rx.
Syntax

Behavior

Rd=add(Rs,add(Ru,#s6))

Rd = Rs + Ru + apply_extension(#s);

Rd=add(Rs,sub(#s6,Ru))

Rd = Rs - Ru + apply_extension(#s);

Rx+=add(Rs,#s8)

apply_extension(#s);
Rx=Rx + Rs + #s;

Rx+=add(Rs,Rt)

Rx=Rx + Rs + Rt;

Rx-=add(Rs,#s8)

apply_extension(#s);
Rx=Rx - (Rs + #s);

Rx-=add(Rs,Rt)

Rx=Rx - (Rs + Rt);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=add(Rs,add(Ru,#s6))

Word32 Q6_R_add_add_RRI(Word32 Rs, Word32 Ru,
Word32 Is6)

Rd=add(Rs,sub(#s6,Ru))

Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32 Is6,
Word32 Ru)

Rx+=add(Rs,#s8)

Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs,
Word32 Is8)

Rx+=add(Rs,Rt)

Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=add(Rs,#s8)

Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs,
Word32 Is8)

Rx-=add(Rs,Rt)

Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

6

5

4

3

d5

2

1

0

u5

1

1

0

1

1

0

1

1

0

i

i

s

s

s

s

s

P

P

i

d

d

d

d

d

i

i

i

u

u

u

u

u Rd=add(Rs,add(Ru,#s6))

1

1

0

1

1

0

1

1

1

i

i

s

s

s

s

s

P

P

i

d

d

d

d

d

i

i

i

u

u

u

u

u Rd=add(Rs,sub(#s6,Ru))

ICLASS

RegType

MajOp

s5

Parse

MinOp

x5

1

1

1

0

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

x

x

x

x

x Rx+=add(Rs,#s8)

1

1

1

0

0

0

1

0

1

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

x

x

x

x

x Rx-=add(Rs,#s8)

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx+=add(Rs,Rt)

1

1

1

0

1

1

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx-=add(Rs,Rt)

80-N2040-46 Rev. B

393

Hexagon V68 Programmer’s Reference Manual

Field name
RegType
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
u5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Register Type
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

394

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Add doublewords
The first form of this instruction adds two 32-bit registers. If the result overflows 32 bits,
the result is saturated to 0x7FFF_FFFF for a positive result, or 0x8000_0000 for a
negative result. 32-bit non-saturating register add is a ALU32-class instruction and can
execute on any slot.
The second instruction form sign-extends a 32-bit register Rt to 64-bits and performs a 64bit add with Rss. The result is stored in Rdd.
The third instruction form adds 64-bit registers Rss and Rtt and places the result in Rdd.
The final instruction form adds two 64-bit registers Rss and Rtt. If the result overflows 64
bits, it is saturated to 0x7fff_ffff_ffff_ffff for a positive result, or
0x8000_0000_0000_0000 for a negative result.
Syntax

Behavior

Rd=add(Rs,Rt):sat:deprecated

Rd=sat_32(Rs+Rt);

Rdd=add(Rs,Rtt)

if ("Rs & 1") {
Assembler mapped to:
"Rdd=add(Rss,Rtt):raw:hi";
} else {
Assembler mapped to:
"Rdd=add(Rss,Rtt):raw:lo";
}

Rdd=add(Rss,Rtt)

Rdd=Rss+Rtt;

Rdd=add(Rss,Rtt):raw:hi

Rdd=Rtt+sxt32->64(Rss.w[1]);

Rdd=add(Rss,Rtt):raw:lo

Rdd=Rtt+sxt32->64(Rss.w[0]);

Rdd=add(Rss,Rtt):sat

Rdd=sat64(Rss+Rtt);

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rdd=add(Rs,Rtt)

Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)

Rdd=add(Rss,Rtt)

Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)

Rdd=add(Rss,Rtt):sat

Word64 Q6_P_add_PP_sat(Word64 Rss, Word64 Rtt)

395

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=add(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=add(Rss,Rtt):sat

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=add(Rss,Rtt):raw:lo

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=add(Rss,Rtt):raw:hi

1

1

0

1

0

1

0

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

-

-

d

d

d

d

d Rd=add(Rs,Rt):sat:depreca
ted

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

396

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Add halfword
Perform a 16-bit add with optional saturation, and place the result in either the upper or
lower half of a register. If the result goes in the upper half, the sources can be any high or
low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.
If the result is to be placed in the lower 16 bits of Rd, the Rs source can be either high or
low, but the other source must be the low halfword of Rt. In this case, the upper halfword
of Rd is the sign-extension of the low halfword.

Rd=add(Rs.[hl],Rt.[hl])[:sat]
Rs.H

Rs.L

Rt.H

Rs

Mux

Rt.L

Rt

Mux

16-bit Add
0x7FFF

0x8000

Saturate

Sign-extend

Result

Rd

Syntax

Behavior

Rd=add(Rt.L,Rs.[HL])[:sat]

Rd=[sat_16](Rt.h[0]+Rs.h[01]);

Rd=add(Rt.[HL],Rs.[HL])[:sat]:<
<16

Rd=([sat_16](Rt.h[01]+Rs.h[01]))<<16;

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

397

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=add(Rt.H,Rs.H):<<16

Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.H,Rs.H):sat:<<16

Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt, Word32
Rs)

Rd=add(Rt.H,Rs.L):<<16

Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.H,Rs.L):sat:<<16

Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt, Word32
Rs)

Rd=add(Rt.L,Rs.H)

Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):<<16

Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):sat

Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):sat:<<16

Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt, Word32
Rs)

Rd=add(Rt.L,Rs.L)

Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):<<16

Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):sat

Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):sat:<<16

Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt, Word32
Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

1

0

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=add(Rt.L,Rs.L)

1

1

0

1

0

1

0

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rd=add(Rt.L,Rs.H)

1

1

0

1

0

1

0

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=add(Rt.L,Rs.L):sat

1

1

0

1

0

1

0

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rd=add(Rt.L,Rs.H):sat

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=add(Rt.L,Rs.L):<<16

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=add(Rt.L,Rs.H):<<16

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rd=add(Rt.H,Rs.L):<<16

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rd=add(Rt.H,Rs.H):<<16

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

Rd=add(Rt.L,Rs.L):sat:<<1
d 6

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rd=add(Rt.L,Rs.H):sat:<<1
6

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rd=add(Rt.H,Rs.L):sat:<<1
6

1

1

0

1

0

1

0

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

Rd=add(Rt.H,Rs.H):sat:<<1
d 6

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

398

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Add or subtract doublewords with carry
Add or subtract with carry. Predicate register Px is used as an extra input and output.
For adds, the LSB of the predicate is added to the sum of the two input pairs.
For subtracts, the predicate is considered a not-borrow. The LSB of the predicate is added
to the first source register and the logical complement of the second argument.
The carry-out from the sum is saved in predicate Px.
These instructions allow efficient addition or subtraction of numbers larger than 64 bits.
Syntax

Behavior

Rdd=add(Rss,Rtt,Px):carry

PREDUSE_TIMING;
Rdd = Rss + Rtt + Px[0];
Px = carry_from_add(Rss,Rtt,Px[0]) ? 0xff :
0x00;

Rdd=sub(Rss,Rtt,Px):carry

PREDUSE_TIMING;
Rdd = Rss + ~Rtt + Px[0];
Px = carry_from_add(Rss,~Rtt,Px[0]) ? 0xff :
0x00;

Class: XTYPE (slots 2,3)
Notes

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically AND’d with another predicate.

■

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

6

t5

5

4

3

x2

2

1

0

d5

1

1

0

0

0

0

1

0

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

x

x

d

d

d

d

d Rdd=add(Rss,Rtt,Px):carry

1

1

0

0

0

0

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

x

x

d

d

d

d

d Rdd=sub(Rss,Rtt,Px):carry

Field name
ICLASS
Parse
d5
s5
t5
x2
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Register Type

399

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Clip to unsigned
Clip input to unsigned int
Syntax

Behavior

Rd=clip(Rs,#u5)

Rd=MIN((1<<#u)-1,MAX(Rs,-(1<<#u)));
;

Class: XTYPE (slots 2,3)
Notes
■

This instruction can only execute on a core with the Hexagon audio extensions

Intrinsics
Word32 Q6_R_clip_RI(Word32 Rs, Word32 Iu5)

Rd=clip(Rs,#u5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

0

0

MajOp
0

1

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

i

1

Parse
s

s

P

P 0

6

5

4

3

d

d

MinOp
i

i

i

i

0

1

2

1

0

d

d Rd=clip(Rs,#u5)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

400

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical doublewords
Perform bitwise logical AND, OR, XOR, and NOT operations.
The source and destination registers are 64-bit.
For 32-bit logical operations, see the ALU32 logical instructions.
Syntax

Behavior

Rdd=and(Rss,Rtt)

Rdd=Rss&Rtt;

Rdd=and(Rtt,~Rss)

Rdd = (Rtt & ~Rss);

Rdd=not(Rss)

Rdd=~Rss;

Rdd=or(Rss,Rtt)

Rdd=Rss|Rtt;

Rdd=or(Rtt,~Rss)

Rdd = (Rtt | ~Rss);

Rdd=xor(Rss,Rtt)

Rdd=Rss^Rtt;

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=and(Rss,Rtt)

Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)

Rdd=and(Rtt,~Rss)

Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)

Rdd=not(Rss)

Word64 Q6_P_not_P(Word64 Rss)

Rdd=or(Rss,Rtt)

Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)

Rdd=or(Rtt,~Rss)

Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)

Rdd=xor(Rss,Rtt)

Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

ICLASS

0

0

MajOp
0

1

0

s5
0

s

s

RegType

s

8

7

-

1

Parse
s

s

s5

P

P

6

5

4

3

d

d

MinOp
-

-

-

Parse

-

-

t5

0

0

2

1

0

d

d Rdd=not(Rss)

d5

MinOp

d
d5

1

1

0

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=and(Rss,Rtt)

1

1

0

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=and(Rtt,~Rss)

1

1

0

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=or(Rss,Rtt)

1

1

0

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=or(Rtt,~Rss)

1

1

0

1

0

0

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=xor(Rss,Rtt)

Field name
RegType
MinOp
ICLASS
Parse

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits

401

Hexagon V68 Programmer’s Reference Manual

Field name
d5
s5
t5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

402

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical-logical doublewords
Perform a logical operation of the two source operands, then perform a second logical
operation of the result with the destination register Rxx.
The source and destination registers are 64-bit.
Syntax

Behavior

Rxx^=xor(Rss,Rtt)

Rxx^=Rss^Rtt;

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

Rxx^=xor(Rss,Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

1

0

1

Maj
0

1

0

Field name
ICLASS
Parse
s5
t5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P 0

8

t5
t

t

t

7

6

5

4

3

Min
t

t

0

0

2

1

0

x

x Rxx^=xor(Rss,Rtt)

x5
0

x

x

x

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Register Type

403

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Logical-logical words
Perform a logical operation of the two source operands, then perform a second logical
operation of the result with the destination register Rx.
The source and destination registers are 32-bit.
Syntax

Behavior

Rx=or(Ru,and(Rx,#s10))

Rx = Ru | (Rx & apply_extension(#s));

Rx[&|^]=and(Rs,Rt)

Rx [|&^]= (Rs [|&^] Rt);

Rx[&|^]=and(Rs,~Rt)

Rx [|&^]= (Rs [|&^] ~Rt);

Rx[&|^]=or(Rs,Rt)

Rx [|&^]= (Rs [|&^] Rt);

Rx[&|^]=xor(Rs,Rt)

Rx[|&^]=Rs[|&^]Rt;

Rx|=and(Rs,#s10)

Rx = Rx | (Rs & apply_extension(#s));

Rx|=or(Rs,#s10)

Rx = Rx | (Rs | apply_extension(#s));

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx&=and(Rs,Rt)

Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=and(Rs,~Rt)

Word32 Q6_R_andand_RnR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=or(Rs,Rt)

Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=xor(Rs,Rt)

Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx=or(Ru,and(Rx,#s10))

Word32 Q6_R_or_and_RRI(Word32 Ru, Word32 Rx,
Word32 Is10)

Rx^=and(Rs,Rt)

Word32 Q6_R_andxacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx^=and(Rs,~Rt)

Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx^=or(Rs,Rt)

Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx^=xor(Rs,Rt)

Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=and(Rs,#s10)

Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs,
Word32 Is10)

Rx|=and(Rs,Rt)

Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=and(Rs,~Rt)

Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=or(Rs,#s10)

Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs, Word32
Is10)

404

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rx|=or(Rs,Rt)

Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs, Word32
Rt)

Rx|=xor(Rs,Rt)

Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
1

1

ICLASS
1

1

0

1

0

1

1

1

1

1

1

s5
0

0

0

i

s

s

0

1

0

1

0

0

1

i

x

x

0

1

0

i

s

s

1

1

1

x

MajOp
1

0

0

1

s

s

s

s

6

5

4

3

P

P

i

i

i

i

x

x

x

x

s

s

P

P

i

i

i

i

P

i

i

i

i

i

i

i

i

i

u

u

i

i

i

i

i

i

i

i

i

x

x

s

P

0

x

x

x Rx|=and(Rs,#s10)

u

u

u Rx=or(Ru,and(Rx,#s10))

x

x Rx|=or(Rs,#s10)

x

x Rx|=and(Rs,~Rt)

x5

Parse
s

1

u5

Parse
P

2
x5

i

Parse

s5
s

7

Parse
s

s5

RegType
0

s
x5

RegType

ICLASS
1

1

RegType

ICLASS
1

0

8

P 0

t5
t

t

t

MinOp
t

t

0

0

0

x
x5

x

x

x

1

1

1

0

1

1

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx&=and(Rs,~Rt)

1

1

1

0

1

1

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rx^=and(Rs,~Rt)

1

1

1

0

1

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rx&=and(Rs,Rt)

1

1

1

0

1

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx&=or(Rs,Rt)

1

1

1

0

1

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rx&=xor(Rs,Rt)

1

1

1

0

1

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

x

x

x

x

x Rx|=and(Rs,Rt)

1

1

1

0

1

1

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

x

x

x

x

x Rx^=xor(Rs,Rt)

1

1

1

0

1

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rx|=or(Rs,Rt)

1

1

1

0

1

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx|=xor(Rs,Rt)

1

1

1

0

1

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rx^=and(Rs,Rt)

1

1

1

0

1

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

x

x

x

x

x Rx^=or(Rs,Rt)

Field name
RegType
ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
u5
x5

80-N2040-46 Rev. B

Description
Register Type
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

405

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Maximum words
Select either the signed or unsigned maximum of two source registers and place in a
destination register Rdd.
Syntax

Behavior

Rd=max(Rs,Rt)

Rd = max(Rs,Rt);

Rd=maxu(Rs,Rt)

Rd = max(Rs.uw[0],Rt.uw[0]);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=max(Rs,Rt)

Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)

Rd=maxu(Rs,Rt)

UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

1

0

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

-

-

d

d

d

d

d Rd=max(Rs,Rt)

1

1

0

1

0

1

0

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

-

-

d

d

d

d

d Rd=maxu(Rs,Rt)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

406

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Maximum doublewords
Select either the signed or unsigned maximum of two 64-bit source registers and place in a
destination register.
Syntax

Behavior

Rdd=max(Rss,Rtt)

Rdd = max(Rss,Rtt);

Rdd=maxu(Rss,Rtt)

Rdd = max(Rss.u64,Rtt.u64);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=max(Rss,Rtt)

Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)

Rdd=maxu(Rss,Rtt)

UWord64 Q6_P_maxu_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=max(Rss,Rtt)

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=maxu(Rss,Rtt)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

407

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Minimum words
Select either the signed or unsigned minimum of two source registers and place in
destination register Rd.
Syntax

Behavior

Rd=min(Rt,Rs)

Rd = min(Rt,Rs);

Rd=minu(Rt,Rs)

Rd = min(Rt.uw[0],Rs.uw[0]);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=min(Rt,Rs)

Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)

Rd=minu(Rt,Rs)

UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

-

-

d

d

d

d

d Rd=min(Rt,Rs)

1

1

0

1

0

1

0

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

-

-

d

d

d

d

d Rd=minu(Rt,Rs)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

408

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Minimum doublewords
Select either the signed or unsigned minimum of two 64-bit source registers and place in
the destination register Rdd.
Syntax

Behavior

Rdd=min(Rtt,Rss)

Rdd = min(Rtt,Rss);

Rdd=minu(Rtt,Rss)

Rdd = min(Rtt.u64,Rss.u64);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=min(Rtt,Rss)

Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)

Rdd=minu(Rtt,Rss)

UWord64 Q6_P_minu_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=min(Rtt,Rss)

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=minu(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

409

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Modulo wrap
Wrap the Rs value into the modulo range from 0 to Rt.
If Rs is greater than or equal to Rt, wrap it to the bottom of the range by subtracting Rt.
If Rs is less than zero, wrap it to the top of the range by adding Rt.
Otherwise, when Rs fits within the range, no adjustment is necessary. The result is
returned in register Rd.
Syntax

Behavior

Rd=modwrap(Rs,Rt)

if (Rs < 0) {
Rd = Rs + Rt.uw[0];
} else if (Rs.uw[0] >= Rt.uw[0]) {
Rd = Rs - Rt.uw[0];
} else {
Rd = Rs;
}

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_modwrap_RR(Word32 Rs, Word32 Rt)

Rd=modwrap(Rs,Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
1

0

0

1

s5
1

1

1

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

1

s

s

s

Parse
s

s

P

P

8

7

t5
-

t

t

t

6

5

4

3

MinOp
t

t

1

1

1

2

1

0

d

d Rd=modwrap(Rs,Rt)

d5
d

d

d

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

410

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Negate
The first form of this instruction performs a negate on a 32-bit register with saturation. If
the input is 0x80000000, the result is saturated to 0x7fffffff. The non-saturating 32-bit
register negate is a ALU32-class instruction and can execute on any slot.
The second form of this instruction negates a 64-bit source register and places the result in
destination Rdd.
Syntax

Behavior

Rd=neg(Rs):sat

Rd = sat_32(-Rs.s64);

Rdd=neg(Rss)

Rdd = -Rss;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=neg(Rs):sat

Word32 Q6_R_neg_R_sat(Word32 Rs)

Rdd=neg(Rss)

Word64 Q6_P_neg_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rdd=neg(Rss)

1

0

0

0

1

1

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=neg(Rs):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

411

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Round
Perform either arithmetic (.5 is rounded up) or convergent (.5 is rounded towards even)
rounding to any bit location.
Arithmetic rounding has optional saturation. In this version, the result is saturated to a 32bit number after adding the rounding constant. After the rounding and saturation have
been performed, the final result is right shifted using a sign-extending shift.

80-N2040-46 Rev. B

Syntax

Behavior

Rd=cround(Rs,#u5)

Rd = (#u==0)?Rs:convround(Rs,2**(#u-1))>>#u;

Rd=cround(Rs,Rt)

Rd = (zxt5->32(Rt)==0)?Rs:convround(Rs,2**(zxt5>32(Rt)-1))>>zxt5->32(Rt);

Rd=round(Rs,#u5)[:sat]

Rd = ([sat_32]((#u==0)?(Rs):round(Rs,2**(#u1))))>>#u;

Rd=round(Rs,Rt)[:sat]

Rd = ([sat_32]((zxt5>32(Rt)==0)?(Rs):round(Rs,2**(zxt5->32(Rt)1))))>>zxt5->32(Rt);

Rd=round(Rss):sat

tmp=sat64(Rss+0x080000000ULL);
Rd = tmp.w[1];

Rdd=cround(Rss,#u6)

if (#u == 0) {
Rdd = Rss;
} else if ((Rss & (size8s_t)((1LL << (#u - 1)) 1LL)) == 0) {
src_128 = sxt64->128(Rss);
rndbit_128 = sxt64->128(1LL);
rndbit_128 = (rndbit_128 << #u);
rndbit_128 = (rndbit_128 & src_128);
rndbit_128 = (size8s_t) (rndbit_128 >> 1);
tmp128 = src_128+rndbit_128;
tmp128 = (size8s_t) (tmp128 >> #u);
Rdd = sxt128->64(tmp128);
} else {
size16s_t rndbit_128 = sxt64->128((1LL << (#u
- 1)));
size16s_t src_128 = sxt64->128(Rss);
size16s_t tmp128 = src_128+rndbit_128;
tmp128 = (size8s_t) (tmp128 >> #u);
Rdd = sxt128->64(tmp128);
}
;
;

412

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=cround(Rss,Rt)

if (zxt6->32(Rt) == 0) {
Rdd = Rss;
} else if ((Rss & (size8s_t)((1LL << (zxt6>32(Rt) - 1)) - 1LL)) == 0) {
src_128 = sxt64->128(Rss);
rndbit_128 = sxt64->128(1LL);
rndbit_128 = (rndbit_128 << zxt6->32(Rt));
rndbit_128 = (rndbit_128 & src_128);
rndbit_128 = (size8s_t) (rndbit_128 >> 1);
tmp128 = src_128+rndbit_128;
tmp128 = (size8s_t) (tmp128 >> zxt6->32(Rt));
Rdd = sxt128->64(tmp128);
} else {
size16s_t rndbit_128 = sxt64->128((1LL <<
(zxt6->32(Rt) - 1)));
size16s_t src_128 = sxt64->128(Rss);
size16s_t tmp128 = src_128+rndbit_128;
tmp128 = (size8s_t) (tmp128 >> zxt6->32(Rt));
Rdd = sxt128->64(tmp128);
}
;
;

Class: XTYPE (slots 2,3)
Notes
■

This instruction can only execute on a core with the Hexagon audio extensions

■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rd=cround(Rs,#u5)

Word32 Q6_R_cround_RI(Word32 Rs, Word32 Iu5)

Rd=cround(Rs,Rt)

Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)

Rd=round(Rs,#u5)

Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)

Rd=round(Rs,#u5):sat

Word32 Q6_R_round_RI_sat(Word32 Rs, Word32 Iu5)

Rd=round(Rs,Rt)

Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)

Rd=round(Rs,Rt):sat

Word32 Q6_R_round_RR_sat(Word32 Rs, Word32 Rt)

Rd=round(Rss):sat

Word32 Q6_R_round_P_sat(Word64 Rss)

Rdd=cround(Rss,#u6)

Word64 Q6_P_cround_PI(Word64 Rss, Word32 Iu6)

Rdd=cround(Rss,Rt)

Word64 Q6_P_cround_PR(Word64 Rss, Word32 Rt)

413

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=round(Rss):sat

1

0

0

0

1

1

0

0

1

1

1

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

-

d

d

d

d

d Rd=cround(Rs,#u5)

1

0

0

0

1

1

0

0

1

1

1

s

s

s

s

s

P

P 0

i

i

i

i

i

1

0

-

d

d

d

d

d Rd=round(Rs,#u5)

1

0

0

0

1

1

0

0

1

1

1

s

s

s

s

s

P

P 0

i

i

i

i

i

1

1

-

d

d

d

d

d Rd=round(Rs,#u5):sat

1

0

0

0

1

1

0

0

1

1

1

s

s

s

s

s

P

P

i

i

i

i

i

0

1

-

d

d

d

d

d Rdd=cround(Rss,#u6)

ICLASS

RegType

Maj

s5

i

Parse

t5

Min

d5

1

1

0

0

0

1

1

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=cround(Rs,Rt)

1

1

0

0

0

1

1

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=cround(Rss,Rt)

1

1

0

0

0

1

1

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=round(Rs,Rt)

1

1

0

0

0

1

1

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rd=round(Rs,Rt):sat

Field name
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
Maj
Min
RegType
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Major Opcode
Minor Opcode
Register Type
Register Type

414

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Subtract doublewords
Subtract the 64-bit register Rss from register Rtt.
Syntax

Behavior

Rd=sub(Rt,Rs):sat:deprecated

Rd=sat_32(Rt - Rs);

Rdd=sub(Rtt,Rss)

Rdd=Rtt-Rss;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=sub(Rtt,Rss)

Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=sub(Rtt,Rss)

1

1

0

1

0

1

0

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

-

-

d

d

d

d

d Rd=sub(Rt,Rs):sat:depreca
ted

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

415

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Subtract and accumulate words
Subtract Rs from Rt, then add the resulting value with Rx. The result is saved in Rx.
Syntax

Behavior

Rx+=sub(Rt,Rs)

Rx=Rx + Rt - Rs;

Class: XTYPE (slots 2,3)
Intrinsics
Rx+=sub(Rt,Rs)

Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt,
Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

1

1

MajOp
1

0

0

Field name
ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
x5

80-N2040-46 Rev. B

0

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

0

1

1

2

1

0

x

x Rx+=sub(Rt,Rs)

x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x

416

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Subtract halfword
Perform a 16-bit subtract with optional saturation and place the result in either the upper or
lower half of a register. If the result goes in the upper half, the sources can be any high or
low halfword of Rs and Rt. The lower 16 bits of the result are zeroed.
If the result is to be placed in the lower 16 bits of Rd, the Rs source can be either high or
low, but the other source must be the low halfword of Rt. In this case, the upper halfword
of Rd is the sign-extension of the low halfword.

Rd=sub(Rt.[hl],Rs.l)[:sat]
Rt.H

Rd=sub(Rt.[hl],Rs.[hl])[:sat]:<<16

Rt

Rt.L

Rt.H
Rs

Mux
Rs.H

Rt

Rt.L

Rs

Mux

Rs.L

Rs.H

Rs.L

Mux

16-bit Sub
0x7FFF

16-bit Sub
0x7FFF

0x8000

Saturate

Sign-extend

Result

0x8000

Saturate

Result

Rd

Syntax

Behavior

Rd=sub(Rt.L,Rs.[HL])[:sat]

Rd=[sat_16](Rt.h[0]-Rs.h[01]);

Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<
<16

Rd=([sat_16](Rt.h[01]-Rs.h[01]))<<16;

0x0000

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

417

Rd

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=sub(Rt.H,Rs.H):<<16

Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.H):sat:<<16

Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt, Word32
Rs)

Rd=sub(Rt.H,Rs.L):<<16

Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.L):sat:<<16

Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt, Word32
Rs)

Rd=sub(Rt.L,Rs.H)

Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):<<16

Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):sat

Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):sat:<<16

Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt, Word32
Rs)

Rd=sub(Rt.L,Rs.L)

Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):<<16

Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):sat

Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):sat:<<16

Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt, Word32
Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

1

0

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=sub(Rt.L,Rs.L)

1

1

0

1

0

1

0

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rd=sub(Rt.L,Rs.H)

1

1

0

1

0

1

0

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=sub(Rt.L,Rs.L):sat

1

1

0

1

0

1

0

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rd=sub(Rt.L,Rs.H):sat

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=sub(Rt.L,Rs.L):<<16

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=sub(Rt.L,Rs.H):<<16

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rd=sub(Rt.H,Rs.L):<<16

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rd=sub(Rt.H,Rs.H):<<16

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

Rd=sub(Rt.L,Rs.L):sat:<<1
d 6

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rd=sub(Rt.L,Rs.H):sat:<<1
6

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rd=sub(Rt.H,Rs.L):sat:<<1
6

1

1

0

1

0

1

0

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

Rd=sub(Rt.H,Rs.H):sat:<<1
d 6

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

418

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Sign extend word to doubleword
Sign-extend a 32-bit word to a 64-bit doubleword.
Syntax

Behavior

Rdd=sxtw(Rs)

Rdd = sxt32->64(Rs);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=sxtw(Rs)

Word64 Q6_P_sxtw_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

1

0

MajOp
0

0

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

8

7

Parse
s

s

P

P

6

5

4

3

MinOp
-

-

-

-

-

-

0

0

2

1

0

d

d Rdd=sxtw(Rs)

d5
-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

419

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector absolute value halfwords
Take the absolute value of each of the four halfwords in the 64-bit source vector Rss. Place
the result in Rdd.
Saturation is optionally available.
Syntax

Behavior

Rdd=vabsh(Rss)

for (i=0;i<4;i++) {
Rdd.h[i]=ABS(Rss.h[i]);
}

Rdd=vabsh(Rss):sat

for (i=0;i<4;i++) {
Rdd.h[i]=sat_16(ABS(Rss.h[i]));
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vabsh(Rss)

Word64 Q6_P_vabsh_P(Word64 Rss)

Rdd=vabsh(Rss):sat

Word64 Q6_P_vabsh_P_sat(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rdd=vabsh(Rss)

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rdd=vabsh(Rss):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

420

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector absolute value words
Take the absolute value of each of the two words in the 64-bit source vector Rss. Place the
result in Rdd.
Saturation is optionally available.
Syntax

Behavior

Rdd=vabsw(Rss)

for (i=0;i<2;i++) {
Rdd.w[i]=ABS(Rss.w[i]);
}

Rdd=vabsw(Rss):sat

for (i=0;i<2;i++) {
Rdd.w[i]=sat_32(ABS(Rss.w[i]));
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vabsw(Rss)

Word64 Q6_P_vabsw_P(Word64 Rss)

Rdd=vabsw(Rss):sat

Word64 Q6_P_vabsw_P_sat(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rdd=vabsw(Rss)

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

1

d

d

d

d

d Rdd=vabsw(Rss):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

421

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector absolute difference bytes
For each element in the source vector Rss, subtract the corresponding element in source
vector Rtt. Take the absolute value of the results, and store into Rdd.
Syntax

Behavior

Rdd=vabsdiffb(Rtt,Rss)

for (i=0;i<8;i++) {
Rdd.b[i]=ABS(Rtt.b[i] - Rss.b[i]);
}

Rdd=vabsdiffub(Rtt,Rss)

for (i=0;i<8;i++) {
Rdd.b[i]=ABS(Rtt.ub[i] - Rss.ub[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vabsdiffb(Rtt,Rss)

Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64 Rss)

Rdd=vabsdiffub(Rtt,Rss)

Word64 Q6_P_vabsdiffub_PP(Word64 Rtt, Word64
Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vabsdiffub(Rtt,Rss)

1

1

1

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vabsdiffb(Rtt,Rss)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

422

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector absolute difference halfwords
For each element in the source vector Rss, subtract the corresponding element in source
vector Rtt. Take the absolute value of the results, and store into Rdd.
Syntax

Behavior

Rdd=vabsdiffh(Rtt,Rss)

for (i=0;i<4;i++) {
Rdd.h[i]=ABS(Rtt.h[i] - Rss.h[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vabsdiffh(Rtt,Rss)

Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

0

MajOp
0

0

1

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

0

0

0

2

1

0

d

d Rdd=vabsdiffh(Rtt,Rss)

d5
d

d

d

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

423

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector absolute difference words
For each element in the source vector Rss, subtract the corresponding element in source
vector Rtt. Take the absolute value of the results, and store into Rdd.
Syntax

Behavior

Rdd=vabsdiffw(Rtt,Rss)

for (i=0;i<2;i++) {
Rdd.w[i]=ABS(Rtt.w[i] - Rss.w[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vabsdiffw(Rtt,Rss)

Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

0

MajOp
0

0

0

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

0

0

0

2

1

0

d

d Rdd=vabsdiffw(Rtt,Rss)

d5
d

d

d

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

424

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add compare and select maximum bytes
Add each byte element in Rxx and Rtt, and compare the resulting sums with the
corresponding differences between Rss and Rtt. Store the maximum value of each
compare in Rxx, and set the corresponding bits in a predicate destination to '1' if the
compare result is greater, '0' if not. Each sum and difference is saturated to 8 bits before
the compare, and the compare operation is a signed byte compare.

Rxx.H3

Rxx.H2

Rxx.H1

Rss.H3

Rtt.H3

Rxx.H0

Rss.H2

Rtt.H2

Rxx

Rss.H1

Rtt.H1

Rss.H0

Rss
Rtt

Rtt.H0

+

-

+

-

+

-

+

-

sat16

sat16

sat16

sat16

sat16

sat16

sat16

sat16

Rxx,Pd=vacsh(Rss,Rtt)

>
>
>

1

0

>

1bit

16bits

1

1

0

0

0

1

Rxx.H3

Rxx.H2

Syntax

Rxx.H1

Rxx.H0

Pd

Behavior

Class: N/A

80-N2040-46 Rev. B

425

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add compare and select maximum halfwords
Add each halfword element in Rxx and Rtt, and compare the resulting sums with the
corresponding differences between Rss and Rtt. Store the maximum value of each
compare in Rxx, and set the corresponding bits in a predicate destination to '11' if the
compare result is greater, '00' if not. Each sum and difference is saturated to 16 bits before
the compare, and the compare operation is a signed halfword compare.

Rxx.H3

Rxx.H2

Rxx.H1

Rss.H3

Rtt.H3

Rxx.H0

Rss.H2

Rtt.H2

Rxx

Rss.H1

Rtt.H1

Rss.H0

Rss
Rtt

Rtt.H0

+

-

+

-

+

-

+

-

sat16

sat16

sat16

sat16

sat16

sat16

sat16

sat16

Rxx,Pd=vacsh(Rss,Rtt)

>
>
>

1

0

>

1bit

16bits

1

1

1

0

0

Rxx.H3

80-N2040-46 Rev. B

0

Rxx.H2

Rxx.H1

Rxx.H0

Syntax

Behavior

Rxx,Pe=vacsh(Rss,Rtt)

for (i = 0; i < 4; i++) {
xv = (int) Rxx.h[i];
sv = (int) Rss.h[i];
tv = (int) Rtt.h[i];
xv = xv + tv;
sv = sv - tv;
Pe.i*2 = (xv > sv);
Pe.i*2+1 = (xv > sv);
Rxx.h[i]=sat_16(max(xv,sv));
}

Pd

426

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes
■

The predicate generated by this instruction cannot be used as a .new predicate, nor
can it be automatically AND’d with another predicate.

■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

1

MajOp
0

1

0

Field name
ICLASS
MajOp
MinOp
RegType
Parse
e2
s5
t5
x5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

6

t5
t

t

t

5

4

3

e2
t

t

0

e

2

1

0

x

x Rxx,Pe=vacsh(Rss,Rtt)

x5
e

x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register e
Field to encode register s
Field to encode register t
Field to encode register x

427

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add halfwords
Add each of the four halfwords in 64-bit vector Rss to the corresponding halfword in
vector Rtt.
Optionally saturate each 16-bit addition to either a signed or unsigned 16-bit value.
Applying saturation to the vaddh instruction clamps the result to the signed range 0x8000
to 0x7fff, whereas applying saturation to the vadduh instruction ensures that the unsigned
result falls within the range 0 to 0xffff. When saturation is not needed, the vaddh form
should be used.
For the 32-bit version of this vector operation, see the ALU32 instructions.
Syntax

Behavior

Rdd=vaddh(Rss,Rtt)[:sat]

for (i=0;i<4;i++) {
Rdd.h[i]=[sat_16](Rss.h[i]+Rtt.h[i]);
}

Rdd=vadduh(Rss,Rtt):sat

for (i=0;i<4;i++) {
Rdd.h[i]=usat_16(Rss.uh[i]+Rtt.uh[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vaddh(Rss,Rtt)

Word64 Q6_P_vaddh_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddh(Rss,Rtt):sat

Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64 Rtt)

Rdd=vadduh(Rss,Rtt):sat

Word64 Q6_P_vadduh_PP_sat(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vaddh(Rss,Rtt)

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vaddh(Rss,Rtt):sat

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vadduh(Rss,Rtt):sat

80-N2040-46 Rev. B

428

Hexagon V68 Programmer’s Reference Manual

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

429

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add halfwords with saturate and pack to unsigned bytes
Add the four 16-bit halfwords of Rss to the four 16-bit halfwords of Rtt. The results are
saturated to unsigned 8 bits and packed in destination register Rd.
Syntax

Behavior

Rd=vaddhub(Rss,Rtt):sat

for (i=0;i<4;i++) {
Rd.b[i]=usat_8(Rss.h[i]+Rtt.h[i]);
}

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rd=vaddhub(Rss,Rtt):sat

Word32 Q6_R_vaddhub_PP_sat(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

0

0

Maj
1

0

1

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P

8

t5
-

t

t

t

7

6

5

4

3

Min
t

t

0

0

2

1

0

d

d Rd=vaddhub(Rss,Rtt):sat

d5
1

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

430

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce add unsigned bytes
For each byte in the source vector Rss, add the corresponding byte in the source vector Rtt.
Add the four upper intermediate results and optionally the upper word of the destination.
Add the four lower results and optionally the lower word of the destination.

Rss
Rtt

+

+

+

+

+

32bit Add

+

+

+

32bit Add

Rdd

Syntax

Behavior

Rdd=vraddub(Rss,Rtt)

Rdd = 0;
for (i=0;i<4;i++) {
Rdd.w[0]=(Rdd.w[0] + (Rss.ub[i]+Rtt.ub[i]));
}
for (i=4;i<8;i++) {
Rdd.w[1]=(Rdd.w[1] + (Rss.ub[i]+Rtt.ub[i]));
}

Rxx+=vraddub(Rss,Rtt)

for (i = 0; i < 4; i++) {
Rxx.w[0]=(Rxx.w[0] + (Rss.ub[i]+Rtt.ub[i]));
}
for (i = 4; i < 8; i++) {
Rxx.w[1]=(Rxx.w[1] + (Rss.ub[i]+Rtt.ub[i]));
}
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=vraddub(Rss,Rtt)

Word64 Q6_P_vraddub_PP(Word64 Rss, Word64 Rtt)

Rxx+=vraddub(Rss,Rtt)

Word64 Q6_P_vraddubacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

431

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS
1

1

1

0

0

MajOp
0

0

RegType
0

1

0

1

1

0

0

ICLASS
MajOp
MinOp
RegType
Parse

s5
t5
x5

80-N2040-46 Rev. B

s5
s

s

MajOp
1

Field name

d5

0

0

s

Parse
s

s

s5
s

s

s

P

P 0

s

P

P 0

7

t

0

t5
t

t

Parse
s

8

t

t

t

5

4

3

d

d

MinOp
t

t5
t

6
0

1

t

0

0

1

1

0

d

d Rdd=vraddub(Rss,Rtt)

x

x Rxx+=vraddub(Rss,Rtt)

d5

MinOp
t

2
d
x5

x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

432

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce add halfwords
For each halfword in the source vector Rss, add the corresponding halfword in the source
vector Rtt. Add these intermediate results together, and place the result in Rd.

Rss
Rtt

+

+

+

+

+

Rd
Syntax

Behavior

Rd=vraddh(Rss,Rtt)

Rd = 0;
for (i=0;i<4;i++) {
Rd += (Rss.h[i]+Rtt.h[i]);
}

Rd=vradduh(Rss,Rtt)

Rd = 0;
for (i=0;i<4;i++) {
Rd += (Rss.uh[i]+Rtt.uh[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rd=vraddh(Rss,Rtt)

Word32 Q6_R_vraddh_PP(Word64 Rss, Word64 Rtt)

Rd=vradduh(Rss,Rtt)

Word32 Q6_R_vradduh_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

1

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

-

0

1

d

d

d

d

d Rd=vradduh(Rss,Rtt)

1

1

1

0

1

0

0

1

0

-

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

d Rd=vraddh(Rss,Rtt)

80-N2040-46 Rev. B

433

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

434

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add bytes
Add each of the eight bytes in 64-bit vector Rss to the corresponding byte in vector Rtt.
Optionally, saturate each 8-bit addition to an unsigned value between 0 and 255. The eight
results are stored in destination register Rdd.
Syntax

Behavior

Rdd=vaddb(Rss,Rtt)

Assembler mapped to: "Rdd=vaddub(Rss,Rtt)"

Rdd=vaddub(Rss,Rtt)[:sat]

for (i = 0; i < 8; i++) {
Rdd.b[i]=[usat_8](Rss.ub[i]+Rtt.ub[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vaddb(Rss,Rtt)

Word64 Q6_P_vaddb_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddub(Rss,Rtt)

Word64 Q6_P_vaddub_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddub(Rss,Rtt):sat

Word64 Q6_P_vaddub_PP_sat(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vaddub(Rss,Rtt)

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vaddub(Rss,Rtt):sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

435

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector add words
Add each of the two words in 64-bit vector Rss to the corresponding word in vector Rtt.
Optionally, saturate each 32-bit addition to a signed value between 0x80000000 and
0x7fffffff. The two word results are stored in destination register Rdd.
Syntax

Behavior

Rdd=vaddw(Rss,Rtt)[:sat]

for (i=0;i<2;i++) {
Rdd.w[i]=[sat_32](Rss.w[i]+Rtt.w[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vaddw(Rss,Rtt)

Word64 Q6_P_vaddw_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddw(Rss,Rtt):sat

Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vaddw(Rss,Rtt)

1

1

0

1

0

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=vaddw(Rss,Rtt):sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

436

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector average halfwords
Average each of the four halfwords in the 64-bit source vector Rss with the corresponding
halfword in Rtt. The average operation performed on each halfword adds the two
halfwords and shifts the result right by 1 bit. Unsigned average uses a logical right shift
(shift in 0), whereas signed average uses an arithmetic right shift (shift in the sign bit). If
the round option is used, a 0x0001 is also added to each result before shifting. This
operation does not overflow. When a summation (before right shift by 1) causes an
overflow of 32 bits, the value shifted in is the most-significant carry out.
The signed average and negative average halfwords is available with optional convergent
rounding. In convergent rounding, when the two LSBs after the addition/subtraction are
11, a rounding constant of 1 is added, otherwise a 0 is added. This result is then shifted
right by one bit. Convergent rounding accumulates less error than arithmetic rounding.
Syntax

Behavior

Rdd=vavgh(Rss,Rtt)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.h[i]+Rtt.h[i])>>1;
}

Rdd=vavgh(Rss,Rtt):crnd

for (i=0;i<4;i++) {
Rdd.h[i]=convround(Rss.h[i]+Rtt.h[i])>>1;
}

Rdd=vavgh(Rss,Rtt):rnd

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.h[i]+Rtt.h[i]+1)>>1;
}

Rdd=vavguh(Rss,Rtt)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i])>>1;
}

Rdd=vavguh(Rss,Rtt):rnd

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i]+1)>>1;
}

Rdd=vnavgh(Rtt,Rss)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rtt.h[i]-Rss.h[i])>>1;
}

Rdd=vnavgh(Rtt,Rss):crnd:sat

for (i=0;i<4;i++) {
Rdd.h[i]=sat_16(convround(Rtt.h[i]Rss.h[i])>>1);
}

Rdd=vnavgh(Rtt,Rss):rnd:sat

for (i=0;i<4;i++) {
Rdd.h[i]=sat_16((Rtt.h[i]-Rss.h[i]+1)>>1);
}

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

437

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rdd=vavgh(Rss,Rtt)

Word64 Q6_P_vavgh_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgh(Rss,Rtt):crnd

Word64 Q6_P_vavgh_PP_crnd(Word64 Rss, Word64
Rtt)

Rdd=vavgh(Rss,Rtt):rnd

Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64 Rtt)

Rdd=vavguh(Rss,Rtt)

Word64 Q6_P_vavguh_PP(Word64 Rss, Word64 Rtt)

Rdd=vavguh(Rss,Rtt):rnd

Word64 Q6_P_vavguh_PP_rnd(Word64 Rss, Word64
Rtt)

Rdd=vnavgh(Rtt,Rss)

Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64 Rss)

Rdd=vnavgh(Rtt,Rss):crnd:sat

Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt,
Word64 Rss)

Rdd=vnavgh(Rtt,Rss):rnd:sat

Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt, Word64
Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vavgh(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vavgh(Rss,Rtt):rnd

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vavgh(Rss,Rtt):crnd

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vavguh(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=vavguh(Rss,Rtt):rnd

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vnavgh(Rtt,Rss)

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

Rdd=vnavgh(Rtt,Rss):rnd:s
d at

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vnavgh(Rtt,Rss):crnd:
sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

438

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector average unsigned bytes
Average each of the eight unsigned bytes in the 64-bit source vector Rss with the
corresponding byte in Rtt. The average operation performed on each byte is the sum of the
two bytes shifted right by 1 bit. If the round option is used, a 0x01 is also added to each
result before shifting. This operation does not overflow. When a summation (before right
shift by 1) causes an overflow of 8 bits, the value shifted in is the most-significant carry
out.
Syntax

Behavior

Rdd=vavgub(Rss,Rtt)

for (i = 0; i < 8; i++) {
Rdd.b[i]=((Rss.ub[i] + Rtt.ub[i])>>1);
}

Rdd=vavgub(Rss,Rtt):rnd

for (i = 0; i < 8; i++) {
Rdd.b[i]=((Rss.ub[i]+Rtt.ub[i]+1)>>1);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vavgub(Rss,Rtt)

Word64 Q6_P_vavgub_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgub(Rss,Rtt):rnd

Word64 Q6_P_vavgub_PP_rnd(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vavgub(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vavgub(Rss,Rtt):rnd

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

439

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector average words
Average each of the two words in the 64-bit source vector Rss with the corresponding
word in Rtt. The average operation performed on each halfword adds the two words and
shifts the result right by one bit. Unsigned average uses a logical right shift (shift in 0),
whereas signed average uses an arithmetic right shift (shift in the sign bit). When using the
round option, a 0x1 is also added to each result before shifting. This operation does not
overflow. When a summation (before right shift by 1) causes an overflow of 32 bits, the
value shifted in is the most-significant carry out.
The signed average and negative average words is available with optional convergent
rounding. In convergent rounding, when the two LSBs after the addition/subtraction are
11, add a rounding constant of 1, otherwise add 0. This result is then shifted right by one
bit. Convergent rounding accumulates less error than arithmetic rounding.
Syntax

Behavior

Rdd=vavguw(Rss,Rtt)[:rnd]

for (i=0;i<2;i++) {
Rdd.w[i]=(zxt32->33(Rss.uw[i])+zxt32(Rtt.uw[i])+1)>>1;
>33
}

Rdd=vavgw(Rss,Rtt):crnd

for (i=0;i<2;i++) {
Rdd.w[i]=(convround(sxt32->33(Rss.w[i])+sxt32>33(Rtt.w[i]))>>1);
}

Rdd=vavgw(Rss,Rtt)[:rnd]

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt32->33(Rss.w[i])+sxt32>33(Rtt.w[i])+1)>>1;
}

Rdd=vnavgw(Rtt,Rss)

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt32->33(Rtt.w[i])-sxt32>33(Rss.w[i]))>>1;
}

Rdd=vnavgw(Rtt,Rss):crnd:sat

for (i=0;i<2;i++) {
Rdd.w[i]=sat_32(convround(sxt32(Rtt.w[i])-sxt
>33
32->33(Rss.w[i]))>>1);
}

Rdd=vnavgw(Rtt,Rss):rnd:sat

for (i=0;i<2;i++) {
Rdd.w[i]=sat_32((sxt32->33(Rtt.w[i])-sxt32>33(Rss.w[i])+1)>>1);
}

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

440

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rdd=vavguw(Rss,Rtt)

Word64 Q6_P_vavguw_PP(Word64 Rss, Word64 Rtt)

Rdd=vavguw(Rss,Rtt):rnd

Word64 Q6_P_vavguw_PP_rnd(Word64 Rss, Word64
Rtt)

Rdd=vavgw(Rss,Rtt)

Word64 Q6_P_vavgw_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgw(Rss,Rtt):crnd

Word64 Q6_P_vavgw_PP_crnd(Word64 Rss, Word64
Rtt)

Rdd=vavgw(Rss,Rtt):rnd

Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64 Rtt)

Rdd=vnavgw(Rtt,Rss)

Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64 Rss)

Rdd=vnavgw(Rtt,Rss):crnd:sat

Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt,
Word64 Rss)

Rdd=vnavgw(Rtt,Rss):rnd:sat

Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt, Word64
Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vavgw(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vavgw(Rss,Rtt):rnd

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vavgw(Rss,Rtt):crnd

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vavguw(Rss,Rtt)

1

1

0

1

0

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vavguw(Rss,Rtt):rnd

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vnavgw(Rtt,Rss)

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

Rdd=vnavgw(Rtt,Rss):rnd:s
d at

1

1

0

1

0

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=vnavgw(Rtt,Rss):crnd:
sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

441

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector clip to unsigned
Clip input to unsigned int
Syntax

Behavior

Rdd=vclip(Rss,#u5)

tmp=MIN((1<<#u)-1,MAX(Rss.w[0],-(1<<#u)));
Rdd.w[0]=tmp;
tmp=MIN((1<<#u)-1,MAX(Rss.w[1],-(1<<#u)));
Rdd.w[1]=tmp;
;

Class: XTYPE (slots 2,3)
Notes
■

This instruction can only execute on a core with the Hexagon audio extensions

Intrinsics
Word64 Q6_P_vclip_PI(Word64 Rss, Word32 Iu5)

Rdd=vclip(Rss,#u5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

0

0

MajOp
0

1

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

Parse
s

s

P

P 0

6

5

4

3

MinOp
i

i

i

i

i

1

1

0

2

1

0

d

d Rdd=vclip(Rss,#u5)

d5
d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

442

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector conditional negate
Based on bits in Rt, conditionally negate halves in Rss.
Syntax

Behavior

Rdd=vcnegh(Rss,Rt)

for (i = 0; i < 4; i++) {
if (Rt.i) {
Rdd.h[i]=sat_16(-Rss.h[i]);
} else {
Rdd.h[i]=Rss.h[i];
}
}

Rxx+=vrcnegh(Rss,Rt)

for (i = 0; i < 4; i++) {
if (Rt.i) {
Rxx += -Rss.h[i];
} else {
Rxx += Rss.h[i];
}
}
;

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vcnegh(Rss,Rt)

Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32 Rt)

Rxx+=vrcnegh(Rss,Rt)

Word64 Q6_P_vrcneghacc_PR(Word64 Rxx, Word64
Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

ICLASS
1

1

0

0

1

Maj
1

RegType
0

1

0

1

1

1

1

0

ICLASS
Parse

s5
t5

80-N2040-46 Rev. B

s

s

Maj
0

Field name

d5

s5
-

s

Parse
s

s

s5
1

s

s

s

P

P

s

P

7

t

0

t5
-

t

t

Parse
s

8

P 1

t

t

t

5

4

3

-

d

d

Min
t

t5
t

6
1

t

1

1

1

0

d

d Rdd=vcnegh(Rss,Rt)

x

x Rxx+=vrcnegh(Rss,Rt)

d5

Min
t

2
d
x5

1

x

x

x

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

443

Hexagon V68 Programmer’s Reference Manual

Field name
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register x
Major Opcode
Minor Opcode
Register Type

444

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector maximum bytes
Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
corresponding byte in Rtt. For each comparison, select the maximum of the two bytes and
place that byte in the corresponding location in Rdd.
Syntax

Behavior

Rdd=vmaxb(Rtt,Rss)

for (i = 0; i < 8; i++) {
Rdd.b[i]=max(Rtt.b[i],Rss.b[i]);
}

Rdd=vmaxub(Rtt,Rss)

for (i = 0; i < 8; i++) {
Rdd.b[i]=max(Rtt.ub[i],Rss.ub[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vmaxb(Rtt,Rss)

Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64 Rss)

Rdd=vmaxub(Rtt,Rss)

Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vmaxub(Rtt,Rss)

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=vmaxb(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

445

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector maximum halfwords
Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
halfword in Rtt. For each comparison, select the maximum of the two halfwords and place
that halfword in the corresponding location in Rdd. Comparisons are available in both
signed and unsigned form.
Syntax

Behavior

Rdd=vmaxh(Rtt,Rss)

for (i = 0; i < 4; i++) {
Rdd.h[i]=max(Rtt.h[i],Rss.h[i]);
}

Rdd=vmaxuh(Rtt,Rss)

for (i = 0; i < 4; i++) {
Rdd.h[i]=max(Rtt.uh[i],Rss.uh[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vmaxh(Rtt,Rss)

Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64 Rss)

Rdd=vmaxuh(Rtt,Rss)

Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vmaxh(Rtt,Rss)

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vmaxuh(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

446

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce maximum halfwords
Register Rxx contains a maximum value in the low word and the address of that maximum
value in the high word. Register Rss contains a vector of four halfword values, and register
Ru contains the address of this data. The instruction finds the maximum halfword between
the previous maximum in Rxx[0] and the four values in Rss. The address of the new
maximum is stored in Rxx[1].
Syntax

Behavior

Rxx=vrmaxh(Rss,Ru)

max = Rxx.h[0];
addr = Rxx.w[1];
for (i = 0; i < 4; i++) {
if (max < Rss.h[i]) {
max = Rss.h[i];
addr = Ru | i<<1;
}
}
Rxx.w[0]=max;
Rxx.w[1]=addr;

Rxx=vrmaxuh(Rss,Ru)

max = Rxx.uh[0];
addr = Rxx.w[1];
for (i = 0; i < 4; i++) {
if (max < Rss.uh[i]) {
max = Rss.uh[i];
addr = Ru | i<<1;
}
}
Rxx.w[0]=max;
Rxx.w[1]=addr;

Class: XTYPE (slots 2,3)
Intrinsics
Rxx=vrmaxh(Rss,Ru)

Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Rxx=vrmaxuh(Rss,Ru)

Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

x5

8

7

6

5

4

3

Min

2

1

0

u5

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 0

x

x

x

x

x 0

0

1

u

u

u

u

u Rxx=vrmaxh(Rss,Ru)

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 1

x

x

x

x

x 0

0

1

u

u

u

u

u Rxx=vrmaxuh(Rss,Ru)

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

447

Hexagon V68 Programmer’s Reference Manual

Field name
u5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register u
Field to encode register x
Major Opcode
Minor Opcode
Register Type

448

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce maximum words
Find the maximum word between the previous maximum in Rxx[0] and the two values in
Rss. The address of the new maximum is stored in Rxx[1].
Register Rxx contains a maximum value in the low word and the address of that maximum
value in the high word. Register Rss contains a vector of two word values, and register Ru
contains the address of this data.
Syntax

Behavior

Rxx=vrmaxuw(Rss,Ru)

max = Rxx.uw[0];
addr = Rxx.w[1];
for (i = 0; i < 2; i++) {
if (max < Rss.uw[i]) {
max = Rss.uw[i];
addr = Ru | i<<2;
}
}
Rxx.w[0]=max;
Rxx.w[1]=addr;

Rxx=vrmaxw(Rss,Ru)

max = Rxx.w[0];
addr = Rxx.w[1];
for (i = 0; i < 2; i++) {
if (max < Rss.w[i]) {
max = Rss.w[i];
addr = Ru | i<<2;
}
}
Rxx.w[0]=max;
Rxx.w[1]=addr;

Class: XTYPE (slots 2,3)
Intrinsics
Rxx=vrmaxuw(Rss,Ru)

Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Rxx=vrmaxw(Rss,Ru)

Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

x5

8

7

6

5

4

3

Min

2

1

0

u5

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 0

x

x

x

x

x 0

1

0

u

u

u

u

u Rxx=vrmaxw(Rss,Ru)

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 1

x

x

x

x

x 0

1

0

u

u

u

u

u Rxx=vrmaxuw(Rss,Ru)

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

449

Hexagon V68 Programmer’s Reference Manual

Field name
u5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register u
Field to encode register x
Major Opcode
Minor Opcode
Register Type

450

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector maximum words
Compare each of the two words in the 64-bit source vector Rss to the corresponding word
in Rtt. For each comparison, select the maximum of the two words and place that word in
the corresponding location in Rdd.
Comparisons are available in both signed and unsigned form.
Syntax

Behavior

Rdd=vmaxuw(Rtt,Rss)

for (i = 0; i < 2; i++) {
Rdd.w[i]=max(Rtt.uw[i],Rss.uw[i]);
}

Rdd=vmaxw(Rtt,Rss)

for (i = 0; i < 2; i++) {
Rdd.w[i]=max(Rtt.w[i],Rss.w[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vmaxuw(Rtt,Rss)

Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64 Rss)

Rdd=vmaxw(Rtt,Rss)

Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vmaxuw(Rtt,Rss)

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vmaxw(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

451

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector minimum bytes
Compare each of the eight unsigned bytes in the 64-bit source vector Rss to the
corresponding byte in Rtt. For each comparison, select the minimum of the two bytes and
place that byte in the corresponding location in Rdd.
Syntax

Behavior

Rdd,Pe=vminub(Rtt,Rss)

for (i = 0; i < 8; i++) {
Pe.i = (Rtt.ub[i] > Rss.ub[i]);
Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
}

Rdd=vminb(Rtt,Rss)

for (i = 0; i < 8; i++) {
Rdd.b[i]=min(Rtt.b[i],Rss.b[i]);
}

Rdd=vminub(Rtt,Rss)

for (i = 0; i < 8; i++) {
Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);
}

Class: XTYPE (slots 2,3)
Notes

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically AND’d with another predicate.

■

Intrinsics
Rdd=vminb(Rtt,Rss)

Word64 Q6_P_vminb_PP(Word64 Rtt, Word64 Rss)

Rdd=vminub(Rtt,Rss)

Word64 Q6_P_vminub_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vminub(Rtt,Rss)

1

1

0

1

0

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=vminb(Rtt,Rss)

d

d Rdd,Pe=vminub(Rtt,Rss)

ICLASS
1

1

1

RegType
0

1

0

1

MajOp
0

1

1

Field name
RegType
MinOp
ICLASS
MajOp
MinOp
RegType
Parse

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

t5
t

t

t

e2
t

t

0

e

d5
e

d

d

d

Description
Register Type
Minor Opcode
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits

452

Hexagon V68 Programmer’s Reference Manual

Field name
d5
e2
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t

453

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector minimum halfwords
Compare each of the four halfwords in the 64-bit source vector Rss to the corresponding
halfword in Rtt. For each comparison, select the minimum of the two halfwords and place
that halfword in the corresponding location in Rdd.
Comparisons are available in both signed and unsigned form.
Syntax

Behavior

Rdd=vminh(Rtt,Rss)

for (i = 0; i < 4; i++) {
Rdd.h[i]=min(Rtt.h[i],Rss.h[i]);
}

Rdd=vminuh(Rtt,Rss)

for (i = 0; i < 4; i++) {
Rdd.h[i]=min(Rtt.uh[i],Rss.uh[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vminh(Rtt,Rss)

Word64 Q6_P_vminh_PP(Word64 Rtt, Word64 Rss)

Rdd=vminuh(Rtt,Rss)

Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vminh(Rtt,Rss)

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vminuh(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

454

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce minimum halfwords
Find the minimum halfword between the previous minimum in Rxx[0] and the four values
in Rss. The address of the new minimum is stored in Rxx[1].
Register Rxx contains a minimum value in the low word and the address of that minimum
value in the high word. Register Rss contains a vector of four halfword values, and register
Ru contains the address of this data.
Syntax

Behavior

Rxx=vrminh(Rss,Ru)

min = Rxx.h[0];
addr = Rxx.w[1];
for (i = 0; i < 4; i++) {
if (min > Rss.h[i]) {
min = Rss.h[i];
addr = Ru | i<<1;
}
}
Rxx.w[0]=min;
Rxx.w[1]=addr;

Rxx=vrminuh(Rss,Ru)

min = Rxx.uh[0];
addr = Rxx.w[1];
for (i = 0; i < 4; i++) {
if (min > Rss.uh[i]) {
min = Rss.uh[i];
addr = Ru | i<<1;
}
}
Rxx.w[0]=min;
Rxx.w[1]=addr;

Class: XTYPE (slots 2,3)
Intrinsics
Rxx=vrminh(Rss,Ru)

Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Rxx=vrminuh(Rss,Ru)

Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

x5

8

7

6

5

4

3

Min

2

1

0

u5

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 0

x

x

x

x

x 1

0

1

u

u

u

u

u Rxx=vrminh(Rss,Ru)

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 1

x

x

x

x

x 1

0

1

u

u

u

u

u Rxx=vrminuh(Rss,Ru)

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

455

Hexagon V68 Programmer’s Reference Manual

Field name
u5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register u
Field to encode register x
Major Opcode
Minor Opcode
Register Type

456

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce minimum words
Find the minimum word between the previous minimum in Rxx[0] and the two values in
Rss. The address of the new minimum is stored in Rxx[1].
Register Rxx contains a minimum value in the low word and the address of that minimum
value in the high word. Register Rss contains a vector of two word values, and register Ru
contains the address of this data.
Syntax

Behavior

Rxx=vrminuw(Rss,Ru)

min = Rxx.uw[0];
addr = Rxx.w[1];
for (i = 0; i < 2; i++) {
if (min > Rss.uw[i]) {
min = Rss.uw[i];
addr = Ru | i<<2;
}
}
Rxx.w[0]=min;
Rxx.w[1]=addr;

Rxx=vrminw(Rss,Ru)

min = Rxx.w[0];
addr = Rxx.w[1];
for (i = 0; i < 2; i++) {
if (min > Rss.w[i]) {
min = Rss.w[i];
addr = Ru | i<<2;
}
}
Rxx.w[0]=min;
Rxx.w[1]=addr;

Class: XTYPE (slots 2,3)
Intrinsics
Rxx=vrminuw(Rss,Ru)

Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Rxx=vrminw(Rss,Ru)

Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64 Rss,
Word32 Ru)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

x5

8

7

6

5

4

3

Min

2

1

0

u5

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 0

x

x

x

x

x 1

1

0

u

u

u

u

u Rxx=vrminw(Rss,Ru)

1

1

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P 1

x

x

x

x

x 1

1

0

u

u

u

u

u Rxx=vrminuw(Rss,Ru)

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

457

Hexagon V68 Programmer’s Reference Manual

Field name
u5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register u
Field to encode register x
Major Opcode
Minor Opcode
Register Type

458

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector minimum words
Compare each of the two words in the 64-bit source vector Rss to the corresponding word
in Rtt. For each comparison, select the minimum of the two words and place that word in
the corresponding location in Rdd.
Comparisons are available in both signed and unsigned form.
Syntax

Behavior

Rdd=vminuw(Rtt,Rss)

for (i = 0; i < 2; i++) {
Rdd.w[i]=min(Rtt.uw[i],Rss.uw[i]);
}

Rdd=vminw(Rtt,Rss)

for (i = 0; i < 2; i++) {
Rdd.w[i]=min(Rtt.w[i],Rss.w[i]);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vminuw(Rtt,Rss)

Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64 Rss)

Rdd=vminw(Rtt,Rss)

Word64 Q6_P_vminw_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vminw(Rtt,Rss)

1

1

0

1

0

0

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vminuw(Rtt,Rss)

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

459

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector sum of absolute differences unsigned bytes
For each byte in the source vector Rss, subtract the corresponding byte in source vector
Rtt. Take the absolute value of the intermediate results, and the upper four together and
add the lower four together. Optionally, add the destination upper and lower words to these
results.
This instruction is useful in determining distance between two vectors, in applications
such as motion estimation.

Rss
Rtt

sad

sad

sad

sad

sad

32bit Add

sad

sad

sad

32bit Add

Rdd

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vrsadub(Rss,Rtt)

Rdd = 0;
for (i = 0; i < 4; i++) {
Rdd.w[0]=(Rdd.w[0] + ABS((Rss.ub[i] Rtt.ub[i])));
}
for (i = 4; i < 8; i++) {
Rdd.w[1]=(Rdd.w[1] + ABS((Rss.ub[i] Rtt.ub[i])));
}

Rxx+=vrsadub(Rss,Rtt)

for (i = 0; i < 4; i++) {
Rxx.w[0]=(Rxx.w[0] + ABS((Rss.ub[i] Rtt.ub[i])));
}
for (i = 4; i < 8; i++) {
Rxx.w[1]=(Rxx.w[1] + ABS((Rss.ub[i] Rtt.ub[i])));
}
;

460

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vrsadub(Rss,Rtt)

Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrsadub(Rss,Rtt)

Word64 Q6_P_vrsadubacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS
1

1

1

0

0

MajOp
0

0

RegType
0

1

0

1

1

0

0

ICLASS
MajOp
MinOp
RegType
Parse

s5
t5
x5

80-N2040-46 Rev. B

s

s

MajOp
1

Field name

d5

0

s5

0

s

Parse
s

s

s5
s

s

s

P

P 0

t

t

Parse
s

s

P

P 0

8

7

t5
t

t

t

0

t5
t

t

t

6

5

4

3

MinOp
1

0

d

d

MinOp
t

t

0

1

0

2

1

0

d

d Rdd=vrsadub(Rss,Rtt)

x

x Rxx+=vrsadub(Rss,Rtt)

d5
d
x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

461

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector subtract halfwords
Subtract each of the four halfwords in 64-bit vector Rss from the corresponding halfword
in vector Rtt.
Optionally, saturate each 16-bit addition to either a signed or unsigned 16-bit value.
Applying saturation to the vsubh instruction clamps the result to the signed range 0x8000
to 0x7fff, whereas applying saturation to the vsubuh instruction ensures that the unsigned
result falls within the range 0 to 0xffff.
When saturation is not needed, vsubh should be used.
Syntax

Behavior

Rdd=vsubh(Rtt,Rss)[:sat]

for (i=0;i<4;i++) {
Rdd.h[i]=[sat_16](Rtt.h[i]-Rss.h[i]);
}

Rdd=vsubuh(Rtt,Rss):sat

for (i=0;i<4;i++) {
Rdd.h[i]=usat_16(Rtt.uh[i]-Rss.uh[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vsubh(Rtt,Rss)

Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64 Rss)

Rdd=vsubh(Rtt,Rss):sat

Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64 Rss)

Rdd=vsubuh(Rtt,Rss):sat

Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt, Word64
Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vsubh(Rtt,Rss)

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vsubh(Rtt,Rss):sat

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vsubuh(Rtt,Rss):sat

Field name
RegType
MinOp
ICLASS

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class

462

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

463

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector subtract bytes
Subtract each of the eight bytes in 64-bit vector Rss from the corresponding byte in vector
Rtt.
Optionally, saturate each 8-bit subtraction to an unsigned value between 0 and 255. The
eight results are stored in destination register Rdd.
Syntax

Behavior

Rdd=vsubb(Rss,Rtt)

Assembler mapped to: "Rdd=vsubub(Rss,Rtt)"

Rdd=vsubub(Rtt,Rss)[:sat]

for (i = 0; i < 8; i++) {
Rdd.b[i]=[usat_8](Rtt.ub[i]-Rss.ub[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vsubb(Rss,Rtt)

Word64 Q6_P_vsubb_PP(Word64 Rss, Word64 Rtt)

Rdd=vsubub(Rtt,Rss)

Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64 Rss)

Rdd=vsubub(Rtt,Rss):sat

Word64 Q6_P_vsubub_PP_sat(Word64 Rtt, Word64
Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=vsubub(Rtt,Rss)

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vsubub(Rtt,Rss):sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

464

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector subtract words
Subtract each of the two words in 64-bit vector Rss from the corresponding word in vector
Rtt.
Optionally, saturate each 32-bit subtraction to a signed value between 0x8000_0000 and
0x7fff_ffff. The two word results are stored in destination register Rdd.
Syntax

Behavior

Rdd=vsubw(Rtt,Rss)[:sat]

for (i=0;i<2;i++) {
Rdd.w[i]=[sat_32](Rtt.w[i]-Rss.w[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vsubw(Rtt,Rss)

Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64 Rss)

Rdd=vsubw(Rtt,Rss):sat

Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vsubw(Rtt,Rss)

1

1

0

1

0

0

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=vsubw(Rtt,Rss):sat

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

465

Hexagon V68 Programmer’s Reference Manual

11.10.2

Instruction Set

XTYPE/BIT
The XTYPE/BIT instruction subclass includes instructions for bit manipulation.

Count leading
Count leading zeros (cl0) counts the number of consecutive zeros starting with the most
significant bit.
Count leading ones (cl1) counts the number of consecutive ones starting with the most
significant bit.
Count leading bits (clb) counts both leading ones and leading zeros and then selects the
maximum.
The NORMAMT instruction returns the number of leading bits minus one.
For a two's-complement number, the number of leading zeros is zero for negative
numbers. The number of leading ones is zero for positive numbers.
Use the number of leading bits to judge the magnitude of the value.

80-N2040-46 Rev. B

Syntax

Behavior

Rd=add(clb(Rs),#s6)

Rd =
(max(count_leading_ones(Rs),count_leading_ones(~
Rs)))+#s;

Rd=add(clb(Rss),#s6)

Rd =
(max(count_leading_ones(Rss),count_leading_ones(
~Rss)))+#s;

Rd=cl0(Rs)

Rd = count_leading_ones(~Rs);

Rd=cl0(Rss)

Rd = count_leading_ones(~Rss);

Rd=cl1(Rs)

Rd = count_leading_ones(Rs);

Rd=cl1(Rss)

Rd = count_leading_ones(Rss);

Rd=clb(Rs)

Rd =
max(count_leading_ones(Rs),count_leading_ones(~R
s));

Rd=clb(Rss)

Rd =
max(count_leading_ones(Rss),count_leading_ones(~
Rss));

Rd=normamt(Rs)

if (Rs == 0) {
Rd = 0;
} else {
Rd =
(max(count_leading_ones(Rs),count_leading_ones(~
Rs)))-1;
}

466

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=normamt(Rss)

if (Rss == 0) {
Rd = 0;
} else {
Rd =
(max(count_leading_ones(Rss),count_leading_ones(
~Rss)))-1;
}

Class: XTYPE (slots 2,3)
Intrinsics
Rd=add(clb(Rs),#s6)

Word32 Q6_R_add_clb_RI(Word32 Rs, Word32 Is6)

Rd=add(clb(Rss),#s6)

Word32 Q6_R_add_clb_PI(Word64 Rss, Word32 Is6)

Rd=cl0(Rs)

Word32 Q6_R_cl0_R(Word32 Rs)

Rd=cl0(Rss)

Word32 Q6_R_cl0_P(Word64 Rss)

Rd=cl1(Rs)

Word32 Q6_R_cl1_R(Word32 Rs)

Rd=cl1(Rss)

Word32 Q6_R_cl1_P(Word64 Rss)

Rd=clb(Rs)

Word32 Q6_R_clb_R(Word32 Rs)

Rd=clb(Rss)

Word32 Q6_R_clb_P(Word64 Rss)

Rd=normamt(Rs)

Word32 Q6_R_normamt_R(Word32 Rs)

Rd=normamt(Rss)

Word32 Q6_R_normamt_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=clb(Rss)

1

0

0

0

1

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

0

d

d

d

d

d Rd=cl0(Rss)

1

0

0

0

1

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=cl1(Rss)

1

0

0

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=normamt(Rss)

1

0

0

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

0

d

d

d

d

d Rd=add(clb(Rss),#s6)

1

0

0

0

1

1

0

0

0

0

1

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

0

d

d

d

d

d Rd=add(clb(Rs),#s6)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=clb(Rs)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rd=cl0(Rs)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=cl1(Rs)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

1

d

d

d

d

d Rd=normamt(Rs)

Field name
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

467

Hexagon V68 Programmer’s Reference Manual

Field name
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Major Opcode
Minor Opcode
Register Type

468

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Count population
Population Count (popcount) counts the number of bits in Rss that are set.
Syntax

Behavior

Rd=popcount(Rss)

Rd = count_ones(Rss);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=popcount(Rss)

Word32 Q6_R_popcount_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

0

0

MajOp
0

0

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
1

s

s

s

8

7

-

0

Parse
s

s

P

P

6

5

4

3

d

d

MinOp
-

-

-

-

-

1

1

2

1

0

d

d Rd=popcount(Rss)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

469

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Count trailing
Count trailing zeros (ct0) counts the number of consecutive zeros starting with the least
significant bit.
Count trailing ones (ct1) counts the number of consecutive ones starting with the least
significant bit.
Syntax

Behavior

Rd=ct0(Rs)

Rd = count_leading_ones(~reverse_bits(Rs));

Rd=ct0(Rss)

Rd = count_leading_ones(~reverse_bits(Rss));

Rd=ct1(Rs)

Rd = count_leading_ones(reverse_bits(Rs));

Rd=ct1(Rss)

Rd = count_leading_ones(reverse_bits(Rss));

Class: XTYPE (slots 2,3)
Intrinsics
Rd=ct0(Rs)

Word32 Q6_R_ct0_R(Word32 Rs)

Rd=ct0(Rss)

Word32 Q6_R_ct0_P(Word64 Rss)

Rd=ct1(Rs)

Word32 Q6_R_ct1_R(Word32 Rs)

Rd=ct1(Rss)

Word32 Q6_R_ct1_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

0

d

d

d

d

d Rd=ct0(Rss)

1

0

0

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=ct1(Rss)

1

0

0

0

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=ct0(Rs)

1

0

0

0

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rd=ct1(Rs)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

470

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Extract bitfield
Extract a bitfield from the source register (or register pair) and deposit into the least
significant bits of the destination register (or register pair). The other, more significant bits
in the destination are either cleared or sign-extended, depending on the instruction.
The width of the extracted field is obtained from the first immediate or from the mostsignificant word of Rtt. The field offset is obtained from either the second immediate or
from the least-significant word of Rtt.
For register-based extract, where Rtt supplies the offset and width, the offset value is
treated as a signed 7-bit number. If this value is negative, the source register Rss is shifted
left (the reverse direction). Width number of bits are then taken from the least-significant
portion of this result.
If the shift amount and/or offset captures data beyond the most significant end of the input,
these bits are taken as zero.

Width

Offset
Rs

Rd
Zero Extension

80-N2040-46 Rev. B

Syntax

Behavior

Rd=extract(Rs,#u5,#U5)

width=#u;
offset=#U;
Rd = sxtwidth->32((Rs >> offset));

Rd=extract(Rs,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
Rd = sxtwidth->64((offset>0)?(zxt32->64(zxt32>64(Rs))>>>offset):(zxt32->64(zxt32>64(Rs))<<offset));

Rd=extractu(Rs,#u5,#U5)

width=#u;
offset=#U;
Rd = zxtwidth->32((Rs >> offset));

Rd=extractu(Rs,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
Rd = zxtwidth->64((offset>0)?(zxt32->64(zxt32>64(Rs))>>>offset):(zxt32->64(zxt32>64(Rs))<<offset));

471

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=extract(Rss,#u6,#U6)

width=#u;
offset=#U;
Rdd = sxtwidth->64((Rss >> offset));

Rdd=extract(Rss,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
Rdd = sxtwidth>64((offset>0)?(Rss>>>offset):(Rss<<offset));

Rdd=extractu(Rss,#u6,#U6)

width=#u;
offset=#U;
Rdd = zxtwidth->64((Rss >> offset));

Rdd=extractu(Rss,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
Rdd = zxtwidth>64((offset>0)?(Rss>>>offset):(Rss<<offset));

Class: XTYPE (slots 2,3)
Intrinsics
Rd=extract(Rs,#u5,#U5)

Word32 Q6_R_extract_RII(Word32 Rs, Word32 Iu5,
Word32 IU5)

Rd=extract(Rs,Rtt)

Word32 Q6_R_extract_RP(Word32 Rs, Word64 Rtt)

Rd=extractu(Rs,#u5,#U5)

Word32 Q6_R_extractu_RII(Word32 Rs, Word32 Iu5,
Word32 IU5)

Rd=extractu(Rs,Rtt)

Word32 Q6_R_extractu_RP(Word32 Rs, Word64 Rtt)

Rdd=extract(Rss,#u6,#U6)

Word64 Q6_P_extract_PII(Word64 Rss, Word32 Iu6,
Word32 IU6)

Rdd=extract(Rss,Rtt)

Word64 Q6_P_extract_PP(Word64 Rss, Word64 Rtt)

Rdd=extractu(Rss,#u6,#U6)

Word64 Q6_P_extractu_PII(Word64 Rss, Word32 Iu6,
Word32 IU6)

Rdd=extractu(Rss,Rtt)

Word64 Q6_P_extractu_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

0

0

0

0

0

0

1

1

0

0

0

1

0

1

0

I

I

I

s

s

s

s

s

1

0

0

0

1

1

0

1

0

I

I

s

s

s

s

s

0

0

0

1

1

0

1

1

I

I

s

s

s

s

s

P

ICLASS

RegType

I

I

s

s

Maj

s

8

7

Parse

1

1

I

s5
s

s

s5

P

6

5

4

3

MinOp
i

i

i

i

I

0

d

d Rdd=extractu(Rss,#u6,#U6
)

i

P

P

i

i

i

i

i

i

I

I

I

d

d

d

d

d Rdd=extract(Rss,#u6,#U6)

P

P 0

i

i

i

i

i

I

I

I

d

d

d

d

d Rd=extractu(Rs,#u5,#U5)

P 0

i

i

i

i

i

I

I

I

d

d

d

d

d Rd=extract(Rs,#u5,#U5)

t5

I

1

P

Parse

i

2
d5

I

d

d

Min

d

d5

1

1

0

0

0

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rdd=extractu(Rss,Rtt)

1

1

0

0

0

0

0

1

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rdd=extract(Rss,Rtt)

1

1

0

0

1

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=extractu(Rs,Rtt)

1

1

0

0

1

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rd=extract(Rs,Rtt)

80-N2040-46 Rev. B

472

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
Maj
Min
RegType
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Major Opcode
Minor Opcode
Register Type
Register Type

473

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Insert bit field
Replace a bit field in the destination register (or register pair) with bits from the least
significant portion of Rs/Rss. The number of bits is obtained from the first immediate or
the most-significant word of Rtt. The bits are shifted by the second immediate or the least
significant word of Rtt.
If register Rtt specifies the offset, the low 7 bits of Rtt are treated as a signed 7-bit value. If
this value is negative, the result is zero.
Shift amounts and offsets that are too large can push bits beyond the end of the destination
register, in this case the bits do not appear in the destination register.

Width
Rs

Offset
Rd
Unchanged

80-N2040-46 Rev. B

Unchanged

Syntax

Behavior

Rx=insert(Rs,#u5,#U5)

width=#u;
offset=#U;
Rx &= ~(((1<<width)-1)<<offset);
Rx |= ((Rs & ((1<<width)-1)) << offset);

Rx=insert(Rs,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
mask = ((1<<width)-1);
if (offset < 0) {
Rx = 0;
} else {
Rx &= ~(mask<<offset);
Rx |= ((Rs & mask) << offset);
}

Rxx=insert(Rss,#u6,#U6)

width=#u;
offset=#U;
Rxx &= ~(((1<<width)-1)<<offset);
Rxx |= ((Rss & ((1<<width)-1)) << offset);

474

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx=insert(Rss,Rtt)

width=zxt6->32((Rtt.w[1]));
offset=sxt7->32((Rtt.w[0]));
mask = ((1<<width)-1);
if (offset < 0) {
Rxx = 0;
} else {
Rxx &= ~(mask<<offset);
Rxx |= ((Rss & mask) << offset);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rx=insert(Rs,#u5,#U5)

Word32 Q6_R_insert_RII(Word32 Rx, Word32 Rs,
Word32 Iu5, Word32 IU5)

Rx=insert(Rs,Rtt)

Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs,
Word64 Rtt)

Rxx=insert(Rss,#u6,#U6)

Word64 Q6_P_insert_PII(Word64 Rxx, Word64 Rss,
Word32 Iu6, Word32 IU6)

Rxx=insert(Rss,Rtt)

Word64 Q6_P_insert_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1
1

RegType

0

0

0

0

0

0

0

1

ICLASS
1

1

0

1

0

s5

0

1

1

I

I

I

s

s

1

1

1

0

I

I

s

s

RegType
0

1

ICLASS
1

MajOp

0

0

0

1

0

1

0

-

-

-

s

s

Maj
0

0

-

Field name
ICLASS
Parse
s5
t5
x5
MajOp
MinOp
Maj
RegType
RegType

80-N2040-46 Rev. B

s

s

s

s

s

s

s5

RegType

s

s

s

s

7

s

s

P

P

i

i

i

P

P 0

i

i

P

P

s

P

5

4

3

-

t

t

i

i

i

I

I

I

x

x

i

i

i

I

I

I

x

x

P 0

t

t

t

1

0

x

x

x Rxx=insert(Rss,#u6,#U6)

x

x

x Rx=insert(Rs,#u5,#U5)

x

x Rx=insert(Rs,Rtt)

x

x Rxx=insert(Rss,Rtt)

x5
t

t

-

-

-

x

x

t5
t

2
x5

t5

Parse
s

6

MinOp

Parse

s5
-

8

Parse

x
x5

t

t

-

-

-

x

x

x

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Major Opcode
Register Type
Register Type

475

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Interleave/deinterleave
For interleave, bits I+32 of Rss (which are the bits from the upper source word) get placed
in the odd bits (I*2)+1 of Rdd, while bits I of Rss (which are the bits from the lower source
word) get placed in the even bits (I*2) of Rdd.
For deinterleave, the even bits of the source register are placed in the even register of the
result pair, and the odd bits of the source register are placed in the odd register of the result
pair.
"r1:0 = deinterleave(r1:0)" is the inverse of "r1:0 = interleave(r1:0)".
Syntax

Behavior

Rdd=deinterleave(Rss)

Rdd = deinterleave(ODD,EVEN);

Rdd=interleave(Rss)

Rdd = interleave(Rss.w[1],Rss.w[0]);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=deinterleave(Rss)

Word64 Q6_P_deinterleave_P(Word64 Rss)

Rdd=interleave(Rss)

Word64 Q6_P_interleave_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rdd=deinterleave(Rss)

1

0

0

0

0

0

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rdd=interleave(Rss)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

476

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Linear feedback-shift iteration
Count the number of ones of the logical AND of the two source input values, and take the
least significant value of that sum. The first source value is shifted right by one bit, and the
parity is placed in the MSB.
Syntax

Behavior

Rdd=lfs(Rss,Rtt)

Rdd = (Rss.u64 >> 1) | ((1&count_ones(Rss &
Rtt)).u64<<63) ;

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)

Rdd=lfs(Rss,Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

0

0

Maj
1

1

0

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P

8

7

t

1

t5
-

t

t

t

6

5

4

3

0

d

d

Min
t

1

2

1

0

d

d Rdd=lfs(Rss,Rtt)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

477

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Masked parity
Count the number of ones of the logical AND of the two source input values, and take the
least significant bit of that sum.
Syntax

Behavior

Rd=parity(Rs,Rt)

Rd = 1&count_ones(Rs & Rt);

Rd=parity(Rss,Rtt)

Rd = 1&count_ones(Rss & Rtt);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=parity(Rs,Rt)

Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)

Rd=parity(Rss,Rtt)

Word32 Q6_R_parity_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

6

5

4

3

t5

2

1

0

d5

1

1

0

1

0

0

0

0

-

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=parity(Rss,Rtt)

1

1

0

1

0

1

0

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

d

d

d

d

d Rd=parity(Rs,Rt)

Field name
RegType
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

478

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Bit reverse
Reverse the order of bits. The most significant gets swapped with the least significant, bit
30 gets swapped with bit 1, and so on.
Syntax

Behavior

Rd=brev(Rs)

Rd = reverse_bits(Rs);

Rdd=brev(Rss)

Rdd = reverse_bits(Rss);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=brev(Rs)

Word32 Q6_R_brev_R(Word32 Rs)

Rdd=brev(Rss)

Word64 Q6_P_brev_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rdd=brev(Rss)

1

0

0

0

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=brev(Rs)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

479

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Set/clear/toggle bit
Set (to 1), clear (to 0), or toggle a single bit in the source, and place the resulting value in
the destination. Indicate the bit to manipulate using an immediate or register value.
If a register indicates the bit position and the value of the least-significant seven bits of Rt
is out of range, the destination register is unchanged.
Syntax

Behavior

Rd=clrbit(Rs,#u5)

Rd = (Rs & (~(1<<#u)));

Rd=clrbit(Rs,Rt)

Rd = (Rs & (~((sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7>32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)))));

Rd=setbit(Rs,#u5)

Rd = (Rs | (1<<#u));

Rd=setbit(Rs,Rt)

Rd = (Rs | (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7>32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)));

Rd=togglebit(Rs,#u5)

Rd = (Rs ^ (1<<#u));

Rd=togglebit(Rs,Rt)

Rd = (Rs ^ (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7>32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)));

Class: XTYPE (slots 2,3)
Intrinsics
Rd=clrbit(Rs,#u5)

Word32 Q6_R_clrbit_RI(Word32 Rs, Word32 Iu5)

Rd=clrbit(Rs,Rt)

Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)

Rd=setbit(Rs,#u5)

Word32 Q6_R_setbit_RI(Word32 Rs, Word32 Iu5)

Rd=setbit(Rs,Rt)

Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)

Rd=togglebit(Rs,#u5)

Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5)

Rd=togglebit(Rs,Rt)

Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

d

d

d

d

d Rd=setbit(Rs,#u5)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

d

d

d

d

d Rd=clrbit(Rs,#u5)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

d

d

d

d

d Rd=togglebit(Rs,#u5)

ICLASS
1

1

0

RegType
0

0

1

1

Maj
0

1

0

s5
-

s

s

s

Parse
s

s

P

P

t5
-

Min

d5

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=setbit(Rs,Rt)

1

1

0

0

0

1

1

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rd=clrbit(Rs,Rt)

1

1

0

0

0

1

1

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=togglebit(Rs,Rt)

80-N2040-46 Rev. B

480

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
Maj
Min
RegType
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Major Opcode
Minor Opcode
Register Type
Register Type

481

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Split bitfield
Split the bitfield in a register into upper and lower parts of variable size. The lower part is
placed in the lower word of a destination register pair, and the upper part is placed in the
upper word of the destination. Use an immediate value or register Rt to determine the bit
position of the split.

Bits
Rs

Rdd[0]
Zero

Rdd[1]
Zero
Syntax

Behavior

Rdd=bitsplit(Rs,#u5)

Rdd.w[1]=(Rs>>#u);
Rdd.w[0]=zxt#u->32(Rs);

Rdd=bitsplit(Rs,Rt)

shamt = zxt5->32(Rt);
Rdd.w[1]=(Rs>>shamt);
Rdd.w[0]=zxtshamt->32(Rs);

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=bitsplit(Rs,#u5)

Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32 Iu5)

Rdd=bitsplit(Rs,Rt)

Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32 Rt)

482

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

ICLASS
1

1

0

0

0

MajOp
0

1

1

s5
0

s

s

RegType
1

0

1

0

0

-

-

RegType
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
RegType

1

s

s

s

7

i

1

Parse
s

s

s5

Field name

80-N2040-46 Rev. B

s

8

P

s

P

P

5

4

3

d

d

MinOp

P 0

i

i

Parse
s

6

i

i

0

t

t

t

1

0

d

d Rdd=bitsplit(Rs,#u5)

d

d Rdd=bitsplit(Rs,Rt)

d5

0

t5
-

2
d
d5

t

t

-

-

-

d

d

d

Description
Register Type
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

483

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Table index
The table index instruction supports fast lookup tables where the index into the table is
stored in a bit-field. The instruction forms the address of a table element by extracting the
bit-field and inserting it into the appropriate bits of a pointer to the table element.
Tables are defined to contain entries of bytes, halfwords, words, or doublewords. The table
must be aligned to a power-of-2 size greater than or equal to the table size. For example, a
4Kbyte table should be aligned to a 4Kbyte boundary. This instruction supports tables
with a maximum of 32K table entries.
Register Rx contains a pointer to within the table. Register Rs contains a field to extract
and use as a table index. This instruction first extracts the field from register Rs and then
inserts it into register Rx. The insertion point is bit 0 for tables of bytes, bit 1 for tables of
halfwords, bit 2 for tables of words, and bit 3 for tables of doublewords.
In the assembly syntax, the width and offset values represent the field in Rs to extract. Use
unsigned constants to specify the width and offsets in assembly. In the encoded
instruction, however, the assembler adjusts these values as follows.
For tableidxb, no adjustment is necessary.
For tableidxh, the assembler encodes offset-1 in the signed immediate field.
For tableidxw, the assembler encodes offset-2 in the signed immediate field.
For tableidxd, the assembler encodes offset-3 in the signed immediate field.
Rx=TABLEIDXD(Rs,#width,#offset)
Width

Offset

Rs

Rx

Unchanged

Unchanged

80-N2040-46 Rev. B

Syntax

Behavior

Rx=tableidxb(Rs,#u4,#S6):raw

width=#u;
offset=#S;
field = Rs[(width+offset-1):offset];
Rx[(width-1+0):0]=field;

Rx=tableidxb(Rs,#u4,#U5)

Assembler mapped to:
"Rx=tableidxb(Rs,#u4,#U5):raw"

484

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rx=tableidxd(Rs,#u4,#S6):raw

width=#u;
offset=#S+3;
field = Rs[(width+offset-1):offset];
Rx[(width-1+3):3]=field;

Rx=tableidxd(Rs,#u4,#U5)

Assembler mapped to: "Rx=tableidxd(Rs,#u4,#U53):raw"

Rx=tableidxh(Rs,#u4,#S6):raw

width=#u;
offset=#S+1;
field = Rs[(width+offset-1):offset];
Rx[(width-1+1):1]=field;

Rx=tableidxh(Rs,#u4,#U5)

Assembler mapped to: "Rx=tableidxh(Rs,#u4,#U51):raw"

Rx=tableidxw(Rs,#u4,#S6):raw

width=#u;
offset=#S+2;
field = Rs[(width+offset-1):offset];
Rx[(width-1+2):2]=field;

Rx=tableidxw(Rs,#u4,#U5)

Assembler mapped to: "Rx=tableidxw(Rs,#u4,#U52):raw"

Class: XTYPE (slots 2,3)
Intrinsics
Rx=tableidxb(Rs,#u4,#U5)

Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32 Rs,
Word32 Iu4, Word32 IU5)

Rx=tableidxd(Rs,#u4,#U5)

Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32 Rs,
Word32 Iu4, Word32 IU5)

Rx=tableidxh(Rs,#u4,#U5)

Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32 Rs,
Word32 Iu4, Word32 IU5)

Rx=tableidxw(Rs,#u4,#U5)

Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32 Rs,
Word32 Iu4, Word32 IU5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

x5

1

0

0

0

0

1

1

1

0

0

i

s

s

s

s

s

P

P

I

I

I

I

I

I

i

i

i

x

x

x

x

Rx=tableidxb(Rs,#u4,#S6):r
x aw

1

0

0

0

0

1

1

1

0

1

i

s

s

s

s

s

P

P

I

I

I

I

I

I

i

i

i

x

x

x

x

x Rx=tableidxh(Rs,#u4,#S6):r
aw

1

0

0

0

0

1

1

1

1

0

i

s

s

s

s

s

P

P

I

I

I

I

I

I

i

i

i

x

x

x

x

x Rx=tableidxw(Rs,#u4,#S6):
raw

1

0

0

0

0

1

1

1

1

1

i

s

s

s

s

s

P

P

I

I

I

I

I

I

i

i

i

x

x

x

x

Rx=tableidxd(Rs,#u4,#S6):r
x aw

Field name
ICLASS
Parse
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s

485

Hexagon V68 Programmer’s Reference Manual

Field name
x5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register x
Major Opcode
Minor Opcode
Register Type

486

Hexagon V68 Programmer’s Reference Manual

11.10.3

Instruction Set

XTYPE/COMPLEX
The XTYPE/COMPLEX instruction subclass includes instructions which are for complex
math, using imaginary values.

Complex add/sub halfwords
Use cross vector add-sub or sub-add to perform X+jY and X-jY complex operations. Each
16-bit result is saturated to 16-bits.

Rdd=vxaddsubh(Rss,Rtt):sat
I

R

I

R

Rss

I

R

I

R

Rtt

-

-

+

+

+

+

Sat_16

Sat_16

Sat_16

Sat_16

I

R

I

R

Rdd

Rdd=vxsubaddh(Rss,Rt):rnd:>>1:sat
I

R

I

R

Rss

I

R

I

R

Rtt

-

1

+

1

+

1

+

1

+

>>1

>>1

>>1

>>1

Sat_16

Sat_16

Sat_16

Sat_16

I

R

I

R

80-N2040-46 Rev. B

Rdd

Syntax

Behavior

Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:
sat

Rdd.h[0]=sat_16((Rss.h[0]+Rtt.h[1]+1)>>1);
Rdd.h[1]=sat_16((Rss.h[1]-Rtt.h[0]+1)>>1);
Rdd.h[2]=sat_16((Rss.h[2]+Rtt.h[3]+1)>>1);
Rdd.h[3]=sat_16((Rss.h[3]-Rtt.h[2]+1)>>1);

487

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vxaddsubh(Rss,Rtt):sat

Rdd.h[0]=sat_16(Rss.h[0]+Rtt.h[1]);
Rdd.h[1]=sat_16(Rss.h[1]-Rtt.h[0]);
Rdd.h[2]=sat_16(Rss.h[2]+Rtt.h[3]);
Rdd.h[3]=sat_16(Rss.h[3]-Rtt.h[2]);

Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:
sat

Rdd.h[0]=sat_16((Rss.h[0]-Rtt.h[1]+1)>>1);
Rdd.h[1]=sat_16((Rss.h[1]+Rtt.h[0]+1)>>1);
Rdd.h[2]=sat_16((Rss.h[2]-Rtt.h[3]+1)>>1);
Rdd.h[3]=sat_16((Rss.h[3]+Rtt.h[2]+1)>>1);

Rdd=vxsubaddh(Rss,Rtt):sat

Rdd.h[0]=sat_16(Rss.h[0]-Rtt.h[1]);
Rdd.h[1]=sat_16(Rss.h[1]+Rtt.h[0]);
Rdd.h[2]=sat_16(Rss.h[2]-Rtt.h[3]);
Rdd.h[3]=sat_16(Rss.h[3]+Rtt.h[2]);

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:
sat

Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64 Rss,
Word64 Rtt)

Rdd=vxaddsubh(Rss,Rtt):sat

Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss, Word64
Rtt)

Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:
sat

Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64 Rss,
Word64 Rtt)

Rdd=vxsubaddh(Rss,Rtt):sat

Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

0

0

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vxaddsubh(Rss,Rtt):s
at

1

1

0

0

0

0

0

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

Rdd=vxsubaddh(Rss,Rtt):s
d at

1

1

0

0

0

0

0

1

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rdd=vxaddsubh(Rss,Rtt):r
nd:>>1:sat

1

1

0

0

0

0

0

1

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=vxsubaddh(Rss,Rtt):r
nd:>>1:sat

Field name
ICLASS
Parse
d5
s5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s

488

Hexagon V68 Programmer’s Reference Manual

Field name
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register t
Major Opcode
Minor Opcode
Register Type

489

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex add/sub words
Use cross vector add-sub or sub-add to perform X+jY and X-jY complex operations. Each
32-bit result is saturated to 32-bits.

Rdd=vxsubaddw(Rss,Rt):sat

Rdd=vxaddsubw(Rss,Rt):sat
I

R

Rss

I

R

Rss

I

R

Rtt

I

R

Rtt

-

+

+

-

Sat_32

Sat_32

Sat_32

Sat_32

I

R

I

R

Rdd

Syntax

Behavior

Rdd=vxaddsubw(Rss,Rtt):sat

Rdd.w[0]=sat_32(Rss.w[0]+Rtt.w[1]);
Rdd.w[1]=sat_32(Rss.w[1]-Rtt.w[0]);

Rdd=vxsubaddw(Rss,Rtt):sat

Rdd.w[0]=sat_32(Rss.w[0]-Rtt.w[1]);
Rdd.w[1]=sat_32(Rss.w[1]+Rtt.w[0]);

Rdd

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rdd=vxaddsubw(Rss,Rtt):sat

Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss, Word64
Rtt)

Rdd=vxsubaddw(Rss,Rtt):sat

Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss, Word64
Rtt)

490

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5
Rdd=vxaddsubw(Rss,Rtt):s
at

1

1

0

0

0

0

0

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d

1

1

0

0

0

0

0

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vxsubaddw(Rss,Rtt):s
at

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

491

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex multiply
Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
halfword and an imaginary 16-bit value in the high halfword. Optionally, scale the result
by 0-1 bits. Optionally, add a complex accumulator. Saturate the real and imaginary
portions to 32-bits. The output has a real 32-bit value in the low word and an imaginary
32-bit value in the high word. The Rt input can be optionally conjugated. Another option
is that the result can be subtracted from the destination rather than accumulated.

Rxx+=cmpy(Rs,Rt):sat
Rs

I

R

I

R

Rs

Rt

I

R

I

R

Rt

*

*

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32

32

32

Imaginary Accumulation

Real Accumulation
Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=cmpy(Rs,Rt)[:<<1]:sat

Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[0])[<<1] +
(Rs.h[0] * Rt.h[1])[<<1]);
Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1] (Rs.h[1] * Rt.h[1])[<<1]);

Rdd=cmpy(Rs,Rt*)[:<<1]:sat

Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[0])[<<1] (Rs.h[0] * Rt.h[1])[<<1]);
Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1] +
(Rs.h[1] * Rt.h[1])[<<1]);

492

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx+=cmpy(Rs,Rt)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
Rt.h[0])[<<1] + (Rs.h[0] * Rt.h[1])[<<1]);
Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
Rt.h[0])[<<1] - (Rs.h[1] * Rt.h[1])[<<1]);
;

Rxx+=cmpy(Rs,Rt*)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
Rt.h[0])[<<1] - (Rs.h[0] * Rt.h[1])[<<1]);
Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
Rt.h[0])[<<1] + (Rs.h[1] * Rt.h[1])[<<1]);
;

Rxx-=cmpy(Rs,Rt)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] - ((Rs.h[1] *
Rt.h[0])[<<1] + (Rs.h[0] * Rt.h[1])[<<1]));
Rxx.w[0]=sat_32(Rxx.w[0] - ((Rs.h[0] *
Rt.h[0])[<<1] - (Rs.h[1] * Rt.h[1])[<<1]));
;

Rxx-=cmpy(Rs,Rt*)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] - ((Rs.h[1] *
Rt.h[0])[<<1] - (Rs.h[0] * Rt.h[1])[<<1]));
Rxx.w[0]=sat_32(Rxx.w[0] - ((Rs.h[0] *
Rt.h[0])[<<1] + (Rs.h[1] * Rt.h[1])[<<1]));
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rdd=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs,
Word32 Rt)

Rdd=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs, Word32
Rt)

Rxx+=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

493

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rxx+=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

0

1

0

1

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=cmpy(Rs,Rt)[:<<N]:sat

1

1

1

0

0

1

0

1

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=cmpy(Rs,Rt*)[:<<N]:s
at

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

0

1

1

1

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

x Rxx+=cmpy(Rs,Rt)[:<<N]:s
at

1

1

1

0

0

1

1

1

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

x Rxx=cmpy(Rs,Rt)[:<<N]:sat

1

1

1

0

0

1

1

1

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

Rxx+=cmpy(Rs,Rt*)[:<<N]:
x sat

1

1

1

0

0

1

1

1

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

x Rxx=cmpy(Rs,Rt*)[:<<N]:sat

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

494

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex multiply real or imaginary
Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
halfword and an imaginary 16-bit value in the high halfword. Take either the real or
imaginary result and optionally accumulate with a 64-bit destination.

Rxx+=cmpyi(Rs,Rt)
I

R

Rs

I

R

Rt

*

*
32

32

Add
64

Imaginary Accumulation

Rxx

Syntax

Behavior

Rdd=cmpyi(Rs,Rt)

Rdd = (Rs.h[1] * Rt.h[0]) + (Rs.h[0] * Rt.h[1]);

Rdd=cmpyr(Rs,Rt)

Rdd = (Rs.h[0] * Rt.h[0]) - (Rs.h[1] * Rt.h[1]);

Rxx+=cmpyi(Rs,Rt)

Rxx = Rxx + (Rs.h[1] * Rt.h[0]) + (Rs.h[0] *
Rt.h[1]);
;

Rxx+=cmpyr(Rs,Rt)

Rxx = Rxx + (Rs.h[0] * Rt.h[0]) - (Rs.h[1] *
Rt.h[1]);
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=cmpyi(Rs,Rt)

Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)

Rdd=cmpyr(Rs,Rt)

Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)

Rxx+=cmpyi(Rs,Rt)

Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=cmpyr(Rs,Rt)

Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

495

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

0

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=cmpyi(Rs,Rt)

1

1

1

0

0

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=cmpyr(Rs,Rt)

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

0

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=cmpyi(Rs,Rt)

1

1

1

0

0

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=cmpyr(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

496

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex multiply with round and pack
Multiply complex values Rs and Rt. The inputs have a real 16-bit value in the low
halfword and an imaginary 16-bit value in the high halfword. The Rt input is optionally
conjugated. The multiplier results are optionally scaled by 0-1 bits. A rounding constant is
added to each real and imaginary sum. The real and imaginary parts are individually
saturated to 32bits. The upper 16-bits of each 32-bit results are packed in a 32-bit
destination register.

Rd=cmpy(Rs,Rt):rnd:sat
Rs

I

R

I

R

Rs

Rt

I

R

I

R

Rt

*
0x8000

*

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

0x8000

Add

Add

Sat_32

Sat_32
High 16bits

I

80-N2040-46 Rev. B

High 16bits

R

Rd

Syntax

Behavior

Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat

Rd.h[1]=(sat_32((Rs.h[1] * Rt.h[0])[<<1] +
(Rs.h[0] * Rt.h[1])[<<1] + 0x8000)).h[1];
Rd.h[0]=(sat_32((Rs.h[0] * Rt.h[0])[<<1] (Rs.h[1] * Rt.h[1])[<<1] + 0x8000)).h[1];

Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat

Rd.h[1]=(sat_32((Rs.h[1] * Rt.h[0])[<<1] (Rs.h[0] * Rt.h[1])[<<1] + 0x8000)).h[1];
Rd.h[0]=(sat_32((Rs.h[0] * Rt.h[0])[<<1] +
(Rs.h[1] * Rt.h[1])[<<1] + 0x8000)).h[1];

497

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rd=cmpy(Rs,Rt):<<1:rnd:sat

Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs, Word32
Rt)

Rd=cmpy(Rs,Rt):rnd:sat

Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs, Word32
Rt)

Rd=cmpy(Rs,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=cmpy(Rs,Rt*):rnd:sat

Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

1

0

1

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rd=cmpy(Rs,Rt)[:<<N]:rnd:
sat

1

1

1

0

1

1

0

1

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

Rd=cmpy(Rs,Rt*)[:<<N]:rnd
d :sat

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

498

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex multiply 32x16
Multiply 32 by 16 bit complex values Rss and Rt. The inputs have a real value in the low
part of a register and the imaginary value in the upper part. The multiplier results are
scaled by 1 bit and accumulated with a rounding constant. The result is saturated to 32bits.

Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat
I

Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat
Rss

R
I

I

*

R

Rt

*

* 48

48

Rss

R

Rt

R

* 48

I

48

0x8000

0x8000
<<1

<<1

<<1

<<1

Add

Add

Sat_32

Sat_32

Real result

Imag result

Rd

Rd

Syntax

Behavior

Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat

Rd = sat_32(( (Rss.w[0] * Rt.h[1]) + (Rss.w[1] *
Rt.h[0]) + 0x4000)>>15);

Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat

Rd = sat_32(( (Rss.w[1] * Rt.h[0]) - (Rss.w[0] *
Rt.h[1]) + 0x4000)>>15);

Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat

Rd = sat_32(( (Rss.w[0] * Rt.h[0]) - (Rss.w[1] *
Rt.h[1]) + 0x4000)>>15);

Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat

Rd = sat_32(( (Rss.w[0] * Rt.h[0]) + (Rss.w[1] *
Rt.h[1]) + 0x4000)>>15);

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

499

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64 Rss,
Word32 Rt)

Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64
Rss, Word32 Rt)

Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64 Rss,
Word32 Rt)

Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64
Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

1

0

1

-

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rd=cmpyiwh(Rss,Rt):<<1:r
nd:sat

1

1

0

0

0

1

0

1

-

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rd=cmpyiwh(Rss,Rt*):<<1:
rnd:sat

1

1

0

0

0

1

0

1

-

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

Rd=cmpyrwh(Rss,Rt):<<1:r
d nd:sat

1

1

0

0

0

1

0

1

-

-

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rd=cmpyrwh(Rss,Rt*):<<1:
rnd:sat

Field name
ICLASS
Parse
d5
s5
t5
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Minor Opcode
Register Type

500

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Complex multiply real or imaginary 32-bit
Multiply complex values Rss and Rtt. The inputs have a real 32-bit value in the low word
and an imaginary 32-bit value in the high word. Take either the real or imaginary result
and optionally accumulate with a 64-bit destination.

80-N2040-46 Rev. B

Syntax

Behavior

Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
const128 = sxt64->128(0x40000000);
acc128 = tmp128+acc128;
acc128 = acc128+const128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyiw(Rss,Rtt):<<1:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
acc128 = tmp128+acc128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat

tmp128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
const128 = sxt64->128(0x40000000);
acc128 = tmp128-acc128;
acc128 = acc128+const128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyiw(Rss,Rtt*):<<1:sat

tmp128 = sxt64->128((Rss.w[1] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[0] * Rtt.w[1]));
acc128 = tmp128-acc128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
const128 = sxt64->128(0x40000000);
acc128 = tmp128-acc128;
acc128 = acc128+const128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyrw(Rss,Rtt):<<1:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
acc128 = tmp128-acc128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

501

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
const128 = sxt64->128(0x40000000);
acc128 = tmp128+acc128;
acc128 = acc128+const128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rd=cmpyrw(Rss,Rtt*):<<1:sat

tmp128 = sxt64->128((Rss.w[0] * Rtt.w[0]));
acc128 = sxt64->128((Rss.w[1] * Rtt.w[1]));
acc128 = tmp128+acc128;
acc128 = (size8s_t) (acc128 >> 31);
acc64 = sxt128->64(acc128);
Rd = sat_32(acc64);
;

Rdd=cmpyiw(Rss,Rtt)

Rdd = ((Rss.w[0] * Rtt.w[1]) + (Rss.w[1] *
Rtt.w[0]));
;

Rdd=cmpyiw(Rss,Rtt*)

Rdd = ((Rss.w[1] * Rtt.w[0]) - (Rss.w[0] *
Rtt.w[1]));
;

Rdd=cmpyrw(Rss,Rtt)

Rdd = ((Rss.w[0] * Rtt.w[0]) - (Rss.w[1] *
Rtt.w[1]));
;

Rdd=cmpyrw(Rss,Rtt*)

Rdd = ((Rss.w[0] * Rtt.w[0]) + (Rss.w[1] *
Rtt.w[1]));
;

Rxx+=cmpyiw(Rss,Rtt)

Rxx += ((Rss.w[0] * Rtt.w[1]) + (Rss.w[1] *
Rtt.w[0]));
;
;

Rxx+=cmpyiw(Rss,Rtt*)

Rxx += ((Rss.w[1] * Rtt.w[0]) - (Rss.w[0] *
Rtt.w[1]));
;
;

Rxx+=cmpyrw(Rss,Rtt)

Rxx += ((Rss.w[0] * Rtt.w[0]) - (Rss.w[1] *
Rtt.w[1]));
;
;

Rxx+=cmpyrw(Rss,Rtt*)

Rxx += ((Rss.w[0] * Rtt.w[0]) + (Rss.w[1] *
Rtt.w[1]));
;
;

Class: XTYPE (slots 3)
Notes

80-N2040-46 Rev. B

■

This instruction can only execute on a core with the Hexagon audio extensions

■

A packet with this instruction cannot have a slot 2 multiply instruction.

502

Hexagon V68 Programmer’s Reference Manual

■

Instruction Set

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_cmpyiw_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rd=cmpyiw(Rss,Rtt):<<1:sat

Word32 Q6_R_cmpyiw_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat

Word32 Q6_R_cmpyiw_PP_conj_s1_rnd_sat(Word64
Rss, Word64 Rtt)

Rd=cmpyiw(Rss,Rtt*):<<1:sat

Word32 Q6_R_cmpyiw_PP_conj_s1_sat(Word64 Rss,
Word64 Rtt)

Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_cmpyrw_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rd=cmpyrw(Rss,Rtt):<<1:sat

Word32 Q6_R_cmpyrw_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat

Word32 Q6_R_cmpyrw_PP_conj_s1_rnd_sat(Word64
Rss, Word64 Rtt)

Rd=cmpyrw(Rss,Rtt*):<<1:sat

Word32 Q6_R_cmpyrw_PP_conj_s1_sat(Word64 Rss,
Word64 Rtt)

Rdd=cmpyiw(Rss,Rtt)

Word64 Q6_P_cmpyiw_PP(Word64 Rss, Word64 Rtt)

Rdd=cmpyiw(Rss,Rtt*)

Word64 Q6_P_cmpyiw_PP_conj(Word64 Rss, Word64
Rtt)

Rdd=cmpyrw(Rss,Rtt)

Word64 Q6_P_cmpyrw_PP(Word64 Rss, Word64 Rtt)

Rdd=cmpyrw(Rss,Rtt*)

Word64 Q6_P_cmpyrw_PP_conj(Word64 Rss, Word64
Rtt)

Rxx+=cmpyiw(Rss,Rtt)

Word64 Q6_P_cmpyiwacc_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

Rxx+=cmpyiw(Rss,Rtt*)

Word64 Q6_P_cmpyiwacc_PP_conj(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=cmpyrw(Rss,Rtt)

Word64 Q6_P_cmpyrwacc_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

Rxx+=cmpyrw(Rss,Rtt*)

Word64 Q6_P_cmpyrwacc_PP_conj(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=cmpyiw(Rss,Rtt)

1

1

1

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=cmpyrw(Rss,Rtt)

1

1

1

0

1

0

0

0

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=cmpyrw(Rss,Rtt*)

1

1

1

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=cmpyiw(Rss,Rtt*)

1

1

1

0

1

0

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

d Rd=cmpyiw(Rss,Rtt*):<<1:s
at

1

1

1

0

1

0

0

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

Rd=cmpyiw(Rss,Rtt):<<1:s
d at

80-N2040-46 Rev. B

503

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

1

1

0

1

0

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d

Rd=cmpyrw(Rss,Rtt):<<1:s
at

1

1

1

0

1

0

0

1

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d

Rd=cmpyrw(Rss,Rtt*):<<1:
sat

1

1

1

0

1

0

0

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

d

Rd=cmpyiw(Rss,Rtt*):<<1:r
nd:sat

1

1

1

0

1

0

0

1

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

Rd=cmpyiw(Rss,Rtt):<<1:rn
d d:sat

1

1

1

0

1

0

0

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d

1

1

1

0

1

0

0

1

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=cmpyrw(Rss,Rtt*):<<1:r
nd:sat

0

1

0

0

s

s

s

s

t

t

t

t

1

x

x

x

x Rxx+=cmpyiw(Rss,Rtt*)

ICLASS
1

1

1

RegType
0

1

MajOp
1

0

s5
s

Parse
P

P 0

t5
t

MinOp
1

0

Rd=cmpyrw(Rss,Rtt):<<1:r
nd:sat

x5
x

1

1

1

0

1

0

1

0

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=cmpyiw(Rss,Rtt)

1

1

1

0

1

0

1

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=cmpyrw(Rss,Rtt)

1

1

1

0

1

0

1

0

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=cmpyrw(Rss,Rtt*)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

504

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector complex multiply real or imaginary
The inputs Rss and Rtt are a vector of two complex values. Each complex value is
composed of a 16-bit imaginary portion in the upper halfword and a 16-bit real portion in
the lower halfword. Generate two complex results, either the real result or the imaginary
result. These results are optionally shifted left by 0-1 bits, and optionally accumulated
with the destination register.

Rxx+=vcmpyi(Rss,Rtt):sat
I

R

I

R

Rss

I

R

I

R

Rtt

*

*

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32

Imag Accumulation

Imag Accumulation

32

32

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat

Rdd.w[0]=sat_32((Rss.h[1] * Rtt.h[0]) +
(Rss.h[0] * Rtt.h[1])[<<1]);
Rdd.w[1]=sat_32((Rss.h[3] * Rtt.h[2]) +
(Rss.h[2] * Rtt.h[3])[<<1]);
;
;

Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat

Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0]) (Rss.h[1] * Rtt.h[1])[<<1]);
Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2]) (Rss.h[3] * Rtt.h[3])[<<1]);
;
;

505

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx+=vcmpyi(Rss,Rtt):sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[1] * Rtt.h[0])
+ (Rss.h[0] * Rtt.h[1])<<0);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[3] * Rtt.h[2])
+ (Rss.h[2] * Rtt.h[3])<<0);
;
;

Rxx+=vcmpyr(Rss,Rtt):sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] * Rtt.h[0])
- (Rss.h[1] * Rtt.h[1])<<0);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] * Rtt.h[2])
- (Rss.h[3] * Rtt.h[3])<<0);
;
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vcmpyi(Rss,Rtt):<<1:sat

Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vcmpyi(Rss,Rtt):sat

Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss, Word64
Rtt)

Rdd=vcmpyr(Rss,Rtt):<<1:sat

Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vcmpyr(Rss,Rtt):sat

Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss, Word64
Rtt)

Rxx+=vcmpyi(Rss,Rtt):sat

Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vcmpyr(Rss,Rtt):sat

Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=vcmpyr(Rss,Rtt)[:<<N]
:sat

1

1

1

0

1

0

0

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rdd=vcmpyi(Rss,Rtt)[:<<N]
:sat

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

x

x

x

x

x Rxx+=vcmpyr(Rss,Rtt):sat

1

1

1

0

1

0

1

0

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

x

x

x

x

x Rxx+=vcmpyi(Rss,Rtt):sat

80-N2040-46 Rev. B

506

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

507

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector complex conjugate
Perform a vector complex conjugate of both complex values in vector Rss. This is done by
negating the imaginary halfwords, and placing the result in destination Rdd.
Syntax

Behavior

Rdd=vconj(Rss):sat

Rdd.h[1]=sat_16(-Rss.h[1]);
Rdd.h[0]=Rss.h[0];
Rdd.h[3]=sat_16(-Rss.h[3]);
Rdd.h[2]=Rss.h[2];

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vconj(Rss):sat

Word64 Q6_P_vconj_P_sat(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

0

0

MajOp
0

1

0

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

Parse
s

s

P

P

6

5

4

3

MinOp
-

-

-

-

-

-

1

1

1

2

1

0

d

d Rdd=vconj(Rss):sat

d5
d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

508

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector complex rotate
Take the least significant bits of Rt, and use these bits to rotate each of the two complex
values in the source vector a multiple of 90 degrees. Bits 0 and 1 control the rotation factor
for word 0, and bits 2 and 3 control the rotation factor for word 1.
If the rotation control bits are 0, the rotation is 0: the real and imaginary halves of the
source appear unchanged and unmoved in the destination.
If the rotation control bits are 1, the rotation is -pi/2: the real half of the destination gets the
imaginary half of the source, and the imaginary half of the destination gets the negative
real half of the source.
If the rotation control bits are 2, the rotation is pi/2: the real half of the destination gets the
negative imaginary half of the source, and the imaginary half of the destination gets the
real half of the source.
If the rotation control bits are 3, the rotation is pi: the real half of the destination gets the
negative real half of the source, and the imaginary half of the destination gets the negative
imaginary half of the source.

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vcrotate(Rss,Rt)

tmp = Rt[1:0];
if (tmp == 0) {
Rdd.h[0]=Rss.h[0];
Rdd.h[1]=Rss.h[1];
} else if (tmp == 1) {
Rdd.h[0]=Rss.h[1];
Rdd.h[1]=sat_16(-Rss.h[0]);
} else if (tmp == 2) {
Rdd.h[0]=sat_16(-Rss.h[1]);
Rdd.h[1]=Rss.h[0];
} else {
Rdd.h[0]=sat_16(-Rss.h[0]);
Rdd.h[1]=sat_16(-Rss.h[1]);
}
tmp = Rt[3:2];
if (tmp == 0) {
Rdd.h[2]=Rss.h[2];
Rdd.h[3]=Rss.h[3];
} else if (tmp == 1) {
Rdd.h[2]=Rss.h[3];
Rdd.h[3]=sat_16(-Rss.h[2]);
} else if (tmp == 2) {
Rdd.h[2]=sat_16(-Rss.h[3]);
Rdd.h[3]=Rss.h[2];
} else {
Rdd.h[2]=sat_16(-Rss.h[2]);
Rdd.h[3]=sat_16(-Rss.h[3]);
}

509

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vcrotate(Rss,Rt)

Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

0

1

Maj
1

1

1

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P

8

7

t

0

t5
-

t

t

t

6

5

4

3

-

d

d

Min
t

0

2

1

0

d

d Rdd=vcrotate(Rss,Rt)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

510

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce complex multiply by scalar
Multiply a complex number by a scalar. Rss contains two complex numbers. The real
portions are each multiplied by two scalars contained in register Rt, scaled, summed,
optionally accumulated, saturated, and stored in the lower word of Rdd. A similar
operation is done on the two imaginary portions of Rss.

Rdd=vrcmpys(Rss,Rt):<<1:sat
I
Rt

R

b

I

a

*

b

*

32
<<1

<<1

Rt

a

*

32

Rss

R

*

32

32

<<1

<<1

Add

Add

Sat_32

Sat_32

Rdd

I

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vrcmpys(Rss,Rt):<<1:sat

if ("Rt & 1") {
Assembler mapped to:
"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
} else {
Assembler mapped to:
"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
}

Rdd=vrcmpys(Rss,Rtt):<<1:sat:ra
w:hi

Rdd.w[1]=sat_32((Rss.h[1] * Rtt.w[1].h[0])<<1 +
(Rss.h[3] * Rtt.w[1].h[1])<<1);
Rdd.w[0]=sat_32((Rss.h[0] * Rtt.w[1].h[0])<<1 +
(Rss.h[2] * Rtt.w[1].h[1])<<1);

511

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vrcmpys(Rss,Rtt):<<1:sat:ra
w:lo

Rdd.w[1]=sat_32((Rss.h[1] * Rtt.w[0].h[0])<<1 +
(Rss.h[3] * Rtt.w[0].h[1])<<1);
Rdd.w[0]=sat_32((Rss.h[0] * Rtt.w[0].h[0])<<1 +
(Rss.h[2] * Rtt.w[0].h[1])<<1);

Rxx+=vrcmpys(Rss,Rt):<<1:sat

if ("Rt & 1") {
Assembler mapped to:
"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi";
} else {
Assembler mapped to:
"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo";
}

Rxx+=vrcmpys(Rss,Rtt):<<1:sat:r
aw:hi

Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[1] *
Rtt.w[1].h[0])<<1 + (Rss.h[3] *
Rtt.w[1].h[1])<<1);
Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.w[1].h[0])<<1 + (Rss.h[2] *
Rtt.w[1].h[1])<<1);
;

Rxx+=vrcmpys(Rss,Rtt):<<1:sat:r
aw:lo

Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[1] *
Rtt.w[0].h[0])<<1 + (Rss.h[3] *
Rtt.w[0].h[1])<<1);
Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.w[0].h[0])<<1 + (Rss.h[2] *
Rtt.w[0].h[1])<<1);
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vrcmpys(Rss,Rt):<<1:sat

Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss, Word32
Rt)

Rxx+=vrcmpys(Rss,Rt):<<1:sat

Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64 Rxx,
Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

80-N2040-46 Rev. B

MajOp

s5

Parse

t5

8

7

6

5

MinOp

4

3

2

1

0

d5

512

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

1

1

0

1

0

0

0

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

d

Rdd=vrcmpys(Rss,Rtt):<<1
:sat:raw:hi

1

1

1

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

d

Rdd=vrcmpys(Rss,Rtt):<<1
:sat:raw:lo

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

x

x

x

x

x Rxx+=vrcmpys(Rss,Rtt):<<
1:sat:raw:hi

1

1

1

0

1

0

1

0

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

x

x

x

x

x

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Rxx+=vrcmpys(Rss,Rtt):<<
1:sat:raw:lo

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

513

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce complex multiply by scalar with round and pack
Multiply a complex number by scalar. Rss contains two complex numbers. The real
portions are each multiplied by two scalars contained in register Rt, scaled, summed,
rounded, and saturated. The upper 16bits of this result are packed in the lower halfword of
Rd. A similar operation is done on the two imaginary portions of Rss.

Rd=vrcmpys(Rss,Rt):<<1:rnd:sat
I
Rt

R

b

a

*
0x8000

I
b

*

Rt

a

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32
High 16bits

I

80-N2040-46 Rev. B

Rss

R

0x8000

High 16bits

R

Rd

Syntax

Behavior

Rd=vrcmpys(Rss,Rt):<<1:rnd:sat

if ("Rt & 1") {
Assembler mapped to:
"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi";
} else {
Assembler mapped to:
"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo";
}

Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat
:raw:hi

Rd.h[1]=sat_32((Rss.h[1] * Rtt.w[1].h[0])<<1 +
(Rss.h[3] * Rtt.w[1].h[1])<<1 + 0x8000).h[1];
Rd.h[0]=sat_32((Rss.h[0] * Rtt.w[1].h[0])<<1 +
(Rss.h[2] * Rtt.w[1].h[1])<<1 + 0x8000).h[1];

514

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat
:raw:lo

Rd.h[1]=sat_32((Rss.h[1] * Rtt.w[0].h[0])<<1 +
(Rss.h[3] * Rtt.w[0].h[1])<<1 + 0x8000).h[1];
Rd.h[0]=sat_32((Rss.h[0] * Rtt.w[0].h[0])<<1 +
(Rss.h[2] * Rtt.w[0].h[1])<<1 + 0x8000).h[1];

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rd=vrcmpys(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

1

1

-

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

d

d

d

d

d Rd=vrcmpys(Rss,Rtt):<<1:r
nd:sat:raw:hi

1

1

1

0

1

0

0

1

1

-

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

d Rd=vrcmpys(Rss,Rtt):<<1:r
nd:sat:raw:lo

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

515

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce complex rotate
This instruction is useful for CDMA despreading. An unsigned 2-bit immediate specifies a
byte to use in Rt. Each of four 2-bit fields in the specified byte selects a rotation amount
for one of the four complex numbers in Rss. The real and imaginary products are
accumulated and stored as a 32-bit complex number in Rd. Optionally, the destination
register can also be accumulated.
Rxx += vrcrotate(Rss,Rt,#0)

Rt

1 j -1 -j

1 j -1 -j

1 j -1 -j

1 j -1 -j

mux

mux

mux

mux

Im3

Re3

Im2

*

*
+

I

80-N2040-46 Rev. B

Re2

Im1

Re1

Im0

Re0

Rss

*

*
+

R

Rxx

516

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vrcrotate(Rss,Rt,#u2)

sumr = 0;
sumi = 0;
control = Rt.ub[#u];
for (i = 0; i < 8; i += 2) {
tmpr = Rss.b[i];
tmpi = Rss.b[i+1];
switch (control & 3) {
case 0: sumr += tmpr;
sumi += tmpi;
break;
case 1: sumr += tmpi;
sumi -= tmpr;
break;
case 2: sumr -= tmpi;
sumi += tmpr;
break;
case 3: sumr -= tmpr;
sumi -= tmpi;
break;
}
control = control >> 2;
}
Rdd.w[0]=sumr;
Rdd.w[1]=sumi;

Rxx+=vrcrotate(Rss,Rt,#u2)

sumr = 0;
sumi = 0;
control = Rt.ub[#u];
for (i = 0; i < 8; i += 2) {
tmpr = Rss.b[i];
tmpi = Rss.b[i+1];
switch (control & 3) {
case 0: sumr += tmpr;
sumi += tmpi;
break;
case 1: sumr += tmpi;
sumi -= tmpr;
break;
case 2: sumr -= tmpi;
sumi += tmpr;
break;
case 3: sumr -= tmpr;
sumi -= tmpi;
break;
}
control = control >> 2;
}
Rxx.w[0]=Rxx.w[0] + sumr;
Rxx.w[1]=Rxx.w[1] + sumi;
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=vrcrotate(Rss,Rt,#u2)

Word64 Q6_P_vrcrotate_PRI(Word64 Rss, Word32 Rt,
Word32 Iu2)

Rxx+=vrcrotate(Rss,Rt,#u2)

Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx, Word64
Rss, Word32 Rt, Word32 Iu2)

517

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

ICLASS
1

1

0

0

1

Maj
1

RegType
0

1

0

1

1

1

s

s

Maj
1

1

0

Field name
ICLASS
Parse
d5
s5
t5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
-

s

Parse
s

s

s5
1

s

s

s

P

P

s

P

P

7

t

1

t5
i

t

t

Parse
s

8

t

6

5

4

3

i

d

d

Min
t

1

t

t

t

1

0

d

d Rdd=vrcrotate(Rss,Rt,#u2)

x

x

d5

t5
i

2
d
x5

t

t

-

-

i

x

x

x

Rxx+=vrcrotate(Rss,Rt,#u2
)

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Register Type

518

Hexagon V68 Programmer’s Reference Manual

11.10.4

Instruction Set

XTYPE/FP
The XTYPE/FP instruction subclass includes instructions that are for floating point math.

Floating point addition
Add two floating point values
Syntax

Behavior

Rd=sfadd(Rs,Rt)

Rd=Rs+Rt;

Rdd=dfadd(Rss,Rtt)

Rdd=Rss+Rtt;

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfadd(Rs,Rt)

Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)

Rdd=dfadd(Rss,Rtt)

Word64 Q6_P_dfadd_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfadd(Rss,Rtt)

1

1

1

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=sfadd(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

519

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Classify floating-point value
Classify floating point values. Classes are Normal, Subnormal, Zero, NaN, or Infinity. If
the number is one of the specified classes, return true.
Syntax

Behavior

Pd=dfclass(Rss,#u5)

Pd = 0;
class = fpclassify(Rss);
if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
if (#u.1 && (class == FP_NORMAL)) Pd = 0xff;
if (#u.2 && (class == FP_SUBNORMAL)) Pd = 0xff;
if (#u.3 && (class == FP_INFINITE)) Pd = 0xff;
if (#u.4 && (class == FP_NAN)) Pd = 0xff;
cancel_flags();

Pd=sfclass(Rs,#u5)

Pd = 0;
class = fpclassify(Rs);
if (#u.0 && (class == FP_ZERO)) Pd = 0xff;
if (#u.1 && (class == FP_NORMAL)) Pd = 0xff;
if (#u.2 && (class == FP_SUBNORMAL)) Pd = 0xff;
if (#u.3 && (class == FP_INFINITE)) Pd = 0xff;
if (#u.4 && (class == FP_NAN)) Pd = 0xff;
cancel_flags();

Class: XTYPE (slots 2,3)
Intrinsics
Pd=dfclass(Rss,#u5)

Byte Q6_p_dfclass_PI(Word64 Rss, Word32 Iu5)

Pd=sfclass(Rs,#u5)

Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

ICLASS
1

1

0

1

0

MajOp
1

1

1

s5
1

s

s

RegType
1

1

1

0

0

1

0

RegType
MajOp
ICLASS
Parse
d2
s5
MajOp
RegType

0

s

s

s

7

6

5

4

3

2

1

i

-

-

-

-

-

-

d

Parse
s

s

s5

Field name

80-N2040-46 Rev. B

s

8

P

d2

P 0

i

i

i

i

Parse
s

s

P

P

0
d Pd=sfclass(Rs,#u5)

d2
-

0

0

0

i

i

i

i

i

1

0

-

d

d Pd=dfclass(Rss,#u5)

Description
Register Type
Major Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Register Type

520

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare floating-point value
Compare floating point values. p0 returns true if at least one value is a NaN, zero
otherwise.
Syntax

Behavior

Pd=dfcmp.eq(Rss,Rtt)

Pd=Rss==Rtt ? 0xff : 0x00;

Pd=dfcmp.ge(Rss,Rtt)

Pd=Rss>=Rtt ? 0xff : 0x00;

Pd=dfcmp.gt(Rss,Rtt)

Pd=Rss>Rtt ? 0xff : 0x00;

Pd=dfcmp.uo(Rss,Rtt)

Pd=isunordered(Rss,Rtt) ? 0xff : 0x00;

Pd=sfcmp.eq(Rs,Rt)

Pd=Rs==Rt ? 0xff : 0x00;

Pd=sfcmp.ge(Rs,Rt)

Pd=Rs>=Rt ? 0xff : 0x00;

Pd=sfcmp.gt(Rs,Rt)

Pd=Rs>Rt ? 0xff : 0x00;

Pd=sfcmp.uo(Rs,Rt)

Pd=isunordered(Rs,Rt) ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=dfcmp.eq(Rss,Rtt)

Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64 Rtt)

Pd=dfcmp.ge(Rss,Rtt)

Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64 Rtt)

Pd=dfcmp.gt(Rss,Rtt)

Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64 Rtt)

Pd=dfcmp.uo(Rss,Rtt)

Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64 Rtt)

Pd=sfcmp.eq(Rs,Rt)

Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)

Pd=sfcmp.ge(Rs,Rt)

Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)

Pd=sfcmp.gt(Rs,Rt)

Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)

Pd=sfcmp.uo(Rs,Rt)

Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

2

Min

1

0
d2

1

1

0

0

0

1

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

-

-

-

d

d Pd=sfcmp.ge(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

-

-

-

d

d Pd=sfcmp.uo(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

-

-

-

d

d Pd=sfcmp.eq(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

-

-

-

d

d Pd=sfcmp.gt(Rs,Rt)

ICLASS

RegType

s5

Parse

t5

MinOp

d2

1

1

0

1

0

0

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

-

-

-

d

d Pd=dfcmp.eq(Rss,Rtt)

1

1

0

1

0

0

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

-

-

-

d

d Pd=dfcmp.gt(Rss,Rtt)

1

1

0

1

0

0

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

-

-

-

d

d Pd=dfcmp.ge(Rss,Rtt)

1

1

0

1

0

0

1

0

1

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

-

-

-

d

d Pd=dfcmp.uo(Rss,Rtt)

80-N2040-46 Rev. B

521

Hexagon V68 Programmer’s Reference Manual

Field name
RegType
MinOp
ICLASS
Parse
d2
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

522

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Convert floating-point value to other format
Convert floating point values. If rounding is required, it happens according to the rounding
mode.
Syntax

Behavior

Rd=convert_df2sf(Rss)

Rd = conv_df_to_sf(Rss);

Rdd=convert_sf2df(Rs)

Rdd = conv_sf_to_df(Rs);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=convert_df2sf(Rss)

Word32 Q6_R_convert_df2sf_P(Word64 Rss)

Rdd=convert_sf2df(Rs)

Word64 Q6_P_convert_sf2df_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rdd=convert_sf2df(Rs)

1

0

0

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_df2sf(Rss)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

523

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Convert integer to floating-point value
Convert floating point values. If rounding is required, it happens according to the rounding
mode unless the :chop option is specified.
Syntax

Behavior

Rd=convert_d2sf(Rss)

Rd = conv_8s_to_sf(Rss.s64);

Rd=convert_ud2sf(Rss)

Rd = conv_8u_to_sf(Rss.u64);

Rd=convert_uw2sf(Rs)

Rd = conv_4u_to_sf(Rs.uw[0]);

Rd=convert_w2sf(Rs)

Rd = conv_4s_to_sf(Rs.s32);

Rdd=convert_d2df(Rss)

Rdd = conv_8s_to_df(Rss.s64);

Rdd=convert_ud2df(Rss)

Rdd = conv_8u_to_df(Rss.u64);

Rdd=convert_uw2df(Rs)

Rdd = conv_4u_to_df(Rs.uw[0]);

Rdd=convert_w2df(Rs)

Rdd = conv_4s_to_df(Rs.s32);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=convert_d2sf(Rss)

Word32 Q6_R_convert_d2sf_P(Word64 Rss)

Rd=convert_ud2sf(Rss)

Word32 Q6_R_convert_ud2sf_P(Word64 Rss)

Rd=convert_uw2sf(Rs)

Word32 Q6_R_convert_uw2sf_R(Word32 Rs)

Rd=convert_w2sf(Rs)

Word32 Q6_R_convert_w2sf_R(Word32 Rs)

Rdd=convert_d2df(Rss)

Word64 Q6_P_convert_d2df_P(Word64 Rss)

Rdd=convert_ud2df(Rss)

Word64 Q6_P_convert_ud2df_P(Word64 Rss)

Rdd=convert_uw2df(Rs)

Word64 Q6_P_convert_uw2df_R(Word32 Rs)

Rdd=convert_w2df(Rs)

Word64 Q6_P_convert_w2df_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

0

1

0

d

d

d

d

d Rdd=convert_ud2df(Rss)

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

0

1

1

d

d

d

d

d Rdd=convert_d2df(Rss)

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rdd=convert_uw2df(Rs)

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

0

d

d

d

d

d Rdd=convert_w2df(Rs)

1

0

0

0

1

0

0

0

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_ud2sf(Rss)

1

0

0

0

1

0

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_d2sf(Rss)

1

0

0

0

1

0

1

1

0

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=convert_uw2sf(Rs)

1

0

0

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=convert_w2sf(Rs)

80-N2040-46 Rev. B

524

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

525

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Convert floating-point value to integer
Convert floating point values. If rounding is required, it happens according to the rounding
mode unless the :chop option is specified. If the value is out of range of the destination
integer type, the INVALID flag is raised and closest integer is chosen, including for
infinite inputs. For NaN inputs, the INVALID flag is also raised, and the output value is
IMPLEMENTATION DEFINED.
Syntax

Behavior

Rd=convert_df2uw(Rss)

Rd = conv_df_to_4u(Rss).uw[0];

Rd=convert_df2uw(Rss):chop

round_to_zero();
Rd = conv_df_to_4u(Rss).uw[0];

Rd=convert_df2w(Rss)

Rd = conv_df_to_4s(Rss).s32;

Rd=convert_df2w(Rss):chop

round_to_zero();
Rd = conv_df_to_4s(Rss).s32;

Rd=convert_sf2uw(Rs)

Rd = conv_sf_to_4u(Rs).uw[0];

Rd=convert_sf2uw(Rs):chop

round_to_zero();
Rd = conv_sf_to_4u(Rs).uw[0];

Rd=convert_sf2w(Rs)

Rd = conv_sf_to_4s(Rs).s32;

Rd=convert_sf2w(Rs):chop

round_to_zero();
Rd = conv_sf_to_4s(Rs).s32;

Rdd=convert_df2d(Rss)

Rdd = conv_df_to_8s(Rss).s64;

Rdd=convert_df2d(Rss):chop

round_to_zero();
Rdd = conv_df_to_8s(Rss).s64;

Rdd=convert_df2ud(Rss)

Rdd = conv_df_to_8u(Rss).u64;

Rdd=convert_df2ud(Rss):chop

round_to_zero();
Rdd = conv_df_to_8u(Rss).u64;

Rdd=convert_sf2d(Rs)

Rdd = conv_sf_to_8s(Rs).s64;

Rdd=convert_sf2d(Rs):chop

round_to_zero();
Rdd = conv_sf_to_8s(Rs).s64;

Rdd=convert_sf2ud(Rs)

Rdd = conv_sf_to_8u(Rs).u64;

Rdd=convert_sf2ud(Rs):chop

round_to_zero();
Rdd = conv_sf_to_8u(Rs).u64;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rd=convert_df2uw(Rss)

Word32 Q6_R_convert_df2uw_P(Word64 Rss)

Rd=convert_df2uw(Rss):chop

Word32 Q6_R_convert_df2uw_P_chop(Word64 Rss)

Rd=convert_df2w(Rss)

Word32 Q6_R_convert_df2w_P(Word64 Rss)

Rd=convert_df2w(Rss):chop

Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)

Rd=convert_sf2uw(Rs)

Word32 Q6_R_convert_sf2uw_R(Word32 Rs)

Rd=convert_sf2uw(Rs):chop

Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)

526

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rd=convert_sf2w(Rs)

Word32 Q6_R_convert_sf2w_R(Word32 Rs)

Rd=convert_sf2w(Rs):chop

Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)

Rdd=convert_df2d(Rss)

Word64 Q6_P_convert_df2d_P(Word64 Rss)

Rdd=convert_df2d(Rss):chop

Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)

Rdd=convert_df2ud(Rss)

Word64 Q6_P_convert_df2ud_P(Word64 Rss)

Rdd=convert_df2ud(Rss):chop

Word64 Q6_P_convert_df2ud_P_chop(Word64 Rss)

Rdd=convert_sf2d(Rs)

Word64 Q6_P_convert_sf2d_R(Word32 Rs)

Rdd=convert_sf2d(Rs):chop

Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)

Rdd=convert_sf2ud(Rs)

Word64 Q6_P_convert_sf2ud_R(Word32 Rs)

Rdd=convert_sf2ud(Rs):chop

Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

0

0

0

d

d

d

d

d Rdd=convert_df2d(Rss)

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

0

0

1

d

d

d

d

d Rdd=convert_df2ud(Rss)

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

1

1

0

d

d

d

d

Rdd=convert_df2d(Rss):ch
d op

1

0

0

0

0

0

0

0

1

1

1

s

s

s

s

s

P

P 0

-

-

-

-

-

1

1

1

d

d

d

d

d Rdd=convert_df2ud(Rss):c
hop

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

1

d

d

d

d

d Rdd=convert_sf2ud(Rs)

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rdd=convert_sf2d(Rs)

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

Rdd=convert_sf2ud(Rs):ch
d op

1

0

0

0

0

1

0

0

1

-

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rdd=convert_sf2d(Rs):cho
p

1

0

0

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_df2uw(Rss)

1

0

0

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_df2w(Rss)

1

0

0

0

1

0

0

0

1

0

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

Rd=convert_df2uw(Rss):ch
d op

1

0

0

0

1

0

0

0

1

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_df2w(Rss):cho
p

1

0

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=convert_sf2uw(Rs)

1

0

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_sf2uw(Rs):cho
p

1

0

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=convert_sf2w(Rs)

1

0

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

1

d

d

d

d

d Rd=convert_sf2w(Rs):chop

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

527

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point extreme value assistance
For divide and square root routines, certain values are problematic for the default routine.
These instructions appropriately fix up the numerator (fixupn), denominator (fixupd), or
radicand (fixupr) for proper calculations when combined with the divide or square root
approximation instructions.
Syntax

Behavior

Rd=sffixupd(Rs,Rt)

(Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
Rd = Rt;

Rd=sffixupn(Rs,Rt)

(Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);
Rd = Rs;

Rd=sffixupr(Rs)

(Rs,Rd,adjust)=invsqrt_common(Rs);
Rd = Rs;

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sffixupd(Rs,Rt)

Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32 Rt)

Rd=sffixupn(Rs,Rt)

Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32 Rt)

Rd=sffixupr(Rs)

Word32 Q6_R_sffixupr_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

ICLASS

0

1

MajOp
1

1

RegType

0

s5
1

s

s

MajOp

s

8

7

-

0

Parse
s

s

s5

P

P

6

5

4

3

d

d

MinOp
-

-

-

Parse

-

-

t5

0

0

2

1

0

d

d Rd=sffixupr(Rs)

d5

MinOp

d
d5

1

1

1

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=sffixupn(Rs,Rt)

1

1

1

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=sffixupd(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

528

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point fused multiply-add
Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
precision is kept.
Syntax

Behavior

Rx+=sfmpy(Rs,Rt)

Rx=fmaf(Rs,Rt,Rx);

Rx-=sfmpy(Rs,Rt)

Rx=fmaf(-Rs,Rt,Rx);

Rxx+=dfmpyhh(Rss,Rtt)

Rxx = Rss*Rtt with partial product Rxx;

Rxx+=dfmpylh(Rss,Rtt)

Rxx += (Rss.uw[0] * (0x00100000 | zxt20>64(Rtt.uw[1]))) << 1;

Class: XTYPE (slots 2,3)
Intrinsics
Rx+=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rxx+=dfmpyhh(Rss,Rtt)

Word64 Q6_P_dfmpyhhacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=dfmpylh(Rss,Rtt)

Word64 Q6_P_dfmpylhacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

1

MajOp
0

0

0

0

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

0

1

1

2

1

0

x

x Rxx+=dfmpylh(Rss,Rtt)

x5
x

x

x

1

1

1

0

1

0

1

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

x

x

x

x

x Rxx+=dfmpyhh(Rss,Rtt)

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

x

x

x

x

x Rx+=sfmpy(Rs,Rt)

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

x Rx-=sfmpy(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x

529

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point fused multiply-add with scaling
Multiply two values, and add to (or subtract from) the accumulator. Keep full intermediate
precision. Additionally, scale the output. This instruction has special handling of corner
cases. If a multiplicand source is zero and a NaN is not produced, the accumulator is left
unchanged; this means the sign of a zero accumulator does not change if the product is a
true zero. The scaling factor is the predicate taken as a two's compliment number for
single precision. The scaling factor is twice the predicate taken as a two's compliment
number for double precision. The implementation can change denormal accumulator
values to zero for positive scale factors.
Syntax

Behavior

Rx+=sfmpy(Rs,Rt,Pu):scale

PREDUSE_TIMING;
if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
NaN;
;
tmp=fmaf(Rs,Rt,Rx) * 2**(Pu);
if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
tmp;

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx, Word32
Rs, Word32 Rt, Byte Pu)

Rx+=sfmpy(Rs,Rt,Pu):scale

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

1

1

MajOp
1

0

1

Field name
ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
u2
x5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

u2
t

t

1

u

u

2

1

0

x

Rx+=sfmpy(Rs,Rt,Pu):scal
x e

x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x

530

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point reciprocal square root approximation
Provides an approximation of the reciprocal square root of the radicand (Rs), if combined
with the appropriate fixup instruction. Certain values (such as infinities or zeros) in the
numerator or denominator may yield values that are not reciprocal approximations, but
yield the correct answer when combined with fixup instructions and the appropriate
routines.
For compatibility, exact results of these instructions can not be relied on. The precision of
the approximation for this architecture and later is at least 6.6 bits.
Syntax

Behavior

Rd,Pe=sfinvsqrta(Rs)

if ((Rs,Rd,adjust)=invsqrt_common(Rs)) {
Pe = adjust;
idx = (Rs >> 17) & 0x7f;
mant = (invsqrt_lut[idx] << 15);
exp = 127 - ((exponent(Rs) - 127) >> 1) - 1;
Rd = -1**Rs.31 * 1.MANT * 2**(exp-BIAS);
}

Class: XTYPE (slots 2,3)
Notes
■

This instruction provides a certain amount of accuracy. In future versions the
accuracy may increase. For future compatibility, dependence on exact values must
be avoided.

■

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically ANDed with another predicate.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

0

1

MajOp
1

1

1

Field name
ICLASS
Parse
d5
e2
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
1

s

s

s

8

7

6

Parse
s

s

P

P

5

4

3

e2
-

-

-

-

-

-

0

e

2

1

0

d

d Rd,Pe=sfinvsqrta(Rs)

d5
e

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Major Opcode
Minor Opcode
Register Type

531

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point fused multiply-add for library routines
Multiply two values, and add to (or subtract from) the accumulator. Full intermediate
precision is kept. This instruction has special handling of corner cases. Addition of
infinities with opposite signs, or subtraction of infinities with like signs, is defined as
(positive) zero. Rounding is always Nearest-Even, except that overflows to infinity round
to maximal finite values. If a multiplicand source is zero and a NaN is not produced, the
accumulator is left unchanged; this means the sign of a zero accumulator does not change
if the product is a true zero. Flags and Exceptions are not generated.
Syntax

Behavior

Rx+=sfmpy(Rs,Rt):lib

round_to_nearest();
infminusinf = ((isinf(Rx)) && (isinf(Rs*Rt)) &&
(Rs ^ Rx ^ Rt.31 != 0));
infinp = (isinf(Rx)) || (isinf(Rt)) ||
(isinf(Rs));
if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
NaN;
;
tmp=fmaf(Rs,Rt,Rx);
if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
tmp;
cancel_flags();
if (isinf(Rx) && !infinp) Rx = Rx - 1;
if (infminusinf) Rx = 0;

Rx-=sfmpy(Rs,Rt):lib

round_to_nearest();
infminusinf = ((isinf(Rx)) && (isinf(Rs*Rt)) &&
(Rs ^ Rx ^ Rt.31 == 0));
infinp = (isinf(Rx)) || (isinf(Rt)) ||
(isinf(Rs));
if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx =
NaN;
;
tmp=fmaf(-Rs,Rt,Rx);
if (!((Rx == 0.0) && is_true_zero(Rs*Rt))) Rx =
tmp;
cancel_flags();
if (isinf(Rx) && !infinp) Rx = Rx - 1;
if (infminusinf) Rx = 0;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx+=sfmpy(Rs,Rt):lib

Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=sfmpy(Rs,Rt):lib

Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx, Word32
Rs, Word32 Rt)

532

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

x5

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

x Rx+=sfmpy(Rs,Rt):lib

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

x Rx-=sfmpy(Rs,Rt):lib

Field name
ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x

533

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Create floating-point constant
Using ten bits of immediate, form a floating-point constant.
Syntax

Behavior

Rd=sfmake(#u10):neg

Rd = (127 - 6) << 23;
Rd += (#u << 17);
Rd |= (1 << 31);

Rd=sfmake(#u10):pos

Rd = (127 - 6) << 23;
Rd += #u << 17;

Rdd=dfmake(#u10):neg

Rdd = (1023ULL - 6) << 52;
Rdd += (#u) << 46;
Rdd |= ((1ULL) << 63);

Rdd=dfmake(#u10):pos

Rdd = (1023ULL - 6) << 52;
Rdd += (#u) << 46;

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfmake(#u10):neg

Word32 Q6_R_sfmake_I_neg(Word32 Iu10)

Rd=sfmake(#u10):pos

Word32 Q6_R_sfmake_I_pos(Word32 Iu10)

Rdd=dfmake(#u10):neg

Word64 Q6_P_dfmake_I_neg(Word32 Iu10)

Rdd=dfmake(#u10):pos

Word64 Q6_P_dfmake_I_pos(Word32 Iu10)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

1

0

1

0

1

1

0

0

0

i

-

-

-

-

-

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=sfmake(#u10):pos

1

1

0

1

0

1

1

0

0

1

i

-

-

-

-

-

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=sfmake(#u10):neg

ICLASS

RegType

Parse

d5

1

1

0

1

1

0

0

1

0

0

i

-

-

-

-

-

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=dfmake(#u10):pos

1

1

0

1

1

0

0

1

0

1

i

-

-

-

-

-

P

P

i

i

i

i

i

i

i

i

i

d

d

d

d

d Rdd=dfmake(#u10):neg

Field name
RegType
MinOp
ICLASS
Parse
d5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d

534

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point maximum
Maximum of two floating point values. If one value is a NaN, the other is chosen.
Syntax

Behavior

Rd=sfmax(Rs,Rt)

Rd = fmaxf(Rs,Rt);

Rdd=dfmax(Rss,Rtt)

Rdd = fmax(Rss,Rtt);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfmax(Rs,Rt)

Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)

Rdd=dfmax(Rss,Rtt)

Word64 Q6_P_dfmax_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfmax(Rss,Rtt)

1

1

1

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=sfmax(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

535

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point minimum
Minimum of two floating point values. If one value is a NaN, the other is chosen.
Syntax

Behavior

Rd=sfmin(Rs,Rt)

Rd = fmin(Rs,Rt);

Rdd=dfmin(Rss,Rtt)

Rdd = fmin(Rss,Rtt);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfmin(Rs,Rt)

Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)

Rdd=dfmin(Rss,Rtt)

Word64 Q6_P_dfmin_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfmin(Rss,Rtt)

1

1

1

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=sfmin(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

536

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point multiply
Multiply two floating point values
Syntax

Behavior

Rd=sfmpy(Rs,Rt)

Rd=Rs*Rt;

Rdd=dfmpyfix(Rss,Rtt)

if (is_denormal(Rss) && (df_exponent(Rtt) >=
512) && is_normal(Rtt)) Rdd = Rss * 0x1.0p52;
else if (is_denormal(Rtt) && (df_exponent(Rss)
>= 512) && is_normal(Rss)) Rdd = Rss * 0x1.0p-52;
else Rdd = Rss;

Rdd=dfmpyll(Rss,Rtt)

prod = (Rss.uw[0] * Rtt.uw[0]);
Rdd = (prod >> 32) << 1;
if (prod.uw[0] != 0) Rdd.0 = 1;

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)

Rdd=dfmpyfix(Rss,Rtt)

Word64 Q6_P_dfmpyfix_PP(Word64 Rss, Word64 Rtt)

Rdd=dfmpyll(Rss,Rtt)

Word64 Q6_P_dfmpyll_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfmpyfix(Rss,Rtt)

1

1

1

0

1

0

0

0

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfmpyll(Rss,Rtt)

1

1

1

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=sfmpy(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

537

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point reciprocal approximation
Provides an approximation of the reciprocal of the denominator (Rt), if combined with the
appropriate fixup instructions. Certain values (such as infinities or zeros) in the numerator
or denominator may yield values that are not reciprocal approximations, but yield the
correct answer when combined with fixup instructions and the appropriate routines.
For compatibility, exact results of these instructions can not be relied on. The precision of
the approximation for this architecture and later is at least 6.6 bits.
Syntax

Behavior

Rd,Pe=sfrecipa(Rs,Rt)

if ((Rs,Rt,Rd,adjust)=recip_common(Rs,Rt)) {
Pe = adjust;
idx = (Rt >> 16) & 0x7f;
mant = (recip_lut[idx] << 15) | 1;
exp = 127 - (exponent(Rt) - 127) - 1;
Rd = -1**Rt.31 * 1.MANT * 2**(exp-BIAS);
}

Class: XTYPE (slots 2,3)
Notes
■

This instruction provides a certain amount of accuracy. In future versions the
accuracy may increase. For future compatibility, dependence on exact values must
be avoided.

■

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically ANDed with another predicate.

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

1

MajOp
1

1

1

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
e2
s5
t5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

6

t5
t

t

t

5

4

3

e2
t

t

1

e

2

1

0

d

d Rd,Pe=sfrecipa(Rs,Rt)

d5
e

d

d

d

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register e
Field to encode register s
Field to encode register t

538

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Floating point subtraction
Subtract two floating point values
Syntax

Behavior

Rd=sfsub(Rs,Rt)

Rd=Rs-Rt;

Rdd=dfsub(Rss,Rtt)

Rdd=Rss-Rtt;

Class: XTYPE (slots 2,3)
Intrinsics
Rd=sfsub(Rs,Rt)

Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)

Rdd=dfsub(Rss,Rtt)

Word64 Q6_P_dfsub_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=dfsub(Rss,Rtt)

1

1

1

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=sfsub(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

11.10.5

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

XTYPE/MPY
The XTYPE/MPY instruction subclass includes instructions which perform
multiplication.

80-N2040-46 Rev. B

539

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Multiply and use lower result
Multiply the signed 32-bit integer in Rs by either the signed 32-bit integer in Rt or an
unsigned immediate value. The 64-bit result is optionally accumulated with the 32-bit
destination, or added to an immediate. The least-significant 32-bits of the result are written
to the single destination register.
This multiply produces the correct results for the ANSI C multiplication of two signed or
unsigned integers with an integer result.
Rs
Rt /#u8

*
64

Add
Low 32-bits

32

Rx

80-N2040-46 Rev. B

Syntax

Behavior

Rd=+mpyi(Rs,#u8)

apply_extension(#u);
Rd=Rs*#u;

Rd=-mpyi(Rs,#u8)

Rd=Rs*-#u;

Rd=add(#u6,mpyi(Rs,#U6))

apply_extension(#u);
Rd = #u + Rs*#U;

Rd=add(#u6,mpyi(Rs,Rt))

apply_extension(#u);
Rd = #u + Rs*Rt;

Rd=add(Ru,mpyi(#u6:2,Rs))

Rd = Ru + Rs*#u;
;

Rd=add(Ru,mpyi(Rs,#u6))

apply_extension(#u);
Rd = Ru + Rs*#u;
;

Rd=mpyi(Rs,#m9)

if ("((#m9<0) && (#m9>-256))") {
Assembler mapped to: "Rd=-mpyi(Rs,#m9*(1))";
} else {
Assembler mapped to: "Rd=+mpyi(Rs,#m9)";
}

Rd=mpyi(Rs,Rt)

Rd=Rs*Rt;

540

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=mpyui(Rs,Rt)

Assembler mapped to: "Rd=mpyi(Rs,Rt)"

Rx+=mpyi(Rs,#u8)

apply_extension(#u);
Rx=Rx + (Rs*#u);
;

Rx+=mpyi(Rs,Rt)

Rx=Rx + Rs*Rt;
;

Rx-=mpyi(Rs,#u8)

apply_extension(#u);
Rx=Rx - (Rs*#u);
;

Rx-=mpyi(Rs,Rt)

Rx=Rx - Rs*Rt;
;

Ry=add(Ru,mpyi(Ry,Rs))

Ry = Ru + Rs*Ry;
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rd=add(#u6,mpyi(Rs,#U6))

Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32 Rs,
Word32 IU6)

Rd=add(#u6,mpyi(Rs,Rt))

Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32 Rs,
Word32 Rt)

Rd=add(Ru,mpyi(#u6:2,Rs))

Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32
Iu6_2, Word32 Rs)

Rd=add(Ru,mpyi(Rs,#u6))

Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32 Rs,
Word32 Iu6)

Rd=mpyi(Rs,#m9)

Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)

Rd=mpyi(Rs,Rt)

Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)

Rd=mpyui(Rs,Rt)

Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)

Rx+=mpyi(Rs,#u8)

Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu8)

Rx+=mpyi(Rs,Rt)

Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpyi(Rs,#u8)

Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32 Rs,
Word32 Iu8)

Rx-=mpyi(Rs,Rt)

Word32 Q6_R_mpyinac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Ry=add(Ru,mpyi(Ry,Rs))

Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32 Ry,
Word32 Rs)

541

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
1

0

ICLASS
1

1

0

1

1

1

1

0

1

1

1

0

1

1

1

1

s5
1

0

i

i

s

s

0

0

0

I

0

0

1

1

1

0

1

1

1

1

0

1

Parse
s

s

i

i

s

s

s

i

i

s

s

i

i

s

s

MajOp
1

0

RegType

s

s

0

0

s

s

s

s

s

s

s

s

s

P

P

P

t

t

s

s

i

d

d

P

i

d

d

P

P

i

d

d

P

t

t

i

i

d

d

i

i

5

4

3

i

d

d

i

I

I

MinOp

2

1

0

d

d

d Rd=add(#u6,mpyi(Rs,Rt))

I

I

I

u

u

u Rd=add(Ru,mpyi(#u6:2,Rs)
)

u

u

u Rd=add(Ru,mpyi(Rs,#u6))

u

u Ry=add(Ru,mpyi(Ry,Rs))

d5

d
d5

P

P

t

6

d5

Parse

s5

7

t5
i

Parse

s5

MajOp

P

Parse

s5

RegType

ICLASS

s
s5

RegType

ICLASS
1

1

RegType

ICLASS
1

1

8

d

d

d

i

i

i

u

u

d

d

d

i

i

i

u

u

y5
-

y

y

y

Rd=add(#u6,mpyi(Rs,#U6))

u5

u5
y

y

-

Parse

-

-

u

u

MinOp

u
d5

1

1

1

0

0

0

0

0

0

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=+mpyi(Rs,#u8)

1

1

1

0

0

0

0

0

1

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

d

d

d

d

d Rd=-mpyi(Rs,#u8)

ICLASS

RegType

MajOp

s5

Parse

MinOp

x5

1

1

1

0

0

0

0

1

0

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

x

x

x

x

x Rx+=mpyi(Rs,#u8)

1

1

1

0

0

0

0

1

1

-

-

s

s

s

s

s

P

P 0

i

i

i

i

i

i

i

i

x

x

x

x

x Rx-=mpyi(Rs,#u8)

d

d Rd=mpyi(Rs,Rt)

ICLASS
1

1

1

RegType
0

1

ICLASS

1

0

MajOp
1

0

RegType

0

0

s5
s

s

MajOp

s

Parse
s

s

s5

P

P 0

t5
t

t

Parse

t

MinOp
t

t

0

t5

0

0

d5
d

d

MinOp

d
x5

1

1

1

0

1

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rx+=mpyi(Rs,Rt)

1

1

1

0

1

1

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rx-=mpyi(Rs,Rt)

Field name
RegType
MajOp
MinOp
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
u5
x5
y5

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Minor Opcode
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u
Field to encode register x
Field to encode register y

542

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply word by signed half (32x16)
Perform mixed precision vector multiply operations. A 32-bit word from vector Rss is
multiplied by a 16-bit halfword (either even or odd) from vector Rtt. The multiplication is
performed as a signed 32x16, which produces a 48-bit result. This result is optionally
scaled left by one bit. This result is then shifted right by 16 bits, optionally accumulated
and then saturated to 32-bits. This operation is available in vector form
(vmpyweh/vmpywoh) and non-vector form (multiply and use upper result).

s16

s16

s16

mux

mux

s32

s32

*

*

48

0x0

<<0-1

Rtt

s16

Rss

48

0x8000

0x0

<<0-1

mux

0x8000
mux

Add

Add

>>16

>>16

Add

Add

Sat_32

Sat_32

32

32

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:
sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.h[2])[<<1]+0x8000)>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.h[0])[<<1]+0x8000)>>16);

543

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.h[2])[<<1])>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.h[0])[<<1])>>16);

Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:
sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.h[3])[<<1]+0x8000)>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.h[1])[<<1]+0x8000)>>16);

Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.h[3])[<<1])>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.h[1])[<<1])>>16);

Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd
:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.h[2])[<<1]+0x8000)>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.h[0])[<<1]+0x8000)>>16));
;

Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.h[2])[<<1])>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.h[0])[<<1])>>16));
;

Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd
:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.h[3])[<<1]+0x8000)>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.h[1])[<<1]+0x8000)>>16 ));
;

Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.h[3])[<<1])>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.h[1])[<<1])>>16 ));
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sa
t

Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpyweh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vmpyweh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpyweh(Rss,Rtt):sat

Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss, Word64
Rtt)

544

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sa
t

Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpywoh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vmpywoh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpywoh(Rss,Rtt):sat

Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss, Word64
Rtt)

Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:s
at

Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyweh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyweh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyweh(Rss,Rtt):sat

Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:s
at

Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywoh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywoh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywoh(Rss,Rtt):sat

Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

d

d

d

d

Rdd=vmpyweh(Rss,Rtt)[:<<
d N]:sat

1

1

1

0

1

0

0

0

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=vmpywoh(Rss,Rtt)[:<<
N]:sat

1

1

1

0

1

0

0

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vmpyweh(Rss,Rtt)[:<<
N]:rnd:sat

1

1

1

0

1

0

0

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

Rdd=vmpywoh(Rss,Rtt)[:<<
d N]:rnd:sat

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

Rxx+=vmpyweh(Rss,Rtt)[:<
x <N]:sat

1

1

1

0

1

0

1

0

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

x Rxx+=vmpywoh(Rss,Rtt)[:<
<N]:sat

1

1

1

0

1

0

1

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

x Rxx+=vmpyweh(Rss,Rtt)[:<
<N]:rnd:sat

1

1

1

0

1

0

1

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

Rxx+=vmpywoh(Rss,Rtt)[:<
x <N]:rnd:sat

Field name
ICLASS
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type

545

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

546

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply word by unsigned half (32x16)
Perform mixed precision vector multiply operations. A 32-bit signed word from vector
Rss is multiplied by a 16-bit unsigned halfword (either odd or even) from vector Rtt. This
multiplication produces a 48-bit result. This result is optionally scaled left by one bit, and
then a rounding constant is optionally added to the lower 16-bits. This result is then shifted
right by 16 bits, optionally accumulated and then saturated to 32-bits. This is a dual vector
operation and is performed for both high and low word of Rss.

u16

u16

u16

mux

mux

s32

s32

*

*

48

0x0

<<0-1

Rtt

u16

Rss

48

0x8000

0x0

<<0-1

mux

0x8000
mux

Add

Add

>>16

>>16

Add

Add

Sat_32

Sat_32

32

32

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd
:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.uh[2])[<<1]+0x8000)>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.uh[0])[<<1]+0x8000)>>16);

547

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.uh[2])[<<1])>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.uh[0])[<<1])>>16);

Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd
:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.uh[3])[<<1]+0x8000)>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.uh[1])[<<1]+0x8000)>>16);

Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat

Rdd.w[1]=sat_32(((Rss.w[1] *
Rtt.uh[3])[<<1])>>16);
Rdd.w[0]=sat_32(((Rss.w[0] *
Rtt.uh[1])[<<1])>>16);

Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rn
d:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.uh[2])[<<1]+0x8000)>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.uh[0])[<<1]+0x8000)>>16));
;

Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sa
t

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.uh[2])[<<1])>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.uh[0])[<<1])>>16));
;

Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rn
d:sat

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.uh[3])[<<1]+0x8000)>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.uh[1])[<<1]+0x8000)>>16 ));
;

Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sa
t

Rxx.w[1]=sat_32(Rxx.w[1] + (((Rss.w[1] *
Rtt.uh[3])[<<1])>>16));
Rxx.w[0]=sat_32(Rxx.w[0] + (((Rss.w[0] *
Rtt.uh[1])[<<1])>>16 ));
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:s
at

Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):sat

Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss, Word64
Rtt)

548

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rdd=vmpywouh(Rss,Rtt):<<1:rnd:s
at

Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpywouh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpywouh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss,
Word64 Rtt)

Rdd=vmpywouh(Rss,Rtt):sat

Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss, Word64
Rtt)

Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:
sat

Word64 Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64
Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpyweuh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyweuh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyweuh(Rss,Rtt):sat

Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:
sat

Word64 Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64
Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpywouh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywouh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpywouh(Rss,Rtt):sat

Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

d

d

d

d

Rdd=vmpyweuh(Rss,Rtt)[:<
d <N]:sat

1

1

1

0

1

0

0

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

d Rdd=vmpywouh(Rss,Rtt)[:<
<N]:sat

1

1

1

0

1

0

0

0

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vmpyweuh(Rss,Rtt)[:<
<N]:rnd:sat

1

1

1

0

1

0

0

0

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

d

d

d

d

Rdd=vmpywouh(Rss,Rtt)[:<
d <N]:rnd:sat

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

Rxx+=vmpyweuh(Rss,Rtt)[:
x <<N]:sat

1

1

1

0

1

0

1

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

x Rxx+=vmpywouh(Rss,Rtt)[:
<<N]:sat

1

1

1

0

1

0

1

0

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

x Rxx+=vmpyweuh(Rss,Rtt)[:
<<N]:rnd:sat

1

1

1

0

1

0

1

0

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

x

x

x

x

Rxx+=vmpywouh(Rss,Rtt)[:
x <<N]:rnd:sat

Field name
ICLASS
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type

549

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

550

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Multiply signed halfwords
Multiply two signed halfwords. Optionally shift the multiplier result by 1 bit. This result
can be accumulated or rounded. The destination/accumulator can be either 32 or 64-bits.
For 32-bit results, saturation is optional.
Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat]
Rd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat]

Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]
Rdd = mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd]

Rs

Rt

Rs

Rt

mux

mux

mux

mux

16x16
32

16x16
0x0 0x8000

0x0 0x8000

32

<<0-1

<<0-1
mux

mux

64-bit Add/
Sub

32-bit
Add/Sub

Optional Sat
to 32-bits

Rxx

Rx

80-N2040-46 Rev. B

Syntax

Behavior

Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:
rnd][:sat]

Rd=[sat_32]([round]((Rs.h[01] *
Rt.h[01])[<<1]));
;

Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][
:rnd]

Rdd=[round]((Rs.h[01] * Rt.h[01])[<<1]);
;

Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][
:sat]

Rx=[sat_32](Rx+ (Rs.h[01] * Rt.h[01])[<<1]);
;

Rx=mpy(Rs.[HL],Rt.[HL])[:<<1][:sa
t]

Rx=[sat_32](Rx- (Rs.h[01] * Rt.h[01])[<<1]);
;

Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1]

Rxx=Rxx+ (Rs.h[01] * Rt.h[01])[<<1];
;

551

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1]

Rxx=Rxx- (Rs.h[01] * Rt.h[01])[<<1];
;

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rd=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1:rnd

Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.H):rnd

Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):rnd:sat

Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1:rnd

Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.L):rnd

Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):rnd:sat

Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1:rnd

Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs, Word32
Rt)

552

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Rd=mpy(Rs.L,Rt.H):rnd

Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):rnd:sat

Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1:rnd

Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.L,Rt.L):rnd

Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):rnd:sat

Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H):<<1:rnd

Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs, Word32
Rt)

Rdd=mpy(Rs.H,Rt.H):rnd

Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L):<<1:rnd

Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs, Word32
Rt)

Rdd=mpy(Rs.H,Rt.L):rnd

Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H):<<1:rnd

Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs, Word32
Rt)

Rdd=mpy(Rs.L,Rt.H):rnd

Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L):<<1:rnd

Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs, Word32
Rt)

Rdd=mpy(Rs.L,Rt.L):rnd

Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx, Word32
Rs, Word32 Rt)

553

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Rx+=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx, Word32
Rs, Word32 Rt)

554

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rx-=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

sH tH

2

1

0

d5

1

1

1

0

0

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

0

d

d

d

d

d Rdd=mpy(Rs.L,Rt.L)[:<<N]

1

1

1

0

0

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

1

d

d

d

d

d Rdd=mpy(Rs.L,Rt.H)[:<<N]

1

1

1

0

0

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

0

d

d

d

d

d Rdd=mpy(Rs.H,Rt.L)[:<<N]

1

1

1

0

0

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

1

d

d

d

d

d Rdd=mpy(Rs.H,Rt.H)[:<<N]

80-N2040-46 Rev. B

555

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

1

1

0

0

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

0

d

d

d

d

d

Rdd=mpy(Rs.L,Rt.L)[:<<N]:
rnd

1

1

1

0

0

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

1

d

d

d

d

d

Rdd=mpy(Rs.L,Rt.H)[:<<N]:
rnd

1

1

1

0

0

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

0

d

d

d

d

d

Rdd=mpy(Rs.H,Rt.L)[:<<N]:
rnd

1

1

1

0

0

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

1

d

d

d

d

Rdd=mpy(Rs.H,Rt.H)[:<<N]
d :rnd

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

x5

1

1

1

0

0

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

Rxx+=mpy(Rs.L,Rt.L)[:<<N
x ]

1

1

1

0

0

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x

1

1

1

0

0

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

Rxx+=mpy(Rs.H,Rt.L)[:<<N
x ]

1

1

1

0

0

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

x

1

1

1

0

0

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx-=mpy(Rs.L,Rt.L)[:<<N]

Rxx+=mpy(Rs.L,Rt.H)[:<<N
]

Rxx+=mpy(Rs.H,Rt.H)[:<<
N]

1

1

1

0

0

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx-=mpy(Rs.L,Rt.H)[:<<N]

1

1

1

0

0

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx-=mpy(Rs.H,Rt.L)[:<<N]

1

1

1

0

0

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

Rxxx =mpy(Rs.H,Rt.H)[:<<N]

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

d5

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=mpy(Rs.L,Rt.L)[:<<N]

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpy(Rs.L,Rt.H)[:<<N]

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rd=mpy(Rs.H,Rt.L)[:<<N]

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rd=mpy(Rs.H,Rt.H)[:<<N]

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rd=mpy(Rs.L,Rt.L)[:<<N]:s
at

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

Rd=mpy(Rs.L,Rt.H)[:<<N]:s
d at

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

d Rd=mpy(Rs.H,Rt.L)[:<<N]:s
at

1

1

1

0

1

1

0

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rd=mpy(Rs.H,Rt.H)[:<<N]:
sat

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

Rd=mpy(Rs.L,Rt.L)[:<<N]:r
d nd

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpy(Rs.L,Rt.H)[:<<N]:r
nd

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rd=mpy(Rs.H,Rt.L)[:<<N]:r
nd

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

Rd=mpy(Rs.H,Rt.H)[:<<N]:r
d nd

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rd=mpy(Rs.L,Rt.L)[:<<N]:r
nd:sat

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rd=mpy(Rs.L,Rt.H)[:<<N]:r
nd:sat

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

d

d

d

d

Rd=mpy(Rs.H,Rt.L)[:<<N]:r
d nd:sat

1

1

1

0

1

1

0

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

d

d

d

d

d Rd=mpy(Rs.H,Rt.H)[:<<N]:r
nd:sat

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

x5

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rx+=mpy(Rs.L,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rx+=mpy(Rs.L,Rt.H)[:<<N]

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rx+=mpy(Rs.H,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

x Rx+=mpy(Rs.H,Rt.H)[:<<N]

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

x

x

x

x

Rx+=mpy(Rs.L,Rt.L)[:<<N]:
x sat

80-N2040-46 Rev. B

556

Hexagon V68 Programmer’s Reference Manual

Instruction Set

31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9

8

7

6

5

4

3

2

1

0

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

x

x

x

x

x

Rx+=mpy(Rs.L,Rt.H)[:<<N]:
sat

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

x

x

x

x

x

Rx+=mpy(Rs.H,Rt.L)[:<<N]:
sat

1

1

1

0

1

1

1

0

N 0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

x

x

x

x

x

Rx+=mpy(Rs.H,Rt.H)[:<<N]
:sat

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rx-=mpy(Rs.L,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rx-=mpy(Rs.L,Rt.H)[:<<N]

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rx-=mpy(Rs.H,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

x Rx-=mpy(Rs.H,Rt.H)[:<<N]

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

x

x

x

x

x

Rx=mpy(Rs.L,Rt.L)[:<<N]:sat

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

x

x

x

x

x

Rx=mpy(Rs.L,Rt.H)[:<<N]:sat

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

x

x

x

x

x

Rx=mpy(Rs.H,Rt.L)[:<<N]:sat

1

1

1

0

1

1

1

0

N 0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

x

x

x

x

x Rx=mpy(Rs.H,Rt.H)[:<<N]:sat

Field name
ICLASS
MajOp
MinOp
RegType
sH
tH
sH
tH
sH
tH
sH
tH
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Rs is High
Rt is High
Rs is High
Rt is High
Rs is High
Rt is High
Rs is High
Rt is High
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

557

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Multiply unsigned halfwords
Multiply two unsigned halfwords. Scale the result by 0-3 bits. Optionally, add or subtract
the result from the accumulator.
Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]
Rdd = mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]
Rd = mpyu(Rs.[HL],Rt.[HL])[:<<1]
Rs

Rt

Rs

Rt

mux

mux

mux

mux

16x16
32

16x16
0x0

0x0

32

<<0-1

<<0-1
mux

mux

64-bit Add/
Sub

32-bit
Add/Sub
Rx

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rd=(Rs.uh[01] * Rt.uh[01])[<<1];
;

Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rdd=(Rs.uh[01] * Rt.uh[01])[<<1];
;

Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rx=Rx+ (Rs.uh[01] * Rt.uh[01])[<<1];
;

Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rx=Rx- (Rs.uh[01] * Rt.uh[01])[<<1];
;

Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1
]

Rxx=Rxx+ (Rs.uh[01] * Rt.uh[01])[<<1];
;

Rxx=mpyu(Rs.[HL],Rt.[HL])[:<<1]

Rxx=Rxx- (Rs.uh[01] * Rt.uh[01])[<<1];
;

558

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rd=mpyu(Rs.H,Rt.H)

UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.H):<<1

UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.L)

UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.L):<<1

UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.H)

UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.H):<<1

UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.L)

UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.L):<<1

UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.H)

UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.H):<<1

UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.L)

UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.L):<<1

UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.H)

UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.H):<<1

UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.L)

UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.L):<<1

UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.H,Rt.H)

Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpyu(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpyu(Rs.H,Rt.L)

Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpyu(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.H)

Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpyu(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.L)

Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=mpyu(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.H)

Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpyu(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.L)

Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpyu(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx, Word32
Rs, Word32 Rt)

559

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Rx-=mpyu(Rs.L,Rt.H)

Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpyu(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpyu(Rs.L,Rt.L)

Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=mpyu(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx, Word32
Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.H)

Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.L)

Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.H)

Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.L)

Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.H)

Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.L)

Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.H)

Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.L)

Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx, Word32
Rs, Word32 Rt)

560

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

sH tH

2

1

0

d5
Rdd=mpyu(Rs.L,Rt.L)[:<<N
]

1

1

1

0

0

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

0

d

d

d

d

d

1

1

1

0

0

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

0

1

d

d

d

d

d Rdd=mpyu(Rs.L,Rt.H)[:<<N
]

1

1

1

0

0

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

0

d

d

d

d

d

1

1

1

0

0

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

1

1

d

d

d

d

d Rdd=mpyu(Rs.H,Rt.H)[:<<
N]

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

Rdd=mpyu(Rs.H,Rt.L)[:<<N
]

x5
Rxx+=mpyu(Rs.L,Rt.L)[:<<
N]

1

1

1

0

0

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x

1

1

1

0

0

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=mpyu(Rs.L,Rt.H)[:<<
N]

1

1

1

0

0

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=mpyu(Rs.H,Rt.L)[:<<
N]

1

1

1

0

0

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

Rxx+=mpyu(Rs.H,Rt.H)[:<<
x N]

1

1

1

0

0

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx=mpyu(Rs.L,Rt.L)[:<<N]

1

1

1

0

0

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx=mpyu(Rs.L,Rt.H)[:<<N]

1

1

1

0

0

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

Rxxx =mpyu(Rs.H,Rt.L)[:<<N]

1

1

1

0

0

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

x Rxx=mpyu(Rs.H,Rt.H)[:<<N]

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

d5

1

1

1

0

1

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=mpyu(Rs.L,Rt.L)[:<<N]

1

1

1

0

1

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpyu(Rs.L,Rt.H)[:<<N]

1

1

1

0

1

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rd=mpyu(Rs.H,Rt.L)[:<<N]

1

1

1

0

1

1

0

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rd=mpyu(Rs.H,Rt.H)[:<<N]

ICLASS

RegType

MajOp

s5

Parse

t5

sH tH

x5

1

1

1

0

1

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rx+=mpyu(Rs.L,Rt.L)[:<<N
]

1

1

1

0

1

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

Rx+=mpyu(Rs.L,Rt.H)[:<<N
x ]

1

1

1

0

1

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rx+=mpyu(Rs.H,Rt.L)[:<<N
]

1

1

1

0

1

1

1

0

N 1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

x Rx+=mpyu(Rs.H,Rt.H)[:<<
N]

1

1

1

0

1

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

x

x

x

x

x Rx-=mpyu(Rs.L,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

1

x

x

x

x

x Rx-=mpyu(Rs.L,Rt.H)[:<<N]

1

1

1

0

1

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

x

x

x

x

x Rx-=mpyu(Rs.H,Rt.L)[:<<N]

1

1

1

0

1

1

1

0

N 1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

x

x

x

x

Rxx =mpyu(Rs.H,Rt.H)[:<<N]

Field name
ICLASS
MajOp
MinOp
RegType
sH
tH

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Rs is High
Rt is High

561

Hexagon V68 Programmer’s Reference Manual

Field name
sH
tH
sH
tH
sH
tH
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Rs is High
Rt is High
Rs is High
Rt is High
Rs is High
Rt is High
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

562

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Polynomial multiply words
Perform a 32x32 carryless polynomial multiply using 32-bit source registers Rs and Rt.
The 64-bit result is optionally accumulated (XORed) with the destination register. Finite
field multiply instructions are useful for many algorithms including scramble code
generation, cryptographic algorithms, convolutional, and Reed Solomon codes.
Rxx += pmpyw(Rs,Rt)

Rs

Rt

32x32
Carryless
Polynomial
mpy

*

XOR

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=pmpyw(Rs,Rt)

x = Rs.uw[0];
y = Rt.uw[0];
prod = 0;
for(i=0; i < 32; i++) {
if((y >> i) & 1) prod ^= (x << i);
}
Rdd = prod;

Rxx^=pmpyw(Rs,Rt)

x = Rs.uw[0];
y = Rt.uw[0];
prod = 0;
for(i=0; i < 32; i++) {
if((y >> i) & 1) prod ^= (x << i);
}
Rxx ^= prod;

563

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=pmpyw(Rs,Rt)

Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)

Rxx^=pmpyw(Rs,Rt)

Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

0

ICLASS
1

1

1

1

0

MajOp
1

0

RegType
0

0

1

1

1

1

0

ICLASS
MajOp
MinOp
RegType
Parse

s5
t5
x5

80-N2040-46 Rev. B

s

s

MajOp
0

Field name

d5

0

s5

1

s

Parse
s

s

s5
s

s

s

P

P 0

t

t

Parse
s

s

P

P 0

8

7

t5
t

t

t

1

t5
t

t

t

6

5

4

3

MinOp
1

1

d

d

MinOp
t

t

1

1

1

2

1

0

d

d Rdd=pmpyw(Rs,Rt)

x

x Rxx^=pmpyw(Rs,Rt)

d5
d
x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

564

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce multiply word by signed half (32x16)
Perform mixed precision vector multiply operations and accumulate the results. A 32-bit
word from vector Rss is multiplied by a 16-bit halfword (either even or odd) from vector
Rtt. The multiplication is performed as a signed 32x16, which produces a 48-bit result.
This result is optionally scaled left by one bit. A similar operation is performed for both
words in Rss, and the two results are accumulated. The final result is optionally
accumulated with Rxx.

s16

s16

s16

s16

mux

Rtt

mux

s32

s32

*

*

48

48

<<0-1

<<0-1

Rss

Add

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vrmpyweh(Rss,Rtt)[:<<1]

Rdd = (Rss.w[1] * Rtt.h[2])[<<1] + (Rss.w[0] *
Rtt.h[0])[<<1];
;

Rdd=vrmpywoh(Rss,Rtt)[:<<1]

Rdd = (Rss.w[1] * Rtt.h[3])[<<1] + (Rss.w[0] *
Rtt.h[1])[<<1];
;

Rxx+=vrmpyweh(Rss,Rtt)[:<<1]

Rxx += (Rss.w[1] * Rtt.h[2])[<<1] + (Rss.w[0] *
Rtt.h[0])[<<1];
;

Rxx+=vrmpywoh(Rss,Rtt)[:<<1]

Rxx += (Rss.w[1] * Rtt.h[3])[<<1] + (Rss.w[0] *
Rtt.h[1])[<<1];
;

565

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vrmpyweh(Rss,Rtt)

Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64 Rtt)

Rdd=vrmpyweh(Rss,Rtt):<<1

Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss, Word64
Rtt)

Rdd=vrmpywoh(Rss,Rtt)

Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64 Rtt)

Rdd=vrmpywoh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss, Word64
Rtt)

Rxx+=vrmpyweh(Rss,Rtt)

Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vrmpyweh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vrmpywoh(Rss,Rtt)

Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vrmpywoh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

d

d

d

d

Rdd=vrmpywoh(Rss,Rtt)[:<
d <N]

1

1

1

0

1

0

0

0

N 1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vrmpyweh(Rss,Rtt)[:<
<N]

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

N 0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

x Rxx+=vrmpyweh(Rss,Rtt)[:
<<N]

1

1

1

0

1

0

1

0

N 1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

x Rxx+=vrmpywoh(Rss,Rtt)[:
<<N]

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

566

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Multiply and use upper result
Multiply two signed or unsigned 32-bit words. Take the upper 32-bits of this results store
to a single destination register. Optional rounding is available.

Rs
Rt

32x32
64

Rd
Syntax

Behavior

Rd=mpy(Rs,Rt.H):<<1:rnd:sat

Rd = sat_32(((Rs * Rt.h[1])<<1+0x8000)>>16);

Rd=mpy(Rs,Rt.H):<<1:sat

Rd = sat_32(((Rs * Rt.h[1])<<1)>>16);

Rd=mpy(Rs,Rt.L):<<1:rnd:sat

Rd = sat_32(((Rs * Rt.h[0])<<1+0x8000)>>16);

Rd=mpy(Rs,Rt.L):<<1:sat

Rd = sat_32(((Rs * Rt.h[0])<<1)>>16);

Rd=mpy(Rs,Rt)

Rd=(Rs * Rt)>>32;

Rd=mpy(Rs,Rt):<<1

Rd=(Rs * Rt)>>31;

Rd=mpy(Rs,Rt):<<1:sat

Rd=sat_32((Rs * Rt)>>31);

Rd=mpy(Rs,Rt):rnd

Rd=((Rs * Rt)+0x80000000)>>32;

Rd=mpysu(Rs,Rt)

Rd=(Rs * Rt.uw[0])>>32;

Rd=mpyu(Rs,Rt)

Rd=(Rs.uw[0] * Rt.uw[0])>>32;

Rx+=mpy(Rs,Rt):<<1:sat

Rx=sat_32((Rx) + ((Rs * Rt)>>31));
;

Rx-=mpy(Rs,Rt):<<1:sat

Rx=sat_32((Rx) - ((Rs * Rt)>>31));
;

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

567

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=mpy(Rs,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs,Rt.H):<<1:sat

Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs, Word32
Rt)

Rd=mpy(Rs,Rt.L):<<1:sat

Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt)

Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):<<1

Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):rnd

Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32 Rt)

Rd=mpysu(Rs,Rt)

Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs,Rt)

UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)

Rx+=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Rx-=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx, Word32
Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

1

0

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpy(Rs,Rt):rnd

1

1

1

0

1

1

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpyu(Rs,Rt)

1

1

1

0

1

1

0

1

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpysu(Rs,Rt)

1

1

1

0

1

1

0

1

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=mpy(Rs,Rt.H):<<1:sat

1

1

1

0

1

1

0

1

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rd=mpy(Rs,Rt.L):<<1:sat

1

1

1

0

1

1

0

1

1

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

Rd=mpy(Rs,Rt.H):<<1:rnd:
d sat

1

1

1

0

1

1

0

1

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rd=mpy(Rs,Rt):<<1:sat

1

1

1

0

1

1

0

1

1

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

d

d

d

d

Rd=mpy(Rs,Rt.L):<<1:rnd:s
d at

1

1

0

1

1

0

1

N 0

N

s

s

s

s

s

P

P 0

t

t

t

t

t

0

N N

d

d

d

d

d Rd=mpy(Rs,Rt)[:<<N]

1

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

1

1

1

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rx+=mpy(Rs,Rt):<<1:sat

1

1

1

0

1

1

1

1

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rx-=mpy(Rs,Rt):<<1:sat

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d

568

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Field to encode register x

569

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Multiply and use full result
Multiply two signed or unsigned 32-bit words. Optionally, add or subtract this value from
the 64-bit accumulator. The result is a full-precision 64-bit value.

Rs
Rt

32x32
64

64-bit Add/Sub

Rxx
Syntax

Behavior

Rdd=mpy(Rs,Rt)

Rdd=(Rs * Rt);

Rdd=mpyu(Rs,Rt)

Rdd=(Rs.uw[0] * Rt.uw[0]);

Rxx[+-]=mpy(Rs,Rt)

Rxx= Rxx [+-] (Rs * Rt);
;

Rxx[+-]=mpyu(Rs,Rt)

Rxx= Rxx [+-] (Rs.uw[0] * Rt.uw[0]);
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=mpy(Rs,Rt)

Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs,Rt)

UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs,Rt)

Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=mpyu(Rs,Rt)

Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpy(Rs,Rt)

Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx-=mpyu(Rs,Rt)

Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

570

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

0

1

0

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=mpy(Rs,Rt)

1

1

1

0

0

1

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=mpyu(Rs,Rt)

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

0

1

1

1

0

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx+=mpy(Rs,Rt)

1

1

1

0

0

1

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx-=mpy(Rs,Rt)

1

1

1

0

0

1

1

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx+=mpyu(Rs,Rt)

1

1

1

0

0

1

1

1

0

1

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

x

x

x

x

x Rxx-=mpyu(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

571

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector dual multiply
Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
two lower results are scaled and added. The lower word of the accumulator is optionally
added. This result is saturated to 32-bits and stored in the lower word of the accumulator.
The same operation is performed on the upper two products using the upper word of the
accumulator.

Rxx+=vdmpy(Rss,Rtt):sat
Rss
Rtt

*

*

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32

High Accumulation

Low Accumulation

32

32

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vdmpy(Rss,Rtt):<<1:sat

Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<1 +
(Rss.h[1] * Rtt.h[1])<<1);
Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<1 +
(Rss.h[3] * Rtt.h[3])<<1);

Rdd=vdmpy(Rss,Rtt):sat

Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<0 +
(Rss.h[1] * Rtt.h[1])<<0);
Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<0 +
(Rss.h[3] * Rtt.h[3])<<0);

572

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx+=vdmpy(Rss,Rtt):<<1:sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.h[0])<<1 + (Rss.h[1] * Rtt.h[1])<<1);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
Rtt.h[2])<<1 + (Rss.h[3] * Rtt.h[3])<<1);
;

Rxx+=vdmpy(Rss,Rtt):sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.h[0])<<0 + (Rss.h[1] * Rtt.h[1])<<0);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
Rtt.h[2])<<0 + (Rss.h[3] * Rtt.h[3])<<0);
;

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vdmpy(Rss,Rtt):<<1:sat

Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vdmpy(Rss,Rtt):sat

Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vdmpy(Rss,Rtt):<<1:sat

Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vdmpy(Rss,Rtt):sat

Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS
1

1

1

0

0

MajOp
0

N 0

RegType
0

1

0

1

0

N 0

ICLASS
MajOp
MinOp
RegType
Parse

80-N2040-46 Rev. B

s

s

MajOp

Field name

d5

0

s5

0

s

Parse
s

s

s5
s

s

s

P

P 0

t

t

Parse
s

s

P

P 0

8

7

t5
t

t

t

1

t5
t

t

t

6

5

4

3

MinOp
0

0

d

d

MinOp
t

t

1

0

0

2

1

0

d

d Rdd=vdmpy(Rss,Rtt)[:<<N]:
sat

x

x Rxx+=vdmpy(Rss,Rtt)[:<<N
]:sat

d5
d
x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d

573

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Field to encode register x

574

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector dual multiply with round and pack
Multiply four 16-bit halfwords in Rss by the corresponding 16-bit halfwords in Rtt. The
two lower results are scaled and added together with a rounding constant. This result is
saturated to 32-bits, and the upper 16-bits of this result are stored in the lower 16-bits of
the destination register. The same operation is performed on the upper two products and
the result is stored in the upper 16-bit halfword of the destination.

Rd=vdmpy(Rss,Rtt):rnd:sat
Rss
Rtt

*
0x8000

*

*

*

32

32

32

32

<<0-1

<<0-1

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32
High 16bits

0x8000

High 16bits

Rd
Syntax

Behavior

Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat

Rd.h[0]=(sat_32((Rss.h[0] * Rtt.h[0])[<<1] +
(Rss.h[1] * Rtt.h[1])[<<1] + 0x8000)).h[1];
Rd.h[1]=(sat_32((Rss.h[2] * Rtt.h[2])[<<1] +
(Rss.h[3] * Rtt.h[3])[<<1] + 0x8000)).h[1];

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

575

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=vdmpy(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss,
Word64 Rtt)

Rd=vdmpy(Rss,Rtt):rnd:sat

Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

0

0

MajOp
1

N 0

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

0

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

0

0

0

2

1

0

d

d

d5
d

d

d

Rd=vdmpy(Rss,Rtt)[:<<N]:r
nd:sat

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

576

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce multiply bytes
Multiply eight 8-bit bytes in Rss by the corresponding 8-bit bytes in Rtt. The four lower
results are accumulated. The lower word of the accumulator is optionally added. This
result is stored in the lower 32-bits of the accumulator. The same operation is performed
on the upper four products using the upper word of the accumulator. The eight bytes of
Rss can be treated as either signed or unsigned.

Rss
Rtt

*

*

*
16

16

*

16

16

*

*

*
16

Add

16

16

*
16

Add

32

32

High Accumulation

Low Accumulation
Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vrmpybsu(Rss,Rtt)

Rdd.w[0]=((Rss.b[0] * Rtt.ub[0]) + (Rss.b[1] *
Rtt.ub[1]) + (Rss.b[2] * Rtt.ub[2]) + (Rss.b[3]
* Rtt.ub[3]));
Rdd.w[1]=((Rss.b[4] * Rtt.ub[4]) + (Rss.b[5] *
Rtt.ub[5]) + (Rss.b[6] * Rtt.ub[6]) + (Rss.b[7]
* Rtt.ub[7]));

Rdd=vrmpybu(Rss,Rtt)

Rdd.w[0]=((Rss.ub[0] * Rtt.ub[0]) + (Rss.ub[1] *
Rtt.ub[1]) + (Rss.ub[2] * Rtt.ub[2]) +
(Rss.ub[3] * Rtt.ub[3]));
Rdd.w[1]=((Rss.ub[4] * Rtt.ub[4]) + (Rss.ub[5] *
Rtt.ub[5]) + (Rss.ub[6] * Rtt.ub[6]) +
(Rss.ub[7] * Rtt.ub[7]));

Rxx+=vrmpybsu(Rss,Rtt)

Rxx.w[0]=(Rxx.w[0] + (Rss.b[0] * Rtt.ub[0]) +
(Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] * Rtt.ub[2])
+ (Rss.b[3] * Rtt.ub[3]));
Rxx.w[1]=(Rxx.w[1] + (Rss.b[4] * Rtt.ub[4]) +
(Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] * Rtt.ub[6])
+ (Rss.b[7] * Rtt.ub[7]));
;

577

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx+=vrmpybu(Rss,Rtt)

Rxx.w[0]=(Rxx.w[0] + (Rss.ub[0] * Rtt.ub[0]) +
(Rss.ub[1] * Rtt.ub[1]) + (Rss.ub[2] *
Rtt.ub[2]) + (Rss.ub[3] * Rtt.ub[3]));
Rxx.w[1]=(Rxx.w[1] + (Rss.ub[4] * Rtt.ub[4]) +
(Rss.ub[5] * Rtt.ub[5]) + (Rss.ub[6] *
Rtt.ub[6]) + (Rss.ub[7] * Rtt.ub[7]));
;

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vrmpybsu(Rss,Rtt)

Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64 Rtt)

Rdd=vrmpybu(Rss,Rtt)

Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrmpybsu(Rss,Rtt)

Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Rxx+=vrmpybu(Rss,Rtt)

Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vrmpybu(Rss,Rtt)

1

1

1

0

1

0

0

0

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vrmpybsu(Rss,Rtt)

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

1

0

1

0

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=vrmpybu(Rss,Rtt)

1

1

1

0

1

0

1

0

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=vrmpybsu(Rss,Rtt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

578

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector dual multiply signed by unsigned bytes
Multiply eight 8-bit signed bytes in Rss by the corresponding 8-bit unsigned bytes in Rtt.
Add the results in pairs, and optionally add the accumulator. The results are saturated to
signed 16-bits and stored in the four halfwords of the destination register.

Rss
Rtt

*

*
16

16

*

*
16

16

*

*
16

16

*

*
16

16

Add

Add

Add

Add

Sat_16

Sat_16

Sat_16

Sat_16
Rxx

Syntax

Behavior

Rdd=vdmpybsu(Rss,Rtt):sat

Rdd.h[0]=sat_16(((Rss.b[0] * Rtt.ub[0]) +
(Rss.b[1] * Rtt.ub[1])));
Rdd.h[1]=sat_16(((Rss.b[2] * Rtt.ub[2]) +
(Rss.b[3] * Rtt.ub[3])));
Rdd.h[2]=sat_16(((Rss.b[4] * Rtt.ub[4]) +
(Rss.b[5] * Rtt.ub[5])));
Rdd.h[3]=sat_16(((Rss.b[6] * Rtt.ub[6]) +
(Rss.b[7] * Rtt.ub[7])));

Rxx+=vdmpybsu(Rss,Rtt):sat

Rxx.h[0]=sat_16((Rxx.h[0] + (Rss.b[0] *
Rtt.ub[0]) + (Rss.b[1] * Rtt.ub[1])));
Rxx.h[1]=sat_16((Rxx.h[1] + (Rss.b[2] *
Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3])));
Rxx.h[2]=sat_16((Rxx.h[2] + (Rss.b[4] *
Rtt.ub[4]) + (Rss.b[5] * Rtt.ub[5])));
Rxx.h[3]=sat_16((Rxx.h[3] + (Rss.b[6] *
Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7])));
;

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

579

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rdd=vdmpybsu(Rss,Rtt):sat

Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss, Word64
Rtt)

Rxx+=vdmpybsu(Rss,Rtt):sat

Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS
1

1

1

0

0

MajOp
0

1

RegType
0

1

0

1

0

0

0

ICLASS
MajOp
MinOp
RegType
Parse

s5
t5
x5

80-N2040-46 Rev. B

s

s

MajOp
0

Field name

d5

1

s5

1

s

Parse
s

s

s5
s

s

s

P

P 0

t

t

Parse
s

s

P

P 0

8

7

t5
t

t

t

0

t5
t

t

t

6

5

4

3

MinOp
0

1

d

d

MinOp
t

t

0

0

1

2

1

0

d

d

x

x Rxx+=vdmpybsu(Rss,Rtt):s
at

d5
d

Rdd=vdmpybsu(Rss,Rtt):sa
t

x5
x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

580

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply even halfwords
Multiply the even 16-bit halfwords from Rss and Rtt separately. Optionally accumulate
with the low and high words of the destination register pair and optionally saturate.
Rxx+=vmpyeh(Rss,Rtt):sat
Rss
Rtt

*

*
32

32

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32

32

32

High Accumulation

Low Accumulation
Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vmpyeh(Rss,Rtt):<<1:sat

Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<1);
Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<1);

Rdd=vmpyeh(Rss,Rtt):sat

Rdd.w[0]=sat_32((Rss.h[0] * Rtt.h[0])<<0);
Rdd.w[1]=sat_32((Rss.h[2] * Rtt.h[2])<<0);

Rxx+=vmpyeh(Rss,Rtt)

Rxx.w[0]=Rxx.w[0] + (Rss.h[0] * Rtt.h[0]);
Rxx.w[1]=Rxx.w[1] + (Rss.h[2] * Rtt.h[2]);
;

Rxx+=vmpyeh(Rss,Rtt):<<1:sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.h[0])<<1);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
Rtt.h[2])<<1);
;

Rxx+=vmpyeh(Rss,Rtt):sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rss.h[0] *
Rtt.h[0])<<0);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rss.h[2] *
Rtt.h[2])<<0);
;

581

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vmpyeh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss, Word64
Rtt)

Rdd=vmpyeh(Rss,Rtt):sat

Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss, Word64
Rtt)

Rxx+=vmpyeh(Rss,Rtt)

Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

Rxx+=vmpyeh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx,
Word64 Rss, Word64 Rtt)

Rxx+=vmpyeh(Rss,Rtt):sat

Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx, Word64
Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS

0

0

MajOp
0

N 0

RegType

0

s5
s

s

MajOp

s

Parse
s

s

s5

P

P 0

8

7

t5
t

t

Parse

t

6

5

4

3

MinOp
t

t

1

t5

1

0

2

1

0

d

Rdd=vmpyeh(Rss,Rtt)[:<<N
d ]:sat

d5
d

d

MinOp

d
x5

1

1

1

0

1

0

1

0

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

x

x

x

x

x Rxx+=vmpyeh(Rss,Rtt)

1

1

1

0

1

0

1

0

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

x

x

x

x

x Rxx+=vmpyeh(Rss,Rtt)[:<<
N]:sat

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

582

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply halfwords
Multiply two 16-bit halfwords separately, and optionally accumulate with the low and
high words of the destination. Optionally saturate, and store the results back to the
destination register pair.
Rxx+=vmpyh(Rs,Rt):sat
Rs
Rt

*

*

32

32

<<0-1

<<0-1

Add

Add

Sat_32

Sat_32

32

32

High Accumulation

Low Accumulation
Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vmpyh(Rs,Rt)[:<<1]:sat

Rdd.w[0]=sat_32((Rs.h[0] * Rt.h[0])[<<1]);
Rdd.w[1]=sat_32((Rs.h[1] * Rt.h[1])[<<1]);

Rxx+=vmpyh(Rs,Rt)

Rxx.w[0]=Rxx.w[0] + (Rs.h[0] * Rt.h[0]);
Rxx.w[1]=Rxx.w[1] + (Rs.h[1] * Rt.h[1]);
;

Rxx+=vmpyh(Rs,Rt)[:<<1]:sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
Rt.h[0])[<<1]);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
Rt.h[1])[<<1]);
;

583

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vmpyh(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs, Word32
Rt)

Rdd=vmpyh(Rs,Rt):sat

Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32 Rt)

Rxx+=vmpyh(Rs,Rt)

Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=vmpyh(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

Rxx+=vmpyh(Rs,Rt):sat

Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

0

ICLASS

1

0

MajOp
1

N 0

RegType

0

s5
s

s

MajOp

s

Parse
s

s

s5

P

P 0

8

7

t5
t

t

Parse

t

6

5

4

3

MinOp
t

t

1

t5

0

1

2

1

0

d

d Rdd=vmpyh(Rs,Rt)[:<<N]:s
at

d5
d

d

MinOp

d
x5

1

1

1

0

0

1

1

1

0

0

1

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=vmpyh(Rs,Rt)

1

1

1

0

0

1

1

1

N 0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

x

x

x

x

Rxx+=vmpyh(Rs,Rt)[:<<N]:
x sat

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

584

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply halfwords with round and pack
Multiply two 16-bit halfwords separately. Round the results, and store the high halfwords
packed in a single register destination.
Rd=vmpyh(Rs,Rt):rnd:sat
Rs
Rt

*
0x8000

*

32

32

<<0-1

<<0-1

0x8000

Add

Add

Sat_32

Sat_32

High 16-bits

High 16-bits
Rd

Syntax

Behavior

Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat

Rd.h[1]=(sat_32((Rs.h[1] * Rt.h[1])[<<1] +
0x8000)).h[1];
Rd.h[0]=(sat_32((Rs.h[0] * Rt.h[0])[<<1] +
0x8000)).h[1];

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

585

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=vmpyh(Rs,Rt):<<1:rnd:sat

Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs,
Word32 Rt)

Rd=vmpyh(Rs,Rt):rnd:sat

Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs, Word32
Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

1

0

MajOp
1

N 0

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5

80-N2040-46 Rev. B

1

s5
s

s

s

Parse
s

s

P

P 0

8

7

t5
t

t

t

6

5

4

3

MinOp
t

t

1

1

1

2

1

0

d

d

d5
d

d

d

Rd=vmpyh(Rs,Rt)[:<<N]:rn
d:sat

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

586

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply halfwords, signed by unsigned
Multiply two 16-bit halfwords. Rs is considered signed, Ru unsigned.
Syntax

Behavior

Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat

Rdd.w[0]=sat_32((Rs.h[0] * Rt.uh[0])[<<1]);
Rdd.w[1]=sat_32((Rs.h[1] * Rt.uh[1])[<<1]);

Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat

Rxx.w[0]=sat_32(Rxx.w[0] + (Rs.h[0] *
Rt.uh[0])[<<1]);
Rxx.w[1]=sat_32(Rxx.w[1] + (Rs.h[1] *
Rt.uh[1])[<<1]);
;

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rdd=vmpyhsu(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs, Word32
Rt)

Rdd=vmpyhsu(Rs,Rt):sat

Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs, Word32 Rt)

Rxx+=vmpyhsu(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64 Rxx,
Word32 Rs, Word32 Rt)

Rxx+=vmpyhsu(Rs,Rt):sat

Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx, Word32
Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

0

ICLASS
1

1

1

1

0

MajOp
1

N 0

RegType
0

0

1

1

1

N 1

ICLASS
MajOp
MinOp
RegType
Parse

80-N2040-46 Rev. B

s

s

MajOp

Field name

d5

0

s5

1

s

Parse
s

s

s5
s

s

s

P

P 0

s

P

P 0

7

t5
t

t

Parse
s

8

t

t

t

5

4

3

MinOp
t

t

1

t5
t

6

1

1

t

1

0

1

1

0

d

d Rdd=vmpyhsu(Rs,Rt)[:<<N]
:sat

x

x Rxx+=vmpyhsu(Rs,Rt)[:<<
N]:sat

d5
d

d

MinOp
t

2

d
x5

x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d

587

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
x5

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Field to encode register x

588

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector reduce multiply halfwords
Multiply each halfword of Rss by the corresponding halfword in Rtt. Add the intermediate
products together and then optionally add the accumulator. Store the full 64-bit result in
the destination register pair.
Rss
Rtt

*

*

*
32

32

32

*
32

Add
64

64-bit Register Pair

Rdd

Syntax

Behavior

Rdd=vrmpyh(Rss,Rtt)

Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
Rtt.h[3]);

Rxx+=vrmpyh(Rss,Rtt)

Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *
Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) + (Rss.h[3] *
Rtt.h[3]);
;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rdd=vrmpyh(Rss,Rtt)

Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrmpyh(Rss,Rtt)

Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64 Rss,
Word64 Rtt)

589

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

1

ICLASS
1

1

1

0

0

MajOp
0

0

RegType
0

1

0

1

0

0

0

ICLASS
MajOp
MinOp
RegType
Parse

s5
t5
x5

80-N2040-46 Rev. B

s5
s

s

MajOp
0

Field name

d5

0

0

s

Parse
s

s

s5
s

s

s

P

P 0

s

P

P 0

7

t

0

t5
t

t

Parse
s

8

t

t

t

5

4

3

d

d

MinOp
t

t5
t

6
1

0

t

0

1

0

1

0

d

d Rdd=vrmpyh(Rss,Rtt)

x

x Rxx+=vrmpyh(Rss,Rtt)

d5

MinOp
t

2
d
x5

x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

590

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector multiply bytes
Four 8-bit bytes from register Rs are multiplied by four 8-bit bytes from Rt. The product is
optionally accumulated with the 16-bit value from the destination register. The 16-bit
results are packed in the destination register pair. The bytes of Rs can be treated as either
signed or unsigned.

Rs
Rt

*
Add

*
Add

*

*
Add

Add

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vmpybsu(Rs,Rt)

Rdd.h[0]=((Rs.b[0] * Rt.ub[0]));
Rdd.h[1]=((Rs.b[1] * Rt.ub[1]));
Rdd.h[2]=((Rs.b[2] * Rt.ub[2]));
Rdd.h[3]=((Rs.b[3] * Rt.ub[3]));

Rdd=vmpybu(Rs,Rt)

Rdd.h[0]=((Rs.ub[0] * Rt.ub[0]));
Rdd.h[1]=((Rs.ub[1] * Rt.ub[1]));
Rdd.h[2]=((Rs.ub[2] * Rt.ub[2]));
Rdd.h[3]=((Rs.ub[3] * Rt.ub[3]));

Rxx+=vmpybsu(Rs,Rt)

Rxx.h[0]=(Rxx.h[0]+(Rs.b[0] * Rt.ub[0]));
Rxx.h[1]=(Rxx.h[1]+(Rs.b[1] * Rt.ub[1]));
Rxx.h[2]=(Rxx.h[2]+(Rs.b[2] * Rt.ub[2]));
Rxx.h[3]=(Rxx.h[3]+(Rs.b[3] * Rt.ub[3]));
;

Rxx+=vmpybu(Rs,Rt)

Rxx.h[0]=(Rxx.h[0]+(Rs.ub[0] * Rt.ub[0]));
Rxx.h[1]=(Rxx.h[1]+(Rs.ub[1] * Rt.ub[1]));
Rxx.h[2]=(Rxx.h[2]+(Rs.ub[2] * Rt.ub[2]));
Rxx.h[3]=(Rxx.h[3]+(Rs.ub[3] * Rt.ub[3]));
;

591

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vmpybsu(Rs,Rt)

Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32 Rt)

Rdd=vmpybu(Rs,Rt)

Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)

Rxx+=vmpybsu(Rs,Rt)

Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Rxx+=vmpybu(Rs,Rt)

Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

Parse

8

7

t5

6

5

4

3

MinOp

2

1

0

d5

1

1

1

0

0

1

0

1

0

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vmpybsu(Rs,Rt)

1

1

1

0

0

1

0

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

d

d

d

d

d Rdd=vmpybu(Rs,Rt)

ICLASS

RegType

MajOp

s5

Parse

t5

MinOp

x5

1

1

1

0

0

1

1

1

1

0

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=vmpybu(Rs,Rt)

1

1

1

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

x

x

x

x

x Rxx+=vmpybsu(Rs,Rt)

Field name
ICLASS
MajOp
MinOp
RegType
Parse
d5
s5
t5
x5

80-N2040-46 Rev. B

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

592

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector polynomial multiply halfwords
Perform a vector 16x16 carryless polynomial multiply using 32-bit source registers Rs and
Rt. The 64-bit result is stored in packed H,H,L,L format in the destination register. The
destination register can also be optionally accumulated (XORed). Finite field multiply
instructions are useful for many algorithms including scramble code generation,
cryptographic algorithms, convolutional, and Reed Solomon codes.
Rxx += vpmpyh(Rs,Rt)

Rs

Rt

16x16
Carryless
Polynomial
Mpy

*

*

XOR

XOR

16x16
Carryless
Polynomial
Mpy

Rxx

80-N2040-46 Rev. B

Syntax

Behavior

Rdd=vpmpyh(Rs,Rt)

x0 = Rs.uh[0];
x1 = Rs.uh[1];
y0 = Rt.uh[0];
y1 = Rt.uh[1];
prod0 = prod1 = 0;
for(i=0; i < 16; i++) {
if((y0 >> i) & 1) prod0 ^= (x0 << i);
if((y1 >> i) & 1) prod1 ^= (x1 << i);
}
Rdd.h[0]=prod0.uh[0];
Rdd.h[1]=prod1.uh[0];
Rdd.h[2]=prod0.uh[1];
Rdd.h[3]=prod1.uh[1];

593

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx^=vpmpyh(Rs,Rt)

x0 = Rs.uh[0];
x1 = Rs.uh[1];
y0 = Rt.uh[0];
y1 = Rt.uh[1];
prod0 = prod1 = 0;
for(i=0; i < 16; i++) {
if((y0 >> i) & 1) prod0 ^= (x0 << i);
if((y1 >> i) & 1) prod1 ^= (x1 << i);
}
Rxx.h[0]=Rxx.uh[0] ^ prod0.uh[0];
Rxx.h[1]=Rxx.uh[1] ^ prod1.uh[0];
Rxx.h[2]=Rxx.uh[2] ^ prod0.uh[1];
Rxx.h[3]=Rxx.uh[3] ^ prod1.uh[1];

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vpmpyh(Rs,Rt)

Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)

Rxx^=vpmpyh(Rs,Rt)

Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx, Word32 Rs,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

1

RegType
0

0

ICLASS
1

1

1

1

0

MajOp
1

1

RegType
0

0

1

1

1

1

1

ICLASS
MajOp
MinOp
RegType
Parse
s5
t5
x5

80-N2040-46 Rev. B

s5
s

s

MajOp
0

Field name

d5

0

1

s

Parse
s

s

s5
s

s

s

P

P 0

s

P

P 0

7

t

1

t5
t

t

Parse
s

8

t

t

t

5

4

3

d

d

MinOp
t

t5
t

6
1

1

t

1

1

1

1

0

d

d Rdd=vpmpyh(Rs,Rt)

x

x Rxx^=vpmpyh(Rs,Rt)

d5

MinOp
t

2
d
x5

x

x

x

Description
Instruction Class
Major Opcode
Minor Opcode
Register Type
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register x

594

Hexagon V68 Programmer’s Reference Manual

11.10.6

Instruction Set

XTYPE/PERM
The XTYPE/PERM instruction subclass includes instructions which perform
permutations.

CABAC decode bin
This is a special-purpose instruction to support H.264 Context Adaptive Binary
Arithmetic Coding (CABAC). See Section X.X for a complete description.
Syntax

Behavior

Rdd=decbin(Rss,Rtt)

state = Rtt.w[1][5:0];
valMPS = Rtt.w[1][8:8];
bitpos = Rtt.w[0][4:0];
range = Rss.w[0];
offset = Rss.w[1];
range <<= bitpos;
offset <<= bitpos;
rLPS = rLPS_table_64x4[state][ (range >>29)&3];
rLPS = rLPS << 23;
rMPS= (range&0xff800000) - rLPS;
if (offset < rMPS) {
Rdd = AC_next_state_MPS_64[state];
Rdd[8:8]=valMPS;
Rdd[31:23]=(rMPS>>23);
Rdd.w[1]=offset;
P0=valMPS;
} else {
Rdd = AC_next_state_LPS_64[state];
Rdd[8:8]=((!state)?(1-valMPS):(valMPS));
Rdd[31:23]=(rLPS>>23);
Rdd.w[1]=(offset-rMPS);
P0=(valMPS^1);
}

Class: XTYPE (slots 2,3)
Notes

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically ANDed with another predicate.

■

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

0

0

Maj
1

1

1

Field name
ICLASS
Parse
d5

80-N2040-46 Rev. B

s5
-

s

s

s

Parse
s

s

P

P

8

7

t

1

t5
-

t

t

t

6

5

4

3

-

d

d

Min
t

1

2

1

0

d

d Rdd=decbin(Rss,Rtt)

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d

595

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

596

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Saturate
Saturate a single scalar value.
sath saturates a signed 32-bit number to a signed 16-bit number, which is sign-extended
back to 32 bits and placed in the destination register. The minimum negative value of the
result is 0xffff8000 and the maximum positive value is 0x00007fff.
satuh saturates a signed 32-bit number to an unsigned 16-bit number, which is zeroextended back to 32 bits and placed in the destination register. The minimum value of the
result is 0 and the maximum value is 0x0000ffff.
satb saturates a signed 32-bit number to an signed 8-bit number, which is sign-extended
back to 32 bits and placed in the destination register. The minimum value of the result is
0xffffff80 and the maximum value is 0x0000007f.
satub saturates a signed 32-bit number to an unsigned 8-bit number, which is zeroextended back to 32 bits and placed in the destination register. The minimum value of the
result is 0 and the maximum value is 0x000000ff.
Syntax

Behavior

Rd=sat(Rss)

Rd = sat_32(Rss);

Rd=satb(Rs)

Rd = sat_8(Rs);

Rd=sath(Rs)

Rd = sat_16(Rs);

Rd=satub(Rs)

Rd = usat_8(Rs);

Rd=satuh(Rs)

Rd = usat_16(Rs);

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rd=sat(Rss)

Word32 Q6_R_sat_P(Word64 Rss)

Rd=satb(Rs)

Word32 Q6_R_satb_R(Word32 Rs)

Rd=sath(Rs)

Word32 Q6_R_sath_R(Word32 Rs)

Rd=satub(Rs)

Word32 Q6_R_satub_R(Word32 Rs)

Rd=satuh(Rs)

Word32 Q6_R_satuh_R(Word32 Rs)

597

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=sat(Rss)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=sath(Rs)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rd=satuh(Rs)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=satub(Rs)

1

0

0

0

1

1

0

0

1

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

1

d

d

d

d

d Rd=satb(Rs)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

598

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Swizzle bytes
Swizzle the bytes of a word. This instruction is useful in converting between little and big
endian formats.
Rd=swiz(Rs)
Rs

Rd
Syntax

Behavior

Rd=swiz(Rs)

Rd.b[0]=Rs.b[3];
Rd.b[1]=Rs.b[2];
Rd.b[2]=Rs.b[1];
Rd.b[3]=Rs.b[0];

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_swiz_R(Word32 Rs)

Rd=swiz(Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

1

0

MajOp
0

1

0

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

Parse
s

s

P

P

6

5

4

3

MinOp
-

-

-

-

-

-

1

1

1

2

1

0

d

d Rd=swiz(Rs)

d5
d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

599

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector align
Align a vector. Use the immediate amount, or the least significant 3 bits of a Predicate
register, as the number of bytes to align. Shift the Rss register pair right by this number of
bytes. Fill the vacated positions with the least significant elements from Rtt.
#u3/P
Rtt

Rss

Rdd
Syntax

Behavior

Rdd=valignb(Rtt,Rss,#u3)

Rdd = (Rss >>> #u*8)|(Rtt << ((8-#u)*8));

Rdd=valignb(Rtt,Rss,Pu)

PREDUSE_TIMING;
Rdd = Rss >>> (Pu&0x7)*8|(Rtt << (8(Pu&0x7))*8);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=valignb(Rtt,Rss,#u3)

Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64 Rss,
Word32 Iu3)

Rdd=valignb(Rtt,Rss,Pu)

Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64 Rss,
Byte Pu)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

ICLASS
1

1

0

0

0

Maj
0

RegType
0

0

0

1

0

-

0

0

ICLASS
Parse

s5
t5
u2

80-N2040-46 Rev. B

-

s

s

Maj
-

Field name

d5

s5
s

Parse
s

s

s5
-

s

s

s

P

P

-

t

t

Parse
s

s

P

P

8

t5
t

7

t

t

i

t5
-

t

t

t

6

5

4

3

Min
i

i

d

d

u2
t

t

-

2

1

0

d

d Rdd=valignb(Rtt,Rss,#u3)

d

d Rdd=valignb(Rtt,Rss,Pu)

d5

u

u

d
d5

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

600

Hexagon V68 Programmer’s Reference Manual

Field name
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Major Opcode
Minor Opcode
Register Type

601

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector round and pack
Add the constant 0x00008000 to each word in the 64-bit source vector Rss. Optionally
saturate this addition to 32bits. Pack the high halfwords of the result into the
corresponding halfword of the 32-bit destination register.

Rss.w[1]

Rss.w[0]

0x8000

Rss

0x8000

32-bit Add

32-bit Add

Rd.h[1]

Rd.h[0]

Rd

Syntax

Behavior

Rd=vrndwh(Rss)

for (i=0;i<2;i++) {
Rd.h[i]=(Rss.w[i]+0x08000).h[1];
}

Rd=vrndwh(Rss):sat

for (i=0;i<2;i++) {
Rd.h[i]=sat_32(Rss.w[i]+0x08000).h[1];
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics

80-N2040-46 Rev. B

Rd=vrndwh(Rss)

Word32 Q6_R_vrndwh_P(Word64 Rss)

Rd=vrndwh(Rss):sat

Word32 Q6_R_vrndwh_P_sat(Word64 Rss)

602

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=vrndwh(Rss)

1

0

0

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=vrndwh(Rss):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

603

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector saturate and pack
For each element in the vector, saturate the value to the next smaller size. VSATHUB
saturates signed halfwords to unsigned bytes, while VSATHB saturates signed halfwords
to signed bytes.
Rd=vsathub(Rs)

Rd=vsathub(Rss)
s16

s16

s16

s16

Sat_u8

Sat_u8

Sat_u8

Sat_u8

u8

u8

u8

u8

s16

s16

Sat_u8

Sat_u8

Rss

0

Rd

Rd=vsathb(Rss)

0

u8

Rs

u8

Rd

Rd=vsathb(Rs)

s16

s16

s16

s16

Sat_s8

Sat_s8

Sat_s8

Sat_s8

s8

s8

s8

s8

s16

s16

Sat_s8

Sat_s8

Rss

Rd

0

0

s8

Rs

s8

Rd

VSATWH saturates signed words to signed halfwords, while VSATWUH saturates signed
words to unsigned halfwords. The resulting values are packed together into destination
register Rd.
Rd=vsathwh(Rss)
s32

Rd=vsathwuh(Rss)
s32
Sat_s16

Sat_s16

s16

80-N2040-46 Rev. B

Rss

s16

s32

s32

Sat_u16

Sat_u16

Rd

u16

Syntax

Behavior

Rd=vsathb(Rs)

Rd.b[0]=sat_8(Rs.h[0]);
Rd.b[1]=sat_8(Rs.h[1]);
Rd.b[2]=0;
Rd.b[3]=0;

Rd=vsathb(Rss)

for (i=0;i<4;i++) {
Rd.b[i]=sat_8(Rss.h[i]);
}

u16

Rss

Rd

604

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=vsathub(Rs)

Rd.b[0]=usat_8(Rs.h[0]);
Rd.b[1]=usat_8(Rs.h[1]);
Rd.b[2]=0;
Rd.b[3]=0;

Rd=vsathub(Rss)

for (i=0;i<4;i++) {
Rd.b[i]=usat_8(Rss.h[i]);
}

Rd=vsatwh(Rss)

for (i=0;i<2;i++) {
Rd.h[i]=sat_16(Rss.w[i]);
}

Rd=vsatwuh(Rss)

for (i=0;i<2;i++) {
Rd.h[i]=usat_16(Rss.w[i]);
}

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=vsathb(Rs)

Word32 Q6_R_vsathb_R(Word32 Rs)

Rd=vsathb(Rss)

Word32 Q6_R_vsathb_P(Word64 Rss)

Rd=vsathub(Rs)

Word32 Q6_R_vsathub_R(Word32 Rs)

Rd=vsathub(Rss)

Word32 Q6_R_vsathub_P(Word64 Rss)

Rd=vsatwh(Rss)

Word32 Q6_R_vsatwh_P(Word64 Rss)

Rd=vsatwuh(Rss)

Word32 Q6_R_vsatwuh_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=vsathub(Rss)

1

0

0

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

0

d

d

d

d

d Rd=vsatwh(Rss)

1

0

0

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rd=vsatwuh(Rss)

1

0

0

0

1

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rd=vsathb(Rss)

1

0

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

-

d

d

d

d

d Rd=vsathb(Rs)

1

0

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

-

d

d

d

d

d Rd=vsathub(Rs)

Field name
ICLASS
Parse
d5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d

605

Hexagon V68 Programmer’s Reference Manual

Field name
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Major Opcode
Minor Opcode
Register Type

606

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector saturate without pack
Saturate each element of source vector Rss to the next smaller size. VSATHUB saturates
signed halfwords to unsigned bytes. VSATWH saturates signed words to signed
halfwords, and VSATWUH saturates signed words to unsigned halfwords. The resulting
values are placed in destination register Rdd in unpacked form.
Rdd=vsathub(Rss)
s16

s16

s16

s16

Sat_u8

Sat_u8

Sat_u8

Sat_u8

0

u8

0

u8

0

u8

0

Rss

u8

Rdd

Rdd=vsathb(Rss)

se

80-N2040-46 Rev. B

s16

s16

s16

s16

Sat_s8

Sat_s8

Sat_s8

Sat_s8

s8

se

s8

se

s8

se

Rss

s8

Rdd

Syntax

Behavior

Rdd=vsathb(Rss)

for (i=0;i<4;i++) {
Rdd.h[i]=sat_8(Rss.h[i]);
}

Rdd=vsathub(Rss)

for (i=0;i<4;i++) {
Rdd.h[i]=usat_8(Rss.h[i]);
}

Rdd=vsatwh(Rss)

for (i=0;i<2;i++) {
Rdd.w[i]=sat_16(Rss.w[i]);
}

Rdd=vsatwuh(Rss)

for (i=0;i<2;i++) {
Rdd.w[i]=usat_16(Rss.w[i]);
}

607

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rdd=vsathb(Rss)

Word64 Q6_P_vsathb_P(Word64 Rss)

Rdd=vsathub(Rss)

Word64 Q6_P_vsathub_P(Word64 Rss)

Rdd=vsatwh(Rss)

Word64 Q6_P_vsatwh_P(Word64 Rss)

Rdd=vsatwuh(Rss)

Word64 Q6_P_vsatwuh_P(Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

0

d

d

d

d

d Rdd=vsathub(Rss)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

1

d

d

d

d

d Rdd=vsatwuh(Rss)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

0

d

d

d

d

d Rdd=vsatwh(Rss)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

1

d

d

d

d

d Rdd=vsathb(Rss)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

608

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shuffle
Shuffle odd halfwords (shuffoh) takes the odd halfwords from Rtt and the odd halfwords
from Rss and merges them together into vector Rdd. Shuffle even halfwords (shuffeh)
performs the same operation on every even halfword in Rss and Rtt. The same operation is
available for odd and even bytes.
shuffoh

shuffeh
Rtt

Rss

Rss

Rtt

Rdd

Rdd

shuffob

80-N2040-46 Rev. B

shuffeb
Rtt

Rss

Rss

Rtt

Rdd

Rdd

Syntax

Behavior

Rdd=shuffeb(Rss,Rtt)

for (i=0;i<4;i++) {
Rdd.b[i*2]=Rtt.b[i*2];
Rdd.b[i*2+1]=Rss.b[i*2];
}

Rdd=shuffeh(Rss,Rtt)

for (i=0;i<2;i++) {
Rdd.h[i*2]=Rtt.h[i*2];
Rdd.h[i*2+1]=Rss.h[i*2];
}

Rdd=shuffob(Rtt,Rss)

for (i=0;i<4;i++) {
Rdd.b[i*2]=Rss.b[i*2+1];
Rdd.b[i*2+1]=Rtt.b[i*2+1];
}

Rdd=shuffoh(Rtt,Rss)

for (i=0;i<2;i++) {
Rdd.h[i*2]=Rss.h[i*2+1];
Rdd.h[i*2+1]=Rtt.h[i*2+1];
}

609

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=shuffeb(Rss,Rtt)

Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64 Rtt)

Rdd=shuffeh(Rss,Rtt)

Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64 Rtt)

Rdd=shuffob(Rtt,Rss)

Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64 Rss)

Rdd=shuffoh(Rtt,Rss)

Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64 Rss)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

t5

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=shuffeb(Rss,Rtt)

1

1

0

0

0

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rdd=shuffob(Rtt,Rss)

1

1

0

0

0

0

0

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=shuffeh(Rss,Rtt)

1

1

0

0

0

0

0

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

d

d

d

d

d Rdd=shuffoh(Rtt,Rss)

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

610

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector splat bytes
Replicate the low 8-bits from register Rs into each of the four bytes of destination register
Rd.

Rd=vsplatb(Rs)
Rs

Rd
Syntax

Behavior

Rd=vsplatb(Rs)

for (i=0;i<4;i++) {
Rd.b[i]=Rs.b[0];
}

Rdd=vsplatb(Rs)

for (i=0;i<8;i++) {
Rdd.b[i]=Rs.b[0];
}

Class: XTYPE (slots 2,3)
Intrinsics
Rd=vsplatb(Rs)

Word32 Q6_R_vsplatb_R(Word32 Rs)

Rdd=vsplatb(Rs)

Word64 Q6_P_vsplatb_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

1

0

0

0

1

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

-

d

d

d

d

d Rdd=vsplatb(Rs)

1

0

0

0

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

1

d

d

d

d

d Rd=vsplatb(Rs)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

611

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector splat halfwords
Replicate the low 16-bits from register Rs into each of the four halfwords of destination
Rdd.

Rdd=vsplath(Rs)
Rs

Rdd
Syntax

Behavior

Rdd=vsplath(Rs)

for (i=0;i<4;i++) {
Rdd.h[i]=Rs.h[0];
}

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_vsplath_R(Word32 Rs)

Rdd=vsplath(Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

1

0

MajOp
0

0

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
-

s

s

s

8

7

Parse
s

s

P

P

6

5

4

3

MinOp
-

-

-

-

-

-

0

1

2

1

0

d

d Rdd=vsplath(Rs)

d5
-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

612

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector splice
Concatenate the low (8-N) bytes of vector Rtt with the low N bytes of vector Rss. This
instruction is helpful to vectorize unaligned stores.
#u3/P
Rtt

Rss

Rdd
Syntax

Behavior

Rdd=vspliceb(Rss,Rtt,#u3)

Rdd = Rtt << #u*8 | zxt#u*8->64(Rss);

Rdd=vspliceb(Rss,Rtt,Pu)

PREDUSE_TIMING;
Rdd = Rtt << (Pu&7)*8 | zxt(Pu&7)*8->64(Rss);

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vspliceb(Rss,Rtt,#u3)

Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64 Rtt,
Word32 Iu3)

Rdd=vspliceb(Rss,Rtt,Pu)

Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64 Rtt,
Byte Pu)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

ICLASS
1

1

0

0

0

Maj
0

RegType
0

0

0

1

1

-

-

s

s

Maj
0

1

0

Field name
ICLASS
Parse
d5
s5
t5
u2
Maj
Min
RegType

80-N2040-46 Rev. B

s5
s

Parse
s

s

s5
0

s

s

s

P

P

-

t

t

Parse
s

s

P

P

8

t5
t

7

t

t

i

t5
-

t

t

t

6

5

4

3

Min
i

i

d

d

u2
t

t

-

2

1

0

d

d Rdd=vspliceb(Rss,Rtt,#u3)

d

d Rdd=vspliceb(Rss,Rtt,Pu)

d5

u

u

d
d5

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u
Major Opcode
Minor Opcode
Register Type

613

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector sign extend
vsxtbh sign-extends each byte of a single register source to halfwords, and places the
result in the destination register pair.
vsxthw sign-extends each halfword of a single register source to words, and places the
result in the destination register pair.

Rdd=vsxtbh(Rs)

sign

Rs

sign

sign

sign

Rdd

Rs

Rdd=vsxthw(Rs)
sign

sign

Rdd

Syntax

Behavior

Rdd=vsxtbh(Rs)

for (i=0;i<4;i++) {
Rdd.h[i]=Rs.b[i];
}

Rdd=vsxthw(Rs)

for (i=0;i<2;i++) {
Rdd.w[i]=Rs.h[i];
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vsxtbh(Rs)

Word64 Q6_P_vsxtbh_R(Word32 Rs)

Rdd=vsxthw(Rs)

Word64 Q6_P_vsxthw_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

1

0

0

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

-

d

d

d

d

d Rdd=vsxtbh(Rs)

1

0

0

0

0

1

0

0

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

0

-

d

d

d

d

d Rdd=vsxthw(Rs)

80-N2040-46 Rev. B

614

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

615

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector truncate
In vtrunehb, for each halfword in a vector, take the even (lower) byte and ignore the other
byte. The resulting values are packed into destination register Rd.
vtrunohb takes each odd byte of the source vector.
vtrunewh uses two source register pairs, Rss and Rtt. The even (lower) halfwords of Rss
are packed in the upper word of Rdd, while the lower halfwords of Rtt are packed in the
lower word of Rdd.
vtrunowh performs the same operation as vtrunewh, but uses the odd (upper) halfwords of
the source vectors instead.
Rdd=vtrunewh(Rss,Rtt)

Rd=vtrunehb(Rss)

Rss

Rss

Rtt
Rd
Rdd
Rd=vtrunohb(Rss)

Rdd=vtrunowh(Rss,Rtt)

Rss

Rss
Rtt

Rd

Rdd

80-N2040-46 Rev. B

Syntax

Behavior

Rd=vtrunehb(Rss)

for (i=0;i<4;i++) {
Rd.b[i]=Rss.b[i*2];
}

Rd=vtrunohb(Rss)

for (i=0;i<4;i++) {
Rd.b[i]=Rss.b[i*2+1];
}

Rdd=vtrunehb(Rss,Rtt)

for (i=0;i<4;i++) {
Rdd.b[i]=Rtt.b[i*2];
Rdd.b[i+4]=Rss.b[i*2];
}

Rdd=vtrunewh(Rss,Rtt)

Rdd.h[0]=Rtt.h[0];
Rdd.h[1]=Rtt.h[2];
Rdd.h[2]=Rss.h[0];
Rdd.h[3]=Rss.h[2];

Rdd=vtrunohb(Rss,Rtt)

for (i=0;i<4;i++) {
Rdd.b[i]=Rtt.b[i*2+1];
Rdd.b[i+4]=Rss.b[i*2+1];
}

616

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rdd=vtrunowh(Rss,Rtt)

Rdd.h[0]=Rtt.h[1];
Rdd.h[1]=Rtt.h[3];
Rdd.h[2]=Rss.h[1];
Rdd.h[3]=Rss.h[3];

Class: XTYPE (slots 2,3)
Intrinsics
Rd=vtrunehb(Rss)

Word32 Q6_R_vtrunehb_P(Word64 Rss)

Rd=vtrunohb(Rss)

Word32 Q6_R_vtrunohb_P(Word64 Rss)

Rdd=vtrunehb(Rss,Rtt)

Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64 Rtt)

Rdd=vtrunewh(Rss,Rtt)

Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64 Rtt)

Rdd=vtrunohb(Rss,Rtt)

Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64 Rtt)

Rdd=vtrunowh(Rss,Rtt)

Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

0

0

d

d

d

d

d Rd=vtrunohb(Rss)

1

0

0

0

1

0

0

0

1

0

0

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

0

d

d

d

d

d Rd=vtrunehb(Rss)

ICLASS

RegType

Maj

s5

Parse

t5

Min

d5

1

1

0

0

0

0

0

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

d

d

d

d

d Rdd=vtrunewh(Rss,Rtt)

1

1

0

0

0

0

0

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

d

d

d

d

d Rdd=vtrunehb(Rss,Rtt)

1

1

0

0

0

0

0

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

d

d

d

d

d Rdd=vtrunowh(Rss,Rtt)

1

1

0

0

0

0

0

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

d

d

d

d

d Rdd=vtrunohb(Rss,Rtt)

Field name
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
Maj
Min
RegType
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Major Opcode
Minor Opcode
Register Type
Register Type

617

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector zero extend
vzxtbh zero-extends each byte of a single register source to halfwords, and places the
result in the destination register pair.
vzxthw zero-extends each halfword of a single register source to words, and places the
result in the destination register pair.

Rdd=vzxtbh(Rs)

Rs

zero

zero

zero

zero

Rdd

Rs

Rdd=vzxthw(Rs)

zero

zero

Rdd

Syntax

Behavior

Rdd=vzxtbh(Rs)

for (i=0;i<4;i++) {
Rdd.h[i]=Rs.ub[i];
}

Rdd=vzxthw(Rs)

for (i=0;i<2;i++) {
Rdd.w[i]=Rs.uh[i];
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vzxtbh(Rs)

Word64 Q6_P_vzxtbh_R(Word32 Rs)

Rdd=vzxthw(Rs)

Word64 Q6_P_vzxthw_R(Word32 Rs)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

1

0

0

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

0

1

-

d

d

d

d

d Rdd=vzxtbh(Rs)

1

0

0

0

0

1

0

0

0

0

-

s

s

s

s

s

P

P

-

-

-

-

-

-

1

1

-

d

d

d

d

d Rdd=vzxthw(Rs)

80-N2040-46 Rev. B

618

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

619

Hexagon V68 Programmer’s Reference Manual

11.10.7

Instruction Set

XTYPE/PRED
The XTYPE/PRED instruction subclass includes instructions which perform
miscellaneous operations on predicates, including mask generation, predicate transfers,
and the Viterbi pack operation.

Bounds check
Determine if Rs falls in the range defined by Rtt.
Rtt.w0 is set by the user to the lower bound, and Rtt.w1 is set by the user to the upper
bound.
All bits of the destination predicate are set if the value falls within the range, or all cleared
otherwise.
Syntax

Behavior

Pd=boundscheck(Rs,Rtt)

if ("Rs & 1") {
Assembler mapped to:
"Pd=boundscheck(Rss,Rtt):raw:hi";
} else {
Assembler mapped to:
"Pd=boundscheck(Rss,Rtt):raw:lo";
}

Pd=boundscheck(Rss,Rtt):raw:hi

src = Rss.uw[1];
Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0] <
Rtt.uw[1]) ? 0xff : 0x00;

Pd=boundscheck(Rss,Rtt):raw:lo

src = Rss.uw[0];
Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0] <
Rtt.uw[1]) ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Byte Q6_p_boundscheck_RP(Word32 Rs, Word64 Rtt)

Pd=boundscheck(Rs,Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

MinOp

1

0
d2

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 1

t

t

t

t

t

1

0

0

-

-

-

d

Pd=boundscheck(Rss,Rtt):r
d aw:lo

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 1

t

t

t

t

t

1

0

1

-

-

-

d

d Pd=boundscheck(Rss,Rtt):r
aw:hi

80-N2040-46 Rev. B

620

Hexagon V68 Programmer’s Reference Manual

Field name
RegType
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Instruction Set

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

621

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare byte
These instructions sign- or zero-extend the low 8-bits of the source registers and perform
32-bit comparisons on the result. In the case of an extended 32-bit immediate operand, the
full 32 immediate bits are used for the comparison.
Syntax

Behavior

Pd=cmpb.eq(Rs,#u8)

Pd=Rs.ub[0] == #u ? 0xff : 0x00;

Pd=cmpb.eq(Rs,Rt)

Pd=Rs.b[0] == Rt.b[0] ? 0xff : 0x00;

Pd=cmpb.gt(Rs,#s8)

Pd=Rs.b[0] > #s ? 0xff : 0x00;

Pd=cmpb.gt(Rs,Rt)

Pd=Rs.b[0] > Rt.b[0] ? 0xff : 0x00;

Pd=cmpb.gtu(Rs,#u7)

apply_extension(#u);
Pd=Rs.ub[0] > #u.uw[0] ? 0xff : 0x00;

Pd=cmpb.gtu(Rs,Rt)

Pd=Rs.ub[0] > Rt.ub[0] ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=cmpb.eq(Rs,#u8)

Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)

Pd=cmpb.eq(Rs,Rt)

Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)

Pd=cmpb.gt(Rs,#s8)

Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)

Pd=cmpb.gt(Rs,Rt)

Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)

Pd=cmpb.gtu(Rs,#u7)

Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32 Iu7)

Pd=cmpb.gtu(Rs,Rt)

Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

t5

6

5

4

3

2

1

Min

0
d2

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

-

-

-

d

d Pd=cmpb.gt(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

0

-

-

-

d

d Pd=cmpb.eq(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

1

-

-

-

d

d Pd=cmpb.gtu(Rs,Rt)

ICLASS

RegType

s5

Parse

d2

1

1

0

1

1

1

0

1

-

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

0

-

d

d Pd=cmpb.eq(Rs,#u8)

1

1

0

1

1

1

0

1

-

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

0

-

d

d Pd=cmpb.gt(Rs,#s8)

1

1

0

1

1

1

0

1

-

1

0

s

s

s

s

s

P

P

-

0

i

i

i

i

i

i

i

0

0

-

d

d Pd=cmpb.gtu(Rs,#u7)

Field name
RegType
MajOp
ICLASS
Parse
d2

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d

622

Hexagon V68 Programmer’s Reference Manual

Field name
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

623

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare half
These instructions sign- or zero-extend the low 16-bits of the source registers and perform
32-bit comparisons on the result. In the case of an extended 32-bit immediate operand, the
full 32 immediate bits are used for the comparison.
Syntax

Behavior

Pd=cmph.eq(Rs,#s8)

apply_extension(#s);
Pd=Rs.h[0] == #s ? 0xff : 0x00;

Pd=cmph.eq(Rs,Rt)

Pd=Rs.h[0] == Rt.h[0] ? 0xff : 0x00;

Pd=cmph.gt(Rs,#s8)

apply_extension(#s);
Pd=Rs.h[0] > #s ? 0xff : 0x00;

Pd=cmph.gt(Rs,Rt)

Pd=Rs.h[0] > Rt.h[0] ? 0xff : 0x00;

Pd=cmph.gtu(Rs,#u7)

apply_extension(#u);
Pd=Rs.uh[0] > #u.uw[0] ? 0xff : 0x00;

Pd=cmph.gtu(Rs,Rt)

Pd=Rs.uh[0] > Rt.uh[0] ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=cmph.eq(Rs,#s8)

Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)

Pd=cmph.eq(Rs,Rt)

Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)

Pd=cmph.gt(Rs,#s8)

Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)

Pd=cmph.gt(Rs,Rt)

Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)

Pd=cmph.gtu(Rs,#u7)

Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32 Iu7)

Pd=cmph.gtu(Rs,Rt)

Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

t5

6

5

4

3

2

1

Min

0
d2

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

1

-

-

-

d

d Pd=cmph.eq(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

-

-

-

d

d Pd=cmph.gt(Rs,Rt)

1

1

0

0

0

1

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

1

-

-

-

d

d Pd=cmph.gtu(Rs,Rt)

ICLASS

RegType

s5

Parse

d2

1

1

0

1

1

1

0

1

-

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

1

-

d

d Pd=cmph.eq(Rs,#s8)

1

1

0

1

1

1

0

1

-

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

1

-

d

d Pd=cmph.gt(Rs,#s8)

1

1

0

1

1

1

0

1

-

1

0

s

s

s

s

s

P

P

-

0

i

i

i

i

i

i

i

0

1

-

d

d Pd=cmph.gtu(Rs,#u7)

Field name
RegType
MajOp
ICLASS

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Instruction Class

624

Hexagon V68 Programmer’s Reference Manual

Field name
Parse
d2
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

625

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare doublewords
Compare two 64-bit register pairs for unsigned greater than, greater than, or equal. The 8bit predicate register Pd is set to all 1's or all 0's depending on the result.
Syntax

Behavior

Pd=cmp.eq(Rss,Rtt)

Pd=Rss==Rtt ? 0xff : 0x00;

Pd=cmp.gt(Rss,Rtt)

Pd=Rss>Rtt ? 0xff : 0x00;

Pd=cmp.gtu(Rss,Rtt)

Pd=Rss.u64>Rtt.u64 ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=cmp.eq(Rss,Rtt)

Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)

Pd=cmp.gt(Rss,Rtt)

Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)

Pd=cmp.gtu(Rss,Rtt)

Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

1

MinOp

0
d2

1

1

0

1

0

0

1

0

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

0

-

-

-

d

d Pd=cmp.eq(Rss,Rtt)

1

1

0

1

0

0

1

0

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

0

-

-

-

d

d Pd=cmp.gt(Rss,Rtt)

1

1

0

1

0

0

1

0

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

0

-

-

-

d

d Pd=cmp.gtu(Rss,Rtt)

Field name
RegType
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

626

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Compare bit mask
If all the bits in the mask in Rt or a short immediate are set (BITSSET) or clear
(BITSCLEAR) in Rs, set the Pd to true. Otherwise, set the bits in Pd to false.
Syntax

Behavior

Pd=[!]bitsclr(Rs,#u6)

Pd=(Rs&#u)[!]=0 ? 0xff : 0x00;

Pd=[!]bitsclr(Rs,Rt)

Pd=(Rs&Rt)[!]=0 ? 0xff : 0x00;

Pd=[!]bitsset(Rs,Rt)

Pd=(Rs&Rt)[!]=Rt ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=!bitsclr(Rs,#u6)

Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32 Iu6)

Pd=!bitsclr(Rs,Rt)

Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32 Rt)

Pd=!bitsset(Rs,Rt)

Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32 Rt)

Pd=bitsclr(Rs,#u6)

Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)

Pd=bitsclr(Rs,Rt)

Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)

Pd=bitsset(Rs,Rt)

Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

6

5

4

3

2

1

Parse

0
d2

1

0

0

0

0

1

0

1

1

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

-

-

-

-

-

-

d

d Pd=bitsclr(Rs,#u6)

1

0

0

0

0

1

0

1

1

0

1

s

s

s

s

s

P

P

i

i

i

i

i

i

-

-

-

-

-

-

d

d Pd=!bitsclr(Rs,#u6)

ICLASS

RegType

Maj

s5

Parse

t5

d2

1

1

0

0

0

1

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=bitsset(Rs,Rt)

1

1

0

0

0

1

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=!bitsset(Rs,Rt)

1

1

0

0

0

1

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=bitsclr(Rs,Rt)

1

1

0

0

0

1

1

1

1

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=!bitsclr(Rs,Rt)

Field name
ICLASS
Parse
d2
s5
t5
MajOp
Maj
RegType
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Major Opcode
Register Type
Register Type

627

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Mask generate from predicate
For each of the low eight bits in predicate register Pt, when the bit is set, set the
corresponding byte in 64-bit register pair Rdd to 0xff, otherwise, set the corresponding
byte to 0x00.
7

0

1

0xFF

0x00

0

0xFF

1

0

0x00

1

0

Pt

0x00

0xFF

0

1

0xFF

Rdd

0x00

Syntax

Behavior

Rdd=mask(Pt)

PREDUSE_TIMING;
for (i = 0; i < 8; i++) {
Rdd.b[i]=(Pt.i?(0xff):(0x00));
}

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_mask_p(Byte Pt)

Rdd=mask(Pt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

1

1

Parse
0

-

-

Field name
ICLASS
Parse
d5
t2
RegType

80-N2040-46 Rev. B

-

-

-

-

-

-

P

P

8

7

6

5

4

3

t2
-

-

-

-

t

2

1

0

d

d Rdd=mask(Pt)

d5
t

-

-

-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register t
Register Type

628

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Check for TLB match
Determine if the TLB entry in Rss matches the ASID:PPN in Rt.
Syntax

Behavior

Pd=tlbmatch(Rss,Rt)

MASK = 0x07ffffff;
TLBLO = Rss.uw[0];
TLBHI = Rss.uw[1];
SIZE =
min(6,count_leading_ones(~reverse_bits(TLBLO)));
MASK &= (0xffffffff << 2*SIZE);
Pd = TLBHI.31 && ((TLBHI & MASK) == (Rt & MASK))
? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Notes
■

The predicate generated by this instruction can not be used as a .new predicate,
nor can it be automatically ANDed with another predicate.

Intrinsics
Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32 Rt)

Pd=tlbmatch(Rss,Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
1

0

0

1

s5
0

0

-

Field name
RegType
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

-

s

s

s

Parse
s

s

P

P 1

8

7

t

0

t5
t

t

t

6

5

4

3

2

1

-

-

-

d

MinOp
t

1

1

0
d2
d Pd=tlbmatch(Rss,Rt)

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

629

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Predicate transfer
Pd=Rs transfers a predicate to the 8 least-significant bits of a general register and zeros the
other bits.
Rd=Ps transfers the 8 least-significant bits of a general register to a predicate.
Syntax

Behavior

Pd=Rs

Pd = Rs.ub[0];

Rd=Ps

PREDUSE_TIMING;
Rd = zxt8->32(Ps);

Class: XTYPE (slots 2,3)
Intrinsics
Pd=Rs

Byte Q6_p_equals_R(Word32 Rs)

Rd=Ps

Word32 Q6_R_equals_p(Byte Ps)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

0

1

ICLASS
1

0

0

1

0

MajOp
1

RegType
0

0

0

1

-

1

ICLASS
Parse
d2
d5
s2
s5
MajOp
RegType

8

7

6

5

4

3

2

Parse

0

s

s

s

s

-

-

-

-

s

MajOp
1

Field name

80-N2040-46 Rev. B

s5
s
s2

P

P

P

P

0
d2

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

-

d

d

Parse
s

1

-

d

d Pd=Rs

d

d Rd=Ps

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register d
Field to encode register s
Field to encode register s
Major Opcode
Register Type

630

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Test bit
Extract a bit from a register. If the bit is true (1), set all the bits of the predicate register
destination to 1. If the bit is false (0), set all the bits of the predicate register destination to
0. Indicate the bit to test using an immediate or register value.
When a register indicates the bit to test, and the value specified is out of range, the
predicate result is zero.
Syntax

Behavior

Pd=[!]tstbit(Rs,#u5)

Pd = (Rs & (1<<#u)) == 0 ? 0xff : 0x00;

Pd=[!]tstbit(Rs,Rt)

Pd = (zxt32->64(Rs) & (sxt7->32(Rt)>0)?(zxt32>64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)))
== 0 ? 0xff : 0x00;

Class: XTYPE (slots 2,3)
Intrinsics
Pd=!tstbit(Rs,#u5)

Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32 Iu5)

Pd=!tstbit(Rs,Rt)

Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32 Rt)

Pd=tstbit(Rs,#u5)

Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)

Pd=tstbit(Rs,Rt)

Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

6

5

4

3

2

1

Parse

0
d2

1

0

0

0

0

1

0

1

0

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

-

-

-

-

-

-

d

d Pd=tstbit(Rs,#u5)

1

0

0

0

0

1

0

1

0

0

1

s

s

s

s

s

P

P 0

i

i

i

i

i

-

-

-

-

-

-

d

d Pd=!tstbit(Rs,#u5)

ICLASS

RegType

Maj

s5

Parse

t5

d2

1

1

0

0

0

1

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=tstbit(Rs,Rt)

1

1

0

0

0

1

1

1

0

0

1

s

s

s

s

s

P

P

-

t

t

t

t

t

-

-

-

-

-

-

d

d Pd=!tstbit(Rs,Rt)

Field name
ICLASS
Parse
d2
s5
t5
MajOp
Maj
RegType
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Major Opcode
Register Type
Register Type

631

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector compare halfwords
Compare each of four 16-bit halfwords in two 64-bit vectors and set the corresponding bits
in a predicate destination to '11' if true, '00' if false.
Halfword comparisons can be for equal, signed greater than, or unsigned greater than.

Rss
Rtt

cmp

cmp

1

1

0

cmp

0

1

1

7

80-N2040-46 Rev. B

0

cmp

0

Pd

0

Syntax

Behavior

Pd=vcmph.eq(Rss,#s8)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.h[i] == #s);
Pd.i*2+1 = (Rss.h[i] == #s);
}

Pd=vcmph.eq(Rss,Rtt)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.h[i] == Rtt.h[i]);
Pd.i*2+1 = (Rss.h[i] == Rtt.h[i]);
}

Pd=vcmph.gt(Rss,#s8)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.h[i] > #s);
Pd.i*2+1 = (Rss.h[i] > #s);
}

Pd=vcmph.gt(Rss,Rtt)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.h[i] > Rtt.h[i]);
Pd.i*2+1 = (Rss.h[i] > Rtt.h[i]);
}

Pd=vcmph.gtu(Rss,#u7)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.uh[i] > #u);
Pd.i*2+1 = (Rss.uh[i] > #u);
}

Pd=vcmph.gtu(Rss,Rtt)

for (i = 0; i < 4; i++) {
Pd.i*2 = (Rss.uh[i] > Rtt.uh[i]);
Pd.i*2+1 = (Rss.uh[i] > Rtt.uh[i]);
}

632

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Pd=vcmph.eq(Rss,#s8)

Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32 Is8)

Pd=vcmph.eq(Rss,Rtt)

Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64 Rtt)

Pd=vcmph.gt(Rss,#s8)

Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmph.gt(Rss,Rtt)

Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64 Rtt)

Pd=vcmph.gtu(Rss,#u7)

Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmph.gtu(Rss,Rtt)

Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

MinOp

1

0
d2

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

1

-

-

-

d

d Pd=vcmph.eq(Rss,Rtt)

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

0

-

-

-

d

d Pd=vcmph.gt(Rss,Rtt)

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

1

0

1

-

-

-

d

d Pd=vcmph.gtu(Rss,Rtt)

1

ICLASS

RegType

s5

Parse

d2

1

1

0

1

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

1

-

d

d Pd=vcmph.eq(Rss,#s8)

1

1

0

1

1

1

0

0

0

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

1

-

d

d Pd=vcmph.gt(Rss,#s8)

1

1

0

1

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

0

i

i

i

i

i

i

i

0

1

-

d

d Pd=vcmph.gtu(Rss,#u7)

Field name
RegType
MajOp
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

633

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector compare bytes for any match
Compare each byte in two 64-bit source vectors and set a predicate if any of the 8 bytes are
equal.
This instruction can quickly find the null terminator in a string.
Syntax

Behavior

Pd=!any8(vcmpb.eq(Rss,Rtt))

Pd = 0;
for (i = 0; i < 8; i++) {
if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;
}
Pd = ~Pd;

Pd=any8(vcmpb.eq(Rss,Rtt))

Pd = 0;
for (i = 0; i < 8; i++) {
if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;
}

Class: XTYPE (slots 2,3)
Intrinsics
Pd=!any8(vcmpb.eq(Rss,Rtt))

Byte Q6_p_not_any8_vcmpb_eq_PP(Word64 Rss,
Word64 Rtt)

Pd=any8(vcmpb.eq(Rss,Rtt))

Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss, Word64
Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

MinOp

1

0
d2

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 1

t

t

t

t

t

0

0

0

-

-

-

d

d Pd=any8(vcmpb.eq(Rss,Rtt
))

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 1

t

t

t

t

t

0

0

1

-

-

-

d

d Pd=!any8(vcmpb.eq(Rss,Rt
t))

Field name
RegType
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

634

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector compare bytes
Compare each of eight bytes in two 64-bit vectors and set the corresponding bit in a
predicate destination to 1 if true, 0 if false.
Byte comparisons can be for equal or for unsigned greater than.
In the following example, every other comparison is true.

Rss
Rtt

cmp

cmp

cmp

cmp

cmp

cmp

1

1

1

1

0

0

0

7

80-N2040-46 Rev. B

0

cmp

cmp

Pd

0

Syntax

Behavior

Pd=vcmpb.eq(Rss,#u8)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.ub[i] == #u);
}

Pd=vcmpb.eq(Rss,Rtt)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.b[i] == Rtt.b[i]);
}

Pd=vcmpb.gt(Rss,#s8)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.b[i] > #s);
}

Pd=vcmpb.gt(Rss,Rtt)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.b[i] > Rtt.b[i]);
}

Pd=vcmpb.gtu(Rss,#u7)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.ub[i] > #u);
}

Pd=vcmpb.gtu(Rss,Rtt)

for (i = 0; i < 8; i++) {
Pd.i = (Rss.ub[i] > Rtt.ub[i]);
}

635

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Pd=vcmpb.eq(Rss,#u8)

Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32 Iu8)

Pd=vcmpb.eq(Rss,Rtt)

Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)

Pd=vcmpb.gt(Rss,#s8)

Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmpb.gt(Rss,Rtt)

Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64 Rtt)

Pd=vcmpb.gtu(Rss,#u7)

Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmpb.gtu(Rss,Rtt)

Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64 Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

MinOp

1

0
d2

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

0

-

-

-

d

d Pd=vcmpb.eq(Rss,Rtt)

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

1

1

1

-

-

-

d

d Pd=vcmpb.gtu(Rss,Rtt)

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 1

t

t

t

t

t

0

1

0

-

-

-

d

d Pd=vcmpb.gt(Rss,Rtt)

1

ICLASS

RegType

s5

Parse

d2

1

1

0

1

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

0

-

d

d Pd=vcmpb.eq(Rss,#u8)

1

1

0

1

1

1

0

0

0

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

0

0

-

d

d Pd=vcmpb.gt(Rss,#s8)

1

1

0

1

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

0

i

i

i

i

i

i

i

0

0

-

d

d Pd=vcmpb.gtu(Rss,#u7)

Field name
RegType
MajOp
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

636

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector compare words
Compare each of two 32-bit words in two 64-bit vectors and set the corresponding bits in a
predicate destination to '1111' if true, '0000' if false.
Word comparisons can be for equal, signed greater than, or unsigned greater than.

Rss
Rtt

cmp

cmp

1

1

1

1

0

0

0

7

0

Pd

0

Syntax

Behavior

Pd=vcmpw.eq(Rss,#s8)

Pd[3:0] = (Rss.w[0]==#s);
Pd[7:4] = (Rss.w[1]==#s);

Pd=vcmpw.eq(Rss,Rtt)

Pd[3:0] = (Rss.w[0]==Rtt.w[0]);
Pd[7:4] = (Rss.w[1]==Rtt.w[1]);

Pd=vcmpw.gt(Rss,#s8)

Pd[3:0] = (Rss.w[0]>#s);
Pd[7:4] = (Rss.w[1]>#s);

Pd=vcmpw.gt(Rss,Rtt)

Pd[3:0] = (Rss.w[0]>Rtt.w[0]);
Pd[7:4] = (Rss.w[1]>Rtt.w[1]);

Pd=vcmpw.gtu(Rss,#u7)

Pd[3:0] = (Rss.uw[0]>#u.uw[0]);
Pd[7:4] = (Rss.uw[1]>#u.uw[0]);

Pd=vcmpw.gtu(Rss,Rtt)

Pd[3:0] = (Rss.uw[0]>Rtt.uw[0]);
Pd[7:4] = (Rss.uw[1]>Rtt.uw[1]);

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Pd=vcmpw.eq(Rss,#s8)

Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32 Is8)

Pd=vcmpw.eq(Rss,Rtt)

Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64 Rtt)

Pd=vcmpw.gt(Rss,#s8)

Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmpw.gt(Rss,Rtt)

Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64 Rtt)

Pd=vcmpw.gtu(Rss,#u7)

Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmpw.gtu(Rss,Rtt)

Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64 Rtt)

637

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

s5

Parse

8

7

t5

6

5

4

3

2

1

MinOp

0
d2

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

0

-

-

-

d

d Pd=vcmpw.eq(Rss,Rtt)

1

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

0

0

1

-

-

-

d

d Pd=vcmpw.gt(Rss,Rtt)

1

0

1

0

0

1

0

0

-

-

s

s

s

s

s

P

P 0

t

t

t

t

t

0

1

0

-

-

-

d

d Pd=vcmpw.gtu(Rss,Rtt)

1

ICLASS

RegType

s5

Parse

d2

1

1

0

1

1

1

0

0

0

0

0

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

1

0

-

d

d Pd=vcmpw.eq(Rss,#s8)

1

1

0

1

1

1

0

0

0

0

1

s

s

s

s

s

P

P

-

i

i

i

i

i

i

i

i

1

0

-

d

d Pd=vcmpw.gt(Rss,#s8)

1

1

0

1

1

1

0

0

0

1

0

s

s

s

s

s

P

P

-

0

i

i

i

i

i

i

i

1

0

-

d

d Pd=vcmpw.gtu(Rss,#u7)

Field name
RegType
MajOp
MinOp
ICLASS
Parse
d2
s5
t5

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

638

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Viterbi pack even and odd predicate bits
Pack the even and odd bits of two predicate registers into a single destination register. A
variant of this instruction is the R3:2 |= vitpack(P1,P0). This places the packed predicate
bits into the lower 8 bits of the register pair, which has been preshifted by 8 bits.
This instruction is useful in Viterbi decoding. Repeated use of the push version enables
storage of a history for traceback, purposes.
7

0
Ps

Pt

0

Rd
0

31

8 7

Syntax

Behavior

Rd=vitpack(Ps,Pt)

PREDUSE_TIMING;
Rd = (Ps&0x55) | (Pt&0xAA);

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)

Rd=vitpack(Ps,Pt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

0

0

MajOp
1

-

0

Field name
ICLASS
Parse
d5
s2
t2
MajOp
RegType

80-N2040-46 Rev. B

s2
0

-

-

-

s

Parse
s

P

P

8

7

6

5

4

3

t2
-

-

-

-

t

2

1

0

d

d Rd=vitpack(Ps,Pt)

d5
t

-

-

-

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Register Type

639

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector mux
Perform an element-wise byte selection between two vectors.
For each of the low eight bits of predicate register Pu, when the bit is set, set the
corresponding byte in Rdd to the corresponding byte from Rss. Otherwise, set the byte in
Rdd to the byte from Rtt.

Rss
Rtt

mux
mux
mux
P[7]
P[6]
P[5]

mux
P[4]

mux
mux
mux
mux
P[3]
P[2]
P[1]
P[0]

Rdd
Syntax

Behavior

Rdd=vmux(Pu,Rss,Rtt)

PREDUSE_TIMING;
for (i = 0; i < 8; i++) {
Rdd.b[i]=(Pu.i?(Rss.b[i]):(Rtt.b[i]));
}

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss, Word64
Rtt)

Rdd=vmux(Pu,Rss,Rtt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
1

0

0

0

s5
1

-

-

Field name
RegType
MinOp
ICLASS
Parse
d5
s5
t5
u2

80-N2040-46 Rev. B

-

s

s

s

Parse
s

s

P

P

8

7

t5
-

t

t

t

6

5

4

3

u2
t

t

-

u

u

2

1

0

d

d Rdd=vmux(Pu,Rss,Rtt)

d5
d

d

d

Description
Register Type
Minor Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Field to encode register u

640

Hexagon V68 Programmer’s Reference Manual

11.10.8

Instruction Set

XTYPE/SHIFT
The XTYPE/SHIFT instruction subclass includes instructions which perform shifts.

Mask generate from immediate
Generate a mask from two immediate values
Syntax

Behavior

Rd=mask(#u5,#U5)

Rd = ((1<<#u)-1) << #U;

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5)

Rd=mask(#u5,#U5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

1

0

MajOp
1

0

I

Field name
ICLASS
Parse
d5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

8

7

i

I

Parse
I

-

-

-

-

-

P

P 1

6

5

4

3

d

d

MinOp
i

i

i

i

I

2

1

0

d

d Rd=mask(#u5,#U5)

d5
I

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Major Opcode
Minor Opcode
Register Type

641

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by immediate
Shift the source register value right or left based on the type of instruction. In these
instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
vacated bits.
ASR

LSR
Lost

Sign-ext

Lost

Rs

Rd

Zero-fill

Rs

Rd

ASL
Lost

Rs
Zero-fill

Rd

Syntax

Behavior

Rd=asl(Rs,#u5)

Rd = Rs << #u;

Rd=asr(Rs,#u5)

Rd = Rs >> #u;

Rd=lsr(Rs,#u5)

Rd = Rs >>> #u;

Rd=rol(Rs,#u5)

Rd = Rs <<R #u;

Rdd=asl(Rss,#u6)

Rdd = Rss << #u;

Rdd=asr(Rss,#u6)

Rdd = Rss >> #u;

Rdd=lsr(Rss,#u6)

Rdd = Rss >>> #u;

Rdd=rol(Rss,#u6)

Rdd = Rss <<R #u;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rd=asl(Rs,#u5)

Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)

Rd=asr(Rs,#u5)

Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)

Rd=lsr(Rs,#u5)

Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)

642

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rd=rol(Rs,#u5)

Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)

Rdd=asl(Rss,#u6)

Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)

Rdd=asr(Rss,#u6)

Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)

Rdd=lsr(Rss,#u6)

Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)

Rdd=rol(Rss,#u6)

Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

0

d

d

d

d

d Rdd=asr(Rss,#u6)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

1

d

d

d

d

d Rdd=lsr(Rss,#u6)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

0

d

d

d

d

d Rdd=asl(Rss,#u6)

1

0

0

0

0

0

0

0

0

0

0

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

1

d

d

d

d

d Rdd=rol(Rss,#u6)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

d

d

d

d

d Rd=asr(Rs,#u5)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

d

d

d

d

d Rd=lsr(Rs,#u5)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

d

d

d

d

d Rd=asl(Rs,#u5)

1

0

0

0

1

1

0

0

0

0

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

1

d

d

d

d

d Rd=rol(Rs,#u5)

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

643

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by immediate and accumulate
Shift the source register value right or left based on the type of instruction. In these
instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
vacated bits.
After shifting, add or subtract the shifted value from the destination register or register
pair.

Rss

# / Rt

Rs

# / Rt

64-bit Shift Value

Shift Amt

32-bit Shift Value

Shift Amt

64-bit Shift

32-bit Shift

64-bit Add/Sub

32-bit Add/Sub

64 bit result

80-N2040-46 Rev. B

32 bit result

Rxx

Rx

Syntax

Behavior

Rx=add(#u8,asl(Rx,#U5))

Rx=apply_extension(#u)+(Rx<<#U);

Rx=add(#u8,lsr(Rx,#U5))

Rx=apply_extension(#u)+(((unsigned int)Rx)>>#U);

Rx=sub(#u8,asl(Rx,#U5))

Rx=apply_extension(#u)-(Rx<<#U);

Rx=sub(#u8,lsr(Rx,#U5))

Rx=apply_extension(#u)-(((unsigned int)Rx)>>#U);

Rx[+-]=asl(Rs,#u5)

Rx = Rx [+-] Rs << #u;

Rx[+-]=asr(Rs,#u5)

Rx = Rx [+-] Rs >> #u;

Rx[+-]=lsr(Rs,#u5)

Rx = Rx [+-] Rs >>> #u;

Rx[+-]=rol(Rs,#u5)

Rx = Rx [+-] Rs <<R #u;

Rxx[+-]=asl(Rss,#u6)

Rxx = Rxx [+-] Rss << #u;

Rxx[+-]=asr(Rss,#u6)

Rxx = Rxx [+-] Rss >> #u;

Rxx[+-]=lsr(Rss,#u6)

Rxx = Rxx [+-] Rss >>> #u;

Rxx[+-]=rol(Rss,#u6)

Rxx = Rxx [+-] Rss <<R #u;

644

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx+=asl(Rs,#u5)

Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx+=asr(Rs,#u5)

Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx+=lsr(Rs,#u5)

Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx+=rol(Rs,#u5)

Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx-=asl(Rs,#u5)

Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx-=asr(Rs,#u5)

Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx-=lsr(Rs,#u5)

Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx-=rol(Rs,#u5)

Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx=add(#u8,asl(Rx,#U5))

Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=add(#u8,lsr(Rx,#U5))

Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=sub(#u8,asl(Rx,#U5))

Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=sub(#u8,lsr(Rx,#U5))

Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rxx+=asl(Rss,#u6)

Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx+=asr(Rss,#u6)

Word64 Q6_P_asracc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx+=lsr(Rss,#u6)

Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx+=rol(Rss,#u6)

Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx-=asl(Rss,#u6)

Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx-=asr(Rss,#u6)

Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx-=lsr(Rss,#u6)

Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx-=rol(Rss,#u6)

Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

645

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

x5

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

0

x

x

x

x

x Rxx-=asr(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

1

x

x

x

x

x Rxx-=lsr(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

0

x

x

x

x

x Rxx-=asl(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

1

x

x

x

x

x Rxx-=rol(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

0

0

x

x

x

x

x Rxx+=asr(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

0

1

x

x

x

x

x Rxx+=lsr(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

1

0

x

x

x

x

x Rxx+=asl(Rss,#u6)

1

0

0

0

0

0

1

0

0

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

1

1

x

x

x

x

x Rxx+=rol(Rss,#u6)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

x

x

x

x

x Rx-=asr(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

x

x

x

x

x Rx-=lsr(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

x

x

x

x

x Rx-=asl(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

1

x

x

x

x

x Rx-=rol(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

0

0

x

x

x

x

x Rx+=asr(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

0

1

x

x

x

x

x Rx+=lsr(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

1

0

x

x

x

x

x Rx+=asl(Rs,#u5)

1

0

0

0

1

1

1

0

0

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

1

1

x

x

x

x

x Rx+=rol(Rs,#u5)

ICLASS

RegType

x5

Parse

MajOp

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

0

i

1

0

-

Rx=add(#u8,asl(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

0

i

1

1

-

Rx=sub(#u8,asl(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

1

i

1

0

-

Rx=add(#u8,lsr(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

1

i

1

1

-

Rx=sub(#u8,lsr(Rx,#U5))

Field name
RegType
MajOp
ICLASS
Parse
s5
x5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Register Type
Major Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register x
Major Opcode
Minor Opcode
Register Type

646

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by immediate and add
Shift Rs left by 0-7 bits, add to Rt, and place the result in Rd.
This instruction is useful for calculating array pointers, where destruction of the base
pointer is undesirable.
Syntax

Behavior

Rd=addasl(Rt,Rs,#u3)

Rd = Rt + Rs << #u;

Class: XTYPE (slots 2,3)
Intrinsics
Word32 Q6_R_addasl_RRI(Word32 Rt, Word32 Rs,
Word32 Iu3)

Rd=addasl(Rt,Rs,#u3)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

1

0

RegType
0

0

1

0

Maj
0

0

0

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

Parse
s

s

P

P 0

8

t5
t

t

t

7

6

5

4

3

Min
t

t

i

i

2

1

0

d

d Rd=addasl(Rt,Rs,#u3)

d5
i

d

d

d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

647

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by immediate and logical
Shift the source register value right or left based on the type of instruction. In these
instructions, the shift amount is contained in an unsigned immediate (5 bits for 32-bit
shifts, 6 bits for 64-bit shifts) and the shift instruction gives the shift direction.
Arithmetic right shifts place the sign bit of the source value in the vacated positions, while
logical right shifts place zeros in the vacated positions. Left shifts always zero-fill the
vacated bits.
After shifting, take the logical AND, OR, or XOR of the shifted amount and the
destination register or register pair, and place the result back in the destination register or
register pair.
Saturation is not available for these instructions.

Rss

# / Rt

Rs

# / Rt

64-bit Shift Value

Shift Amt

32-bit Shift Value

Shift Amt

64-bit Shift

32-bit Shift

64-bit AND/OR

32-bit AND/OR

64 bit result

80-N2040-46 Rev. B

32 bit result

Rxx

Rx

Syntax

Behavior

Rx=and(#u8,asl(Rx,#U5))

Rx=apply_extension(#u)&(Rx<<#U);

Rx=and(#u8,lsr(Rx,#U5))

Rx=apply_extension(#u)&(((unsigned int)Rx)>>#U);

Rx=or(#u8,asl(Rx,#U5))

Rx=apply_extension(#u)|(Rx<<#U);

Rx=or(#u8,lsr(Rx,#U5))

Rx=apply_extension(#u)|(((unsigned int)Rx)>>#U);

Rx[&|]=asl(Rs,#u5)

Rx = Rx [|&] Rs << #u;

Rx[&|]=asr(Rs,#u5)

Rx = Rx [|&] Rs >> #u;

Rx[&|]=lsr(Rs,#u5)

Rx = Rx [|&] Rs >>> #u;

Rx[&|]=rol(Rs,#u5)

Rx = Rx [|&] Rs <<R #u;

Rx^=asl(Rs,#u5)

Rx = Rx ^ Rs << #u;

Rx^=lsr(Rs,#u5)

Rx = Rx ^ Rs >>> #u;

Rx^=rol(Rs,#u5)

Rx = Rx ^ Rs <<R #u;

Rxx[&|]=asl(Rss,#u6)

Rxx = Rxx [|&] Rss << #u;

Rxx[&|]=asr(Rss,#u6)

Rxx = Rxx [|&] Rss >> #u;

648

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rxx[&|]=lsr(Rss,#u6)

Rxx = Rxx [|&] Rss >>> #u;

Rxx[&|]=rol(Rss,#u6)

Rxx = Rxx [|&] Rss <<R #u;

Rxx^=asl(Rss,#u6)

Rxx = Rxx ^ Rss << #u;

Rxx^=lsr(Rss,#u6)

Rxx = Rxx ^ Rss >>> #u;

Rxx^=rol(Rss,#u6)

Rxx = Rxx ^ Rss <<R #u;

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx&=asl(Rs,#u5)

Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx&=asr(Rs,#u5)

Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx&=lsr(Rs,#u5)

Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx&=rol(Rs,#u5)

Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx=and(#u8,asl(Rx,#U5))

Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=and(#u8,lsr(Rx,#U5))

Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=or(#u8,asl(Rx,#U5))

Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx=or(#u8,lsr(Rx,#U5))

Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32 Rx,
Word32 IU5)

Rx^=asl(Rs,#u5)

Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx^=lsr(Rs,#u5)

Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx^=rol(Rs,#u5)

Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx|=asl(Rs,#u5)

Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx|=asr(Rs,#u5)

Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx|=lsr(Rs,#u5)

Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rx|=rol(Rs,#u5)

Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs,
Word32 Iu5)

Rxx&=asl(Rss,#u6)

Word64 Q6_P_asland_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx&=asr(Rss,#u6)

Word64 Q6_P_asrand_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx&=lsr(Rss,#u6)

Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

649

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rxx&=rol(Rss,#u6)

Word64 Q6_P_roland_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx^=asl(Rss,#u6)

Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx^=lsr(Rss,#u6)

Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx^=rol(Rss,#u6)

Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx|=asl(Rss,#u6)

Word64 Q6_P_aslor_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx|=asr(Rss,#u6)

Word64 Q6_P_asror_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx|=lsr(Rss,#u6)

Word64 Q6_P_lsror_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Rxx|=rol(Rss,#u6)

Word64 Q6_P_rolor_PI(Word64 Rxx, Word64 Rss,
Word32 Iu6)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

x5

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

0

x

x

x

x

x Rxx&=asr(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

1

x

x

x

x

x Rxx&=lsr(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

0

x

x

x

x

x Rxx&=asl(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

1

x

x

x

x

x Rxx&=rol(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

0

0

x

x

x

x

x Rxx|=asr(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

0

1

x

x

x

x

x Rxx|=lsr(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

1

0

x

x

x

x

x Rxx|=asl(Rss,#u6)

1

0

0

0

0

0

1

0

0

1

-

s

s

s

s

s

P

P

i

i

i

i

i

i

1

1

1

x

x

x

x

x Rxx|=rol(Rss,#u6)

1

0

0

0

0

0

1

0

1

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

0

1

x

x

x

x

x Rxx^=lsr(Rss,#u6)

1

0

0

0

0

0

1

0

1

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

0

x

x

x

x

x Rxx^=asl(Rss,#u6)

1

0

0

0

0

0

1

0

1

0

-

s

s

s

s

s

P

P

i

i

i

i

i

i

0

1

1

x

x

x

x

x Rxx^=rol(Rss,#u6)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

x

x

x

x

x Rx&=asr(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

x

x

x

x

x Rx&=lsr(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

x

x

x

x

x Rx&=asl(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

1

x

x

x

x

x Rx&=rol(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

0

0

x

x

x

x

x Rx|=asr(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

0

1

x

x

x

x

x Rx|=lsr(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

1

0

x

x

x

x

x Rx|=asl(Rs,#u5)

1

0

0

0

1

1

1

0

0

1

-

s

s

s

s

s

P

P 0

i

i

i

i

i

1

1

1

x

x

x

x

x Rx|=rol(Rs,#u5)

1

0

0

0

1

1

1

0

1

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

x

x

x

x

x Rx^=lsr(Rs,#u5)

1

0

0

0

1

1

1

0

1

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

x

x

x

x

x Rx^=asl(Rs,#u5)

0

0

0

1

1

1

0

1

0

-

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

1

x

x

x

x

x Rx^=rol(Rs,#u5)

1

ICLASS

RegType

x5

Parse

MajOp

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

0

i

0

0

-

Rx=and(#u8,asl(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

0

i

0

1

-

Rx=or(#u8,asl(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

1

i

0

0

-

Rx=and(#u8,lsr(Rx,#U5))

1

1

0

1

1

1

1

0

i

i

i

x

x

x

x

x

P

P

i

I

I

I

I

I

i

i

i

1

i

0

1

-

Rx=or(#u8,lsr(Rx,#U5))

80-N2040-46 Rev. B

650

Hexagon V68 Programmer’s Reference Manual

Field name
RegType
MajOp
ICLASS
Parse
s5
x5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Register Type
Major Opcode
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register x
Major Opcode
Minor Opcode
Register Type

651

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift right by immediate with rounding
Perform an arithmetic right shift by an immediate amount, and then round the result. This
instruction works by first shifting right, then adding the value +1 to the result, and finally
shifting right again by one bit. The right shifts always inserts the sign-bit in the vacated
position.
When using asrrnd, the assembler adjusts the immediate appropriately.

Lost

Rs

Sign-ext

+1
32-bit Add

Rd

80-N2040-46 Rev. B

Syntax

Behavior

Rd=asr(Rs,#u5):rnd

Rd = ((Rs >> #u)+1) >> 1;

Rd=asrrnd(Rs,#u5)

if ("#u5==0") {
Assembler mapped to: "Rd=Rs";
} else {
Assembler mapped to: "Rd=asr(Rs,#u5-1):rnd";
}

Rdd=asr(Rss,#u6):rnd

tmp = Rss >> #u;
rnd = tmp & 1;
Rdd = tmp >> 1 + rnd;

Rdd=asrrnd(Rss,#u6)

if ("#u6==0") {
Assembler mapped to: "Rdd=Rss";
} else {
Assembler mapped to: "Rdd=asr(Rss,#u61):rnd";
}

652

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics
Rd=asr(Rs,#u5):rnd

Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32 Iu5)

Rd=asrrnd(Rs,#u5)

Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32 Iu5)

Rdd=asr(Rss,#u6):rnd

Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32 Iu6)

Rdd=asrrnd(Rss,#u6)

Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32 Iu6)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

1

0

s

s

s

s

s

P

P

i

i

i

i

i

i

1

1

1

d

d

d

d

d Rdd=asr(Rss,#u6):rnd

1

0

0

0

1

1

0

0

0

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

d

d

d

d

d Rd=asr(Rs,#u5):rnd

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

653

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift left by immediate with saturation
Perform a left shift of the 32-bit source register value by an immediate amount and
saturate.
Saturation works by first sign-extending the 32-bit Rs register to 64 bits. It is then left
shifted by the immediate amount. If this 64-bit value cannot fit in a signed 32-bit number
(the upper word is not the sign-extension of bit 31), perform saturation based on the sign
of the original value. Saturation clamps the 32-bit result to the range 0x8000_0000 to
0x7fff_ffff.
Syntax

Behavior

Rd=asl(Rs,#u5):sat

Rd = sat_32(sxt32->64(Rs) << #u);

Class: XTYPE (slots 2,3)
Notes
■

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVF bit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

Intrinsics
Rd=asl(Rs,#u5):sat

Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32 Iu5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

1

0

MajOp
0

0

1

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

s5
0

s

s

s

8

7

i

0

Parse
s

s

P

P 0

6

5

4

3

d

d

MinOp
i

i

i

i

1

0

2

1

0

d

d Rd=asl(Rs,#u5):sat

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

654

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by register
The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
If the shift amount is negative (bit 6 of Rt is set), reverse the direction of the shift indicted
in the opcode (see Figure).
The source data to shift is always performed as a 64-bit shift. When the Rs source register
is a 32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic shifts
sign-extend the 32-bit source to 64-bits, while logical shifts zero extend.
The 64-bit source value is then right or left shifted based on the shift amount and the type
of instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
positions. Logical right shifts place zeros in the vacated positions.
ASR w/ Positive Rt
ASL w/ Negative Rt

LSR w/ Positive Rt
LSL w/ Negative Rt
Lost

Sign-ext

Lost

Rs

Rd

Zero-fill

Rs

Rd

ASL w/ Positive Rt
LSL w/ Positive Rt
ASR w/ Negative Rt
LSR w/ Negative Rt
Lost

Rs
Zero-fill

80-N2040-46 Rev. B

Rd

Syntax

Behavior

Rd=asl(Rs,Rt)

shamt=sxt7->32(Rt);
Rd = (shamt>0)?(sxt32->64(Rs)<<shamt):(sxt32>64(Rs)>>shamt);

Rd=asr(Rs,Rt)

shamt=sxt7->32(Rt);
Rd = (shamt>0)?(sxt32->64(Rs)>>shamt):(sxt32>64(Rs)<<shamt);

Rd=lsl(#s6,Rt)

shamt = sxt7->32(Rt);
Rd = (shamt>0)?(zxt32->64(#s)<<shamt):(zxt32>64(#s)>>>shamt);

Rd=lsl(Rs,Rt)

shamt=sxt7->32(Rt);
Rd = (shamt>0)?(zxt32->64(Rs)<<shamt):(zxt32>64(Rs)>>>shamt);

655

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rd=lsr(Rs,Rt)

shamt=sxt7->32(Rt);
Rd = (shamt>0)?(zxt32->64(Rs)>>>shamt):(zxt32>64(Rs)<<shamt);

Rdd=asl(Rss,Rt)

shamt=sxt7->32(Rt);
Rdd = (shamt>0)?(Rss<<shamt):(Rss>>shamt);

Rdd=asr(Rss,Rt)

shamt=sxt7->32(Rt);
Rdd = (shamt>0)?(Rss>>shamt):(Rss<<shamt);

Rdd=lsl(Rss,Rt)

shamt=sxt7->32(Rt);
Rdd = (shamt>0)?(Rss<<shamt):(Rss>>>shamt);

Rdd=lsr(Rss,Rt)

shamt=sxt7->32(Rt);
Rdd = (shamt>0)?(Rss>>>shamt):(Rss<<shamt);

Class: XTYPE (slots 2,3)
Intrinsics
Rd=asl(Rs,Rt)

Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)

Rd=asr(Rs,Rt)

Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)

Rd=lsl(#s6,Rt)

Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)

Rd=lsl(Rs,Rt)

Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)

Rd=lsr(Rs,Rt)

Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)

Rdd=asl(Rss,Rt)

Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)

Rdd=asr(Rss,Rt)

Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)

Rdd=lsl(Rss,Rt)

Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)

Rdd=lsr(Rss,Rt)

Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

0

1

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rdd=asr(Rss,Rt)

1

1

0

0

0

0

1

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=lsr(Rss,Rt)

1

1

0

0

0

0

1

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rdd=asl(Rss,Rt)

1

1

0

0

0

0

1

1

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=lsl(Rss,Rt)

1

1

0

0

0

1

1

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=asr(Rs,Rt)

1

1

0

0

0

1

1

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rd=lsr(Rs,Rt)

1

1

0

0

0

1

1

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=asl(Rs,Rt)

1

1

0

0

0

1

1

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rd=lsl(Rs,Rt)

d

d Rd=lsl(#s6,Rt)

ICLASS
1

1

0

RegType
0

0

1

80-N2040-46 Rev. B

1

Maj
0

1

0

Parse
-

i

i

i

i

i

P

P

t5
-

t

t

t

Min
t

t

1

1

d5
i

d

d

d

656

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

657

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by register and accumulate
The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
opcode is reversed.
Shift the source register value right or left based on the shift amount and the type of
instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
positions. Logical right shifts place zeros in the vacated positions.
The shift operation is always performed as a 64-bit shift. When Rs is a 32-bit register, this
register is first sign- or zero-extended to 64-bits. Arithmetic shifts sign-extend the 32-bit
source to 64-bits, while logical shifts zero extend.
After shifting, add or subtract the 64-bit shifted amount from the destination register or
register pair.

Rss

# / Rt

Rs

# / Rt

64-bit Shift Value

Shift Amt

32-bit Shift Value

Shift Amt

64-bit Shift

32-bit Shift

64-bit Add/Sub

32-bit Add/Sub

64 bit result

80-N2040-46 Rev. B

32 bit result

Rxx

Syntax

Behavior

Rx[+-]=asl(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [+-] (shamt>0)?(sxt32>64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);

Rx[+-]=asr(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [+-] (shamt>0)?(sxt32>64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);

Rx[+-]=lsl(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [+-] (shamt>0)?(zxt32>64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);

Rx

658

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Syntax

Behavior

Rx[+-]=lsr(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [+-] (shamt>0)?(zxt32>64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);

Rxx[+-]=asl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [+-]
(shamt>0)?(Rss<<shamt):(Rss>>shamt);

Rxx[+-]=asr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [+-]
(shamt>0)?(Rss>>shamt):(Rss<<shamt);

Rxx[+-]=lsl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [+-]
(shamt>0)?(Rss<<shamt):(Rss>>>shamt);

Rxx[+-]=lsr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [+-]
(shamt>0)?(Rss>>>shamt):(Rss<<shamt);

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx+=asl(Rs,Rt)

Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=asr(Rs,Rt)

Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=lsl(Rs,Rt)

Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx+=lsr(Rs,Rt)

Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=asl(Rs,Rt)

Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=asr(Rs,Rt)

Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=lsl(Rs,Rt)

Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx-=lsr(Rs,Rt)

Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rxx+=asl(Rss,Rt)

Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx+=asr(Rss,Rt)

Word64 Q6_P_asracc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx+=lsl(Rss,Rt)

Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

659

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Rxx+=lsr(Rss,Rt)

Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx-=asl(Rss,Rt)

Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx-=asr(Rss,Rt)

Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx-=lsl(Rss,Rt)

Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx-=lsr(Rss,Rt)

Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

x5

1

1

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rxx-=asr(Rss,Rt)

1

1

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rxx-=lsr(Rss,Rt)

1

1

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rxx-=asl(Rss,Rt)

1

1

0

0

1

0

1

1

1

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rxx-=lsl(Rss,Rt)

1

1

0

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rxx+=asr(Rss,Rt)

1

1

0

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rxx+=lsr(Rss,Rt)

1

1

0

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rxx+=asl(Rss,Rt)

1

1

0

0

1

0

1

1

1

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rxx+=lsl(Rss,Rt)

1

1

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rx-=asr(Rs,Rt)

1

1

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rx-=lsr(Rs,Rt)

1

1

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rx-=asl(Rs,Rt)

1

1

0

0

1

1

0

0

1

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rx-=lsl(Rs,Rt)

1

1

0

0

1

1

0

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rx+=asr(Rs,Rt)

1

1

0

0

1

1

0

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rx+=lsr(Rs,Rt)

1

1

0

0

1

1

0

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rx+=asl(Rs,Rt)

1

1

0

0

1

1

0

0

1

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rx+=lsl(Rs,Rt)

Field name
ICLASS
Parse
s5
t5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Register Type

660

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by register and logical
The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicted in the
opcode is reversed.
Shift the source register value right or left based on the shift amount and the type of
instruction. Arithmetic right shifts place the sign bit of the source value in the vacated
positions. Logical right shifts place zeros in the vacated positions.
The shift operation is always performed as a 64-bit shift. When the Rs source register is a
32-bit register, this register is first sign or zero-extended to 64-bits. Arithmetic shifts signextend the 32-bit source to 64-bits, while logical shifts zero extend.
After shifting, take the logical AND or OR of the shifted amount and the destination
register or register pair, and place the result back in the destination register or register pair.
Saturation is not available for these instructions.

Rss

# / Rt

Rs

# / Rt

64-bit Shift Value

Shift Amt

32-bit Shift Value

Shift Amt

64-bit Shift

32-bit Shift

64-bit AND/OR

32-bit AND/OR

64 bit result

80-N2040-46 Rev. B

Rxx

32 bit result

Rx

661

Hexagon V68 Programmer’s Reference Manual

80-N2040-46 Rev. B

Instruction Set

Syntax

Behavior

Rx[&|]=asl(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [|&] (shamt>0)?(sxt32>64(Rs)<<shamt):(sxt32->64(Rs)>>shamt);

Rx[&|]=asr(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [|&] (shamt>0)?(sxt32>64(Rs)>>shamt):(sxt32->64(Rs)<<shamt);

Rx[&|]=lsl(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [|&] (shamt>0)?(zxt32>64(Rs)<<shamt):(zxt32->64(Rs)>>>shamt);

Rx[&|]=lsr(Rs,Rt)

shamt=sxt7->32(Rt);
Rx = Rx [|&] (shamt>0)?(zxt32>64(Rs)>>>shamt):(zxt32->64(Rs)<<shamt);

Rxx[&|]=asl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [|&]
(shamt>0)?(Rss<<shamt):(Rss>>shamt);

Rxx[&|]=asr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [|&]
(shamt>0)?(Rss>>shamt):(Rss<<shamt);

Rxx[&|]=lsl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [|&]
(shamt>0)?(Rss<<shamt):(Rss>>>shamt);

Rxx[&|]=lsr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx [|&]
(shamt>0)?(Rss>>>shamt):(Rss<<shamt);

Rxx^=asl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx ^ (shamt>0)?(Rss<<shamt):(Rss>>shamt);

Rxx^=asr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx ^ (shamt>0)?(Rss>>shamt):(Rss<<shamt);

Rxx^=lsl(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx ^
(shamt>0)?(Rss<<shamt):(Rss>>>shamt);

Rxx^=lsr(Rss,Rt)

shamt=sxt7->32(Rt);
Rxx = Rxx ^
(shamt>0)?(Rss>>>shamt):(Rss<<shamt);

662

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Class: XTYPE (slots 2,3)
Intrinsics

80-N2040-46 Rev. B

Rx&=asl(Rs,Rt)

Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=asr(Rs,Rt)

Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=lsl(Rs,Rt)

Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx&=lsr(Rs,Rt)

Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=asl(Rs,Rt)

Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=asr(Rs,Rt)

Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=lsl(Rs,Rt)

Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rx|=lsr(Rs,Rt)

Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs,
Word32 Rt)

Rxx&=asl(Rss,Rt)

Word64 Q6_P_asland_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx&=asr(Rss,Rt)

Word64 Q6_P_asrand_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx&=lsl(Rss,Rt)

Word64 Q6_P_lsland_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx&=lsr(Rss,Rt)

Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx^=asl(Rss,Rt)

Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx^=asr(Rss,Rt)

Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx^=lsl(Rss,Rt)

Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx^=lsr(Rss,Rt)

Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx|=asl(Rss,Rt)

Word64 Q6_P_aslor_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx|=asr(Rss,Rt)

Word64 Q6_P_asror_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx|=lsl(Rss,Rt)

Word64 Q6_P_lslor_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

Rxx|=lsr(Rss,Rt)

Word64 Q6_P_lsror_PR(Word64 Rxx, Word64 Rss,
Word32 Rt)

663

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

t5

6

5

4

3

Min

2

1

0

x5

1

1

0

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rxx|=asr(Rss,Rt)

1

1

0

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rxx|=lsr(Rss,Rt)

1

1

0

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rxx|=asl(Rss,Rt)

1

1

0

0

1

0

1

1

0

0

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rxx|=lsl(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rxx&=asr(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rxx&=lsr(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rxx&=asl(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

0

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rxx&=lsl(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rxx^=asr(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rxx^=lsr(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rxx^=asl(Rss,Rt)

1

1

0

0

1

0

1

1

0

1

1

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rxx^=lsl(Rss,Rt)

1

1

0

0

1

1

0

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rx|=asr(Rs,Rt)

1

1

0

0

1

1

0

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rx|=lsr(Rs,Rt)

1

1

0

0

1

1

0

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rx|=asl(Rs,Rt)

1

1

0

0

1

1

0

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rx|=lsl(Rs,Rt)

1

1

0

0

1

1

0

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

x

x

x

x

x Rx&=asr(Rs,Rt)

1

1

0

0

1

1

0

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

x

x

x

x

x Rx&=lsr(Rs,Rt)

1

1

0

0

1

1

0

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

x

x

x

x

x Rx&=asl(Rs,Rt)

1

1

0

0

1

1

0

0

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

x

x

x

x

x Rx&=lsl(Rs,Rt)

Field name
ICLASS
Parse
s5
t5
x5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register s
Field to encode register t
Field to encode register x
Major Opcode
Minor Opcode
Register Type

664

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Shift by register with saturation
The shift amount is the least significant seven bits of Rt, treated as a two's complement
value. If the shift amount is negative (bit 6 of Rt is set), the direction of the shift indicated
in the opcode is reversed.
Saturation is available for 32-bit arithmetic left shifts. This can be either an ASL
instruction with positive Rt, or an ASR instruction with negative Rt. Saturation works by
first sign-extending the 32-bit Rs register to 64 bits. It is then shifted by the shift amount.
If this 64-bit value cannot fit in a signed 32-bit number (the upper word is not the signextension of bit 31), saturation is performed based on the sign of the original value.
Saturation clamps the 32-bit result to the range 0x80000000 to 0x7fffffff.
Syntax

Behavior

Rd=asl(Rs,Rt):sat

shamt=sxt7->32(Rt);
Rd = bidir_shiftl(Rs,shamt);

Rd=asr(Rs,Rt):sat

shamt=sxt7->32(Rt);
Rd = bidir_shiftr(Rs,shamt);

Class: XTYPE (slots 2,3)
Notes

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

■

Intrinsics
Rd=asl(Rs,Rt):sat

Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32 Rt)

Rd=asr(Rs,Rt):sat

Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

7

t5

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

1

1

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rd=asr(Rs,Rt):sat

1

1

0

0

0

1

1

0

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rd=asl(Rs,Rt):sat

Field name
ICLASS
Parse
d5
s5
t5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t

665

Hexagon V68 Programmer’s Reference Manual

Field name
Maj
Min
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Major Opcode
Minor Opcode
Register Type

666

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shift halfwords by immediate
Shifts individual halfwords of the source vector. Arithmetic right shifts place the sign bit
of the source values in the vacated positions. Logical right shifts place zeros in the vacated
positions.

Rdd = vaslh(Rss,#)
lost

lost

lost

0

0

Shift Amount

Rt/#u4

lost

Rss

0

0

Syntax

Behavior

Rdd=vaslh(Rss,#u4)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.h[i]<<#u);
}

Rdd=vasrh(Rss,#u4)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.h[i]>>#u);
}

Rdd=vlsrh(Rss,#u4)

for (i=0;i<4;i++) {
Rdd.h[i]=(Rss.uh[i]>>#u);
}

Rdd

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vaslh(Rss,#u4)

Word64 Q6_P_vaslh_PI(Word64 Rss, Word32 Iu4)

Rdd=vasrh(Rss,#u4)

Word64 Q6_P_vasrh_PI(Word64 Rss, Word32 Iu4)

Rdd=vlsrh(Rss,#u4)

Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32 Iu4)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

1

0

0

s

s

s

s

s

P

P 0

0

i

i

i

i

0

0

0

d

d

d

d

d Rdd=vasrh(Rss,#u4)

1

0

0

0

0

0

0

0

1

0

0

s

s

s

s

s

P

P 0

0

i

i

i

i

0

0

1

d

d

d

d

d Rdd=vlsrh(Rss,#u4)

1

0

0

0

0

0

0

0

1

0

0

s

s

s

s

s

P

P 0

0

i

i

i

i

0

1

0

d

d

d

d

d Rdd=vaslh(Rss,#u4)

Field name
ICLASS
Parse
d5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d

667

Hexagon V68 Programmer’s Reference Manual

Field name
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Major Opcode
Minor Opcode
Register Type

668

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector arithmetic shift halfwords with round
For each halfword in the vector, round then arithmetic shift right by an immediate amount.
The results are stored in the destination register.
Rdd = vasrh(Rss,#u):rnd

1<<(#u-1)

1<<(#u-1)

1<<(#u-1)

1<<(#u-1)

+

+

+

+

lost

lost

Signext

Signext

lost

Signext

lost

Signext

Syntax

Behavior

Rdd=vasrh(Rss,#u4):raw

for (i=0;i<4;i++) {
Rdd.h[i]=( ((Rss.h[i] >> #u)+1)>>1 );
}

Rdd=vasrh(Rss,#u4):rnd

if ("#u4==0") {
Assembler mapped to: "Rdd=Rss";
} else {
Assembler mapped to: "Rdd=vasrh(Rss,#u41):raw";
}

Class: XTYPE (slots 2,3)
Intrinsics
Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32 Iu4)

Rdd=vasrh(Rss,#u4):rnd

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

0

0

0

MajOp
0

0

0

Field name
ICLASS
Parse
d5

80-N2040-46 Rev. B

s5
1

s

s

s

8

7

i

0

Parse
s

s

P

P 0

6

5

4

3

d

d

MinOp
0

i

i

i

0

0

2

1

0

d

d Rdd=vasrh(Rss,#u4):raw

d5
d

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d

669

Hexagon V68 Programmer’s Reference Manual

Field name
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Major Opcode
Minor Opcode
Register Type

670

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector arithmetic shift halfwords with saturate and pack
For each halfword in the vector, optionally round, then arithmetic shift right by an
immediate amount. The results are saturated to unsigned [0-255] and then packed in the
destination register.
Rd = vasrhub(Rss,#u):rnd:sat

1<<(#u-1)

1<<(#u-1)

1<<(#u-1)

1<<(#u-1)

+

+

+

+

lost

Sat_u8

lost

Sat_u8

lost

Sat_u8

lost

Sat_u8

Syntax

Behavior

Rd=vasrhub(Rss,#u4):raw

for (i=0;i<4;i++) {
Rd.b[i]=usat_8(((Rss.h[i] >> #u )+1)>>1);
}

Rd=vasrhub(Rss,#u4):rnd:sat

if ("#u4==0") {
Assembler mapped to: "Rd=vsathub(Rss)";
} else {
Assembler mapped to: "Rd=vasrhub(Rss,#u41):raw";
}

Rd=vasrhub(Rss,#u4):sat

for (i=0;i<4;i++) {
Rd.b[i]=usat_8(Rss.h[i] >> #u);
}

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If saturation occurs during execution of this instruction (a result is clamped to
either maximum or minimum values), the OVFbit in the Status Register is set.
OVF remains set until explicitly cleared by a transfer to SR.

671

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rd=vasrhub(Rss,#u4):rnd:sat

Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss,
Word32 Iu4)

Rd=vasrhub(Rss,#u4):sat

Word32 Q6_R_vasrhub_PI_sat(Word64 Rss, Word32
Iu4)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P 0

0

i

i

i

i

1

0

0

d

d

d

d

d Rd=vasrhub(Rss,#u4):raw

1

0

0

0

1

0

0

0

0

1

1

s

s

s

s

s

P

P 0

0

i

i

i

i

1

0

1

d

d

d

d

d Rd=vasrhub(Rss,#u4):sat

Field name
ICLASS
Parse
d5
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Major Opcode
Minor Opcode
Register Type

672

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shift halfwords by register
The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
If the shift amount is negative, the direction of the shift is reversed. Shift the source values
right or left based on the shift amount and the type of instruction. Arithmetic right shifts
place the sign bit of the source value in the vacated positions. Logical right shifts place
zeros in the vacated positions.

Rdd = vaslh(Rss,#)
lost

lost

0

lost

0

0

Shift Amount

Rt/#u4

lost

Rss

0

Rdd

Syntax

Behavior

Rdd=vaslh(Rss,Rt)

for (i=0;i<4;i++) {
Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16>64(Rss.h[i])<<sxt7->32(Rt)):(sxt16>64(Rss.h[i])>>sxt7->32(Rt));
}

Rdd=vasrh(Rss,Rt)

for (i=0;i<4;i++) {
Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16(Rss.h[i])>>sxt
>64
7->32(Rt)):(sxt16>64(Rss.h[i])<<sxt7->32(Rt));
}

Rdd=vlslh(Rss,Rt)

for (i=0;i<4;i++) {
Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16(Rss.uh[i])<<sxt
7->32(Rt)):(zxt16>64
(Rss.uh[i])>>>sxt
>64
7->32(Rt));
}

Rdd=vlsrh(Rss,Rt)

for (i=0;i<4;i++) {
Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16(Rss.uh[i])>>>sxt
>64
7->32(Rt)):(zxt16(Rss.uh[i])<<sxt
>64
7->32(Rt));
}

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If the number of bits to shift is greater than the width of the vector element, the
result is either all sign-bits (for arithmetic right shifts) or all zeros for logical and
left shifts.

673

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rdd=vaslh(Rss,Rt)

Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)

Rdd=vasrh(Rss,Rt)

Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)

Rdd=vlslh(Rss,Rt)

Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)

Rdd=vlsrh(Rss,Rt)

Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

0

1

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rdd=vasrh(Rss,Rt)

1

1

0

0

0

0

1

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=vlsrh(Rss,Rt)

1

1

0

0

0

0

1

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rdd=vaslh(Rss,Rt)

1

1

0

0

0

0

1

1

0

1

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=vlslh(Rss,Rt)

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

674

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shift words by immediate
Shift individual words of the source vector. Arithmetic right shifts place the sign bit of the
source values in the vacated positions. Logical right shifts place zeros in the vacated
positions.

Rdd = vaslw(Rss,{Rt/#})
lost

Rt/#u5

Shift Amount

lost

Rss

0

0

Rdd

0

Syntax

Behavior

Rdd=vaslw(Rss,#u5)

for (i=0;i<2;i++) {
Rdd.w[i]=(Rss.w[i]<<#u);
}

Rdd=vasrw(Rss,#u5)

for (i=0;i<2;i++) {
Rdd.w[i]=(Rss.w[i]>>#u);
}

Rdd=vlsrw(Rss,#u5)

for (i=0;i<2;i++) {
Rdd.w[i]=(Rss.uw[i]>>#u);
}

Class: XTYPE (slots 2,3)
Intrinsics
Rdd=vaslw(Rss,#u5)

Word64 Q6_P_vaslw_PI(Word64 Rss, Word32 Iu5)

Rdd=vasrw(Rss,#u5)

Word64 Q6_P_vasrw_PI(Word64 Rss, Word32 Iu5)

Rdd=vlsrw(Rss,#u5)

Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32 Iu5)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

MajOp

s5

8

7

Parse

6

5

4

3

MinOp

2

1

0

d5

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

0

d

d

d

d

d Rdd=vasrw(Rss,#u5)

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

0

1

d

d

d

d

d Rdd=vlsrw(Rss,#u5)

1

0

0

0

0

0

0

0

0

1

0

s

s

s

s

s

P

P 0

i

i

i

i

i

0

1

0

d

d

d

d

d Rdd=vaslw(Rss,#u5)

Field name
ICLASS
Parse
d5

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d

675

Hexagon V68 Programmer’s Reference Manual

Field name
s5
MajOp
MinOp
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Field to encode register s
Major Opcode
Minor Opcode
Register Type

676

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shift words by register
The shift amount is the least significant 7 bits of Rt, treated as a two's complement value.
If the shift amount is negative, the direction of the shift is reversed. Shift the source values
right or left based on the shift amount and the type of instruction. Arithmetic right shifts
place the sign bit of the source value in the vacated positions. Logical right shifts place
zeros in the vacated positions.

Rdd = vaslw(Rss,{Rt/#})
lost

Rt/#u5

Shift Amount

lost

0

Rss

0

0

Rdd

Syntax

Behavior

Rdd=vaslw(Rss,Rt)

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32>64(Rss.w[i])<<sxt7->32(Rt)):(sxt32>64(Rss.w[i])>>sxt7->32(Rt));
}

Rdd=vasrw(Rss,Rt)

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32>64(Rss.w[i])>>sxt7->32(Rt)):(sxt32>64(Rss.w[i])<<sxt7->32(Rt));
}

Rdd=vlslw(Rss,Rt)

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32>64(Rss.uw[i])<<sxt7->32(Rt)):(zxt32>64(Rss.uw[i])>>>sxt7->32(Rt));
}

Rdd=vlsrw(Rss,Rt)

for (i=0;i<2;i++) {
Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32>64(Rss.uw[i])>>>sxt7->32(Rt)):(zxt32>64(Rss.uw[i])<<sxt7->32(Rt));
}

Class: XTYPE (slots 2,3)
Notes
■

80-N2040-46 Rev. B

If the number of bits to shift is greater than the width of the vector element, the
result is either all sign-bits (for arithmetic right shifts) or all zeros for logical and
left shifts.

677

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Intrinsics
Rdd=vaslw(Rss,Rt)

Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)

Rdd=vasrw(Rss,Rt)

Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)

Rdd=vlslw(Rss,Rt)

Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)

Rdd=vlsrw(Rss,Rt)

Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS

RegType

Maj

s5

Parse

8

t5

7

6

5

4

3

Min

2

1

0

d5

1

1

0

0

0

0

1

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

0

-

d

d

d

d

d Rdd=vasrw(Rss,Rt)

1

1

0

0

0

0

1

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

0

1

-

d

d

d

d

d Rdd=vlsrw(Rss,Rt)

1

1

0

0

0

0

1

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

0

-

d

d

d

d

d Rdd=vaslw(Rss,Rt)

1

1

0

0

0

0

1

1

0

0

-

s

s

s

s

s

P

P

-

t

t

t

t

t

1

1

-

d

d

d

d

d Rdd=vlslw(Rss,Rt)

Field name
ICLASS
Parse
d5
s5
t5
Maj
Min
RegType

80-N2040-46 Rev. B

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Register Type

678

Hexagon V68 Programmer’s Reference Manual

Instruction Set

Vector shift words with truncate and pack
Shifts individual words of the source vector Rss right by a register or immediate amount.
The low 16-bits of each word are packed into destination register Rd.

Rd = vasrw(Rss,{Rt/#})

Rt/#u5

Shift Amount

lost

lost

sxt

Rss

sxt

Low 16bits

Low 16bits

Rd
Syntax

Behavior

Rd=vasrw(Rss,#u5)

for (i=0;i<2;i++) {
Rd.h[i]=(Rss.w[i]>>#u).h[0];
}

Rd=vasrw(Rss,Rt)

for (i=0;i<2;i++) {
Rd.h[i]=(sxt7->32(Rt)>0)?(sxt32>64(Rss.w[i])>>sxt7->32(Rt)):(sxt32>64(Rss.w[i])<<sxt7->32(Rt)).h[0];
}

Class: XTYPE (slots 2,3)
Intrinsics
Rd=vasrw(Rss,#u5)

Word32 Q6_R_vasrw_PI(Word64 Rss, Word32 Iu5)

Rd=vasrw(Rss,Rt)

Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)

Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9
ICLASS
1

0

0

RegType
0

1

ICLASS
1

1

0

0

0

MajOp
0

1

1

s5
0

s

s

RegType
0

0

1

80-N2040-46 Rev. B

0

s

s

s

s5
1

-

-

-

s

s

s

8

7

Parse
P

P 0

i

i

Parse
s

s

P

P

6

5

4

3

MinOp
i

i

i

t5
-

t

t

t

0

1

0

d

d

Min
t

t

0

1

2

1

0

d

d Rd=vasrw(Rss,#u5)

d

d Rd=vasrw(Rss,Rt)

d5
d
d5

0

d

d

d

679

Hexagon V68 Programmer’s Reference Manual

Field name
ICLASS
Parse
d5
s5
t5
MajOp
MinOp
Min
RegType
RegType

80-N2040-46 Rev. B

Instruction Set

Description
Instruction Class
Packet/Loop parse bits
Field to encode register d
Field to encode register s
Field to encode register t
Major Opcode
Minor Opcode
Minor Opcode
Register Type
Register Type

680

Instruction Index
A

any8
Pd=any8(Ps) 213

abs
Rd=abs(Rs)[:sat] 392
Rdd=abs(Rss) 391

asl
Rd=asl(Rs,#u5) 642
Rd=asl(Rs,#u5):sat 654
Rd=asl(Rs,Rt) 655
Rd=asl(Rs,Rt):sat 665
Rdd=asl(Rss,#u6) 642
Rdd=asl(Rss,Rt) 656
Rx^=asl(Rs,#u5) 648
Rx[&|]=asl(Rs,#u5) 648
Rx[&|]=asl(Rs,Rt) 662
Rx[+-]=asl(Rs,#u5) 644
Rx[+-]=asl(Rs,Rt) 658
Rx=add(#u8,asl(Rx,#U5)) 644
Rx=and(#u8,asl(Rx,#U5)) 648
Rx=or(#u8,asl(Rx,#U5)) 648
Rx=sub(#u8,asl(Rx,#U5)) 644
Rxx^=asl(Rss,#u6) 649
Rxx^=asl(Rss,Rt) 662
Rxx[&|]=asl(Rss,#u6) 648
Rxx[&|]=asl(Rss,Rt) 662
Rxx[+-]=asl(Rss,#u6) 644
Rxx[+-]=asl(Rss,Rt) 659

add
if ([!]Pu[.new]) Rd=add(Rs,#s8) 194
if ([!]Pu[.new]) Rd=add(Rs,Rt) 194
Rd=add(#u6,mpyi(Rs,#U6)) 540
Rd=add(#u6,mpyi(Rs,Rt)) 540
Rd=add(Rs,#s16) 170
Rd=add(Rs,add(Ru,#s6)) 393
Rd=add(Rs,Rt) 170
Rd=add(Rs,Rt):sat 170
Rd=add(Rs,Rt):sat:deprecated 395
Rd=add(Rt.[HL],Rs.[HL])[:sat]:<<16 397
Rd=add(Rt.L,Rs.[HL])[:sat] 397
Rd=add(Ru,mpyi(#u6:2,Rs)) 540
Rd=add(Ru,mpyi(Rs,#u6)) 540
Rdd=add(Rs,Rtt) 395
Rdd=add(Rss,Rtt,Px):carry 399
Rdd=add(Rss,Rtt) 395
Rdd=add(Rss,Rtt):raw:hi 395
Rdd=add(Rss,Rtt):raw:lo 395
Rdd=add(Rss,Rtt):sat 395
Rx+=add(Rs,#s8) 393
Rx+=add(Rs,Rt) 393
Rx-=add(Rs,#s8) 393
Rx-=add(Rs,Rt) 393
Ry=add(Ru,mpyi(Ry,Rs)) 541

addasl
Rd=addasl(Rt,Rs,#u3) 647

all8
Pd=all8(Ps) 213

allocframe
allocframe(#u11:3) 329
allocframe(Rx,#u11:3):raw 329

and
if ([!]Pu[.new]) Rd=and(Rs,Rt) 199
Pd=and(Ps,and(Pt,[!]Pu)) 219
Pd=and(Pt,[!]Ps) 219
Rd=and(Rs,#s10) 172
Rd=and(Rs,Rt) 172
Rd=and(Rt,~Rs) 172
Rdd=and(Rss,Rtt) 401
Rdd=and(Rtt,~Rss) 401
Rx[&|^]=and(Rs,~Rt) 404
Rx[&|^]=and(Rs,Rt) 404
Rx|=and(Rs,#s10) 404

80-N2040-46 Rev. B

aslh
if ([!]Pu[.new]) Rd=aslh(Rs) 196
Rd=aslh(Rs) 191

asr
Rd=asr(Rs,#u5) 642
Rd=asr(Rs,#u5):rnd 652
Rd=asr(Rs,Rt) 655
Rd=asr(Rs,Rt):sat 665
Rdd=asr(Rss,#u6) 642
Rdd=asr(Rss,#u6):rnd 652
Rdd=asr(Rss,Rt) 656
Rx[&|]=asr(Rs,#u5) 648
Rx[&|]=asr(Rs,Rt) 662
Rx[+-]=asr(Rs,#u5) 644
Rx[+-]=asr(Rs,Rt) 658
Rxx^=asr(Rss,Rt) 662
Rxx[&|]=asr(Rss,#u6) 648
Rxx[&|]=asr(Rss,Rt) 662
Rxx[+-]=asr(Rss,#u6) 644
Rxx[+-]=asr(Rss,Rt) 659

asrh
if ([!]Pu[.new]) Rd=asrh(Rs) 196
Rd=asrh(Rs) 191

asrrnd
Rd=asrrnd(Rs,#u5) 652
Rdd=asrrnd(Rss,#u6) 652

681

Hexagon V68 Programmer’s Reference Manual

B

Instruction Index

cmp.eq

barrier
barrier 374

bitsclr
Pd=[!]bitsclr(Rs,#u6) 627
Pd=[!]bitsclr(Rs,Rt) 627

bitsplit
Rdd=bitsplit(Rs,#u5) 482
Rdd=bitsplit(Rs,Rt) 482

if ([!]cmp.eq(Ns.new,#-1)) jump:<hint> #r9:2 286
if ([!]cmp.eq(Ns.new,#U5)) jump:<hint> #r9:2 286
if ([!]cmp.eq(Ns.new,Rt)) jump:<hint> #r9:2 286
p[01]=cmp.eq(Rs,#-1) 228
p[01]=cmp.eq(Rs,#U5) 228
p[01]=cmp.eq(Rs,Rt) 228
Pd=[!]cmp.eq(Rs,#s10) 207
Pd=[!]cmp.eq(Rs,Rt) 207
Pd=cmp.eq(Rss,Rtt) 626
Rd=[!]cmp.eq(Rs,#s8) 209
Rd=[!]cmp.eq(Rs,Rt) 209

cmp.ge
bitsset

Pd=cmp.ge(Rs,#s8) 207

Pd=[!]bitsset(Rs,Rt) 627

cmp.geu
boundscheck
Pd=boundscheck(Rs,Rtt) 620
Pd=boundscheck(Rss,Rtt):raw:hi 620
Pd=boundscheck(Rss,Rtt):raw:lo 620

brev
Rd=brev(Rs) 479
Rdd=brev(Rss) 479

brkpt
brkpt 375

C
call
call #r22:2 226
if ([!]Pu) call #r15:2 226

callr
callr Rs 222
if ([!]Pu) callr Rs 222

Pd=cmp.geu(Rs,#u8) 207

cmp.gt
if ([!]cmp.gt(Ns.new,#-1)) jump:<hint> #r9:2 286
if ([!]cmp.gt(Ns.new,#U5)) jump:<hint> #r9:2 286
if ([!]cmp.gt(Ns.new,Rt)) jump:<hint> #r9:2 287
if ([!]cmp.gt(Rt,Ns.new)) jump:<hint> #r9:2 287
p[01]=cmp.gt(Rs,#-1) 228
p[01]=cmp.gt(Rs,#U5) 228
p[01]=cmp.gt(Rs,Rt) 228
Pd=[!]cmp.gt(Rs,#s10) 207
Pd=[!]cmp.gt(Rs,Rt) 207
Pd=cmp.gt(Rss,Rtt) 626

cmp.gtu
if ([!]cmp.gtu(Ns.new,#U5)) jump:<hint> #r9:2 287
if ([!]cmp.gtu(Ns.new,Rt)) jump:<hint> #r9:2 287
if ([!]cmp.gtu(Rt,Ns.new)) jump:<hint> #r9:2 287
p[01]=cmp.gtu(Rs,#U5) 228
p[01]=cmp.gtu(Rs,Rt) 229
Pd=[!]cmp.gtu(Rs,#u9) 207
Pd=[!]cmp.gtu(Rs,Rt) 207
Pd=cmp.gtu(Rss,Rtt) 626

ciad
ciad(Rs) 333

cmp.lt

Rd=cl0(Rs) 466
Rd=cl0(Rss) 466

cmp.ltu

Pd=cmp.lt(Rs,Rt) 207

cl0

cl1

Pd=cmp.ltu(Rs,Rt) 207

cmpb.eq
Rd=cl1(Rs) 466
Rd=cl1(Rss) 466

clb

Pd=cmpb.eq(Rs,#u8) 622
Pd=cmpb.eq(Rs,Rt) 622

cmpb.gt
Rd=add(clb(Rs),#s6) 466
Rd=add(clb(Rss),#s6) 466
Rd=clb(Rs) 466
Rd=clb(Rss) 466

clip
Rd=clip(Rs,#u5) 400

Pd=cmpb.gt(Rs,#s8) 622
Pd=cmpb.gt(Rs,Rt) 622

cmpb.gtu
Pd=cmpb.gtu(Rs,#u7) 622
Pd=cmpb.gtu(Rs,Rt) 622

cmph.eq
clrbit
memb(Rs+#u6:0)=clrbit(#U5) 282
memh(Rs+#u6:1)=clrbit(#U5) 284
memw(Rs+#u6:2)=clrbit(#U5) 285
Rd=clrbit(Rs,#u5) 480
Rd=clrbit(Rs,Rt) 480

80-N2040-46 Rev. B

Pd=cmph.eq(Rs,#s8) 624
Pd=cmph.eq(Rs,Rt) 624

cmph.gt
Pd=cmph.gt(Rs,#s8) 624
Pd=cmph.gt(Rs,Rt) 624

682

Hexagon V68 Programmer’s Reference Manual

cmph.gtu

Instruction Index

convert_df2sf

Pd=cmph.gtu(Rs,#u7) 624
Pd=cmph.gtu(Rs,Rt) 624

Rd=convert_df2sf(Rss) 523

convert_df2ud
Rdd=convert_df2ud(Rss) 526
Rdd=convert_df2ud(Rss):chop 526

cmpy
Rd=cmpy(Rs,Rt)[:<<1]:rnd:sat 497
Rd=cmpy(Rs,Rt*)[:<<1]:rnd:sat 497
Rdd=cmpy(Rs,Rt)[:<<1]:sat 492
Rdd=cmpy(Rs,Rt*)[:<<1]:sat 492
Rxx+=cmpy(Rs,Rt)[:<<1]:sat 493
Rxx+=cmpy(Rs,Rt*)[:<<1]:sat 493
Rxx-=cmpy(Rs,Rt)[:<<1]:sat 493
Rxx-=cmpy(Rs,Rt*)[:<<1]:sat 493

convert_df2uw
Rd=convert_df2uw(Rss) 526
Rd=convert_df2uw(Rss):chop 526

convert_df2w
Rd=convert_df2w(Rss) 526
Rd=convert_df2w(Rss):chop 526

cmpyi
Rdd=cmpyi(Rs,Rt) 495
Rxx+=cmpyi(Rs,Rt) 495

convert_sf2d
Rdd=convert_sf2d(Rs) 526
Rdd=convert_sf2d(Rs):chop 526

cmpyiw
Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat 501
Rd=cmpyiw(Rss,Rtt):<<1:sat 501
Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat 501
Rd=cmpyiw(Rss,Rtt*):<<1:sat 501
Rdd=cmpyiw(Rss,Rtt) 502
Rdd=cmpyiw(Rss,Rtt*) 502
Rxx+=cmpyiw(Rss,Rtt) 502
Rxx+=cmpyiw(Rss,Rtt*) 502

convert_sf2df
Rdd=convert_sf2df(Rs) 523

convert_sf2ud
Rdd=convert_sf2ud(Rs) 526
Rdd=convert_sf2ud(Rs):chop 526

convert_sf2uw
Rd=convert_sf2uw(Rs) 526
Rd=convert_sf2uw(Rs):chop 526

cmpyiwh
Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat 499
Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat 499

convert_sf2w
Rd=convert_sf2w(Rs) 526
Rd=convert_sf2w(Rs):chop 526

cmpyr
Rdd=cmpyr(Rs,Rt) 495
Rxx+=cmpyr(Rs,Rt) 495

convert_ud2df
Rdd=convert_ud2df(Rss) 524

cmpyrw
Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat 501
Rd=cmpyrw(Rss,Rtt):<<1:sat 501
Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat 502
Rd=cmpyrw(Rss,Rtt*):<<1:sat 502
Rdd=cmpyrw(Rss,Rtt) 502
Rdd=cmpyrw(Rss,Rtt*) 502
Rxx+=cmpyrw(Rss,Rtt) 502
Rxx+=cmpyrw(Rss,Rtt*) 502

convert_ud2sf
Rd=convert_ud2sf(Rss) 524

convert_uw2df
Rdd=convert_uw2df(Rs) 524

convert_uw2sf
Rd=convert_uw2sf(Rs) 524

cmpyrwh
Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat 499
Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat 499

convert_w2df
Rdd=convert_w2df(Rs) 524

combine
if ([!]Pu[.new]) Rdd=combine(Rs,Rt) 198
Rd=combine(Rt.[HL],Rs.[HL]) 187
Rdd=combine(#s8,#S8) 187
Rdd=combine(#s8,#U6) 187
Rdd=combine(#s8,Rs) 187
Rdd=combine(Rs,#s8) 187
Rdd=combine(Rs,Rt) 188

convert_w2sf
Rd=convert_w2sf(Rs) 524

cround
Rd=cround(Rs,#u5) 412
Rd=cround(Rs,Rt) 412
Rdd=cround(Rss,#u6) 412
Rdd=cround(Rss,Rt) 413

convert_d2df
Rdd=convert_d2df(Rss) 524

cswi
cswi(Rs) 335

convert_d2sf
Rd=convert_d2sf(Rss) 524

convert_df2d
Rdd=convert_df2d(Rss) 526
Rdd=convert_df2d(Rss):chop 526

80-N2040-46 Rev. B

ct0
Rd=ct0(Rs) 470
Rd=ct0(Rss) 470

683

Hexagon V68 Programmer’s Reference Manual

ct1

Instruction Index

dfadd
Rd=ct1(Rs) 470
Rd=ct1(Rss) 470

Rdd=dfadd(Rss,Rtt) 519

dfclass
Pd=dfclass(Rss,#u5) 520

ctlbw
Rd=ctlbw(Rss,Rt) 365

dfcmp.eq

D

Pd=dfcmp.eq(Rss,Rtt) 521

dccleana
dccleana(Rs) 377

dccleanidx
dccleanidx(Rs) 337

dccleaninva
dccleaninva(Rs) 377

dccleaninvidx
dccleaninvidx(Rs) 337

dfcmp.ge
Pd=dfcmp.ge(Rss,Rtt) 521

dfcmp.gt
Pd=dfcmp.gt(Rss,Rtt) 521

dfcmp.uo
Pd=dfcmp.uo(Rss,Rtt) 521

dfmake
Rdd=dfmake(#u10):neg 534
Rdd=dfmake(#u10):pos 534

dcfetch
dcfetch(Rs) 376
dcfetch(Rs+#u11:3) 376

dcinva
dcinva(Rs) 377

dcinvidx
dcinvidx(Rs) 337

dckill
dckill 336

dctagr
Rd=dctagr(Rs) 337

dctagw
dctagw(Rs,Rt) 337

dczeroa
dczeroa(Rs) 373

dealloc_return
dealloc_return 272
if ([!]Pv.new) Rdd=dealloc_return(Rs):nt:raw 272
if ([!]Pv.new) Rdd=dealloc_return(Rs):t:raw 272
if ([!]Pv) dealloc_return 272
if ([!]Pv) Rdd=dealloc_return(Rs):raw 272
nt
if ([!]Pv.new) dealloc_return:nt 272
Rdd=dealloc_return(Rs):raw 272
t
if ([!]Pv.new) dealloc_return:t 272

deallocframe
deallocframe 270
Rdd=deallocframe(Rs):raw 270

dfmax
Rdd=dfmax(Rss,Rtt) 535

dfmin
Rdd=dfmin(Rss,Rtt) 536

dfmpyfix
Rdd=dfmpyfix(Rss,Rtt) 537

dfmpyhh
Rxx+=dfmpyhh(Rss,Rtt) 529

dfmpylh
Rxx+=dfmpylh(Rss,Rtt) 529

dfmpyll
Rdd=dfmpyll(Rss,Rtt) 537

dfsub
Rdd=dfsub(Rss,Rtt) 539

diag
diag(Rs) 379

diag0
diag0(Rss,Rtt) 379

diag1
diag1(Rss,Rtt) 379

dmsyncht
Rd=dmsyncht 386

E
endloop0

decbin
Rdd=decbin(Rss,Rtt) 595

endloop0 210

endloop01
deinterleave
Rdd=deinterleave(Rss) 476

endloop01 210

endloop1
endloop1 210

80-N2040-46 Rev. B

684

Hexagon V68 Programmer’s Reference Manual

extract
Rd=extract(Rs,#u5,#U5) 471
Rd=extract(Rs,Rtt) 471
Rdd=extract(Rss,#u6,#U6) 472
Rdd=extract(Rss,Rtt) 472

extractu
Rd=extractu(Rs,#u5,#U5) 471
Rd=extractu(Rs,Rtt) 471
Rdd=extractu(Rss,#u6,#U6) 472
Rdd=extractu(Rss,Rtt) 472

Instruction Index

interleave
Rdd=interleave(Rss) 476

isync
isync 381

J
jump
if ([!]Pu.new) jump:<hint> #r15:2 234
if ([!]Pu) jump #r15:2 232
if ([!]Pu) jump:<hint> #r15:2 232
jump #r22:2 232
nt
if (Rs!=#0) jump:nt #r13:2 235
if (Rs<=#0) jump:nt #r13:2 235
if (Rs==#0) jump:nt #r13:2 235
if (Rs>=#0) jump:nt #r13:2 235
Rd=#U6 237
Rd=Rs 237
t
if (Rs!=#0) jump:t #r13:2 235
if (Rs<=#0) jump:t #r13:2 235
if (Rs==#0) jump:t #r13:2 235
if (Rs>=#0) jump:t #r13:2 235

F
fastcorner9
Pd=[!]fastcorner9(Ps,Pt) 212

G
getimask
Rd=getimask(Rs) 339

H
hintjr
hintjr(Rs) 224

I

jump #r9:2 237, 237
jumpr
if ([!]Pu) jumpr Rs 225
if ([!]Pu[.new]) jumpr:<hint> Rs 225
jumpr Rs 225

iassignr
Rd=iassignr(Rs) 342

iassignw
iassignw(Rs) 344

K
k0lock
k0lock 340

icdatar
Rd=icdatar(Rs) 346

k0unlock
k0unlock 341

icdataw
icdataw(Rs,Rt) 347

icinva
icinva(Rs) 380

icinvidx
icinvidx(Rs) 346

ickill
ickill 347

L
l2cleanidx
l2cleanidx(Rs) 348

l2cleaninvidx
l2cleaninvidx(Rs) 348

l2fetch
l2fetch(Rs,Rt) 383
l2fetch(Rs,Rtt) 383

ictagr
Rd=ictagr(Rs) 346

ictagw
ictagw(Rs,Rt) 347

if ([!]p[01].new) jump:<hint> #r9:2 228, 228,
228, 228, 228, 228, 228, 229, 229
insert
Rx=insert(Rs,#u5,#U5) 474
Rx=insert(Rs,Rtt) 474
Rxx=insert(Rss,#u6,#U6) 474
Rxx=insert(Rss,Rtt) 475

80-N2040-46 Rev. B

l2gclean
l2gclean 349
l2gclean(Rtt) 349

l2gcleaninv
l2gcleaninv 349
l2gcleaninv(Rtt) 349

l2gunlock
l2gunlock 349

l2invidx
l2invidx(Rs) 348

685

Hexagon V68 Programmer’s Reference Manual

l2kill
l2kill 349

Instruction Index

maxu
Rd=maxu(Rs,Rt) 406
Rdd=maxu(Rss,Rtt) 407

l2locka
Pd=l2locka(Rs) 351

l2tagr
Rd=l2tagr(Rs) 353

l2tagw
l2tagw(Rs,Rt) 353

l2unlocka
l2unlocka(Rs) 351

lfs
Rdd=lfs(Rss,Rtt) 477

loop0
loop0(#r7:2,#U10) 214
loop0(#r7:2,Rs) 214

loop1
loop1(#r7:2,#U10) 214
loop1(#r7:2,Rs) 214

lsl
Rd=lsl(#s6,Rt) 655
Rd=lsl(Rs,Rt) 655
Rdd=lsl(Rss,Rt) 656
Rx[&|]=lsl(Rs,Rt) 662
Rx[+-]=lsl(Rs,Rt) 658
Rxx^=lsl(Rss,Rt) 662
Rxx[&|]=lsl(Rss,Rt) 662
Rxx[+-]=lsl(Rss,Rt) 659

lsr
Rd=lsr(Rs,#u5) 642
Rd=lsr(Rs,Rt) 656
Rdd=lsr(Rss,#u6) 642
Rdd=lsr(Rss,Rt) 656
Rx^=lsr(Rs,#u5) 648
Rx[&|]=lsr(Rs,#u5) 648
Rx[&|]=lsr(Rs,Rt) 662
Rx[+-]=lsr(Rs,#u5) 644
Rx[+-]=lsr(Rs,Rt) 659
Rx=add(#u8,lsr(Rx,#U5)) 644
Rx=and(#u8,lsr(Rx,#U5)) 648
Rx=or(#u8,lsr(Rx,#U5)) 648
Rx=sub(#u8,lsr(Rx,#U5)) 644
Rxx^=lsr(Rss,#u6) 649
Rxx^=lsr(Rss,Rt) 662
Rxx[&|]=lsr(Rss,#u6) 649
Rxx[&|]=lsr(Rss,Rt) 662
Rxx[+-]=lsr(Rss,#u6) 644
Rxx[+-]=lsr(Rss,Rt) 659

M
mask

memb
if ([!]Pt[.new]) Rd=memb(#u6) 245
if ([!]Pt[.new]) Rd=memb(Rs+#u6:0) 245
if ([!]Pt[.new]) Rd=memb(Rx++#s4:0) 245
if ([!]Pv[.new]) memb(#u6)=Nt.new 292
if ([!]Pv[.new]) memb(#u6)=Rt 313
if ([!]Pv[.new]) memb(Rs+#u6:0)=#S6 313
if ([!]Pv[.new]) memb(Rs+#u6:0)=Nt.new 292
if ([!]Pv[.new]) memb(Rs+#u6:0)=Rt 313
if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Nt.new 292
if ([!]Pv[.new]) memb(Rs+Ru<<#u2)=Rt 313
if ([!]Pv[.new]) memb(Rx++#s4:0)=Nt.new 292
if ([!]Pv[.new]) memb(Rx++#s4:0)=Rt 313
if ([!]Pv[.new]) Rd=memb(Rs+Rt<<#u2) 245
memb(gp+#u16:0)=Nt.new 290
memb(gp+#u16:0)=Rt 311
memb(Re=#U6)=Nt.new 290
memb(Re=#U6)=Rt 311
memb(Rs+#s11:0)=Nt.new 290
memb(Rs+#s11:0)=Rt 311
memb(Rs+#u6:0)[+-]=#U5 282
memb(Rs+#u6:0)[+-|&]=Rt 282
memb(Rs+#u6:0)=#S8 311
memb(Rs+Ru<<#u2)=Nt.new 290
memb(Rs+Ru<<#u2)=Rt 311
memb(Ru<<#u2+#U6)=Nt.new 290
memb(Ru<<#u2+#U6)=Rt 311
memb(Rx++#s4:0:circ(Mu))=Nt.new 290
memb(Rx++#s4:0:circ(Mu))=Rt 311
memb(Rx++#s4:0)=Nt.new 290
memb(Rx++#s4:0)=Rt 311
memb(Rx++I:circ(Mu))=Nt.new 290
memb(Rx++I:circ(Mu))=Rt 311
memb(Rx++Mu:brev)=Nt.new 290
memb(Rx++Mu:brev)=Rt 311
memb(Rx++Mu)=Nt.new 290
memb(Rx++Mu)=Rt 311
Rd=memb(gp+#u16:0) 243
Rd=memb(Re=#U6) 243
Rd=memb(Rs+#s11:0) 243
Rd=memb(Rs+Rt<<#u2) 243
Rd=memb(Rt<<#u2+#U6) 243
Rd=memb(Rx++#s4:0:circ(Mu)) 243
Rd=memb(Rx++#s4:0) 243
Rd=memb(Rx++I:circ(Mu)) 243
Rd=memb(Rx++Mu:brev) 243
Rd=memb(Rx++Mu) 243

memb_fifo
Ryy=memb_fifo(Re=#U6) 247
Ryy=memb_fifo(Rs) 247
Ryy=memb_fifo(Rs+#s11:0) 247
Ryy=memb_fifo(Rt<<#u2+#U6) 247
Ryy=memb_fifo(Rx++#s4:0:circ(Mu)) 247
Ryy=memb_fifo(Rx++#s4:0) 247
Ryy=memb_fifo(Rx++I:circ(Mu)) 248
Ryy=memb_fifo(Rx++Mu:brev) 248
Ryy=memb_fifo(Rx++Mu) 248

Rd=mask(#u5,#U5) 641
Rdd=mask(Pt) 628

max
Rd=max(Rs,Rt) 406
Rdd=max(Rss,Rtt) 407

80-N2040-46 Rev. B

686

Hexagon V68 Programmer’s Reference Manual

membh
Rd=membh(Re=#U6) 274
Rd=membh(Rs) 274
Rd=membh(Rs+#s11:1) 274
Rd=membh(Rt<<#u2+#U6) 274
Rd=membh(Rx++#s4:1:circ(Mu)) 275
Rd=membh(Rx++#s4:1) 275
Rd=membh(Rx++I:circ(Mu)) 275
Rd=membh(Rx++Mu:brev) 275
Rd=membh(Rx++Mu) 275
Rdd=membh(Re=#U6) 277
Rdd=membh(Rs) 277
Rdd=membh(Rs+#s11:2) 277
Rdd=membh(Rt<<#u2+#U6) 277
Rdd=membh(Rx++#s4:2:circ(Mu)) 277
Rdd=membh(Rx++#s4:2) 277
Rdd=membh(Rx++I:circ(Mu)) 278
Rdd=membh(Rx++Mu:brev) 278
Rdd=membh(Rx++Mu) 278

memd
if ([!]Pt[.new]) Rdd=memd(#u6) 241
if ([!]Pt[.new]) Rdd=memd(Rs+#u6:3) 241
if ([!]Pt[.new]) Rdd=memd(Rx++#s4:3) 241
if ([!]Pv[.new]) memd(#u6)=Rtt 309
if ([!]Pv[.new]) memd(Rs+#u6:3)=Rtt 309
if ([!]Pv[.new]) memd(Rs+Ru<<#u2)=Rtt 309
if ([!]Pv[.new]) memd(Rx++#s4:3)=Rtt 309
if ([!]Pv[.new]) Rdd=memd(Rs+Rt<<#u2) 241
memd(gp+#u16:3)=Rtt 305
memd(Re=#U6)=Rtt 305
memd(Rs+#s11:3)=Rtt 305
memd(Rs+Ru<<#u2)=Rtt 305
memd(Ru<<#u2+#U6)=Rtt 305
memd(Rx++#s4:3:circ(Mu))=Rtt 305
memd(Rx++#s4:3)=Rtt 305
memd(Rx++I:circ(Mu))=Rtt 305
memd(Rx++Mu:brev)=Rtt 305
memd(Rx++Mu)=Rtt 305
Rdd=memd(gp+#u16:3) 238
Rdd=memd(Re=#U6) 238
Rdd=memd(Rs+#s11:3) 238
Rdd=memd(Rs+Rt<<#u2) 238
Rdd=memd(Rt<<#u2+#U6) 238
Rdd=memd(Rx++#s4:3:circ(Mu)) 238
Rdd=memd(Rx++#s4:3) 238
Rdd=memd(Rx++I:circ(Mu)) 238
Rdd=memd(Rx++Mu:brev) 238
Rdd=memd(Rx++Mu) 238

memd_aq
Rdd=memd_aq(Rs) 240

memd_locked
memd_locked(Rs,Pd)=Rtt 371
Rdd=memd_locked(Rs) 370

memd_rl
memd_rl(Rs):at=Rtt 308
memd_rl(Rs):st=Rtt 308

80-N2040-46 Rev. B

Instruction Index

memh
if ([!]Pt[.new]) Rd=memh(#u6) 255
if ([!]Pt[.new]) Rd=memh(Rs+#u6:1) 255
if ([!]Pt[.new]) Rd=memh(Rx++#s4:1) 255
if ([!]Pv[.new]) memh(#u6)=Nt.new 297
if ([!]Pv[.new]) memh(#u6)=Rt 319
if ([!]Pv[.new]) memh(#u6)=Rt.H 319
if ([!]Pv[.new]) memh(Rs+#u6:1)=#S6 319
if ([!]Pv[.new]) memh(Rs+#u6:1)=Nt.new 297
if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt 319
if ([!]Pv[.new]) memh(Rs+#u6:1)=Rt.H 319
if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Nt.new 297
if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt 319
if ([!]Pv[.new]) memh(Rs+Ru<<#u2)=Rt.H 319
if ([!]Pv[.new]) memh(Rx++#s4:1)=Nt.new 297
if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt 320
if ([!]Pv[.new]) memh(Rx++#s4:1)=Rt.H 320
if ([!]Pv[.new]) Rd=memh(Rs+Rt<<#u2) 255
memh(gp+#u16:1)=Nt.new 295
memh(gp+#u16:1)=Rt 317
memh(gp+#u16:1)=Rt.H 317
memh(Re=#U6)=Nt.new 295
memh(Re=#U6)=Rt 316
memh(Re=#U6)=Rt.H 316
memh(Rs+#s11:1)=Nt.new 295
memh(Rs+#s11:1)=Rt 316
memh(Rs+#s11:1)=Rt.H 316
memh(Rs+#u6:1)[+-]=#U5 284
memh(Rs+#u6:1)[+-|&]=Rt 284
memh(Rs+#u6:1)=#S8 316
memh(Rs+Ru<<#u2)=Nt.new 295
memh(Rs+Ru<<#u2)=Rt 316
memh(Rs+Ru<<#u2)=Rt.H 316
memh(Ru<<#u2+#U6)=Nt.new 295
memh(Ru<<#u2+#U6)=Rt 316
memh(Ru<<#u2+#U6)=Rt.H 316
memh(Rx++#s4:1:circ(Mu))=Nt.new 295
memh(Rx++#s4:1:circ(Mu))=Rt 316
memh(Rx++#s4:1:circ(Mu))=Rt.H 316
memh(Rx++#s4:1)=Nt.new 295
memh(Rx++#s4:1)=Rt 316
memh(Rx++#s4:1)=Rt.H 316
memh(Rx++I:circ(Mu))=Nt.new 295
memh(Rx++I:circ(Mu))=Rt 316
memh(Rx++I:circ(Mu))=Rt.H 316
memh(Rx++Mu:brev)=Nt.new 295
memh(Rx++Mu:brev)=Rt 317
memh(Rx++Mu:brev)=Rt.H 317
memh(Rx++Mu)=Nt.new 295
memh(Rx++Mu)=Rt 317
memh(Rx++Mu)=Rt.H 317
Rd=memh(gp+#u16:1) 253
Rd=memh(Re=#U6) 253
Rd=memh(Rs+#s11:1) 253
Rd=memh(Rs+Rt<<#u2) 253
Rd=memh(Rt<<#u2+#U6) 253
Rd=memh(Rx++#s4:1:circ(Mu)) 253
Rd=memh(Rx++#s4:1) 253
Rd=memh(Rx++I:circ(Mu)) 253
Rd=memh(Rx++Mu:brev) 253
Rd=memh(Rx++Mu) 253

687

Hexagon V68 Programmer’s Reference Manual

memh_fifo

Instruction Index

memw

Ryy=memh_fifo(Re=#U6) 250
Ryy=memh_fifo(Rs) 250
Ryy=memh_fifo(Rs+#s11:1) 250
Ryy=memh_fifo(Rt<<#u2+#U6) 250
Ryy=memh_fifo(Rx++#s4:1:circ(Mu)) 250
Ryy=memh_fifo(Rx++#s4:1) 250
Ryy=memh_fifo(Rx++I:circ(Mu)) 251
Ryy=memh_fifo(Rx++Mu:brev) 251
Ryy=memh_fifo(Rx++Mu) 251

if ([!]Pt[.new]) Rd=memw(#u6) 268
if ([!]Pt[.new]) Rd=memw(Rs+#u6:2) 268
if ([!]Pt[.new]) Rd=memw(Rx++#s4:2) 268
if ([!]Pv[.new]) memw(#u6)=Nt.new 302
if ([!]Pv[.new]) memw(#u6)=Rt 326
if ([!]Pv[.new]) memw(Rs+#u6:2)=#S6 326
if ([!]Pv[.new]) memw(Rs+#u6:2)=Nt.new 302
if ([!]Pv[.new]) memw(Rs+#u6:2)=Rt 326
if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Nt.new 302
if ([!]Pv[.new]) memw(Rs+Ru<<#u2)=Rt 326
if ([!]Pv[.new]) memw(Rx++#s4:2)=Nt.new 302
if ([!]Pv[.new]) memw(Rx++#s4:2)=Rt 326
if ([!]Pv[.new]) Rd=memw(Rs+Rt<<#u2) 268
memw(gp+#u16:2)=Nt.new 300
memw(gp+#u16:2)=Rt 323
memw(Re=#U6)=Nt.new 300
memw(Re=#U6)=Rt 323
memw(Rs+#s11:2)=Nt.new 300
memw(Rs+#s11:2)=Rt 323
memw(Rs+#u6:2)[+-]=#U5 285
memw(Rs+#u6:2)[+-|&]=Rt 285
memw(Rs+#u6:2)=#S8 323
memw(Rs+Ru<<#u2)=Nt.new 300
memw(Rs+Ru<<#u2)=Rt 323
memw(Ru<<#u2+#U6)=Nt.new 300
memw(Ru<<#u2+#U6)=Rt 323
memw(Rx++#s4:2:circ(Mu))=Nt.new 300
memw(Rx++#s4:2:circ(Mu))=Rt 323
memw(Rx++#s4:2)=Nt.new 300
memw(Rx++#s4:2)=Rt 323
memw(Rx++I:circ(Mu))=Nt.new 300
memw(Rx++I:circ(Mu))=Rt 323
memw(Rx++Mu:brev)=Nt.new 300
memw(Rx++Mu:brev)=Rt 323
memw(Rx++Mu)=Nt.new 300
memw(Rx++Mu)=Rt 323
Rd=memw(gp+#u16:2) 265
Rd=memw(Re=#U6) 265
Rd=memw(Rs+#s11:2) 265
Rd=memw(Rs+Rt<<#u2) 265
Rd=memw(Rt<<#u2+#U6) 265
Rd=memw(Rx++#s4:2:circ(Mu)) 265
Rd=memw(Rx++#s4:2) 265
Rd=memw(Rx++I:circ(Mu)) 265
Rd=memw(Rx++Mu:brev) 265
Rd=memw(Rx++Mu) 265

memub
if ([!]Pt[.new]) Rd=memub(#u6) 259
if ([!]Pt[.new]) Rd=memub(Rs+#u6:0) 259
if ([!]Pt[.new]) Rd=memub(Rx++#s4:0) 259
if ([!]Pv[.new]) Rd=memub(Rs+Rt<<#u2) 259
Rd=memub(gp+#u16:0) 257
Rd=memub(Re=#U6) 257
Rd=memub(Rs+#s11:0) 257
Rd=memub(Rs+Rt<<#u2) 257
Rd=memub(Rt<<#u2+#U6) 257
Rd=memub(Rx++#s4:0:circ(Mu)) 257
Rd=memub(Rx++#s4:0) 257
Rd=memub(Rx++I:circ(Mu)) 257
Rd=memub(Rx++Mu:brev) 257
Rd=memub(Rx++Mu) 257

memubh
Rd=memubh(Re=#U6) 275
Rd=memubh(Rs+#s11:1) 276
Rd=memubh(Rt<<#u2+#U6) 276
Rd=memubh(Rx++#s4:1:circ(Mu)) 276
Rd=memubh(Rx++#s4:1) 276
Rd=memubh(Rx++I:circ(Mu)) 276
Rd=memubh(Rx++Mu:brev) 277
Rd=memubh(Rx++Mu) 276
Rdd=memubh(Re=#U6) 278
Rdd=memubh(Rs+#s11:2) 278
Rdd=memubh(Rt<<#u2+#U6) 278
Rdd=memubh(Rx++#s4:2:circ(Mu)) 279
Rdd=memubh(Rx++#s4:2) 279
Rdd=memubh(Rx++I:circ(Mu)) 279
Rdd=memubh(Rx++Mu:brev) 279
Rdd=memubh(Rx++Mu) 279

memuh
if ([!]Pt[.new]) Rd=memuh(#u6) 263
if ([!]Pt[.new]) Rd=memuh(Rs+#u6:1) 263
if ([!]Pt[.new]) Rd=memuh(Rx++#s4:1) 263
if ([!]Pv[.new]) Rd=memuh(Rs+Rt<<#u2) 263
Rd=memuh(gp+#u16:1) 261
Rd=memuh(Re=#U6) 261
Rd=memuh(Rs+#s11:1) 261
Rd=memuh(Rs+Rt<<#u2) 261
Rd=memuh(Rt<<#u2+#U6) 261
Rd=memuh(Rx++#s4:1:circ(Mu)) 261
Rd=memuh(Rx++#s4:1) 261
Rd=memuh(Rx++I:circ(Mu)) 261
Rd=memuh(Rx++Mu:brev) 261
Rd=memuh(Rx++Mu) 261

memw_aq
Rd=memw_aq(Rs) 267

memw_locked
memw_locked(Rs,Pd)=Rt 371
Rd=memw_locked(Rs) 370

memw_phys
Rd=memw_phys(Rs,Rt) 355

memw_rl
memw_rl(Rs):at=Rt 325
memw_rl(Rs):st=Rt 325

min
Rd=min(Rt,Rs) 408
Rdd=min(Rtt,Rss) 409

minu
Rd=minu(Rt,Rs) 408
Rdd=minu(Rtt,Rss) 409

80-N2040-46 Rev. B

688

Hexagon V68 Programmer’s Reference Manual

modwrap
Rd=modwrap(Rs,Rt) 410

mpy
Rd=mpy(Rs,Rt.H):<<1:rnd:sat 567
Rd=mpy(Rs,Rt.H):<<1:sat 567
Rd=mpy(Rs,Rt.L):<<1:rnd:sat 567
Rd=mpy(Rs,Rt.L):<<1:sat 567
Rd=mpy(Rs,Rt) 567
Rd=mpy(Rs,Rt):<<1 567
Rd=mpy(Rs,Rt):<<1:sat 567
Rd=mpy(Rs,Rt):rnd 567
Rd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd][:sat] 551
Rdd=mpy(Rs,Rt) 570
Rdd=mpy(Rs.[HL],Rt.[HL])[:<<1][:rnd] 551
Rx+=mpy(Rs,Rt):<<1:sat 567
Rx+=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 551
Rx-=mpy(Rs,Rt):<<1:sat 567
Rx-=mpy(Rs.[HL],Rt.[HL])[:<<1][:sat] 551
Rxx[+-]=mpy(Rs,Rt) 570
Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<1] 551
Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<1] 552

Instruction Index

no mnemonic
Cd=Rs 221
Cdd=Rss 221
Gd=Rs 331
Gdd=Rss 331

if ([!]Pu[.new]) Rd=#s12 204
if ([!]Pu[.new]) Rd=Rs 204
if ([!]Pu[.new]) Rdd=Rss 204
Pd=Ps 219
Pd=Rs 630
Rd=#s16 179
Rd=Cs 221
Rd=Gs 331
Rd=Ps 630
Rd=Rs 181
Rd=Ss 367
Rdd=#s8 179
Rdd=Css 221
Rdd=Gss 331
Rdd=Rss 181
Rdd=Sss 367
Rx.[HL]=#u16 179
Sd=Rs 367
Sdd=Rss 367

mpyi
Rd=+mpyi(Rs,#u8) 540
Rd=mpyi(Rs,#m9) 540
Rd=-mpyi(Rs,#u8) 540
Rd=mpyi(Rs,Rt) 540
Rx+=mpyi(Rs,#u8) 541
Rx+=mpyi(Rs,Rt) 541
Rx-=mpyi(Rs,#u8) 541
Rx-=mpyi(Rs,Rt) 541

nop
nop 175

normamt
Rd=normamt(Rs) 466
Rd=normamt(Rss) 467

not
Pd=not(Ps) 219
Rd=not(Rs) 172
Rdd=not(Rss) 401

mpysu
Rd=mpysu(Rs,Rt) 567

mpyu
Rd=mpyu(Rs,Rt) 567
Rd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
Rdd=mpyu(Rs,Rt) 570
Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
Rxx[+-]=mpyu(Rs,Rt) 570
Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558
Rxx-=mpyu(Rs.[HL],Rt.[HL])[:<<1] 558

O
or
if ([!]Pu[.new]) Rd=or(Rs,Rt) 199
Pd=and(Ps,or(Pt,[!]Pu)) 219
Pd=or(Ps,and(Pt,[!]Pu)) 219
Pd=or(Ps,or(Pt,[!]Pu)) 219
Pd=or(Pt,[!]Ps) 219
Rd=or(Rs,#s10) 172
Rd=or(Rs,Rt) 172
Rd=or(Rt,~Rs) 172
Rdd=or(Rss,Rtt) 401
Rdd=or(Rtt,~Rss) 401
Rx[&|^]=or(Rs,Rt) 404
Rx=or(Ru,and(Rx,#s10)) 404
Rx|=or(Rs,#s10) 404

mpyui
Rd=mpyui(Rs,Rt) 541

mux
Rd=mux(Pu,#s8,#S8) 189
Rd=mux(Pu,#s8,Rs) 189
Rd=mux(Pu,Rs,#s8) 189
Rd=mux(Pu,Rs,Rt) 189

N

P
packhl
Rdd=packhl(Rs,Rt) 193

neg
Rd=neg(Rs) 174
Rd=neg(Rs):sat 411
Rdd=neg(Rss) 411

parity
Rd=parity(Rs,Rt) 478
Rd=parity(Rss,Rtt) 478

pause

nmi

pause(#u8) 385

nmi(Rs) 356

pc
Rd=add(pc,#u6) 216

80-N2040-46 Rev. B

689

Hexagon V68 Programmer’s Reference Manual

pmpyw

Instruction Index

sfclass

Rdd=pmpyw(Rs,Rt) 563
Rxx^=pmpyw(Rs,Rt) 563

Pd=sfclass(Rs,#u5) 520

sfcmp.eq
Pd=sfcmp.eq(Rs,Rt) 521

popcount
Rd=popcount(Rss) 469

sfcmp.ge

R

Pd=sfcmp.ge(Rs,Rt) 521

release
release(Rs):at 322
release(Rs):st 322

resume

sfcmp.gt
Pd=sfcmp.gt(Rs,Rt) 521

sfcmp.uo
Pd=sfcmp.uo(Rs,Rt) 521

resume(Rs) 357

sffixupd

rol
Rd=rol(Rs,#u5) 642
Rdd=rol(Rss,#u6) 642
Rx^=rol(Rs,#u5) 648
Rx[&|]=rol(Rs,#u5) 648
Rx[+-]=rol(Rs,#u5) 644
Rxx^=rol(Rss,#u6) 649
Rxx[&|]=rol(Rss,#u6) 649
Rxx[+-]=rol(Rss,#u6) 644

Rd=sffixupd(Rs,Rt) 528

sffixupn
Rd=sffixupn(Rs,Rt) 528

sffixupr
Rd=sffixupr(Rs) 528

sfinvsqrta
Rd,Pe=sfinvsqrta(Rs) 531

round
Rd=round(Rs,#u5)[:sat] 412
Rd=round(Rs,Rt)[:sat] 412
Rd=round(Rss):sat 412

sfmake

rte 358

sfmax

Rd=sfmake(#u10):neg 534
Rd=sfmake(#u10):pos 534

rte
Rd=sfmax(Rs,Rt) 535

S

sfmin
Rd=sfmin(Rs,Rt) 536

sat
Rd=sat(Rss) 597

sfmpy
Rd=sfmpy(Rs,Rt) 537
Rx+=sfmpy(Rs,Rt,Pu):scale 530
Rx+=sfmpy(Rs,Rt) 529
Rx+=sfmpy(Rs,Rt):lib 532
Rx-=sfmpy(Rs,Rt) 529
Rx-=sfmpy(Rs,Rt):lib 532

satb
Rd=satb(Rs) 597

sath
Rd=sath(Rs) 597

satub
Rd=satub(Rs) 597

satuh
Rd=satuh(Rs) 597

setbit
memb(Rs+#u6:0)=setbit(#U5) 282
memh(Rs+#u6:1)=setbit(#U5) 284
memw(Rs+#u6:2)=setbit(#U5) 285
Rd=setbit(Rs,#u5) 480
Rd=setbit(Rs,Rt) 480

setimask
setimask(Pt,Rs) 359

setprio

sfrecipa
Rd,Pe=sfrecipa(Rs,Rt) 538

sfsub
Rd=sfsub(Rs,Rt) 539

sgp
crswap(Rx,sgp) 334

sgp0
crswap(Rx,sgp0) 334

sgp1
0

crswap(Rxx,sgp1:0) 334
crswap(Rx,sgp1) 334

setprio(Pt,Rs) 360

shuffeb
sfadd

Rdd=shuffeb(Rss,Rtt) 609

Rd=sfadd(Rs,Rt) 519

80-N2040-46 Rev. B

690

Hexagon V68 Programmer’s Reference Manual

shuffeh
Rdd=shuffeh(Rss,Rtt) 609

shuffob
Rdd=shuffob(Rtt,Rss) 609

shuffoh
Rdd=shuffoh(Rtt,Rss) 609

Instruction Index

T
tableidxb
Rx=tableidxb(Rs,#u4,#S6):raw 484
Rx=tableidxb(Rs,#u4,#U5) 484

tableidxd
Rx=tableidxd(Rs,#u4,#S6):raw 485
Rx=tableidxd(Rs,#u4,#U5) 485

siad
siad(Rs) 361

sp1loop0
p3=sp1loop0(#r7:2,#U10) 217
p3=sp1loop0(#r7:2,Rs) 217

sp2loop0
p3=sp2loop0(#r7:2,#U10) 217
p3=sp2loop0(#r7:2,Rs) 217

tableidxh
Rx=tableidxh(Rs,#u4,#S6):raw 485
Rx=tableidxh(Rs,#u4,#U5) 485

tableidxw
Rx=tableidxw(Rs,#u4,#S6):raw 485
Rx=tableidxw(Rs,#u4,#U5) 485

tlbinvasid
tlbinvasid(Rs) 366

sp3loop0
p3=sp3loop0(#r7:2,#U10) 217
p3=sp3loop0(#r7:2,Rs) 217

start
start(Rs) 362

stop
stop(Rs) 363

sub
if ([!]Pu[.new]) Rd=sub(Rt,Rs) 201
Rd=add(Rs,sub(#s6,Ru)) 393
Rd=sub(#s10,Rs) 176
Rd=sub(Rt,Rs) 176
Rd=sub(Rt,Rs):sat 176
Rd=sub(Rt,Rs):sat:deprecated 415
Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<<16 417
Rd=sub(Rt.L,Rs.[HL])[:sat] 417
Rdd=sub(Rss,Rtt,Px):carry 399
Rdd=sub(Rtt,Rss) 415
Rx+=sub(Rt,Rs) 416

swi
swi(Rs) 364

tlblock
tlblock 340

tlbmatch
Pd=tlbmatch(Rss,Rt) 629

tlboc
Rd=tlboc(Rss) 365

tlbp
Rd=tlbp(Rs) 365

tlbr
Rdd=tlbr(Rs) 365

tlbunlock
tlbunlock 341

tlbw
tlbw(Rss,Rt) 366

togglebit
Rd=togglebit(Rs,#u5) 480
Rd=togglebit(Rs,Rt) 480

swiz
Rd=swiz(Rs) 599

trace
trace(Rs) 388

sxtb
if ([!]Pu[.new]) Rd=sxtb(Rs) 202
Rd=sxtb(Rs) 178

sxth
if ([!]Pu[.new]) Rd=sxth(Rs) 202
Rd=sxth(Rs) 178

sxtw
Rdd=sxtw(Rs) 419

syncht
syncht 386

80-N2040-46 Rev. B

trap0
trap0(#u8) 389

trap1
trap1(#u8) 389
trap1(Rx,#u8) 389

tstbit
if ([!]tstbit(Ns.new,#0)) jump:<hint> #r9:2 287
p[01]=tstbit(Rs,#0) 229
Pd=[!]tstbit(Rs,#u5) 631
Pd=[!]tstbit(Rs,Rt) 631

691

Hexagon V68 Programmer’s Reference Manual

V

Instruction Index

vasrhub

vabsdiffb
Rdd=vabsdiffb(Rtt,Rss) 422

vabsdiffh
Rdd=vabsdiffh(Rtt,Rss) 423

vabsdiffub
Rdd=vabsdiffub(Rtt,Rss) 422

Rd=vasrhub(Rss,#u4):raw 671
Rd=vasrhub(Rss,#u4):rnd:sat 671
Rd=vasrhub(Rss,#u4):sat 671

vasrw
Rd=vasrw(Rss,#u5) 679
Rd=vasrw(Rss,Rt) 679
Rdd=vasrw(Rss,#u5) 675
Rdd=vasrw(Rss,Rt) 677

vavgh
vabsdiffw
Rdd=vabsdiffw(Rtt,Rss) 424

vabsh
Rdd=vabsh(Rss) 420
Rdd=vabsh(Rss):sat 420

Rd=vavgh(Rs,Rt) 183
Rd=vavgh(Rs,Rt):rnd 183
Rdd=vavgh(Rss,Rtt) 437
Rdd=vavgh(Rss,Rtt):crnd 437
Rdd=vavgh(Rss,Rtt):rnd 437

vavgub
vabsw
Rdd=vabsw(Rss) 421
Rdd=vabsw(Rss):sat 421

Rdd=vavgub(Rss,Rtt) 439
Rdd=vavgub(Rss,Rtt):rnd 439

vavguh
vacsh
Rxx,Pe=vacsh(Rss,Rtt) 426

vaddb
Rdd=vaddb(Rss,Rtt) 435

vaddh
Rd=vaddh(Rs,Rt)[:sat] 182
Rdd=vaddh(Rss,Rtt)[:sat] 428

vaddhub
Rd=vaddhub(Rss,Rtt):sat 430

vaddub
Rdd=vaddub(Rss,Rtt)[:sat] 435

vadduh
Rd=vadduh(Rs,Rt):sat 182
Rdd=vadduh(Rss,Rtt):sat 428

vaddw
Rdd=vaddw(Rss,Rtt)[:sat] 436

valignb
Rdd=valignb(Rtt,Rss,#u3) 600
Rdd=valignb(Rtt,Rss,Pu) 600

vaslh
Rdd=vaslh(Rss,#u4) 667
Rdd=vaslh(Rss,Rt) 673

vaslw
Rdd=vaslw(Rss,#u5) 675
Rdd=vaslw(Rss,Rt) 677

vasrh
Rdd=vasrh(Rss,#u4) 667
Rdd=vasrh(Rss,#u4):raw 669
Rdd=vasrh(Rss,#u4):rnd 669
Rdd=vasrh(Rss,Rt) 673

80-N2040-46 Rev. B

Rdd=vavguh(Rss,Rtt) 437
Rdd=vavguh(Rss,Rtt):rnd 437

vavguw
Rdd=vavguw(Rss,Rtt)[:rnd] 440

vavgw
Rdd=vavgw(Rss,Rtt):crnd 440
Rdd=vavgw(Rss,Rtt)[:rnd] 440

vclip
Rdd=vclip(Rss,#u5) 442

vcmpb.eq
Pd=!any8(vcmpb.eq(Rss,Rtt)) 634
Pd=any8(vcmpb.eq(Rss,Rtt)) 634
Pd=vcmpb.eq(Rss,#u8) 635
Pd=vcmpb.eq(Rss,Rtt) 635

vcmpb.gt
Pd=vcmpb.gt(Rss,#s8) 635
Pd=vcmpb.gt(Rss,Rtt) 635

vcmpb.gtu
Pd=vcmpb.gtu(Rss,#u7) 635
Pd=vcmpb.gtu(Rss,Rtt) 635

vcmph.eq
Pd=vcmph.eq(Rss,#s8) 632
Pd=vcmph.eq(Rss,Rtt) 632

vcmph.gt
Pd=vcmph.gt(Rss,#s8) 632
Pd=vcmph.gt(Rss,Rtt) 632

vcmph.gtu
Pd=vcmph.gtu(Rss,#u7) 632
Pd=vcmph.gtu(Rss,Rtt) 632

vcmpw.eq
Pd=vcmpw.eq(Rss,#s8) 637
Pd=vcmpw.eq(Rss,Rtt) 637

692

Hexagon V68 Programmer’s Reference Manual

vcmpw.gt
Pd=vcmpw.gt(Rss,#s8) 637
Pd=vcmpw.gt(Rss,Rtt) 637

Instruction Index

vmaxuw
Rdd=vmaxuw(Rtt,Rss) 451

vmaxw
vcmpw.gtu
Pd=vcmpw.gtu(Rss,#u7) 637
Pd=vcmpw.gtu(Rss,Rtt) 637

Rdd=vmaxw(Rtt,Rss) 451

vminb
Rdd=vminb(Rtt,Rss) 452

vcmpyi
Rdd=vcmpyi(Rss,Rtt)[:<<1]:sat 505
Rxx+=vcmpyi(Rss,Rtt):sat 506

vcmpyr
Rdd=vcmpyr(Rss,Rtt)[:<<1]:sat 505
Rxx+=vcmpyr(Rss,Rtt):sat 506

vcnegh
Rdd=vcnegh(Rss,Rt) 443

vconj
Rdd=vconj(Rss):sat 508

vcrotate
Rdd=vcrotate(Rss,Rt) 509

vdmpy
Rd=vdmpy(Rss,Rtt)[:<<1]:rnd:sat 575
Rdd=vdmpy(Rss,Rtt):<<1:sat 572
Rdd=vdmpy(Rss,Rtt):sat 572
Rxx+=vdmpy(Rss,Rtt):<<1:sat 573
Rxx+=vdmpy(Rss,Rtt):sat 573

vdmpybsu
Rdd=vdmpybsu(Rss,Rtt):sat 579
Rxx+=vdmpybsu(Rss,Rtt):sat 579

vitpack
Rd=vitpack(Ps,Pt) 639

vminh
Rdd=vminh(Rtt,Rss) 454

vminub
Rdd,Pe=vminub(Rtt,Rss) 452
Rdd=vminub(Rtt,Rss) 452

vminuh
Rdd=vminuh(Rtt,Rss) 454

vminuw
Rdd=vminuw(Rtt,Rss) 459

vminw
Rdd=vminw(Rtt,Rss) 459

vmpybsu
Rdd=vmpybsu(Rs,Rt) 591
Rxx+=vmpybsu(Rs,Rt) 591

vmpybu
Rdd=vmpybu(Rs,Rt) 591
Rxx+=vmpybu(Rs,Rt) 591

vmpyeh
Rdd=vmpyeh(Rss,Rtt):<<1:sat 581
Rdd=vmpyeh(Rss,Rtt):sat 581
Rxx+=vmpyeh(Rss,Rtt) 581
Rxx+=vmpyeh(Rss,Rtt):<<1:sat 581
Rxx+=vmpyeh(Rss,Rtt):sat 581

vlslh
Rdd=vlslh(Rss,Rt) 673

vlslw
Rdd=vlslw(Rss,Rt) 677

vmpyh
Rd=vmpyh(Rs,Rt)[:<<1]:rnd:sat 585
Rdd=vmpyh(Rs,Rt)[:<<1]:sat 583
Rxx+=vmpyh(Rs,Rt) 583
Rxx+=vmpyh(Rs,Rt)[:<<1]:sat 583

vlsrh
Rdd=vlsrh(Rss,#u4) 667
Rdd=vlsrh(Rss,Rt) 673

vmpyhsu
Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat 587
Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat 587

vlsrw
Rdd=vlsrw(Rss,#u5) 675
Rdd=vlsrw(Rss,Rt) 677

vmaxb
Rdd=vmaxb(Rtt,Rss) 445

vmaxh
Rdd=vmaxh(Rtt,Rss) 446

vmaxub
Rdd=vmaxub(Rtt,Rss) 445

vmaxuh
Rdd=vmaxuh(Rtt,Rss) 446

80-N2040-46 Rev. B

vmpyweh
Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 543
Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat 544
Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat 544
Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat 544

vmpyweuh
Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 547
Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat 548
Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat 548
Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sat 548

vmpywoh
Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 544
Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat 544
Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat 544
Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat 544

693

Hexagon V68 Programmer’s Reference Manual

vmpywouh
Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 548
Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat 548
Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat 548
Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sat 548

vmux
Rdd=vmux(Pu,Rss,Rtt) 640

vnavgh
Rd=vnavgh(Rt,Rs) 183
Rdd=vnavgh(Rtt,Rss) 437
Rdd=vnavgh(Rtt,Rss):crnd:sat 437
Rdd=vnavgh(Rtt,Rss):rnd:sat 437

vnavgw
Rdd=vnavgw(Rtt,Rss) 440
Rdd=vnavgw(Rtt,Rss):crnd:sat 440
Rdd=vnavgw(Rtt,Rss):rnd:sat 440

vpmpyh
Rdd=vpmpyh(Rs,Rt) 593
Rxx^=vpmpyh(Rs,Rt) 594

vraddh
Rd=vraddh(Rss,Rtt) 433

vraddub
Rdd=vraddub(Rss,Rtt) 431
Rxx+=vraddub(Rss,Rtt) 431

vradduh
Rd=vradduh(Rss,Rtt) 433

vrcmpys
Rd=vrcmpys(Rss,Rt):<<1:rnd:sat 514
Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi 514
Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo 515
Rdd=vrcmpys(Rss,Rt):<<1:sat 511
Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 511
Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 512
Rxx+=vrcmpys(Rss,Rt):<<1:sat 512
Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi 512
Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo 512

vrcnegh
Rxx+=vrcnegh(Rss,Rt) 443

vrcrotate
Rdd=vrcrotate(Rss,Rt,#u2) 517
Rxx+=vrcrotate(Rss,Rt,#u2) 517

vrmaxh
Rxx=vrmaxh(Rss,Ru) 447

vrmaxuh
Rxx=vrmaxuh(Rss,Ru) 447

vrmaxuw
Rxx=vrmaxuw(Rss,Ru) 449

vrmaxw
Rxx=vrmaxw(Rss,Ru) 449

vrminh
Rxx=vrminh(Rss,Ru) 455

80-N2040-46 Rev. B

Instruction Index

vrminuh
Rxx=vrminuh(Rss,Ru) 455

vrminuw
Rxx=vrminuw(Rss,Ru) 457

vrminw
Rxx=vrminw(Rss,Ru) 457

vrmpybsu
Rdd=vrmpybsu(Rss,Rtt) 577
Rxx+=vrmpybsu(Rss,Rtt) 577

vrmpybu
Rdd=vrmpybu(Rss,Rtt) 577
Rxx+=vrmpybu(Rss,Rtt) 578

vrmpyh
Rdd=vrmpyh(Rss,Rtt) 589
Rxx+=vrmpyh(Rss,Rtt) 589

vrmpyweh
Rdd=vrmpyweh(Rss,Rtt)[:<<1] 565
Rxx+=vrmpyweh(Rss,Rtt)[:<<1] 565

vrmpywoh
Rdd=vrmpywoh(Rss,Rtt)[:<<1] 565
Rxx+=vrmpywoh(Rss,Rtt)[:<<1] 565

vrndwh
Rd=vrndwh(Rss) 602
Rd=vrndwh(Rss):sat 602

vrsadub
Rdd=vrsadub(Rss,Rtt) 460
Rxx+=vrsadub(Rss,Rtt) 460

vsathb
Rd=vsathb(Rs) 604
Rd=vsathb(Rss) 604
Rdd=vsathb(Rss) 607

vsathub
Rd=vsathub(Rs) 605
Rd=vsathub(Rss) 605
Rdd=vsathub(Rss) 607

vsatwh
Rd=vsatwh(Rss) 605
Rdd=vsatwh(Rss) 607

vsatwuh
Rd=vsatwuh(Rss) 605
Rdd=vsatwuh(Rss) 607

vsplatb
Rd=vsplatb(Rs) 611
Rdd=vsplatb(Rs) 611

vsplath
Rdd=vsplath(Rs) 612

vspliceb
Rdd=vspliceb(Rss,Rtt,#u3) 613
Rdd=vspliceb(Rss,Rtt,Pu) 613

694

Hexagon V68 Programmer’s Reference Manual

vsubb
Rdd=vsubb(Rss,Rtt) 464

vsubh

Instruction Index

X
xor
if ([!]Pu[.new]) Rd=xor(Rs,Rt) 199
Pd=xor(Ps,Pt) 219
Rd=xor(Rs,Rt) 172
Rdd=xor(Rss,Rtt) 401
Rx[&|^]=xor(Rs,Rt) 404
Rxx^=xor(Rss,Rtt) 403

Rd=vsubh(Rt,Rs)[:sat] 184
Rdd=vsubh(Rtt,Rss)[:sat] 462

vsubub
Rdd=vsubub(Rtt,Rss)[:sat] 464

vsubuh
Rd=vsubuh(Rt,Rs):sat 184
Rdd=vsubuh(Rtt,Rss):sat 462

vsubw

Z
zxtb
if ([!]Pu[.new]) Rd=zxtb(Rs) 205
Rd=zxtb(Rs) 186

Rdd=vsubw(Rtt,Rss)[:sat] 465

zxth
vsxtbh
Rdd=vsxtbh(Rs) 614

if ([!]Pu[.new]) Rd=zxth(Rs) 205
Rd=zxth(Rs) 186

vsxthw
Rdd=vsxthw(Rs) 614

vtrunehb
Rd=vtrunehb(Rss) 616
Rdd=vtrunehb(Rss,Rtt) 616

vtrunewh
Rdd=vtrunewh(Rss,Rtt) 616

vtrunohb
Rd=vtrunohb(Rss) 616
Rdd=vtrunohb(Rss,Rtt) 616

vtrunowh
Rdd=vtrunowh(Rss,Rtt) 617

vxaddsubh
Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat 487
Rdd=vxaddsubh(Rss,Rtt):sat 488

vxaddsubw
Rdd=vxaddsubw(Rss,Rtt):sat 490

vxsubaddh
Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat 488
Rdd=vxsubaddh(Rss,Rtt):sat 488

vxsubaddw
Rdd=vxsubaddw(Rss,Rtt):sat 490

vzxtbh
Rdd=vzxtbh(Rs) 618

vzxthw
Rdd=vzxthw(Rs) 618

W
wait
wait(Rs) 369

80-N2040-46 Rev. B

695

Intrinsics Index
A
abs
Rd=abs(Rs)

Word32 Q6_R_abs_R(Word32 Rs)

Rd=abs(Rs):sat

Word32 Q6_R_abs_R_sat(Word32 Rs)

Rdd=abs(Rss)

Word64 Q6_P_abs_P(Word64 Rss)

392
392
391

add
Rd=add(#u6,mpyi(Rs,#U6))

Word32 Q6_R_add_mpyi_IRI(Word32 Iu6, Word32 Rs, Word32 IU6)

Rd=add(#u6,mpyi(Rs,Rt))

Word32 Q6_R_add_mpyi_IRR(Word32 Iu6, Word32 Rs, Word32 Rt)

Rd=add(Rs,#s16)

Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)

Rd=add(Rs,add(Ru,#s6))

Word32 Q6_R_add_add_RRI(Word32 Rs, Word32 Ru, Word32 Is6)

Rd=add(Rs,Rt)

Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)

Rd=add(Rs,Rt):sat

Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)

Rd=add(Rt.H,Rs.H):<<16

Word32 Q6_R_add_RhRh_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.H,Rs.H):sat:<<16

Word32 Q6_R_add_RhRh_sat_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.H,Rs.L):<<16

Word32 Q6_R_add_RhRl_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.H,Rs.L):sat:<<16

Word32 Q6_R_add_RhRl_sat_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H)

Word32 Q6_R_add_RlRh(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):<<16

Word32 Q6_R_add_RlRh_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):sat

Word32 Q6_R_add_RlRh_sat(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.H):sat:<<16

Word32 Q6_R_add_RlRh_sat_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L)

Word32 Q6_R_add_RlRl(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):<<16

Word32 Q6_R_add_RlRl_s16(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):sat

Word32 Q6_R_add_RlRl_sat(Word32 Rt, Word32 Rs)

Rd=add(Rt.L,Rs.L):sat:<<16

Word32 Q6_R_add_RlRl_sat_s16(Word32 Rt, Word32 Rs)

Rd=add(Ru,mpyi(#u6:2,Rs))

Word32 Q6_R_add_mpyi_RIR(Word32 Ru, Word32 Iu6_2, Word32 Rs)

Rd=add(Ru,mpyi(Rs,#u6))

Word32 Q6_R_add_mpyi_RRI(Word32 Ru, Word32 Rs, Word32 Iu6)

Rdd=add(Rs,Rtt)

Word64 Q6_P_add_RP(Word32 Rs, Word64 Rtt)

Rdd=add(Rss,Rtt)

Word64 Q6_P_add_PP(Word64 Rss, Word64 Rtt)

Rdd=add(Rss,Rtt):sat

Word64 Q6_P_add_PP_sat(Word64 Rss, Word64 Rtt)

Rx+=add(Rs,#s8)

Word32 Q6_R_addacc_RI(Word32 Rx, Word32 Rs, Word32 Is8)

Rx+=add(Rs,Rt)

Word32 Q6_R_addacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=add(Rs,#s8)

Word32 Q6_R_addnac_RI(Word32 Rx, Word32 Rs, Word32 Is8)

Rx-=add(Rs,Rt)

Word32 Q6_R_addnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Ry=add(Ru,mpyi(Ry,Rs))

Word32 Q6_R_add_mpyi_RRR(Word32 Ru, Word32 Ry, Word32 Rs)

541
541
170
393
170
170
398
398
398
398
398
398
398
398
398
398
398
398
541
541
395
395
395
393
393
393
393
541

Word32 Q6_R_addasl_RRI(Word32 Rt, Word32 Rs, Word32 Iu3)

647

Byte Q6_p_all8_p(Byte Ps)

213

addasl
Rd=addasl(Rt,Rs,#u3)

all8
Pd=all8(Ps)

80-N2040-46 Rev. B

696

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

and
Pd=and(Ps,and(Pt,!Pu))

Byte Q6_p_and_and_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Ps,and(Pt,Pu))

Byte Q6_p_and_and_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Pt,!Ps)

Byte Q6_p_and_pnp(Byte Pt, Byte Ps)

Pd=and(Pt,Ps)

Byte Q6_p_and_pp(Byte Pt, Byte Ps)

Rd=and(Rs,#s10)

Word32 Q6_R_and_RI(Word32 Rs, Word32 Is10)

Rd=and(Rs,Rt)

Word32 Q6_R_and_RR(Word32 Rs, Word32 Rt)

Rd=and(Rt,~Rs)

Word32 Q6_R_and_RnR(Word32 Rt, Word32 Rs)

Rdd=and(Rss,Rtt)

Word64 Q6_P_and_PP(Word64 Rss, Word64 Rtt)

Rdd=and(Rtt,~Rss)

Word64 Q6_P_and_PnP(Word64 Rtt, Word64 Rss)

Rx^=and(Rs,~Rt)

Word32 Q6_R_andxacc_RnR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx^=and(Rs,Rt)

Word32 Q6_R_andxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx&=and(Rs,~Rt)

Word32 Q6_R_andand_RnR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx&=and(Rs,Rt)

Word32 Q6_R_andand_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx|=and(Rs,#s10)

Word32 Q6_R_andor_RI(Word32 Rx, Word32 Rs, Word32 Is10)

Rx|=and(Rs,~Rt)

Word32 Q6_R_andor_RnR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx|=and(Rs,Rt)

Word32 Q6_R_andor_RR(Word32 Rx, Word32 Rs, Word32 Rt)

219
219
219
219
172
172
172
401
401
404
404
404
404
404
404
404

Byte Q6_p_any8_p(Byte Ps)

213

Rd=asl(Rs,#u5)

Word32 Q6_R_asl_RI(Word32 Rs, Word32 Iu5)

Rd=asl(Rs,#u5):sat

Word32 Q6_R_asl_RI_sat(Word32 Rs, Word32 Iu5)

Rd=asl(Rs,Rt)

Word32 Q6_R_asl_RR(Word32 Rs, Word32 Rt)

Rd=asl(Rs,Rt):sat

Word32 Q6_R_asl_RR_sat(Word32 Rs, Word32 Rt)

Rdd=asl(Rss,#u6)

Word64 Q6_P_asl_PI(Word64 Rss, Word32 Iu6)

Rdd=asl(Rss,Rt)

Word64 Q6_P_asl_PR(Word64 Rss, Word32 Rt)

Rx^=asl(Rs,#u5)

Word32 Q6_R_aslxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=asl(Rs,#u5)

Word32 Q6_R_asland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=asl(Rs,Rt)

Word32 Q6_R_asland_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=asl(Rs,#u5)

Word32 Q6_R_aslacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx+=asl(Rs,Rt)

Word32 Q6_R_aslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx=add(#u8,asl(Rx,#U5))

Word32 Q6_R_add_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx=and(#u8,asl(Rx,#U5))

Word32 Q6_R_and_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx-=asl(Rs,#u5)

Word32 Q6_R_aslnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx-=asl(Rs,Rt)

Word32 Q6_R_aslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx=or(#u8,asl(Rx,#U5))

Word32 Q6_R_or_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx=sub(#u8,asl(Rx,#U5))

Word32 Q6_R_sub_asl_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx|=asl(Rs,#u5)

Word32 Q6_R_aslor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx|=asl(Rs,Rt)

Word32 Q6_R_aslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx^=asl(Rss,#u6)

Word64 Q6_P_aslxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx^=asl(Rss,Rt)

Word64 Q6_P_aslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx&=asl(Rss,#u6)

Word64 Q6_P_asland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx&=asl(Rss,Rt)

Word64 Q6_P_asland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx+=asl(Rss,#u6)

Word64 Q6_P_aslacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx+=asl(Rss,Rt)

Word64 Q6_P_aslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx-=asl(Rss,#u6)

Word64 Q6_P_aslnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx-=asl(Rss,Rt)

Word64 Q6_P_aslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx|=asl(Rss,#u6)

Word64 Q6_P_aslor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx|=asl(Rss,Rt)

Word64 Q6_P_aslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

642
654
656
665
643
656
649
649
663
645
659
645
649
645
659
649
645
649
663
650
663
649
663
645
659
645
660
650
663

Word32 Q6_R_aslh_R(Word32 Rs)

191

any8
Pd=any8(Ps)

asl

aslh
Rd=aslh(Rs)

80-N2040-46 Rev. B

697

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

asr
Rd=asr(Rs,#u5)

Word32 Q6_R_asr_RI(Word32 Rs, Word32 Iu5)

Rd=asr(Rs,#u5):rnd

Word32 Q6_R_asr_RI_rnd(Word32 Rs, Word32 Iu5)

Rd=asr(Rs,Rt)

Word32 Q6_R_asr_RR(Word32 Rs, Word32 Rt)

Rd=asr(Rs,Rt):sat

Word32 Q6_R_asr_RR_sat(Word32 Rs, Word32 Rt)

Rdd=asr(Rss,#u6)

Word64 Q6_P_asr_PI(Word64 Rss, Word32 Iu6)

Rdd=asr(Rss,#u6):rnd

Word64 Q6_P_asr_PI_rnd(Word64 Rss, Word32 Iu6)

Rdd=asr(Rss,Rt)

Word64 Q6_P_asr_PR(Word64 Rss, Word32 Rt)

Rx&=asr(Rs,#u5)

Word32 Q6_R_asrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=asr(Rs,Rt)

Word32 Q6_R_asrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=asr(Rs,#u5)

Word32 Q6_R_asracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx+=asr(Rs,Rt)

Word32 Q6_R_asracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=asr(Rs,#u5)

Word32 Q6_R_asrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx-=asr(Rs,Rt)

Word32 Q6_R_asrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx|=asr(Rs,#u5)

Word32 Q6_R_asror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx|=asr(Rs,Rt)

Word32 Q6_R_asror_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx^=asr(Rss,Rt)

Word64 Q6_P_asrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx&=asr(Rss,#u6)

Word64 Q6_P_asrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx&=asr(Rss,Rt)

Word64 Q6_P_asrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx+=asr(Rss,#u6)

Word64 Q6_P_asracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx+=asr(Rss,Rt)

Word64 Q6_P_asracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx-=asr(Rss,#u6)

Word64 Q6_P_asrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx-=asr(Rss,Rt)

Word64 Q6_P_asrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx|=asr(Rss,#u6)

Word64 Q6_P_asror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx|=asr(Rss,Rt)

Word64 Q6_P_asror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

642
653
656
665
643
653
656
649
663
645
659
645
659
649
663
663
649
663
645
659
645
660
650
663

Word32 Q6_R_asrh_R(Word32 Rs)

191

Rd=asrrnd(Rs,#u5)

Word32 Q6_R_asrrnd_RI(Word32 Rs, Word32 Iu5)

Rdd=asrrnd(Rss,#u6)

Word64 Q6_P_asrrnd_PI(Word64 Rss, Word32 Iu6)

653
653

asrh
Rd=asrh(Rs)

asrrnd

B
bitsclr
Pd=!bitsclr(Rs,#u6)

Byte Q6_p_not_bitsclr_RI(Word32 Rs, Word32 Iu6)

Pd=!bitsclr(Rs,Rt)

Byte Q6_p_not_bitsclr_RR(Word32 Rs, Word32 Rt)

Pd=bitsclr(Rs,#u6)

Byte Q6_p_bitsclr_RI(Word32 Rs, Word32 Iu6)

Pd=bitsclr(Rs,Rt)

Byte Q6_p_bitsclr_RR(Word32 Rs, Word32 Rt)

627
627
627
627

bitsplit
Rdd=bitsplit(Rs,#u5)

Word64 Q6_P_bitsplit_RI(Word32 Rs, Word32 Iu5)

Rdd=bitsplit(Rs,Rt)

Word64 Q6_P_bitsplit_RR(Word32 Rs, Word32 Rt)

482
482

bitsset
Pd=!bitsset(Rs,Rt)

Byte Q6_p_not_bitsset_RR(Word32 Rs, Word32 Rt)

Pd=bitsset(Rs,Rt)

Byte Q6_p_bitsset_RR(Word32 Rs, Word32 Rt)

627
627

Byte Q6_p_boundscheck_RP(Word32 Rs, Word64 Rtt)

620

Word32 Q6_R_brev_R(Word32 Rs)

479

boundscheck
Pd=boundscheck(Rs,Rtt)

brev
Rd=brev(Rs)

80-N2040-46 Rev. B

698

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Word64 Q6_P_brev_P(Word64 Rss)

479

Rd=cl0(Rs)

Word32 Q6_R_cl0_R(Word32 Rs)

Rd=cl0(Rss)

Word32 Q6_R_cl0_P(Word64 Rss)

467
467

Rdd=brev(Rss)

C
cl0

cl1
Rd=cl1(Rs)

Word32 Q6_R_cl1_R(Word32 Rs)

Rd=cl1(Rss)

Word32 Q6_R_cl1_P(Word64 Rss)

467
467

clb
Rd=add(clb(Rs),#s6)

Word32 Q6_R_add_clb_RI(Word32 Rs, Word32 Is6)

Rd=add(clb(Rss),#s6)

Word32 Q6_R_add_clb_PI(Word64 Rss, Word32 Is6)

Rd=clb(Rs)

Word32 Q6_R_clb_R(Word32 Rs)

Rd=clb(Rss)

Word32 Q6_R_clb_P(Word64 Rss)

467
467
467
467

Word32 Q6_R_clip_RI(Word32 Rs, Word32 Iu5)

400

Rd=clrbit(Rs,#u5)

Word32 Q6_R_clrbit_RI(Word32 Rs, Word32 Iu5)

Rd=clrbit(Rs,Rt)

Word32 Q6_R_clrbit_RR(Word32 Rs, Word32 Rt)

480
480

clip
Rd=clip(Rs,#u5)

clrbit

cmp.eq
Pd=!cmp.eq(Rs,#s10)

Byte Q6_p_not_cmp_eq_RI(Word32 Rs, Word32 Is10)

Pd=!cmp.eq(Rs,Rt)

Byte Q6_p_not_cmp_eq_RR(Word32 Rs, Word32 Rt)

Pd=cmp.eq(Rs,#s10)

Byte Q6_p_cmp_eq_RI(Word32 Rs, Word32 Is10)

Pd=cmp.eq(Rs,Rt)

Byte Q6_p_cmp_eq_RR(Word32 Rs, Word32 Rt)

Pd=cmp.eq(Rss,Rtt)

Byte Q6_p_cmp_eq_PP(Word64 Rss, Word64 Rtt)

Rd=!cmp.eq(Rs,#s8)

Word32 Q6_R_not_cmp_eq_RI(Word32 Rs, Word32 Is8)

Rd=!cmp.eq(Rs,Rt)

Word32 Q6_R_not_cmp_eq_RR(Word32 Rs, Word32 Rt)

Rd=cmp.eq(Rs,#s8)

Word32 Q6_R_cmp_eq_RI(Word32 Rs, Word32 Is8)

Rd=cmp.eq(Rs,Rt)

Word32 Q6_R_cmp_eq_RR(Word32 Rs, Word32 Rt)

207
207
207
207
626
209
209
209
209

Byte Q6_p_cmp_ge_RI(Word32 Rs, Word32 Is8)

207

Byte Q6_p_cmp_geu_RI(Word32 Rs, Word32 Iu8)

207

Pd=!cmp.gt(Rs,#s10)

Byte Q6_p_not_cmp_gt_RI(Word32 Rs, Word32 Is10)

Pd=!cmp.gt(Rs,Rt)

Byte Q6_p_not_cmp_gt_RR(Word32 Rs, Word32 Rt)

Pd=cmp.gt(Rs,#s10)

Byte Q6_p_cmp_gt_RI(Word32 Rs, Word32 Is10)

Pd=cmp.gt(Rs,Rt)

Byte Q6_p_cmp_gt_RR(Word32 Rs, Word32 Rt)

Pd=cmp.gt(Rss,Rtt)

Byte Q6_p_cmp_gt_PP(Word64 Rss, Word64 Rtt)

207
207
207
208
626

cmp.ge
Pd=cmp.ge(Rs,#s8)

cmp.geu
Pd=cmp.geu(Rs,#u8)

cmp.gt

cmp.gtu
Pd=!cmp.gtu(Rs,#u9)

Byte Q6_p_not_cmp_gtu_RI(Word32 Rs, Word32 Iu9)

Pd=!cmp.gtu(Rs,Rt)

Byte Q6_p_not_cmp_gtu_RR(Word32 Rs, Word32 Rt)

Pd=cmp.gtu(Rs,#u9)

Byte Q6_p_cmp_gtu_RI(Word32 Rs, Word32 Iu9)

Pd=cmp.gtu(Rs,Rt)

Byte Q6_p_cmp_gtu_RR(Word32 Rs, Word32 Rt)

80-N2040-46 Rev. B

207
207
208
208

699

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Byte Q6_p_cmp_gtu_PP(Word64 Rss, Word64 Rtt)

626

Byte Q6_p_cmp_lt_RR(Word32 Rs, Word32 Rt)

208

Byte Q6_p_cmp_ltu_RR(Word32 Rs, Word32 Rt)

208

Pd=cmpb.eq(Rs,#u8)

Byte Q6_p_cmpb_eq_RI(Word32 Rs, Word32 Iu8)

Pd=cmpb.eq(Rs,Rt)

Byte Q6_p_cmpb_eq_RR(Word32 Rs, Word32 Rt)

622
622

Pd=cmp.gtu(Rss,Rtt)

cmp.lt
Pd=cmp.lt(Rs,Rt)

cmp.ltu
Pd=cmp.ltu(Rs,Rt)

cmpb.eq

cmpb.gt
Pd=cmpb.gt(Rs,#s8)

Byte Q6_p_cmpb_gt_RI(Word32 Rs, Word32 Is8)

Pd=cmpb.gt(Rs,Rt)

Byte Q6_p_cmpb_gt_RR(Word32 Rs, Word32 Rt)

622
622

cmpb.gtu
Pd=cmpb.gtu(Rs,#u7)

Byte Q6_p_cmpb_gtu_RI(Word32 Rs, Word32 Iu7)

Pd=cmpb.gtu(Rs,Rt)

Byte Q6_p_cmpb_gtu_RR(Word32 Rs, Word32 Rt)

622
622

cmph.eq
Pd=cmph.eq(Rs,#s8)

Byte Q6_p_cmph_eq_RI(Word32 Rs, Word32 Is8)

Pd=cmph.eq(Rs,Rt)

Byte Q6_p_cmph_eq_RR(Word32 Rs, Word32 Rt)

624
624

cmph.gt
Pd=cmph.gt(Rs,#s8)

Byte Q6_p_cmph_gt_RI(Word32 Rs, Word32 Is8)

Pd=cmph.gt(Rs,Rt)

Byte Q6_p_cmph_gt_RR(Word32 Rs, Word32 Rt)

624
624

cmph.gtu
Pd=cmph.gtu(Rs,#u7)

Byte Q6_p_cmph_gtu_RI(Word32 Rs, Word32 Iu7)

Pd=cmph.gtu(Rs,Rt)

Byte Q6_p_cmph_gtu_RR(Word32 Rs, Word32 Rt)

624
624

cmpy
Rd=cmpy(Rs,Rt):<<1:rnd:sat

Word32 Q6_R_cmpy_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=cmpy(Rs,Rt):rnd:sat

Word32 Q6_R_cmpy_RR_rnd_sat(Word32 Rs, Word32 Rt)

Rd=cmpy(Rs,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpy_RR_conj_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=cmpy(Rs,Rt*):rnd:sat

Word32 Q6_R_cmpy_RR_conj_rnd_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpy_RR_s1_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpy_RR_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpy_RR_conj_s1_sat(Word32 Rs, Word32 Rt)

Rdd=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpy_RR_conj_sat(Word32 Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpyacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpyacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpyacc_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpyacc_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt):<<1:sat

Word64 Q6_P_cmpynac_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt):sat

Word64 Q6_P_cmpynac_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt*):<<1:sat

Word64 Q6_P_cmpynac_RR_conj_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=cmpy(Rs,Rt*):sat

Word64 Q6_P_cmpynac_RR_conj_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

498
498
498
498
493
493
493
493
493
493
493
494
494
494
494
494

cmpyi
Rdd=cmpyi(Rs,Rt)

Word64 Q6_P_cmpyi_RR(Word32 Rs, Word32 Rt)

Rxx+=cmpyi(Rs,Rt)

Word64 Q6_P_cmpyiacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

80-N2040-46 Rev. B

495
495

700

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

cmpyiw
Rd=cmpyiw(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_cmpyiw_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyiw(Rss,Rtt):<<1:sat

Word32 Q6_R_cmpyiw_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyiw(Rss,Rtt*):<<1:rnd:sat

Word32 Q6_R_cmpyiw_PP_conj_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyiw(Rss,Rtt*):<<1:sat

Word32 Q6_R_cmpyiw_PP_conj_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=cmpyiw(Rss,Rtt)

Word64 Q6_P_cmpyiw_PP(Word64 Rss, Word64 Rtt)

Rdd=cmpyiw(Rss,Rtt*)

Word64 Q6_P_cmpyiw_PP_conj(Word64 Rss, Word64 Rtt)

Rxx+=cmpyiw(Rss,Rtt)

Word64 Q6_P_cmpyiwacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=cmpyiw(Rss,Rtt*)

Word64 Q6_P_cmpyiwacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)

503
503
503
503
503
503
503
503

cmpyiwh
Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_cmpyiwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)

Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpyiwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)

500
500

cmpyr
Rdd=cmpyr(Rs,Rt)

Word64 Q6_P_cmpyr_RR(Word32 Rs, Word32 Rt)

Rxx+=cmpyr(Rs,Rt)

Word64 Q6_P_cmpyracc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

495
495

cmpyrw
Rd=cmpyrw(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_cmpyrw_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyrw(Rss,Rtt):<<1:sat

Word32 Q6_R_cmpyrw_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyrw(Rss,Rtt*):<<1:rnd:sat

Word32 Q6_R_cmpyrw_PP_conj_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rd=cmpyrw(Rss,Rtt*):<<1:sat

Word32 Q6_R_cmpyrw_PP_conj_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=cmpyrw(Rss,Rtt)

Word64 Q6_P_cmpyrw_PP(Word64 Rss, Word64 Rtt)

Rdd=cmpyrw(Rss,Rtt*)

Word64 Q6_P_cmpyrw_PP_conj(Word64 Rss, Word64 Rtt)

Rxx+=cmpyrw(Rss,Rtt)

Word64 Q6_P_cmpyrwacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=cmpyrw(Rss,Rtt*)

Word64 Q6_P_cmpyrwacc_PP_conj(Word64 Rxx, Word64 Rss, Word64 Rtt)

503
503
503
503
503
503
503
503

cmpyrwh
Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_cmpyrwh_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)

Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat

Word32 Q6_R_cmpyrwh_PR_conj_s1_rnd_sat(Word64 Rss, Word32 Rt)

500
500

combine
Rd=combine(Rt.H,Rs.H)

Word32 Q6_R_combine_RhRh(Word32 Rt, Word32 Rs)

Rd=combine(Rt.H,Rs.L)

Word32 Q6_R_combine_RhRl(Word32 Rt, Word32 Rs)

Rd=combine(Rt.L,Rs.H)

Word32 Q6_R_combine_RlRh(Word32 Rt, Word32 Rs)

Rd=combine(Rt.L,Rs.L)

Word32 Q6_R_combine_RlRl(Word32 Rt, Word32 Rs)

Rdd=combine(#s8,#S8)

Word64 Q6_P_combine_II(Word32 Is8, Word32 IS8)

Rdd=combine(#s8,Rs)

Word64 Q6_P_combine_IR(Word32 Is8, Word32 Rs)

Rdd=combine(Rs,#s8)

Word64 Q6_P_combine_RI(Word32 Rs, Word32 Is8)

Rdd=combine(Rs,Rt)

Word64 Q6_P_combine_RR(Word32 Rs, Word32 Rt)

188
188
188
188
188
188
188
188

Word64 Q6_P_convert_d2df_P(Word64 Rss)

524

Word32 Q6_R_convert_d2sf_P(Word64 Rss)

524

Rdd=convert_df2d(Rss)

Word64 Q6_P_convert_df2d_P(Word64 Rss)

Rdd=convert_df2d(Rss):chop

Word64 Q6_P_convert_df2d_P_chop(Word64 Rss)

527
527

Word32 Q6_R_convert_df2sf_P(Word64 Rss)

523

convert_d2df
Rdd=convert_d2df(Rss)

convert_d2sf
Rd=convert_d2sf(Rss)

convert_df2d

convert_df2sf
Rd=convert_df2sf(Rss)

80-N2040-46 Rev. B

701

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

convert_df2ud
Rdd=convert_df2ud(Rss)

Word64 Q6_P_convert_df2ud_P(Word64 Rss)

Rdd=convert_df2ud(Rss):chop

Word64 Q6_P_convert_df2ud_P_chop(Word64 Rss)

527
527

convert_df2uw
Rd=convert_df2uw(Rss)

Word32 Q6_R_convert_df2uw_P(Word64 Rss)

Rd=convert_df2uw(Rss):chop

Word32 Q6_R_convert_df2uw_P_chop(Word64 Rss)

526
526

convert_df2w
Rd=convert_df2w(Rss)

Word32 Q6_R_convert_df2w_P(Word64 Rss)

Rd=convert_df2w(Rss):chop

Word32 Q6_R_convert_df2w_P_chop(Word64 Rss)

526
526

convert_sf2d
Rdd=convert_sf2d(Rs)

Word64 Q6_P_convert_sf2d_R(Word32 Rs)

Rdd=convert_sf2d(Rs):chop

Word64 Q6_P_convert_sf2d_R_chop(Word32 Rs)

527
527

Word64 Q6_P_convert_sf2df_R(Word32 Rs)

523

Rdd=convert_sf2ud(Rs)

Word64 Q6_P_convert_sf2ud_R(Word32 Rs)

Rdd=convert_sf2ud(Rs):chop

Word64 Q6_P_convert_sf2ud_R_chop(Word32 Rs)

527
527

convert_sf2df
Rdd=convert_sf2df(Rs)

convert_sf2ud

convert_sf2uw
Rd=convert_sf2uw(Rs)

Word32 Q6_R_convert_sf2uw_R(Word32 Rs)

Rd=convert_sf2uw(Rs):chop

Word32 Q6_R_convert_sf2uw_R_chop(Word32 Rs)

526
526

convert_sf2w
Rd=convert_sf2w(Rs)

Word32 Q6_R_convert_sf2w_R(Word32 Rs)

Rd=convert_sf2w(Rs):chop

Word32 Q6_R_convert_sf2w_R_chop(Word32 Rs)

527
527

Word64 Q6_P_convert_ud2df_P(Word64 Rss)

524

Word32 Q6_R_convert_ud2sf_P(Word64 Rss)

524

Word64 Q6_P_convert_uw2df_R(Word32 Rs)

524

Word32 Q6_R_convert_uw2sf_R(Word32 Rs)

524

Word64 Q6_P_convert_w2df_R(Word32 Rs)

524

Word32 Q6_R_convert_w2sf_R(Word32 Rs)

524

Rd=cround(Rs,#u5)

Word32 Q6_R_cround_RI(Word32 Rs, Word32 Iu5)

Rd=cround(Rs,Rt)

Word32 Q6_R_cround_RR(Word32 Rs, Word32 Rt)

Rdd=cround(Rss,#u6)

Word64 Q6_P_cround_PI(Word64 Rss, Word32 Iu6)

Rdd=cround(Rss,Rt)

Word64 Q6_P_cround_PR(Word64 Rss, Word32 Rt)

413
413
413
413

convert_ud2df
Rdd=convert_ud2df(Rss)

convert_ud2sf
Rd=convert_ud2sf(Rss)

convert_uw2df
Rdd=convert_uw2df(Rs)

convert_uw2sf
Rd=convert_uw2sf(Rs)

convert_w2df
Rdd=convert_w2df(Rs)

convert_w2sf
Rd=convert_w2sf(Rs)

cround

80-N2040-46 Rev. B

702

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

ct0
Rd=ct0(Rs)

Word32 Q6_R_ct0_R(Word32 Rs)

Rd=ct0(Rss)

Word32 Q6_R_ct0_P(Word64 Rss)

470
470

ct1
Rd=ct1(Rs)

Word32 Q6_R_ct1_R(Word32 Rs)

Rd=ct1(Rss)

Word32 Q6_R_ct1_P(Word64 Rss)

470
470

void Q6_dccleana_A(Address a)

377

void Q6_dccleaninva_A(Address a)

377

void Q6_dcfetch_A(Address a)

376

void Q6_dcinva_A(Address a)

377

void Q6_dczeroa_A(Address a)

373

Word64 Q6_P_deinterleave_P(Word64 Rss)

476

Word64 Q6_P_dfadd_PP(Word64 Rss, Word64 Rtt)

519

Byte Q6_p_dfclass_PI(Word64 Rss, Word32 Iu5)

520

Byte Q6_p_dfcmp_eq_PP(Word64 Rss, Word64 Rtt)

521

Byte Q6_p_dfcmp_ge_PP(Word64 Rss, Word64 Rtt)

521

Byte Q6_p_dfcmp_gt_PP(Word64 Rss, Word64 Rtt)

521

Byte Q6_p_dfcmp_uo_PP(Word64 Rss, Word64 Rtt)

521

Rdd=dfmake(#u10):neg

Word64 Q6_P_dfmake_I_neg(Word32 Iu10)

Rdd=dfmake(#u10):pos

Word64 Q6_P_dfmake_I_pos(Word32 Iu10)

534
534

Word64 Q6_P_dfmax_PP(Word64 Rss, Word64 Rtt)

535

D
dccleana
dccleana(Rs)

dccleaninva
dccleaninva(Rs)

dcfetch
dcfetch(Rs)

dcinva
dcinva(Rs)

dczeroa
dczeroa(Rs)

deinterleave
Rdd=deinterleave(Rss)

dfadd
Rdd=dfadd(Rss,Rtt)

dfclass
Pd=dfclass(Rss,#u5)

dfcmp.eq
Pd=dfcmp.eq(Rss,Rtt)

dfcmp.ge
Pd=dfcmp.ge(Rss,Rtt)

dfcmp.gt
Pd=dfcmp.gt(Rss,Rtt)

dfcmp.uo
Pd=dfcmp.uo(Rss,Rtt)

dfmake

dfmax
Rdd=dfmax(Rss,Rtt)

80-N2040-46 Rev. B

703

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

dfmin
Word64 Q6_P_dfmin_PP(Word64 Rss, Word64 Rtt)

536

Word64 Q6_P_dfmpyfix_PP(Word64 Rss, Word64 Rtt)

537

Word64 Q6_P_dfmpyhhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

529

Word64 Q6_P_dfmpylhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

529

Word64 Q6_P_dfmpyll_PP(Word64 Rss, Word64 Rtt)

537

Word64 Q6_P_dfsub_PP(Word64 Rss, Word64 Rtt)

539

Word32 Q6_R_dmsyncht()

386

Rd=extract(Rs,#u5,#U5)

Word32 Q6_R_extract_RII(Word32 Rs, Word32 Iu5, Word32 IU5)

Rd=extract(Rs,Rtt)

Word32 Q6_R_extract_RP(Word32 Rs, Word64 Rtt)

Rdd=extract(Rss,#u6,#U6)

Word64 Q6_P_extract_PII(Word64 Rss, Word32 Iu6, Word32 IU6)

Rdd=extract(Rss,Rtt)

Word64 Q6_P_extract_PP(Word64 Rss, Word64 Rtt)

472
472
472
472

Rdd=dfmin(Rss,Rtt)

dfmpyfix
Rdd=dfmpyfix(Rss,Rtt)

dfmpyhh
Rxx+=dfmpyhh(Rss,Rtt)

dfmpylh
Rxx+=dfmpylh(Rss,Rtt)

dfmpyll
Rdd=dfmpyll(Rss,Rtt)

dfsub
Rdd=dfsub(Rss,Rtt)

dmsyncht
Rd=dmsyncht

E
extract

extractu
Rd=extractu(Rs,#u5,#U5)

Word32 Q6_R_extractu_RII(Word32 Rs, Word32 Iu5, Word32 IU5)

Rd=extractu(Rs,Rtt)

Word32 Q6_R_extractu_RP(Word32 Rs, Word64 Rtt)

Rdd=extractu(Rss,#u6,#U6)

Word64 Q6_P_extractu_PII(Word64 Rss, Word32 Iu6, Word32 IU6)

Rdd=extractu(Rss,Rtt)

Word64 Q6_P_extractu_PP(Word64 Rss, Word64 Rtt)

472
472
472
472

F
fastcorner9
Pd=!fastcorner9(Ps,Pt)

Byte Q6_p_not_fastcorner9_pp(Byte Ps, Byte Pt)

Pd=fastcorner9(Ps,Pt)

Byte Q6_p_fastcorner9_pp(Byte Ps, Byte Pt)

212
212

I
insert
Rx=insert(Rs,#u5,#U5)

Word32 Q6_R_insert_RII(Word32 Rx, Word32 Rs, Word32 Iu5, Word32 IU5)

Rx=insert(Rs,Rtt)

Word32 Q6_R_insert_RP(Word32 Rx, Word32 Rs, Word64 Rtt)

Rxx=insert(Rss,#u6,#U6)

Word64 Q6_P_insert_PII(Word64 Rxx, Word64 Rss, Word32 Iu6, Word32 IU6)

Rxx=insert(Rss,Rtt)

Word64 Q6_P_insert_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

475
475
475
475

Word64 Q6_P_interleave_P(Word64 Rss)

476

interleave
Rdd=interleave(Rss)

80-N2040-46 Rev. B

704

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

L
l2fetch
l2fetch(Rs,Rt)

void Q6_l2fetch_AR(Address a, Word32 Rt)

l2fetch(Rs,Rtt)

void Q6_l2fetch_AP(Address a, Word64 Rtt)

384
384

Word64 Q6_P_lfs_PP(Word64 Rss, Word64 Rtt)

477

Rd=lsl(#s6,Rt)

Word32 Q6_R_lsl_IR(Word32 Is6, Word32 Rt)

Rd=lsl(Rs,Rt)

Word32 Q6_R_lsl_RR(Word32 Rs, Word32 Rt)

Rdd=lsl(Rss,Rt)

Word64 Q6_P_lsl_PR(Word64 Rss, Word32 Rt)

Rx&=lsl(Rs,Rt)

Word32 Q6_R_lsland_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=lsl(Rs,Rt)

Word32 Q6_R_lslacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=lsl(Rs,Rt)

Word32 Q6_R_lslnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx|=lsl(Rs,Rt)

Word32 Q6_R_lslor_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx^=lsl(Rss,Rt)

Word64 Q6_P_lslxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx&=lsl(Rss,Rt)

Word64 Q6_P_lsland_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx+=lsl(Rss,Rt)

Word64 Q6_P_lslacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx-=lsl(Rss,Rt)

Word64 Q6_P_lslnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx|=lsl(Rss,Rt)

Word64 Q6_P_lslor_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

656
656
656
663
659
659
663
663
663
659
660
663

lfs
Rdd=lfs(Rss,Rtt)

lsl

lsr
Rd=lsr(Rs,#u5)

Word32 Q6_R_lsr_RI(Word32 Rs, Word32 Iu5)

Rd=lsr(Rs,Rt)

Word32 Q6_R_lsr_RR(Word32 Rs, Word32 Rt)

Rdd=lsr(Rss,#u6)

Word64 Q6_P_lsr_PI(Word64 Rss, Word32 Iu6)

Rdd=lsr(Rss,Rt)

Word64 Q6_P_lsr_PR(Word64 Rss, Word32 Rt)

Rx^=lsr(Rs,#u5)

Word32 Q6_R_lsrxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=lsr(Rs,#u5)

Word32 Q6_R_lsrand_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=lsr(Rs,Rt)

Word32 Q6_R_lsrand_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=lsr(Rs,#u5)

Word32 Q6_R_lsracc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx+=lsr(Rs,Rt)

Word32 Q6_R_lsracc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx=add(#u8,lsr(Rx,#U5))

Word32 Q6_R_add_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx=and(#u8,lsr(Rx,#U5))

Word32 Q6_R_and_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx-=lsr(Rs,#u5)

Word32 Q6_R_lsrnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx-=lsr(Rs,Rt)

Word32 Q6_R_lsrnac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx=or(#u8,lsr(Rx,#U5))

Word32 Q6_R_or_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx=sub(#u8,lsr(Rx,#U5))

Word32 Q6_R_sub_lsr_IRI(Word32 Iu8, Word32 Rx, Word32 IU5)

Rx|=lsr(Rs,#u5)

Word32 Q6_R_lsror_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx|=lsr(Rs,Rt)

Word32 Q6_R_lsror_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx^=lsr(Rss,#u6)

Word64 Q6_P_lsrxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx^=lsr(Rss,Rt)

Word64 Q6_P_lsrxacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx&=lsr(Rss,#u6)

Word64 Q6_P_lsrand_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx&=lsr(Rss,Rt)

Word64 Q6_P_lsrand_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx+=lsr(Rss,#u6)

Word64 Q6_P_lsracc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx+=lsr(Rss,Rt)

Word64 Q6_P_lsracc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx-=lsr(Rss,#u6)

Word64 Q6_P_lsrnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx-=lsr(Rss,Rt)

Word64 Q6_P_lsrnac_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

Rxx|=lsr(Rss,#u6)

Word64 Q6_P_lsror_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx|=lsr(Rss,Rt)

Word64 Q6_P_lsror_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

80-N2040-46 Rev. B

642
656
643
656
649
649
663
645
659
645
649
645
659
649
645
649
663
650
663
649
663
645
660
645
660
650
663

705

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

M
mask
Rd=mask(#u5,#U5)

Word32 Q6_R_mask_II(Word32 Iu5, Word32 IU5)

Rdd=mask(Pt)

Word64 Q6_P_mask_p(Byte Pt)

641
628

max
Rd=max(Rs,Rt)

Word32 Q6_R_max_RR(Word32 Rs, Word32 Rt)

Rdd=max(Rss,Rtt)

Word64 Q6_P_max_PP(Word64 Rss, Word64 Rtt)

406
407

maxu
Rd=maxu(Rs,Rt)

UWord32 Q6_R_maxu_RR(Word32 Rs, Word32 Rt)

Rdd=maxu(Rss,Rtt)

UWord64 Q6_P_maxu_PP(Word64 Rss, Word64 Rtt)

406
407

memb
memb(Rx++#s4:0:circ(Mu))=Rt

void Q6_memb_IMR_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, Word32 Rt, void*
BaseAddress)

memb(Rx++I:circ(Mu))=Rt

311

void Q6_memb_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)

311
Rd=memb(Rx++#s4:0:circ(Mu))

Word32 Q6_R_memb_IM_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, void* BaseAddress)

Rd=memb(Rx++I:circ(Mu))

Word32 Q6_R_memb_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)

243
243

memd
memd(Rx++#s4:3:circ(Mu))=Rtt

void Q6_memd_IMP_circ(void** StartAddress, Word32 Is4_3, Word32 Mu, Word64 Rtt, void*
BaseAddress)

memd(Rx++I:circ(Mu))=Rtt

306

void Q6_memd_MP_circ(void** StartAddress, Word32 Mu, Word64 Rtt, void* BaseAddress)

306
Rdd=memd(Rx++#s4:3:circ(Mu))

Word32 Q6_R_memd_IM_circ(void** StartAddress, Word32 Is4_3, Word32 Mu, void* BaseAddress)

Rdd=memd(Rx++I:circ(Mu))

Word32 Q6_R_memd_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)

238
238

memh
memh(Rx++#s4:1:circ(Mu))=Rt

void Q6_memh_IMR_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, Word32 Rt, void*
BaseAddress)

memh(Rx++#s4:1:circ(Mu))=Rt.H

void* BaseAddress)
memh(Rx++I:circ(Mu))=Rt

317

void Q6_memh_IMRh_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, Word32 Rt,

317

void Q6_memh_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)

317
memh(Rx++I:circ(Mu))=Rt.H

void Q6_memh_MRh_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)

317
Rd=memh(Rx++#s4:1:circ(Mu))

Word32 Q6_R_memh_IM_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, void* BaseAddress)

Rd=memh(Rx++I:circ(Mu))

Word32 Q6_R_memh_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)

253
253

memub
Rd=memub(Rx++#s4:0:circ(Mu))

Word32 Q6_R_memub_IM_circ(void** StartAddress, Word32 Is4_0, Word32 Mu, void* BaseAddress)

Rd=memub(Rx++I:circ(Mu))

257

Word32 Q6_R_memub_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress) 257

memuh
Rd=memuh(Rx++#s4:1:circ(Mu))

Word32 Q6_R_memuh_IM_circ(void** StartAddress, Word32 Is4_1, Word32 Mu, void* BaseAddress)

Rd=memuh(Rx++I:circ(Mu))

80-N2040-46 Rev. B

261

Word32 Q6_R_memuh_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress) 261

706

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

memw
memw(Rx++#s4:2:circ(Mu))=Rt

void Q6_memw_IMR_circ(void** StartAddress, Word32 Is4_2, Word32 Mu, Word32 Rt, void*
BaseAddress)

memw(Rx++I:circ(Mu))=Rt

323

void Q6_memw_MR_circ(void** StartAddress, Word32 Mu, Word32 Rt, void* BaseAddress)

323
Rd=memw(Rx++#s4:2:circ(Mu))

Word32 Q6_R_memw_IM_circ(void** StartAddress, Word32 Is4_2, Word32 Mu, void* BaseAddress)

Rd=memw(Rx++I:circ(Mu))

Word32 Q6_R_memw_M_circ(void** StartAddress, Word32 Mu, void* BaseAddress)

265
265

min
Rd=min(Rt,Rs)

Word32 Q6_R_min_RR(Word32 Rt, Word32 Rs)

Rdd=min(Rtt,Rss)

Word64 Q6_P_min_PP(Word64 Rtt, Word64 Rss)

408
409

minu
Rd=minu(Rt,Rs)

UWord32 Q6_R_minu_RR(Word32 Rt, Word32 Rs)

Rdd=minu(Rtt,Rss)

UWord64 Q6_P_minu_PP(Word64 Rtt, Word64 Rss)

408
409

Word32 Q6_R_modwrap_RR(Word32 Rs, Word32 Rt)

410

Rd=mpy(Rs,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RRh_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt.H):<<1:sat

Word32 Q6_R_mpy_RRh_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RRl_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt.L):<<1:sat

Word32 Q6_R_mpy_RRl_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt)

Word32 Q6_R_mpy_RR(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):<<1

Word32 Q6_R_mpy_RR_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpy_RR_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs,Rt):rnd

Word32 Q6_R_mpy_RR_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpy_RhRh(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpy_RhRh_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1:rnd

Word32 Q6_R_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RhRh_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpy_RhRh_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):rnd

Word32 Q6_R_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):rnd:sat

Word32 Q6_R_mpy_RhRh_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpy_RhRh_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpy_RhRl(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpy_RhRl_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1:rnd

Word32 Q6_R_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RhRl_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpy_RhRl_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):rnd

Word32 Q6_R_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):rnd:sat

Word32 Q6_R_mpy_RhRl_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpy_RhRl_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpy_RlRh(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpy_RlRh_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1:rnd

Word32 Q6_R_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1:rnd:sat

Word32 Q6_R_mpy_RlRh_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpy_RlRh_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):rnd

Word32 Q6_R_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):rnd:sat

Word32 Q6_R_mpy_RlRh_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpy_RlRh_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpy_RlRl(Word32 Rs, Word32 Rt)

568
568
568
568
568
568
568
568
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
552
553
553
553
553

modwrap
Rd=modwrap(Rs,Rt)

mpy

80-N2040-46 Rev. B

707

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rd=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpy_RlRl_s1(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1:rnd

Word32 Q6_R_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1:rnd:sat

Word32 Q6_R_mpy_RlRl_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpy_RlRl_s1_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):rnd

Word32 Q6_R_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):rnd:sat

Word32 Q6_R_mpy_RlRl_rnd_sat(Word32 Rs, Word32 Rt)

Rd=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpy_RlRl_sat(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs,Rt)

Word64 Q6_P_mpy_RR(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpy_RhRh(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpy_RhRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H):<<1:rnd

Word64 Q6_P_mpy_RhRh_s1_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.H):rnd

Word64 Q6_P_mpy_RhRh_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpy_RhRl(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpy_RhRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L):<<1:rnd

Word64 Q6_P_mpy_RhRl_s1_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.H,Rt.L):rnd

Word64 Q6_P_mpy_RhRl_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpy_RlRh(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpy_RlRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H):<<1:rnd

Word64 Q6_P_mpy_RlRh_s1_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.H):rnd

Word64 Q6_P_mpy_RlRh_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpy_RlRl(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpy_RlRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L):<<1:rnd

Word64 Q6_P_mpy_RlRl_s1_rnd(Word32 Rs, Word32 Rt)

Rdd=mpy(Rs.L,Rt.L):rnd

Word64 Q6_P_mpy_RlRl_rnd(Word32 Rs, Word32 Rt)

Rx+=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpyacc_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpyacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpyacc_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpyacc_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpyacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpyacc_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpyacc_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpyacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpyacc_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpyacc_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpyacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpyacc_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpyacc_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs,Rt):<<1:sat

Word32 Q6_R_mpynac_RR_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H)

Word32 Q6_R_mpynac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):<<1

Word32 Q6_R_mpynac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):<<1:sat

Word32 Q6_R_mpynac_RhRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.H):sat

Word32 Q6_R_mpynac_RhRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L)

Word32 Q6_R_mpynac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):<<1

Word32 Q6_R_mpynac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):<<1:sat

Word32 Q6_R_mpynac_RhRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.H,Rt.L):sat

Word32 Q6_R_mpynac_RhRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H)

Word32 Q6_R_mpynac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):<<1

Word32 Q6_R_mpynac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):<<1:sat

Word32 Q6_R_mpynac_RlRh_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.H):sat

Word32 Q6_R_mpynac_RlRh_sat(Word32 Rx, Word32 Rs, Word32 Rt)

80-N2040-46 Rev. B

553
553
553
553
553
553
553
570
553
553
553
553
553
553
553
553
553
553
553
553
553
553
553
553
568
553
553
553
553
554
554
554
554
554
554
554
554
554
554
554
554
568
554
554
554
554
554
554
554
554
554
554
554
554

708

Hexagon V68 Programmer’s Reference Manual

Rx-=mpy(Rs.L,Rt.L)

Word32 Q6_R_mpynac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):<<1

Word32 Q6_R_mpynac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):<<1:sat

Word32 Q6_R_mpynac_RlRl_s1_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpy(Rs.L,Rt.L):sat

Word32 Q6_R_mpynac_RlRl_sat(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs,Rt)

Word64 Q6_P_mpyacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpyacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpyacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpyacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpyacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs,Rt)

Word64 Q6_P_mpynac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.H)

Word64 Q6_P_mpynac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.H):<<1

Word64 Q6_P_mpynac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.L)

Word64 Q6_P_mpynac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.H,Rt.L):<<1

Word64 Q6_P_mpynac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.H)

Word64 Q6_P_mpynac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.H):<<1

Word64 Q6_P_mpynac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.L)

Word64 Q6_P_mpynac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpy(Rs.L,Rt.L):<<1

Word64 Q6_P_mpynac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Intrinsics Index

555
555
555
555
570
555
555
555
555
555
555
555
555
570
555
555
555
555
555
555
555
555

mpyi
Rd=mpyi(Rs,#m9)

Word32 Q6_R_mpyi_RI(Word32 Rs, Word32 Im9)

Rd=mpyi(Rs,Rt)

Word32 Q6_R_mpyi_RR(Word32 Rs, Word32 Rt)

Rx+=mpyi(Rs,#u8)

Word32 Q6_R_mpyiacc_RI(Word32 Rx, Word32 Rs, Word32 Iu8)

Rx+=mpyi(Rs,Rt)

Word32 Q6_R_mpyiacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyi(Rs,#u8)

Word32 Q6_R_mpyinac_RI(Word32 Rx, Word32 Rs, Word32 Iu8)

Rx-=mpyi(Rs,Rt)

Word32 Q6_R_mpyinac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

541
541
541
541
541
541

Word32 Q6_R_mpysu_RR(Word32 Rs, Word32 Rt)

568

Rd=mpyu(Rs,Rt)

UWord32 Q6_R_mpyu_RR(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.H)

UWord32 Q6_R_mpyu_RhRh(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.H):<<1

UWord32 Q6_R_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.L)

UWord32 Q6_R_mpyu_RhRl(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.H,Rt.L):<<1

UWord32 Q6_R_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.H)

UWord32 Q6_R_mpyu_RlRh(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.H):<<1

UWord32 Q6_R_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.L)

UWord32 Q6_R_mpyu_RlRl(Word32 Rs, Word32 Rt)

Rd=mpyu(Rs.L,Rt.L):<<1

UWord32 Q6_R_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs,Rt)

UWord64 Q6_P_mpyu_RR(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.H)

UWord64 Q6_P_mpyu_RhRh(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.H):<<1

UWord64 Q6_P_mpyu_RhRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.L)

UWord64 Q6_P_mpyu_RhRl(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.H,Rt.L):<<1

UWord64 Q6_P_mpyu_RhRl_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.H)

UWord64 Q6_P_mpyu_RlRh(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.H):<<1

UWord64 Q6_P_mpyu_RlRh_s1(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.L)

UWord64 Q6_P_mpyu_RlRl(Word32 Rs, Word32 Rt)

Rdd=mpyu(Rs.L,Rt.L):<<1

UWord64 Q6_P_mpyu_RlRl_s1(Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.H,Rt.H)

Word32 Q6_R_mpyuacc_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)

568
559
559
559
559
559
559
559
559
570
559
559
559
559
559
559
559
559
559

mpysu
Rd=mpysu(Rs,Rt)

mpyu

80-N2040-46 Rev. B

709

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rx+=mpyu(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyuacc_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.H,Rt.L)

Word32 Q6_R_mpyuacc_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyuacc_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.H)

Word32 Q6_R_mpyuacc_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyuacc_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.L)

Word32 Q6_R_mpyuacc_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=mpyu(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyuacc_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.H)

Word32 Q6_R_mpyunac_RhRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.H):<<1

Word32 Q6_R_mpyunac_RhRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.L)

Word32 Q6_R_mpyunac_RhRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.H,Rt.L):<<1

Word32 Q6_R_mpyunac_RhRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.L,Rt.H)

Word32 Q6_R_mpyunac_RlRh(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.L,Rt.H):<<1

Word32 Q6_R_mpyunac_RlRh_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.L,Rt.L)

Word32 Q6_R_mpyunac_RlRl(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=mpyu(Rs.L,Rt.L):<<1

Word32 Q6_R_mpyunac_RlRl_s1(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs,Rt)

Word64 Q6_P_mpyuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.H)

Word64 Q6_P_mpyuacc_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyuacc_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.L)

Word64 Q6_P_mpyuacc_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyuacc_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.H)

Word64 Q6_P_mpyuacc_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyuacc_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.L)

Word64 Q6_P_mpyuacc_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=mpyu(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyuacc_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs,Rt)

Word64 Q6_P_mpyunac_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.H)

Word64 Q6_P_mpyunac_RhRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.H):<<1

Word64 Q6_P_mpyunac_RhRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.L)

Word64 Q6_P_mpyunac_RhRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.H,Rt.L):<<1

Word64 Q6_P_mpyunac_RhRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.H)

Word64 Q6_P_mpyunac_RlRh(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.H):<<1

Word64 Q6_P_mpyunac_RlRh_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.L)

Word64 Q6_P_mpyunac_RlRl(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx-=mpyu(Rs.L,Rt.L):<<1

Word64 Q6_P_mpyunac_RlRl_s1(Word64 Rxx, Word32 Rs, Word32 Rt)

559
559
559
559
559
559
559
559
559
559
559
560
560
560
560
570
560
560
560
560
560
560
560
560
570
560
560
560
560
560
560
560
560

Word32 Q6_R_mpyui_RR(Word32 Rs, Word32 Rt)

541

Rd=mux(Pu,#s8,#S8)

Word32 Q6_R_mux_pII(Byte Pu, Word32 Is8, Word32 IS8)

Rd=mux(Pu,#s8,Rs)

Word32 Q6_R_mux_pIR(Byte Pu, Word32 Is8, Word32 Rs)

Rd=mux(Pu,Rs,#s8)

Word32 Q6_R_mux_pRI(Byte Pu, Word32 Rs, Word32 Is8)

Rd=mux(Pu,Rs,Rt)

Word32 Q6_R_mux_pRR(Byte Pu, Word32 Rs, Word32 Rt)

189
189
189
189

mpyui
Rd=mpyui(Rs,Rt)

mux

N
neg
Rd=neg(Rs)

Word32 Q6_R_neg_R(Word32 Rs)

Rd=neg(Rs):sat

Word32 Q6_R_neg_R_sat(Word32 Rs)

Rdd=neg(Rss)

Word64 Q6_P_neg_P(Word64 Rss)

174
411
411

no mnemonic
Pd=Ps

Byte Q6_p_equals_p(Byte Ps)

Pd=Rs

Byte Q6_p_equals_R(Word32 Rs)

Rd=#s16

Word32 Q6_R_equals_I(Word32 Is16)

80-N2040-46 Rev. B

219
630
179

710

Hexagon V68 Programmer’s Reference Manual

Rd=Ps

Word32 Q6_R_equals_p(Byte Ps)

Rd=Rs

Word32 Q6_R_equals_R(Word32 Rs)

Rdd=#s8

Word64 Q6_P_equals_I(Word32 Is8)

Rdd=Rss

Word64 Q6_P_equals_P(Word64 Rss)

Rx.H=#u16

Word32 Q6_Rh_equals_I(Word32 Rx, Word32 Iu16)

Rx.L=#u16

Word32 Q6_Rl_equals_I(Word32 Rx, Word32 Iu16)

Intrinsics Index

630
181
179
181
179
179

normamt
Rd=normamt(Rs)

Word32 Q6_R_normamt_R(Word32 Rs)

Rd=normamt(Rss)

Word32 Q6_R_normamt_P(Word64 Rss)

467
467

not
Pd=not(Ps)

Byte Q6_p_not_p(Byte Ps)

Rd=not(Rs)

Word32 Q6_R_not_R(Word32 Rs)

Rdd=not(Rss)

Word64 Q6_P_not_P(Word64 Rss)

219
172
401

O
or
Pd=and(Ps,or(Pt,!Pu))

Byte Q6_p_and_or_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=and(Ps,or(Pt,Pu))

Byte Q6_p_and_or_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,and(Pt,!Pu))

Byte Q6_p_or_and_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,and(Pt,Pu))

Byte Q6_p_or_and_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,or(Pt,!Pu))

Byte Q6_p_or_or_ppnp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Ps,or(Pt,Pu))

Byte Q6_p_or_or_ppp(Byte Ps, Byte Pt, Byte Pu)

Pd=or(Pt,!Ps)

Byte Q6_p_or_pnp(Byte Pt, Byte Ps)

Pd=or(Pt,Ps)

Byte Q6_p_or_pp(Byte Pt, Byte Ps)

Rd=or(Rs,#s10)

Word32 Q6_R_or_RI(Word32 Rs, Word32 Is10)

Rd=or(Rs,Rt)

Word32 Q6_R_or_RR(Word32 Rs, Word32 Rt)

Rd=or(Rt,~Rs)

Word32 Q6_R_or_RnR(Word32 Rt, Word32 Rs)

Rdd=or(Rss,Rtt)

Word64 Q6_P_or_PP(Word64 Rss, Word64 Rtt)

Rdd=or(Rtt,~Rss)

Word64 Q6_P_or_PnP(Word64 Rtt, Word64 Rss)

Rx^=or(Rs,Rt)

Word32 Q6_R_orxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx&=or(Rs,Rt)

Word32 Q6_R_orand_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx=or(Ru,and(Rx,#s10))

Word32 Q6_R_or_and_RRI(Word32 Ru, Word32 Rx, Word32 Is10)

Rx|=or(Rs,#s10)

Word32 Q6_R_oror_RI(Word32 Rx, Word32 Rs, Word32 Is10)

Rx|=or(Rs,Rt)

Word32 Q6_R_oror_RR(Word32 Rx, Word32 Rs, Word32 Rt)

219
219
219
219
220
220
220
220
172
172
172
401
401
404
404
404
404
405

Word64 Q6_P_packhl_RR(Word32 Rs, Word32 Rt)

193

Rd=parity(Rs,Rt)

Word32 Q6_R_parity_RR(Word32 Rs, Word32 Rt)

Rd=parity(Rss,Rtt)

Word32 Q6_R_parity_PP(Word64 Rss, Word64 Rtt)

478
478

P
packhl
Rdd=packhl(Rs,Rt)

parity

pmpyw
Rdd=pmpyw(Rs,Rt)

Word64 Q6_P_pmpyw_RR(Word32 Rs, Word32 Rt)

Rxx^=pmpyw(Rs,Rt)

Word64 Q6_P_pmpywxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

564
564

Word32 Q6_R_popcount_P(Word64 Rss)

469

popcount
Rd=popcount(Rss)

80-N2040-46 Rev. B

711

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

R
rol
Rd=rol(Rs,#u5)

Word32 Q6_R_rol_RI(Word32 Rs, Word32 Iu5)

Rdd=rol(Rss,#u6)

Word64 Q6_P_rol_PI(Word64 Rss, Word32 Iu6)

Rx^=rol(Rs,#u5)

Word32 Q6_R_rolxacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx&=rol(Rs,#u5)

Word32 Q6_R_roland_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx+=rol(Rs,#u5)

Word32 Q6_R_rolacc_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx-=rol(Rs,#u5)

Word32 Q6_R_rolnac_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rx|=rol(Rs,#u5)

Word32 Q6_R_rolor_RI(Word32 Rx, Word32 Rs, Word32 Iu5)

Rxx^=rol(Rss,#u6)

Word64 Q6_P_rolxacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx&=rol(Rss,#u6)

Word64 Q6_P_roland_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx+=rol(Rss,#u6)

Word64 Q6_P_rolacc_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx-=rol(Rss,#u6)

Word64 Q6_P_rolnac_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

Rxx|=rol(Rss,#u6)

Word64 Q6_P_rolor_PI(Word64 Rxx, Word64 Rss, Word32 Iu6)

643
643
649
649
645
645
649
650
650
645
645
650

round
Rd=round(Rs,#u5)

Word32 Q6_R_round_RI(Word32 Rs, Word32 Iu5)

Rd=round(Rs,#u5):sat

Word32 Q6_R_round_RI_sat(Word32 Rs, Word32 Iu5)

Rd=round(Rs,Rt)

Word32 Q6_R_round_RR(Word32 Rs, Word32 Rt)

Rd=round(Rs,Rt):sat

Word32 Q6_R_round_RR_sat(Word32 Rs, Word32 Rt)

Rd=round(Rss):sat

Word32 Q6_R_round_P_sat(Word64 Rss)

413
413
413
413
413

Word32 Q6_R_sat_P(Word64 Rss)

597

Word32 Q6_R_satb_R(Word32 Rs)

597

Word32 Q6_R_sath_R(Word32 Rs)

597

Word32 Q6_R_satub_R(Word32 Rs)

597

Word32 Q6_R_satuh_R(Word32 Rs)

597

Rd=setbit(Rs,#u5)

Word32 Q6_R_setbit_RI(Word32 Rs, Word32 Iu5)

Rd=setbit(Rs,Rt)

Word32 Q6_R_setbit_RR(Word32 Rs, Word32 Rt)

480
480

Word32 Q6_R_sfadd_RR(Word32 Rs, Word32 Rt)

519

Byte Q6_p_sfclass_RI(Word32 Rs, Word32 Iu5)

520

Byte Q6_p_sfcmp_eq_RR(Word32 Rs, Word32 Rt)

521

S
sat
Rd=sat(Rss)

satb
Rd=satb(Rs)

sath
Rd=sath(Rs)

satub
Rd=satub(Rs)

satuh
Rd=satuh(Rs)

setbit

sfadd
Rd=sfadd(Rs,Rt)

sfclass
Pd=sfclass(Rs,#u5)

sfcmp.eq
Pd=sfcmp.eq(Rs,Rt)

80-N2040-46 Rev. B

712

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

sfcmp.ge
Byte Q6_p_sfcmp_ge_RR(Word32 Rs, Word32 Rt)

521

Byte Q6_p_sfcmp_gt_RR(Word32 Rs, Word32 Rt)

521

Byte Q6_p_sfcmp_uo_RR(Word32 Rs, Word32 Rt)

521

Word32 Q6_R_sffixupd_RR(Word32 Rs, Word32 Rt)

528

Word32 Q6_R_sffixupn_RR(Word32 Rs, Word32 Rt)

528

Word32 Q6_R_sffixupr_R(Word32 Rs)

528

Rd=sfmake(#u10):neg

Word32 Q6_R_sfmake_I_neg(Word32 Iu10)

Rd=sfmake(#u10):pos

Word32 Q6_R_sfmake_I_pos(Word32 Iu10)

534
534

Word32 Q6_R_sfmax_RR(Word32 Rs, Word32 Rt)

535

Word32 Q6_R_sfmin_RR(Word32 Rs, Word32 Rt)

536

Rd=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpy_RR(Word32 Rs, Word32 Rt)

Rx+=sfmpy(Rs,Rt,Pu):scale

Word32 Q6_R_sfmpyacc_RRp_scale(Word32 Rx, Word32 Rs, Word32 Rt, Byte Pu)

Rx+=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpyacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx+=sfmpy(Rs,Rt):lib

Word32 Q6_R_sfmpyacc_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=sfmpy(Rs,Rt)

Word32 Q6_R_sfmpynac_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx-=sfmpy(Rs,Rt):lib

Word32 Q6_R_sfmpynac_RR_lib(Word32 Rx, Word32 Rs, Word32 Rt)

537
530
529
532
529
532

Word32 Q6_R_sfsub_RR(Word32 Rs, Word32 Rt)

539

Word64 Q6_P_shuffeb_PP(Word64 Rss, Word64 Rtt)

610

Word64 Q6_P_shuffeh_PP(Word64 Rss, Word64 Rtt)

610

Word64 Q6_P_shuffob_PP(Word64 Rtt, Word64 Rss)

610

Word64 Q6_P_shuffoh_PP(Word64 Rtt, Word64 Rss)

610

Rd=add(Rs,sub(#s6,Ru))

Word32 Q6_R_add_sub_RIR(Word32 Rs, Word32 Is6, Word32 Ru)

Rd=sub(#s10,Rs)

Word32 Q6_R_sub_IR(Word32 Is10, Word32 Rs)

393
176

Pd=sfcmp.ge(Rs,Rt)

sfcmp.gt
Pd=sfcmp.gt(Rs,Rt)

sfcmp.uo
Pd=sfcmp.uo(Rs,Rt)

sffixupd
Rd=sffixupd(Rs,Rt)

sffixupn
Rd=sffixupn(Rs,Rt)

sffixupr
Rd=sffixupr(Rs)

sfmake

sfmax
Rd=sfmax(Rs,Rt)

sfmin
Rd=sfmin(Rs,Rt)

sfmpy

sfsub
Rd=sfsub(Rs,Rt)

shuffeb
Rdd=shuffeb(Rss,Rtt)

shuffeh
Rdd=shuffeh(Rss,Rtt)

shuffob
Rdd=shuffob(Rtt,Rss)

shuffoh
Rdd=shuffoh(Rtt,Rss)

sub

80-N2040-46 Rev. B

713

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rd=sub(Rt,Rs)

Word32 Q6_R_sub_RR(Word32 Rt, Word32 Rs)

Rd=sub(Rt,Rs):sat

Word32 Q6_R_sub_RR_sat(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.H):<<16

Word32 Q6_R_sub_RhRh_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.H):sat:<<16

Word32 Q6_R_sub_RhRh_sat_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.L):<<16

Word32 Q6_R_sub_RhRl_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.H,Rs.L):sat:<<16

Word32 Q6_R_sub_RhRl_sat_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H)

Word32 Q6_R_sub_RlRh(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):<<16

Word32 Q6_R_sub_RlRh_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):sat

Word32 Q6_R_sub_RlRh_sat(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.H):sat:<<16

Word32 Q6_R_sub_RlRh_sat_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L)

Word32 Q6_R_sub_RlRl(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):<<16

Word32 Q6_R_sub_RlRl_s16(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):sat

Word32 Q6_R_sub_RlRl_sat(Word32 Rt, Word32 Rs)

Rd=sub(Rt.L,Rs.L):sat:<<16

Word32 Q6_R_sub_RlRl_sat_s16(Word32 Rt, Word32 Rs)

Rdd=sub(Rtt,Rss)

Word64 Q6_P_sub_PP(Word64 Rtt, Word64 Rss)

Rx+=sub(Rt,Rs)

Word32 Q6_R_subacc_RR(Word32 Rx, Word32 Rt, Word32 Rs)

176
176
418
418
418
418
418
418
418
418
418
418
418
418
415
416

Word32 Q6_R_swiz_R(Word32 Rs)

599

Word32 Q6_R_sxtb_R(Word32 Rs)

178

Word32 Q6_R_sxth_R(Word32 Rs)

178

Word64 Q6_P_sxtw_R(Word32 Rs)

419

Word32 Q6_R_tableidxb_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)

485

Word32 Q6_R_tableidxd_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)

485

Word32 Q6_R_tableidxh_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)

485

Word32 Q6_R_tableidxw_RII(Word32 Rx, Word32 Rs, Word32 Iu4, Word32 IU5)

485

Byte Q6_p_tlbmatch_PR(Word64 Rss, Word32 Rt)

629

Rd=togglebit(Rs,#u5)

Word32 Q6_R_togglebit_RI(Word32 Rs, Word32 Iu5)

Rd=togglebit(Rs,Rt)

Word32 Q6_R_togglebit_RR(Word32 Rs, Word32 Rt)

480
480

swiz
Rd=swiz(Rs)

sxtb
Rd=sxtb(Rs)

sxth
Rd=sxth(Rs)

sxtw
Rdd=sxtw(Rs)

T
tableidxb
Rx=tableidxb(Rs,#u4,#U5)

tableidxd
Rx=tableidxd(Rs,#u4,#U5)

tableidxh
Rx=tableidxh(Rs,#u4,#U5)

tableidxw
Rx=tableidxw(Rs,#u4,#U5)

tlbmatch
Pd=tlbmatch(Rss,Rt)

togglebit

tstbit
Pd=!tstbit(Rs,#u5)

Byte Q6_p_not_tstbit_RI(Word32 Rs, Word32 Iu5)

Pd=!tstbit(Rs,Rt)

Byte Q6_p_not_tstbit_RR(Word32 Rs, Word32 Rt)

Pd=tstbit(Rs,#u5)

Byte Q6_p_tstbit_RI(Word32 Rs, Word32 Iu5)

80-N2040-46 Rev. B

631
631
631

714

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Byte Q6_p_tstbit_RR(Word32 Rs, Word32 Rt)

631

Word64 Q6_P_vabsdiffb_PP(Word64 Rtt, Word64 Rss)

422

Word64 Q6_P_vabsdiffh_PP(Word64 Rtt, Word64 Rss)

423

Word64 Q6_P_vabsdiffub_PP(Word64 Rtt, Word64 Rss)

422

Word64 Q6_P_vabsdiffw_PP(Word64 Rtt, Word64 Rss)

424

Rdd=vabsh(Rss)

Word64 Q6_P_vabsh_P(Word64 Rss)

Rdd=vabsh(Rss):sat

Word64 Q6_P_vabsh_P_sat(Word64 Rss)

420
420

Pd=tstbit(Rs,Rt)

V
vabsdiffb
Rdd=vabsdiffb(Rtt,Rss)

vabsdiffh
Rdd=vabsdiffh(Rtt,Rss)

vabsdiffub
Rdd=vabsdiffub(Rtt,Rss)

vabsdiffw
Rdd=vabsdiffw(Rtt,Rss)

vabsh

vabsw
Rdd=vabsw(Rss)

Word64 Q6_P_vabsw_P(Word64 Rss)

Rdd=vabsw(Rss):sat

Word64 Q6_P_vabsw_P_sat(Word64 Rss)

421
421

Word64 Q6_P_vaddb_PP(Word64 Rss, Word64 Rtt)

435

Rd=vaddh(Rs,Rt)

Word32 Q6_R_vaddh_RR(Word32 Rs, Word32 Rt)

Rd=vaddh(Rs,Rt):sat

Word32 Q6_R_vaddh_RR_sat(Word32 Rs, Word32 Rt)

Rdd=vaddh(Rss,Rtt)

Word64 Q6_P_vaddh_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddh(Rss,Rtt):sat

Word64 Q6_P_vaddh_PP_sat(Word64 Rss, Word64 Rtt)

182
182
428
428

Word32 Q6_R_vaddhub_PP_sat(Word64 Rss, Word64 Rtt)

430

Rdd=vaddub(Rss,Rtt)

Word64 Q6_P_vaddub_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddub(Rss,Rtt):sat

Word64 Q6_P_vaddub_PP_sat(Word64 Rss, Word64 Rtt)

435
435

vaddb
Rdd=vaddb(Rss,Rtt)

vaddh

vaddhub
Rd=vaddhub(Rss,Rtt):sat

vaddub

vadduh
Rd=vadduh(Rs,Rt):sat

Word32 Q6_R_vadduh_RR_sat(Word32 Rs, Word32 Rt)

Rdd=vadduh(Rss,Rtt):sat

Word64 Q6_P_vadduh_PP_sat(Word64 Rss, Word64 Rtt)

182
428

vaddw
Rdd=vaddw(Rss,Rtt)

Word64 Q6_P_vaddw_PP(Word64 Rss, Word64 Rtt)

Rdd=vaddw(Rss,Rtt):sat

Word64 Q6_P_vaddw_PP_sat(Word64 Rss, Word64 Rtt)

436
436

valignb
Rdd=valignb(Rtt,Rss,#u3)

Word64 Q6_P_valignb_PPI(Word64 Rtt, Word64 Rss, Word32 Iu3)

Rdd=valignb(Rtt,Rss,Pu)

Word64 Q6_P_valignb_PPp(Word64 Rtt, Word64 Rss, Byte Pu)

600
600

Word64 Q6_P_vaslh_PI(Word64 Rss, Word32 Iu4)

667

vaslh
Rdd=vaslh(Rss,#u4)

80-N2040-46 Rev. B

715

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Word64 Q6_P_vaslh_PR(Word64 Rss, Word32 Rt)

674

Rdd=vaslw(Rss,#u5)

Word64 Q6_P_vaslw_PI(Word64 Rss, Word32 Iu5)

Rdd=vaslw(Rss,Rt)

Word64 Q6_P_vaslw_PR(Word64 Rss, Word32 Rt)

675
678

Rdd=vaslh(Rss,Rt)

vaslw

vasrh
Rdd=vasrh(Rss,#u4)

Word64 Q6_P_vasrh_PI(Word64 Rss, Word32 Iu4)

Rdd=vasrh(Rss,#u4):rnd

Word64 Q6_P_vasrh_PI_rnd(Word64 Rss, Word32 Iu4)

Rdd=vasrh(Rss,Rt)

Word64 Q6_P_vasrh_PR(Word64 Rss, Word32 Rt)

667
669
674

vasrhub
Rd=vasrhub(Rss,#u4):rnd:sat

Word32 Q6_R_vasrhub_PI_rnd_sat(Word64 Rss, Word32 Iu4)

Rd=vasrhub(Rss,#u4):sat

Word32 Q6_R_vasrhub_PI_sat(Word64 Rss, Word32 Iu4)

672
672

vasrw
Rd=vasrw(Rss,#u5)

Word32 Q6_R_vasrw_PI(Word64 Rss, Word32 Iu5)

Rd=vasrw(Rss,Rt)

Word32 Q6_R_vasrw_PR(Word64 Rss, Word32 Rt)

Rdd=vasrw(Rss,#u5)

Word64 Q6_P_vasrw_PI(Word64 Rss, Word32 Iu5)

Rdd=vasrw(Rss,Rt)

Word64 Q6_P_vasrw_PR(Word64 Rss, Word32 Rt)

679
679
675
678

vavgh
Rd=vavgh(Rs,Rt)

Word32 Q6_R_vavgh_RR(Word32 Rs, Word32 Rt)

Rd=vavgh(Rs,Rt):rnd

Word32 Q6_R_vavgh_RR_rnd(Word32 Rs, Word32 Rt)

Rdd=vavgh(Rss,Rtt)

Word64 Q6_P_vavgh_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgh(Rss,Rtt):crnd

Word64 Q6_P_vavgh_PP_crnd(Word64 Rss, Word64 Rtt)

Rdd=vavgh(Rss,Rtt):rnd

Word64 Q6_P_vavgh_PP_rnd(Word64 Rss, Word64 Rtt)

183
183
438
438
438

vavgub
Rdd=vavgub(Rss,Rtt)

Word64 Q6_P_vavgub_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgub(Rss,Rtt):rnd

Word64 Q6_P_vavgub_PP_rnd(Word64 Rss, Word64 Rtt)

439
439

vavguh
Rdd=vavguh(Rss,Rtt)

Word64 Q6_P_vavguh_PP(Word64 Rss, Word64 Rtt)

Rdd=vavguh(Rss,Rtt):rnd

Word64 Q6_P_vavguh_PP_rnd(Word64 Rss, Word64 Rtt)

438
438

vavguw
Rdd=vavguw(Rss,Rtt)

Word64 Q6_P_vavguw_PP(Word64 Rss, Word64 Rtt)

Rdd=vavguw(Rss,Rtt):rnd

Word64 Q6_P_vavguw_PP_rnd(Word64 Rss, Word64 Rtt)

441
441

vavgw
Rdd=vavgw(Rss,Rtt)

Word64 Q6_P_vavgw_PP(Word64 Rss, Word64 Rtt)

Rdd=vavgw(Rss,Rtt):crnd

Word64 Q6_P_vavgw_PP_crnd(Word64 Rss, Word64 Rtt)

Rdd=vavgw(Rss,Rtt):rnd

Word64 Q6_P_vavgw_PP_rnd(Word64 Rss, Word64 Rtt)

441
441
441

Word64 Q6_P_vclip_PI(Word64 Rss, Word32 Iu5)

442

Pd=!any8(vcmpb.eq(Rss,Rtt))

Byte Q6_p_not_any8_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)

Pd=any8(vcmpb.eq(Rss,Rtt))

Byte Q6_p_any8_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)

Pd=vcmpb.eq(Rss,#u8)

Byte Q6_p_vcmpb_eq_PI(Word64 Rss, Word32 Iu8)

Pd=vcmpb.eq(Rss,Rtt)

Byte Q6_p_vcmpb_eq_PP(Word64 Rss, Word64 Rtt)

634
634
636
636

vclip
Rdd=vclip(Rss,#u5)

vcmpb.eq

80-N2040-46 Rev. B

716

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

vcmpb.gt
Pd=vcmpb.gt(Rss,#s8)

Byte Q6_p_vcmpb_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmpb.gt(Rss,Rtt)

Byte Q6_p_vcmpb_gt_PP(Word64 Rss, Word64 Rtt)

636
636

vcmpb.gtu
Pd=vcmpb.gtu(Rss,#u7)

Byte Q6_p_vcmpb_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmpb.gtu(Rss,Rtt)

Byte Q6_p_vcmpb_gtu_PP(Word64 Rss, Word64 Rtt)

636
636

vcmph.eq
Pd=vcmph.eq(Rss,#s8)

Byte Q6_p_vcmph_eq_PI(Word64 Rss, Word32 Is8)

Pd=vcmph.eq(Rss,Rtt)

Byte Q6_p_vcmph_eq_PP(Word64 Rss, Word64 Rtt)

633
633

vcmph.gt
Pd=vcmph.gt(Rss,#s8)

Byte Q6_p_vcmph_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmph.gt(Rss,Rtt)

Byte Q6_p_vcmph_gt_PP(Word64 Rss, Word64 Rtt)

633
633

vcmph.gtu
Pd=vcmph.gtu(Rss,#u7)

Byte Q6_p_vcmph_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmph.gtu(Rss,Rtt)

Byte Q6_p_vcmph_gtu_PP(Word64 Rss, Word64 Rtt)

633
633

vcmpw.eq
Pd=vcmpw.eq(Rss,#s8)

Byte Q6_p_vcmpw_eq_PI(Word64 Rss, Word32 Is8)

Pd=vcmpw.eq(Rss,Rtt)

Byte Q6_p_vcmpw_eq_PP(Word64 Rss, Word64 Rtt)

637
637

vcmpw.gt
Pd=vcmpw.gt(Rss,#s8)

Byte Q6_p_vcmpw_gt_PI(Word64 Rss, Word32 Is8)

Pd=vcmpw.gt(Rss,Rtt)

Byte Q6_p_vcmpw_gt_PP(Word64 Rss, Word64 Rtt)

637
637

vcmpw.gtu
Pd=vcmpw.gtu(Rss,#u7)

Byte Q6_p_vcmpw_gtu_PI(Word64 Rss, Word32 Iu7)

Pd=vcmpw.gtu(Rss,Rtt)

Byte Q6_p_vcmpw_gtu_PP(Word64 Rss, Word64 Rtt)

637
637

vcmpyi
Rdd=vcmpyi(Rss,Rtt):<<1:sat

Word64 Q6_P_vcmpyi_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vcmpyi(Rss,Rtt):sat

Word64 Q6_P_vcmpyi_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vcmpyi(Rss,Rtt):sat

Word64 Q6_P_vcmpyiacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

506
506
506

vcmpyr
Rdd=vcmpyr(Rss,Rtt):<<1:sat

Word64 Q6_P_vcmpyr_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vcmpyr(Rss,Rtt):sat

Word64 Q6_P_vcmpyr_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vcmpyr(Rss,Rtt):sat

Word64 Q6_P_vcmpyracc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

506
506
506

Word64 Q6_P_vcnegh_PR(Word64 Rss, Word32 Rt)

443

Word64 Q6_P_vconj_P_sat(Word64 Rss)

508

Word64 Q6_P_vcrotate_PR(Word64 Rss, Word32 Rt)

510

Rd=vdmpy(Rss,Rtt):<<1:rnd:sat

Word32 Q6_R_vdmpy_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rd=vdmpy(Rss,Rtt):rnd:sat

Word32 Q6_R_vdmpy_PP_rnd_sat(Word64 Rss, Word64 Rtt)

576
576

vcnegh
Rdd=vcnegh(Rss,Rt)

vconj
Rdd=vconj(Rss):sat

vcrotate
Rdd=vcrotate(Rss,Rt)

vdmpy

80-N2040-46 Rev. B

717

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rdd=vdmpy(Rss,Rtt):<<1:sat

Word64 Q6_P_vdmpy_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vdmpy(Rss,Rtt):sat

Word64 Q6_P_vdmpy_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vdmpy(Rss,Rtt):<<1:sat

Word64 Q6_P_vdmpyacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vdmpy(Rss,Rtt):sat

Word64 Q6_P_vdmpyacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

573
573
573
573

vdmpybsu
Rdd=vdmpybsu(Rss,Rtt):sat

Word64 Q6_P_vdmpybsu_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vdmpybsu(Rss,Rtt):sat

Word64 Q6_P_vdmpybsuacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

580
580

Word32 Q6_R_vitpack_pp(Byte Ps, Byte Pt)

639

Word64 Q6_P_vlslh_PR(Word64 Rss, Word32 Rt)

674

Word64 Q6_P_vlslw_PR(Word64 Rss, Word32 Rt)

678

Rdd=vlsrh(Rss,#u4)

Word64 Q6_P_vlsrh_PI(Word64 Rss, Word32 Iu4)

Rdd=vlsrh(Rss,Rt)

Word64 Q6_P_vlsrh_PR(Word64 Rss, Word32 Rt)

667
674

vitpack
Rd=vitpack(Ps,Pt)

vlslh
Rdd=vlslh(Rss,Rt)

vlslw
Rdd=vlslw(Rss,Rt)

vlsrh

vlsrw
Rdd=vlsrw(Rss,#u5)

Word64 Q6_P_vlsrw_PI(Word64 Rss, Word32 Iu5)

Rdd=vlsrw(Rss,Rt)

Word64 Q6_P_vlsrw_PR(Word64 Rss, Word32 Rt)

675
678

Word64 Q6_P_vmaxb_PP(Word64 Rtt, Word64 Rss)

445

Word64 Q6_P_vmaxh_PP(Word64 Rtt, Word64 Rss)

446

Word64 Q6_P_vmaxub_PP(Word64 Rtt, Word64 Rss)

445

Word64 Q6_P_vmaxuh_PP(Word64 Rtt, Word64 Rss)

446

Word64 Q6_P_vmaxuw_PP(Word64 Rtt, Word64 Rss)

451

Word64 Q6_P_vmaxw_PP(Word64 Rtt, Word64 Rss)

451

Word64 Q6_P_vminb_PP(Word64 Rtt, Word64 Rss)

452

Word64 Q6_P_vminh_PP(Word64 Rtt, Word64 Rss)

454

Word64 Q6_P_vminub_PP(Word64 Rtt, Word64 Rss)

452

vmaxb
Rdd=vmaxb(Rtt,Rss)

vmaxh
Rdd=vmaxh(Rtt,Rss)

vmaxub
Rdd=vmaxub(Rtt,Rss)

vmaxuh
Rdd=vmaxuh(Rtt,Rss)

vmaxuw
Rdd=vmaxuw(Rtt,Rss)

vmaxw
Rdd=vmaxw(Rtt,Rss)

vminb
Rdd=vminb(Rtt,Rss)

vminh
Rdd=vminh(Rtt,Rss)

vminub
Rdd=vminub(Rtt,Rss)

80-N2040-46 Rev. B

718

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

vminuh
Word64 Q6_P_vminuh_PP(Word64 Rtt, Word64 Rss)

454

Word64 Q6_P_vminuw_PP(Word64 Rtt, Word64 Rss)

459

Word64 Q6_P_vminw_PP(Word64 Rtt, Word64 Rss)

459

Rdd=vmpybsu(Rs,Rt)

Word64 Q6_P_vmpybsu_RR(Word32 Rs, Word32 Rt)

Rxx+=vmpybsu(Rs,Rt)

Word64 Q6_P_vmpybsuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

592
592

Rdd=vminuh(Rtt,Rss)

vminuw
Rdd=vminuw(Rtt,Rss)

vminw
Rdd=vminw(Rtt,Rss)

vmpybsu

vmpybu
Rdd=vmpybu(Rs,Rt)

Word64 Q6_P_vmpybu_RR(Word32 Rs, Word32 Rt)

Rxx+=vmpybu(Rs,Rt)

Word64 Q6_P_vmpybuacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

592
592

vmpyeh
Rdd=vmpyeh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyeh_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyeh(Rss,Rtt):sat

Word64 Q6_P_vmpyeh_PP_sat(Word64 Rss, Word64 Rtt)

Rxx+=vmpyeh(Rss,Rtt)

Word64 Q6_P_vmpyehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpyeh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpyeh(Rss,Rtt):sat

Word64 Q6_P_vmpyehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

582
582
582
582
582

vmpyh
Rd=vmpyh(Rs,Rt):<<1:rnd:sat

Word32 Q6_R_vmpyh_RR_s1_rnd_sat(Word32 Rs, Word32 Rt)

Rd=vmpyh(Rs,Rt):rnd:sat

Word32 Q6_R_vmpyh_RR_rnd_sat(Word32 Rs, Word32 Rt)

Rdd=vmpyh(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyh_RR_s1_sat(Word32 Rs, Word32 Rt)

Rdd=vmpyh(Rs,Rt):sat

Word64 Q6_P_vmpyh_RR_sat(Word32 Rs, Word32 Rt)

Rxx+=vmpyh(Rs,Rt)

Word64 Q6_P_vmpyhacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=vmpyh(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=vmpyh(Rs,Rt):sat

Word64 Q6_P_vmpyhacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

586
586
584
584
584
584
584

vmpyhsu
Rdd=vmpyhsu(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhsu_RR_s1_sat(Word32 Rs, Word32 Rt)

Rdd=vmpyhsu(Rs,Rt):sat

Word64 Q6_P_vmpyhsu_RR_sat(Word32 Rs, Word32 Rt)

Rxx+=vmpyhsu(Rs,Rt):<<1:sat

Word64 Q6_P_vmpyhsuacc_RR_s1_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

Rxx+=vmpyhsu(Rs,Rt):sat

Word64 Q6_P_vmpyhsuacc_RR_sat(Word64 Rxx, Word32 Rs, Word32 Rt)

587
587
587
587

vmpyweh

544
544
Word64 Q6_P_vmpyweh_PP_rnd_sat(Word64 Rss, Word64 Rtt)
544
Word64 Q6_P_vmpyweh_PP_sat(Word64 Rss, Word64 Rtt)
544
Word64 Q6_P_vmpywehacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 545
Word64 Q6_P_vmpywehacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywehacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywehacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545

Rdd=vmpyweh(Rss,Rtt):<<1:rnd:sat

Word64 Q6_P_vmpyweh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyweh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweh_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyweh(Rss,Rtt):rnd:sat
Rdd=vmpyweh(Rss,Rtt):sat
Rxx+=vmpyweh(Rss,Rtt):<<1:rnd:sat
Rxx+=vmpyweh(Rss,Rtt):<<1:sat
Rxx+=vmpyweh(Rss,Rtt):rnd:sat
Rxx+=vmpyweh(Rss,Rtt):sat

vmpyweuh
Rdd=vmpyweuh(Rss,Rtt):<<1:rnd:sat

Word64 Q6_P_vmpyweuh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweuh_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpyweuh_PP_rnd_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpyweuh(Rss,Rtt):sat

Word64 Q6_P_vmpyweuh_PP_sat(Word64 Rss, Word64 Rtt)

80-N2040-46 Rev. B

548
548
548
548

719

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rxx+=vmpyweuh(Rss,Rtt):<<1:rnd:sat

Word64 Q6_P_vmpyweuhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 549

Rxx+=vmpyweuh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpyweuhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpyweuh(Rss,Rtt):rnd:sat

Word64 Q6_P_vmpyweuhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vmpyweuh(Rss,Rtt):sat

Word64 Q6_P_vmpyweuhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)

549
549
549

vmpywoh

545
545
Word64 Q6_P_vmpywoh_PP_rnd_sat(Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywoh_PP_sat(Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywohacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 545
Word64 Q6_P_vmpywohacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywohacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545
Word64 Q6_P_vmpywohacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
545

Rdd=vmpywoh(Rss,Rtt):<<1:rnd:sat

Word64 Q6_P_vmpywoh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpywoh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywoh_PP_s1_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpywoh(Rss,Rtt):rnd:sat
Rdd=vmpywoh(Rss,Rtt):sat
Rxx+=vmpywoh(Rss,Rtt):<<1:rnd:sat
Rxx+=vmpywoh(Rss,Rtt):<<1:sat
Rxx+=vmpywoh(Rss,Rtt):rnd:sat
Rxx+=vmpywoh(Rss,Rtt):sat

vmpywouh

549
549
Rdd=vmpywouh(Rss,Rtt):rnd:sat
Word64 Q6_P_vmpywouh_PP_rnd_sat(Word64 Rss, Word64 Rtt)
549
Rdd=vmpywouh(Rss,Rtt):sat
Word64 Q6_P_vmpywouh_PP_sat(Word64 Rss, Word64 Rtt)
549
Rxx+=vmpywouh(Rss,Rtt):<<1:rnd:sat Word64 Q6_P_vmpywouhacc_PP_s1_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt) 549
Rxx+=vmpywouh(Rss,Rtt):<<1:sat
Word64 Q6_P_vmpywouhacc_PP_s1_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
549
Rxx+=vmpywouh(Rss,Rtt):rnd:sat
Word64 Q6_P_vmpywouhacc_PP_rnd_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
549
Rxx+=vmpywouh(Rss,Rtt):sat
Word64 Q6_P_vmpywouhacc_PP_sat(Word64 Rxx, Word64 Rss, Word64 Rtt)
549
Rdd=vmpywouh(Rss,Rtt):<<1:rnd:sat

Word64 Q6_P_vmpywouh_PP_s1_rnd_sat(Word64 Rss, Word64 Rtt)

Rdd=vmpywouh(Rss,Rtt):<<1:sat

Word64 Q6_P_vmpywouh_PP_s1_sat(Word64 Rss, Word64 Rtt)

vmux
Word64 Q6_P_vmux_pPP(Byte Pu, Word64 Rss, Word64 Rtt)

640

Rd=vnavgh(Rt,Rs)

Word32 Q6_R_vnavgh_RR(Word32 Rt, Word32 Rs)

Rdd=vnavgh(Rtt,Rss)

Word64 Q6_P_vnavgh_PP(Word64 Rtt, Word64 Rss)

Rdd=vnavgh(Rtt,Rss):crnd:sat

Word64 Q6_P_vnavgh_PP_crnd_sat(Word64 Rtt, Word64 Rss)

Rdd=vnavgh(Rtt,Rss):rnd:sat

Word64 Q6_P_vnavgh_PP_rnd_sat(Word64 Rtt, Word64 Rss)

183
438
438
438

Rdd=vmux(Pu,Rss,Rtt)

vnavgh

vnavgw
Rdd=vnavgw(Rtt,Rss)

Word64 Q6_P_vnavgw_PP(Word64 Rtt, Word64 Rss)

Rdd=vnavgw(Rtt,Rss):crnd:sat

Word64 Q6_P_vnavgw_PP_crnd_sat(Word64 Rtt, Word64 Rss)

Rdd=vnavgw(Rtt,Rss):rnd:sat

Word64 Q6_P_vnavgw_PP_rnd_sat(Word64 Rtt, Word64 Rss)

441
441
441

vpmpyh
Rdd=vpmpyh(Rs,Rt)

Word64 Q6_P_vpmpyh_RR(Word32 Rs, Word32 Rt)

Rxx^=vpmpyh(Rs,Rt)

Word64 Q6_P_vpmpyhxacc_RR(Word64 Rxx, Word32 Rs, Word32 Rt)

594
594

Word32 Q6_R_vraddh_PP(Word64 Rss, Word64 Rtt)

433

Rdd=vraddub(Rss,Rtt)

Word64 Q6_P_vraddub_PP(Word64 Rss, Word64 Rtt)

Rxx+=vraddub(Rss,Rtt)

Word64 Q6_P_vraddubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

431
431

Word32 Q6_R_vradduh_PP(Word64 Rss, Word64 Rtt)

433

vraddh
Rd=vraddh(Rss,Rtt)

vraddub

vradduh
Rd=vradduh(Rss,Rtt)

80-N2040-46 Rev. B

720

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

vrcmpys
Rd=vrcmpys(Rss,Rt):<<1:rnd:sat

Word32 Q6_R_vrcmpys_PR_s1_rnd_sat(Word64 Rss, Word32 Rt)

Rdd=vrcmpys(Rss,Rt):<<1:sat

Word64 Q6_P_vrcmpys_PR_s1_sat(Word64 Rss, Word32 Rt)

Rxx+=vrcmpys(Rss,Rt):<<1:sat

Word64 Q6_P_vrcmpysacc_PR_s1_sat(Word64 Rxx, Word64 Rss, Word32 Rt)

515
512
512

Word64 Q6_P_vrcneghacc_PR(Word64 Rxx, Word64 Rss, Word32 Rt)

443

Rdd=vrcrotate(Rss,Rt,#u2)

Word64 Q6_P_vrcrotate_PRI(Word64 Rss, Word32 Rt, Word32 Iu2)

517

Rxx+=vrcrotate(Rss,Rt,#u2)

Word64 Q6_P_vrcrotateacc_PRI(Word64 Rxx, Word64 Rss, Word32 Rt, Word32 Iu2) 517

vrcnegh
Rxx+=vrcnegh(Rss,Rt)

vrcrotate

vrmaxh
Word64 Q6_P_vrmaxh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

447

Word64 Q6_P_vrmaxuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

447

Word64 Q6_P_vrmaxuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

449

Word64 Q6_P_vrmaxw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

449

Word64 Q6_P_vrminh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

455

Word64 Q6_P_vrminuh_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

455

Word64 Q6_P_vrminuw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

457

Word64 Q6_P_vrminw_PR(Word64 Rxx, Word64 Rss, Word32 Ru)

457

Rdd=vrmpybsu(Rss,Rtt)

Word64 Q6_P_vrmpybsu_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrmpybsu(Rss,Rtt)

Word64 Q6_P_vrmpybsuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

578
578

Rxx=vrmaxh(Rss,Ru)

vrmaxuh
Rxx=vrmaxuh(Rss,Ru)

vrmaxuw
Rxx=vrmaxuw(Rss,Ru)

vrmaxw
Rxx=vrmaxw(Rss,Ru)

vrminh
Rxx=vrminh(Rss,Ru)

vrminuh
Rxx=vrminuh(Rss,Ru)

vrminuw
Rxx=vrminuw(Rss,Ru)

vrminw
Rxx=vrminw(Rss,Ru)

vrmpybsu

vrmpybu
Rdd=vrmpybu(Rss,Rtt)

Word64 Q6_P_vrmpybu_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrmpybu(Rss,Rtt)

Word64 Q6_P_vrmpybuacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

578
578

vrmpyh
Rdd=vrmpyh(Rss,Rtt)

Word64 Q6_P_vrmpyh_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrmpyh(Rss,Rtt)

Word64 Q6_P_vrmpyhacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

589
589

vrmpyweh
Rdd=vrmpyweh(Rss,Rtt)

Word64 Q6_P_vrmpyweh_PP(Word64 Rss, Word64 Rtt)

Rdd=vrmpyweh(Rss,Rtt):<<1

Word64 Q6_P_vrmpyweh_PP_s1(Word64 Rss, Word64 Rtt)

Rxx+=vrmpyweh(Rss,Rtt)

Word64 Q6_P_vrmpywehacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vrmpyweh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywehacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)

80-N2040-46 Rev. B

566
566
566
566

721

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

vrmpywoh
Rdd=vrmpywoh(Rss,Rtt)

Word64 Q6_P_vrmpywoh_PP(Word64 Rss, Word64 Rtt)

Rdd=vrmpywoh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywoh_PP_s1(Word64 Rss, Word64 Rtt)

Rxx+=vrmpywoh(Rss,Rtt)

Word64 Q6_P_vrmpywohacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

Rxx+=vrmpywoh(Rss,Rtt):<<1

Word64 Q6_P_vrmpywohacc_PP_s1(Word64 Rxx, Word64 Rss, Word64 Rtt)

566
566
566
566

vrndwh
Rd=vrndwh(Rss)

Word32 Q6_R_vrndwh_P(Word64 Rss)

Rd=vrndwh(Rss):sat

Word32 Q6_R_vrndwh_P_sat(Word64 Rss)

602
602

vrsadub
Rdd=vrsadub(Rss,Rtt)

Word64 Q6_P_vrsadub_PP(Word64 Rss, Word64 Rtt)

Rxx+=vrsadub(Rss,Rtt)

Word64 Q6_P_vrsadubacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

461
461

vsathb
Rd=vsathb(Rs)

Word32 Q6_R_vsathb_R(Word32 Rs)

Rd=vsathb(Rss)

Word32 Q6_R_vsathb_P(Word64 Rss)

Rdd=vsathb(Rss)

Word64 Q6_P_vsathb_P(Word64 Rss)

605
605
608

vsathub
Rd=vsathub(Rs)

Word32 Q6_R_vsathub_R(Word32 Rs)

Rd=vsathub(Rss)

Word32 Q6_R_vsathub_P(Word64 Rss)

Rdd=vsathub(Rss)

Word64 Q6_P_vsathub_P(Word64 Rss)

605
605
608

vsatwh
Rd=vsatwh(Rss)

Word32 Q6_R_vsatwh_P(Word64 Rss)

Rdd=vsatwh(Rss)

Word64 Q6_P_vsatwh_P(Word64 Rss)

605
608

vsatwuh
Rd=vsatwuh(Rss)

Word32 Q6_R_vsatwuh_P(Word64 Rss)

Rdd=vsatwuh(Rss)

Word64 Q6_P_vsatwuh_P(Word64 Rss)

605
608

vsplatb
Rd=vsplatb(Rs)

Word32 Q6_R_vsplatb_R(Word32 Rs)

Rdd=vsplatb(Rs)

Word64 Q6_P_vsplatb_R(Word32 Rs)

611
611

Word64 Q6_P_vsplath_R(Word32 Rs)

612

Rdd=vspliceb(Rss,Rtt,#u3)

Word64 Q6_P_vspliceb_PPI(Word64 Rss, Word64 Rtt, Word32 Iu3)

Rdd=vspliceb(Rss,Rtt,Pu)

Word64 Q6_P_vspliceb_PPp(Word64 Rss, Word64 Rtt, Byte Pu)

613
613

Word64 Q6_P_vsubb_PP(Word64 Rss, Word64 Rtt)

464

Rd=vsubh(Rt,Rs)

Word32 Q6_R_vsubh_RR(Word32 Rt, Word32 Rs)

Rd=vsubh(Rt,Rs):sat

Word32 Q6_R_vsubh_RR_sat(Word32 Rt, Word32 Rs)

Rdd=vsubh(Rtt,Rss)

Word64 Q6_P_vsubh_PP(Word64 Rtt, Word64 Rss)

Rdd=vsubh(Rtt,Rss):sat

Word64 Q6_P_vsubh_PP_sat(Word64 Rtt, Word64 Rss)

184
184
462
462

Word64 Q6_P_vsubub_PP(Word64 Rtt, Word64 Rss)

464

vsplath
Rdd=vsplath(Rs)

vspliceb

vsubb
Rdd=vsubb(Rss,Rtt)

vsubh

vsubub
Rdd=vsubub(Rtt,Rss)

80-N2040-46 Rev. B

722

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Word64 Q6_P_vsubub_PP_sat(Word64 Rtt, Word64 Rss)

464

Rd=vsubuh(Rt,Rs):sat

Word32 Q6_R_vsubuh_RR_sat(Word32 Rt, Word32 Rs)

Rdd=vsubuh(Rtt,Rss):sat

Word64 Q6_P_vsubuh_PP_sat(Word64 Rtt, Word64 Rss)

184
462

Rdd=vsubub(Rtt,Rss):sat

vsubuh

vsubw
Rdd=vsubw(Rtt,Rss)

Word64 Q6_P_vsubw_PP(Word64 Rtt, Word64 Rss)

Rdd=vsubw(Rtt,Rss):sat

Word64 Q6_P_vsubw_PP_sat(Word64 Rtt, Word64 Rss)

465
465

Word64 Q6_P_vsxtbh_R(Word32 Rs)

614

Word64 Q6_P_vsxthw_R(Word32 Rs)

614

Rd=vtrunehb(Rss)

Word32 Q6_R_vtrunehb_P(Word64 Rss)

Rdd=vtrunehb(Rss,Rtt)

Word64 Q6_P_vtrunehb_PP(Word64 Rss, Word64 Rtt)

617
617

Word64 Q6_P_vtrunewh_PP(Word64 Rss, Word64 Rtt)

617

Rd=vtrunohb(Rss)

Word32 Q6_R_vtrunohb_P(Word64 Rss)

Rdd=vtrunohb(Rss,Rtt)

Word64 Q6_P_vtrunohb_PP(Word64 Rss, Word64 Rtt)

617
617

Word64 Q6_P_vtrunowh_PP(Word64 Rss, Word64 Rtt)

617

Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat

Word64 Q6_P_vxaddsubh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)

Rdd=vxaddsubh(Rss,Rtt):sat

Word64 Q6_P_vxaddsubh_PP_sat(Word64 Rss, Word64 Rtt)

488
488

Word64 Q6_P_vxaddsubw_PP_sat(Word64 Rss, Word64 Rtt)

490

Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat

Word64 Q6_P_vxsubaddh_PP_rnd_rs1_sat(Word64 Rss, Word64 Rtt)

Rdd=vxsubaddh(Rss,Rtt):sat

Word64 Q6_P_vxsubaddh_PP_sat(Word64 Rss, Word64 Rtt)

488
488

Word64 Q6_P_vxsubaddw_PP_sat(Word64 Rss, Word64 Rtt)

490

Word64 Q6_P_vzxtbh_R(Word32 Rs)

618

Word64 Q6_P_vzxthw_R(Word32 Rs)

618

Byte Q6_p_xor_pp(Byte Ps, Byte Pt)

220

vsxtbh
Rdd=vsxtbh(Rs)

vsxthw
Rdd=vsxthw(Rs)

vtrunehb

vtrunewh
Rdd=vtrunewh(Rss,Rtt)

vtrunohb

vtrunowh
Rdd=vtrunowh(Rss,Rtt)

vxaddsubh

vxaddsubw
Rdd=vxaddsubw(Rss,Rtt):sat

vxsubaddh

vxsubaddw
Rdd=vxsubaddw(Rss,Rtt):sat

vzxtbh
Rdd=vzxtbh(Rs)

vzxthw
Rdd=vzxthw(Rs)

X
xor
Pd=xor(Ps,Pt)

80-N2040-46 Rev. B

723

Hexagon V68 Programmer’s Reference Manual

Intrinsics Index

Rd=xor(Rs,Rt)

Word32 Q6_R_xor_RR(Word32 Rs, Word32 Rt)

Rdd=xor(Rss,Rtt)

Word64 Q6_P_xor_PP(Word64 Rss, Word64 Rtt)

Rx^=xor(Rs,Rt)

Word32 Q6_R_xorxacc_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx&=xor(Rs,Rt)

Word32 Q6_R_xorand_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rx|=xor(Rs,Rt)

Word32 Q6_R_xoror_RR(Word32 Rx, Word32 Rs, Word32 Rt)

Rxx^=xor(Rss,Rtt)

Word64 Q6_P_xorxacc_PP(Word64 Rxx, Word64 Rss, Word64 Rtt)

172
401
404
404
405
403

Word32 Q6_R_zxtb_R(Word32 Rs)

186

Word32 Q6_R_zxth_R(Word32 Rs)

186

Z
zxtb
Rd=zxtb(Rs)

zxth
Rd=zxth(Rs)

80-N2040-46 Rev. B

724

