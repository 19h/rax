//! Rust test code generation.
//!
//! This module generates Rust test files compatible with the rax emulator test suite.
//! Each generated test includes:
//! - Clear provenance comments linking to ASL source
//! - Proper test structure matching rax conventions
//! - Initial state setup and expected result assertions

use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use crate::syntax::InstructionSet;
use crate::testgen::types::*;

/// Format test suites as Rust test code
pub fn format_test_suites(suites: &[InstructionTestSuite]) -> String {
    let mut output = String::new();
    let mut seen_fn_names: HashSet<String> = HashSet::new();

    // Write file header
    write_file_header(&mut output);

    // Group tests by instruction for better organization
    for suite in suites {
        write_instruction_tests_dedup(&mut output, suite, &mut seen_fn_names);
    }

    output
}

/// Write the file header with imports and common utilities
fn write_file_header(output: &mut String) {
    output.push_str(
        r#"//! Auto-generated ARM instruction tests.
//!
//! This file was generated by asl-parser from ARM ASL specifications.
//! Each test includes provenance comments linking to the source specification.
//!
//! DO NOT EDIT MANUALLY - regenerate from ASL source instead.

#![allow(unused_imports)]
#![allow(dead_code)]

use rax::arm::{AArch64Config, AArch64Cpu, ArmCpu, CpuExit, FlatMemory};

// ============================================================================
// Test Helpers
// ============================================================================

/// Create a test CPU with default configuration
fn create_test_cpu() -> AArch64Cpu {
    let memory = FlatMemory::new(0, 0x1000_0000);
    AArch64Cpu::new(AArch64Config::default(), Box::new(memory))
}

/// Write an instruction to memory
fn write_insn(cpu: &mut AArch64Cpu, addr: u64, insn: u32) {
    cpu.write_memory(addr, &insn.to_le_bytes()).unwrap();
}

/// Execute instructions until reaching target address
fn run_to(cpu: &mut AArch64Cpu, target_pc: u64) -> CpuExit {
    loop {
        let exit = cpu.step().unwrap();
        if cpu.get_pc() >= target_pc || !matches!(exit, CpuExit::Continue) {
            return exit;
        }
    }
}

/// Set a general purpose register (X0-X30)
fn set_x(cpu: &mut AArch64Cpu, reg: u8, value: u64) {
    cpu.set_gpr(reg, value);
}

/// Get a general purpose register (X0-X30)
fn get_x(cpu: &AArch64Cpu, reg: u8) -> u64 {
    cpu.get_gpr(reg)
}

/// Set the 32-bit view of a register (W0-W30)
fn set_w(cpu: &mut AArch64Cpu, reg: u8, value: u32) {
    cpu.set_gpr(reg, value as u64);
}

/// Get the 32-bit view of a register (W0-W30)
fn get_w(cpu: &AArch64Cpu, reg: u8) -> u32 {
    cpu.get_gpr(reg) as u32
}

/// Set SIMD register (V0-V31)
fn set_qreg(cpu: &mut AArch64Cpu, reg: u8, value: u128) {
    let low = value as u64;
    let high = (value >> 64) as u64;
    cpu.set_simd_reg(reg, low, high).unwrap();
}

/// Get SIMD register (V0-V31)
fn get_qreg(cpu: &AArch64Cpu, reg: u8) -> u128 {
    let (low, high) = cpu.get_simd_reg(reg).unwrap();
    (high as u128) << 64 | (low as u128)
}

"#,
    );
}

/// Write tests for a single instruction
fn write_instruction_tests(output: &mut String, suite: &InstructionTestSuite) {
    let mut seen = HashSet::new();
    write_instruction_tests_dedup(output, suite, &mut seen);
}

/// Write tests for a single instruction to a string (for structured output)
/// This is called from structured.rs for per-category file generation
pub fn write_instruction_tests_to_string(output: &mut String, suite: &InstructionTestSuite) {
    let mut seen = HashSet::new();
    write_instruction_tests_dedup(output, suite, &mut seen);
}

/// Write tests for a single instruction, deduplicating function names
fn write_instruction_tests_dedup(
    output: &mut String,
    suite: &InstructionTestSuite,
    seen_fn_names: &mut HashSet<String>,
) {
    // Section header
    writeln!(
        output,
        "// ============================================================================"
    )
    .unwrap();
    writeln!(output, "// {} Tests", suite.instruction_name).unwrap();
    writeln!(
        output,
        "// ============================================================================"
    )
    .unwrap();
    writeln!(output).unwrap();

    // Write encoding tests (with deduplication)
    for test in &suite.encoding_tests {
        let base_name = sanitize_test_name(&test.id);
        let fn_name = format!("{}_{:08x}", base_name, test.encoding);
        if seen_fn_names.insert(fn_name) {
            write_encoding_test(output, test);
        }
    }

    // Write execution tests (with deduplication)
    for test in &suite.execution_tests {
        let base_name = sanitize_test_name(&test.id);
        let fn_name = format!("{}_{:08x}", base_name, test.encoding);
        if seen_fn_names.insert(fn_name) {
            write_execution_test(output, test);
        }
    }
}

/// Write a single encoding test
fn write_encoding_test(output: &mut String, test: &EncodingTest) {
    // Write provenance comment
    write_provenance_comment(output, &test.provenance);

    // Write test function - include encoding value for uniqueness
    let base_name = sanitize_test_name(&test.id);
    let fn_name = format!("{}_{:08x}", base_name, test.encoding);
    writeln!(output, "#[test]").unwrap();
    writeln!(output, "fn {}() {{", fn_name).unwrap();

    // Determine instruction set and generate appropriate test
    match test.iset {
        InstructionSet::A64 => {
            write_a64_encoding_test_body(output, test);
        }
        InstructionSet::A32 => {
            write_a32_encoding_test_body(output, test);
        }
        InstructionSet::T32 | InstructionSet::T16 => {
            write_thumb_encoding_test_body(output, test);
        }
    }

    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Write A64 encoding test body
fn write_a64_encoding_test_body(output: &mut String, test: &EncodingTest) {
    writeln!(output, "    // Encoding: 0x{:08X}", test.encoding).unwrap();
    writeln!(output, "    // {}", test.description).unwrap();

    // Write field values as comments
    if !test.field_values.is_empty() {
        write!(output, "    // Fields: ").unwrap();
        let fields: Vec<_> = test
            .field_values
            .iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect();
        writeln!(output, "{}", fields.join(", ")).unwrap();
    }

    writeln!(
        output,
        "    let encoding: u32 = 0x{:08X};",
        test.encoding as u32
    )
    .unwrap();
    writeln!(output, "    let mut cpu = create_test_cpu();").unwrap();
    writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();

    match test.expected_result {
        ExpectedResult::Pass => {
            writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
            writeln!(
                output,
                "    assert_eq!(exit, CpuExit::Continue, \"instruction 0x{{:08X}} should execute successfully\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Undefined => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), \"expected UNDEFINED for encoding 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Unpredictable => {
            writeln!(
                output,
                "    // UNPREDICTABLE - behavior is implementation-defined"
            )
            .unwrap();
            writeln!(output, "    let _ = cpu.step();").unwrap();
        }
        ExpectedResult::Unallocated => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err(), \"expected unallocated encoding for 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Exception(_) => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), \"expected exception for encoding 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
    }
}

/// Write A32 encoding test body
fn write_a32_encoding_test_body(output: &mut String, test: &EncodingTest) {
    writeln!(output, "    // Encoding: 0x{:08X}", test.encoding).unwrap();
    writeln!(output, "    // {}", test.description).unwrap();
    writeln!(output, "    // ISET: A32").unwrap();

    // Write field values as comments
    if !test.field_values.is_empty() {
        write!(output, "    // Fields: ").unwrap();
        let fields: Vec<_> = test
            .field_values
            .iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect();
        writeln!(output, "{}", fields.join(", ")).unwrap();
    }

    writeln!(
        output,
        "    let encoding: u32 = 0x{:08X};",
        test.encoding as u32
    )
    .unwrap();
    writeln!(output, "    let mut cpu = create_test_cpu();").unwrap();
    writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();

    match test.expected_result {
        ExpectedResult::Pass => {
            writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
            writeln!(
                output,
                "    assert_eq!(exit, CpuExit::Continue, \"A32 instruction 0x{{:08X}} should execute successfully\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Undefined => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), \"expected UNDEFINED for A32 encoding 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Unpredictable => {
            writeln!(
                output,
                "    // UNPREDICTABLE - behavior is implementation-defined"
            )
            .unwrap();
            writeln!(output, "    let _ = cpu.step();").unwrap();
        }
        ExpectedResult::Unallocated => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err(), \"expected unallocated encoding for A32 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
        ExpectedResult::Exception(_) => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), \"expected exception for A32 encoding 0x{{:08X}}\", encoding);"
            )
            .unwrap();
        }
    }
}

/// Write Thumb encoding test body
fn write_thumb_encoding_test_body(output: &mut String, test: &EncodingTest) {
    let width = if test.encoding_width == 16 { 16 } else { 32 };
    let iset_name = if width == 16 { "T16" } else { "T32" };
    writeln!(
        output,
        "    // Thumb encoding ({}): 0x{:0width$X}",
        width,
        test.encoding,
        width = (width / 4) as usize
    )
    .unwrap();
    writeln!(output, "    // {}", test.description).unwrap();
    writeln!(output, "    // ISET: {}", iset_name).unwrap();

    // Write field values as comments
    if !test.field_values.is_empty() {
        write!(output, "    // Fields: ").unwrap();
        let fields: Vec<_> = test
            .field_values
            .iter()
            .map(|(k, v)| format!("{}={}", k, v))
            .collect();
        writeln!(output, "{}", fields.join(", ")).unwrap();
    }

    writeln!(output, "    let mut cpu = create_thumb_cpu();").unwrap();

    if width == 16 {
        writeln!(
            output,
            "    let encoding: u16 = 0x{:04X};",
            test.encoding as u16
        )
        .unwrap();
        writeln!(output, "    write_insn16(&mut cpu, 0, encoding);").unwrap();
    } else {
        writeln!(
            output,
            "    let encoding: u32 = 0x{:08X};",
            test.encoding as u32
        )
        .unwrap();
        writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();
    }

    match test.expected_result {
        ExpectedResult::Pass => {
            writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
            writeln!(
                output,
                "    assert_eq!(exit, CpuExit::Continue, \"{} instruction should execute successfully\");",
                iset_name
            )
            .unwrap();
        }
        ExpectedResult::Undefined => {
            writeln!(output, "    let exit = cpu.step();").unwrap();
            writeln!(
                output,
                "    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), \"expected UNDEFINED for {} encoding\");",
                iset_name
            )
            .unwrap();
        }
        _ => {
            writeln!(output, "    let _ = cpu.step();").unwrap();
        }
    }
}

/// Write a single execution test
fn write_execution_test(output: &mut String, test: &ExecutionTest) {
    // Write provenance comment
    write_provenance_comment(output, &test.provenance);

    // Write test function - include encoding value for uniqueness
    let base_name = sanitize_test_name(&test.id);
    let fn_name = format!("{}_{:08x}", base_name, test.encoding);
    writeln!(output, "#[test]").unwrap();
    writeln!(output, "fn {}() {{", fn_name).unwrap();

    match test.iset {
        InstructionSet::A64 => {
            write_a64_execution_test_body(output, test);
        }
        InstructionSet::A32 => {
            write_a32_execution_test_body(output, test);
        }
        InstructionSet::T32 | InstructionSet::T16 => {
            write_thumb_execution_test_body(output, test);
        }
    }

    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Write A64 execution test body
fn write_a64_execution_test_body(output: &mut String, test: &ExecutionTest) {
    writeln!(output, "    // {}", test.description).unwrap();
    writeln!(output, "    // Encoding: 0x{:08X}", test.encoding).unwrap();

    writeln!(output, "    let mut cpu = create_test_cpu();").unwrap();

    // Set up initial state
    write_initial_state_a64(output, &test.initial_state, "    ");

    // Write instruction to memory and execute
    writeln!(
        output,
        "    let encoding: u32 = 0x{:08X};",
        test.encoding as u32
    )
    .unwrap();
    writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();
    writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
    writeln!(
        output,
        "    assert_eq!(exit, CpuExit::Continue, \"instruction should execute\");"
    )
    .unwrap();

    // Write assertions
    write_assertions_a64(output, &test.assertions, "    ");
}

/// Write A32 execution test body
fn write_a32_execution_test_body(output: &mut String, test: &ExecutionTest) {
    writeln!(output, "    // {}", test.description).unwrap();
    writeln!(output, "    // Encoding: 0x{:08X}", test.encoding).unwrap();
    writeln!(output, "    // ISET: A32").unwrap();

    writeln!(output, "    let mut cpu = create_test_cpu();").unwrap();

    // Set up initial state using set_w for 32-bit registers
    write_initial_state_a32(output, &test.initial_state, "    ");

    // Write instruction to memory and execute
    writeln!(
        output,
        "    let encoding: u32 = 0x{:08X};",
        test.encoding as u32
    )
    .unwrap();
    writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();
    writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
    writeln!(
        output,
        "    assert_eq!(exit, CpuExit::Continue, \"instruction should execute\");"
    )
    .unwrap();

    // Write assertions
    write_assertions_a32(output, &test.assertions, "    ");
}

/// Write Thumb execution test body (T32/T16)
fn write_thumb_execution_test_body(output: &mut String, test: &ExecutionTest) {
    writeln!(output, "    // {}", test.description).unwrap();
    let iset_name = match test.iset {
        InstructionSet::T16 => "T16",
        InstructionSet::T32 => "T32",
        _ => "Thumb",
    };
    writeln!(output, "    // ISET: {}", iset_name).unwrap();

    writeln!(output, "    let mut cpu = create_test_cpu();").unwrap();

    // Set up initial state using set_w for 32-bit registers
    write_initial_state_a32(output, &test.initial_state, "    ");

    // Write instruction to memory
    if test.iset == InstructionSet::T16 {
        writeln!(
            output,
            "    let encoding: u16 = 0x{:04X};",
            test.encoding as u16
        )
        .unwrap();
        writeln!(output, "    // T16: Write 16-bit instruction").unwrap();
        writeln!(
            output,
            "    cpu.write_memory(0, &(encoding as u32).to_le_bytes()).unwrap();"
        )
        .unwrap();
    } else {
        writeln!(
            output,
            "    let encoding: u32 = 0x{:08X};",
            test.encoding as u32
        )
        .unwrap();
        writeln!(output, "    write_insn(&mut cpu, 0, encoding);").unwrap();
    }

    writeln!(output, "    let exit = cpu.step().unwrap();").unwrap();
    writeln!(
        output,
        "    assert_eq!(exit, CpuExit::Continue, \"instruction should execute\");"
    )
    .unwrap();

    // Write assertions
    write_assertions_a32(output, &test.assertions, "    ");
}

/// Write provenance comment
fn write_provenance_comment(output: &mut String, provenance: &Provenance) {
    writeln!(output, "/// Provenance: {}", provenance.encoding).unwrap();
    writeln!(output, "/// ASL: `{}`", provenance.asl_source).unwrap();
    writeln!(output, "/// Requirement: {:?}", provenance.requirement).unwrap();
    writeln!(output, "/// {}", provenance.explanation).unwrap();
}

/// Write initial state setup code (generic)
fn write_initial_state(output: &mut String, state: &ProcessorState, indent: &str) {
    // Set up GP registers
    for (reg, value) in &state.gp_regs {
        writeln!(output, "{}cpu.set_x({}, 0x{:X});", indent, reg, value).unwrap();
    }

    // Set up SIMD registers
    for (reg, value) in &state.simd_regs {
        writeln!(output, "{}cpu.set_v({}, 0x{:032X});", indent, reg, value).unwrap();
    }

    // Set up SP
    if let Some(sp) = state.sp {
        writeln!(output, "{}cpu.set_sp(0x{:X});", indent, sp).unwrap();
    }

    // Set up PC
    if let Some(pc) = state.pc {
        writeln!(output, "{}cpu.set_pc(0x{:X});", indent, pc).unwrap();
    }

    // Set up flags
    if let Some(nzcv) = state.nzcv {
        writeln!(output, "{}cpu.set_nzcv(0x{:X});", indent, nzcv).unwrap();
    }

    // Set up memory
    for (addr, data) in &state.memory {
        writeln!(output, "{}// Memory at 0x{:X}: {:?}", indent, addr, data).unwrap();
    }
}

/// Write initial state setup code for A64
fn write_initial_state_a64(output: &mut String, state: &ProcessorState, indent: &str) {
    // Set up GP registers
    for (reg, value) in &state.gp_regs {
        writeln!(output, "{}set_x(&mut cpu, {}, 0x{:X});", indent, reg, value).unwrap();
    }

    // Set up SIMD registers
    for (reg, value) in &state.simd_regs {
        writeln!(
            output,
            "{}set_qreg(&mut cpu, {}, 0x{:032X});",
            indent, reg, value
        )
        .unwrap();
    }

    // Set up memory
    for (addr, data) in &state.memory {
        writeln!(
            output,
            "{}cpu.write_memory(0x{:X}, &{:?}).unwrap();",
            indent, addr, data
        )
        .unwrap();
    }
}

/// Write initial state setup code for A32/T32/T16 (32-bit registers)
fn write_initial_state_a32(output: &mut String, state: &ProcessorState, indent: &str) {
    // Set up GP registers (using set_w for 32-bit)
    for (reg, value) in &state.gp_regs {
        // Truncate to 32-bit for A32
        let value32 = *value as u32;
        writeln!(
            output,
            "{}set_w(&mut cpu, {}, 0x{:X});",
            indent, reg, value32
        )
        .unwrap();
    }

    // Set up memory
    for (addr, data) in &state.memory {
        writeln!(
            output,
            "{}cpu.write_memory(0x{:X}, &{:?}).unwrap();",
            indent, addr, data
        )
        .unwrap();
    }
}

/// Write assertion code for A32/T32/T16 using 32-bit registers
fn write_assertions_a32(output: &mut String, assertions: &[TestAssertion], indent: &str) {
    for assertion in assertions {
        match &assertion.check {
            AssertionCheck::GpReg(reg) => match &assertion.expected {
                AssertionValue::U64(val) => {
                    // For A32, truncate to 32-bit
                    let val32 = *val as u32;
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0x{:X}, \"{}\");",
                        indent, reg, val32, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::U32(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::NonZero => {
                    writeln!(
                        output,
                        "{}assert_ne!(get_w(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for R{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::GpReg32(reg) => match &assertion.expected {
                AssertionValue::U32(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for R{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Flag(flag) => {
                let flag_name = match flag {
                    ProcessorFlag::N => "n",
                    ProcessorFlag::Z => "z",
                    ProcessorFlag::C => "c",
                    ProcessorFlag::V => "v",
                };
                if let AssertionValue::Bool(val) = &assertion.expected {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.get_pstate().{}, {}, \"{}\");",
                        indent, flag_name, val, assertion.message
                    )
                    .unwrap();
                }
            }
            AssertionCheck::Nzcv => {
                if let AssertionValue::U64(val) = &assertion.expected {
                    writeln!(output, "{}// Check NZCV is 0x{:X}", indent, val).unwrap();
                }
            }
            AssertionCheck::Memory { address, size } => {
                writeln!(
                    output,
                    "{}// TODO: Memory assertion at 0x{:X} (size {})",
                    indent, address, size
                )
                .unwrap();
            }
            _ => {
                writeln!(output, "{}// TODO: assertion - {:?}", indent, assertion).unwrap();
            }
        }
    }
}

/// Write assertion code for A64 using proper rax API
fn write_assertions_a64(output: &mut String, assertions: &[TestAssertion], indent: &str) {
    for assertion in assertions {
        match &assertion.check {
            AssertionCheck::GpReg(reg) => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_x(&cpu, {}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_x(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::NonZero => {
                    writeln!(
                        output,
                        "{}assert_ne!(get_x(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for X{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::GpReg32(reg) => match &assertion.expected {
                AssertionValue::U32(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_w(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for W{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::SimdReg(reg) => match &assertion.expected {
                AssertionValue::U128(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_qreg(&cpu, {}), 0x{:032X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(get_qreg(&cpu, {}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: SIMD assertion for V{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Flag(flag) => {
                let flag_name = match flag {
                    ProcessorFlag::N => "n",
                    ProcessorFlag::Z => "z",
                    ProcessorFlag::C => "c",
                    ProcessorFlag::V => "v",
                };
                if let AssertionValue::Bool(val) = &assertion.expected {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.get_pstate().{}, {}, \"{}\");",
                        indent, flag_name, val, assertion.message
                    )
                    .unwrap();
                }
            }
            AssertionCheck::Sp => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.get_sp(), 0x{:X}, \"{}\");",
                        indent, val, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: SP assertion - {:?}",
                        indent, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Nzcv => {
                if let AssertionValue::U64(val) = &assertion.expected {
                    writeln!(output, "{}// Check NZCV is 0x{:X}", indent, val).unwrap();
                }
            }
            AssertionCheck::Memory { address, size } => {
                writeln!(
                    output,
                    "{}// TODO: Memory assertion at 0x{:X} (size {})",
                    indent, address, size
                )
                .unwrap();
            }
            _ => {
                writeln!(output, "{}// TODO: assertion - {:?}", indent, assertion).unwrap();
            }
        }
    }
}

/// Write assertion code (generic)
fn write_assertions(output: &mut String, assertions: &[TestAssertion], indent: &str) {
    for assertion in assertions {
        match &assertion.check {
            AssertionCheck::GpReg(reg) => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.x({}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.x({}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::NonZero => {
                    writeln!(
                        output,
                        "{}assert_ne!(cpu.x({}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for X{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::GpReg32(reg) => match &assertion.expected {
                AssertionValue::U32(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.w({}), 0x{:X}, \"{}\");",
                        indent, reg, val, assertion.message
                    )
                    .unwrap();
                }
                AssertionValue::Zero => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.w({}), 0, \"{}\");",
                        indent, reg, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: assertion for W{} - {:?}",
                        indent, reg, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Flag(flag) => match &assertion.expected {
                AssertionValue::Bool(val) => {
                    let flag_name = match flag {
                        ProcessorFlag::N => "n",
                        ProcessorFlag::Z => "z",
                        ProcessorFlag::C => "c",
                        ProcessorFlag::V => "v",
                    };
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.pstate.{}, {}, \"{}\");",
                        indent, flag_name, val, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: flag assertion - {:?}",
                        indent, assertion
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Nzcv => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.nzcv(), 0x{:X}, \"{}\");",
                        indent, val, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: NZCV assertion - {:?}",
                        indent, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Sp => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.sp(), 0x{:X}, \"{}\");",
                        indent, val, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: SP assertion - {:?}",
                        indent, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Pc => match &assertion.expected {
                AssertionValue::U64(val) => {
                    writeln!(
                        output,
                        "{}assert_eq!(cpu.pc(), 0x{:X}, \"{}\");",
                        indent, val, assertion.message
                    )
                    .unwrap();
                }
                _ => {
                    writeln!(
                        output,
                        "{}// TODO: PC assertion - {:?}",
                        indent, assertion.expected
                    )
                    .unwrap();
                }
            },
            AssertionCheck::Memory { address, size } => {
                writeln!(
                    output,
                    "{}// TODO: Memory assertion at 0x{:X} (size {})",
                    indent, address, size
                )
                .unwrap();
            }
            AssertionCheck::SimdReg(reg) => {
                writeln!(
                    output,
                    "{}// TODO: SIMD register V{} assertion",
                    indent, reg
                )
                .unwrap();
            }
            AssertionCheck::Unchanged(reg) => {
                writeln!(output, "{}// Verify X{} is unchanged", indent, reg).unwrap();
            }
        }
    }
}

/// Sanitize a test ID to be a valid Rust identifier
fn sanitize_test_name(id: &str) -> String {
    let mut result = String::with_capacity(id.len());
    let mut last_was_underscore = false;

    // Ensure we start with "test_" prefix
    if !id.starts_with("test_") {
        result.push_str("test_");
    }

    for c in id.chars() {
        if c.is_ascii_alphanumeric() {
            result.push(c.to_ascii_lowercase());
            last_was_underscore = false;
        } else if !last_was_underscore {
            result.push('_');
            last_was_underscore = true;
        }
    }

    // Remove trailing underscore
    while result.ends_with('_') {
        result.pop();
    }

    result
}

/// Generate a test file for a specific instruction class
pub fn generate_instruction_file(suite: &InstructionTestSuite, module_name: &str) -> String {
    let mut output = String::new();

    // Write file header
    writeln!(output, "//! {} tests", suite.instruction_name).unwrap();
    writeln!(output, "//!").unwrap();
    writeln!(output, "//! Auto-generated from ARM ASL specification.").unwrap();
    writeln!(output, "//! Module: {}", module_name).unwrap();
    writeln!(output).unwrap();

    write_file_header(&mut output);
    write_instruction_tests(&mut output, suite);

    output
}

/// Group test suites by instruction class for multi-file output
pub fn group_by_instruction_class(
    suites: &[InstructionTestSuite],
) -> HashMap<String, Vec<&InstructionTestSuite>> {
    let mut groups: HashMap<String, Vec<&InstructionTestSuite>> = HashMap::new();

    for suite in suites {
        // Extract instruction class from name (e.g., "aarch64_integer_arithmetic" -> "arithmetic")
        let class = extract_instruction_class(&suite.instruction_name);
        groups.entry(class).or_default().push(suite);
    }

    groups
}

/// Extract instruction class from full instruction name
fn extract_instruction_class(name: &str) -> String {
    // Common patterns:
    // aarch64_integer_arithmetic_add_sub_immediate -> add_sub_immediate
    // aarch64_memory_single_general -> memory_single

    let parts: Vec<&str> = name.split('_').collect();

    // Skip architecture prefix (aarch64, arm, etc.)
    let skip = if parts
        .first()
        .map_or(false, |p| *p == "aarch64" || *p == "aarch32" || *p == "arm")
    {
        1
    } else {
        0
    };

    // Skip category (integer, memory, etc.) and take the rest
    if parts.len() > skip + 2 {
        parts[skip + 1..].join("_")
    } else if parts.len() > skip {
        parts[skip..].join("_")
    } else {
        name.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sanitize_test_name() {
        assert_eq!(
            sanitize_test_name("ADD_32_addsub_imm"),
            "test_add_32_addsub_imm"
        );
        assert_eq!(sanitize_test_name("test_foo"), "test_foo");
        assert_eq!(
            sanitize_test_name("field-boundary:max"),
            "test_field_boundary_max"
        );
    }

    #[test]
    fn test_extract_instruction_class() {
        assert_eq!(
            extract_instruction_class("aarch64_integer_arithmetic_add_sub_immediate"),
            "arithmetic_add_sub_immediate"
        );
        assert_eq!(
            extract_instruction_class("aarch64_memory_single"),
            "memory_single"
        );
    }
}
